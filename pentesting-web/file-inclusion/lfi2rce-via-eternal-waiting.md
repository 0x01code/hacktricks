# Sonsuz Bekleme Yoluyla LFI2RCE

<details>

<summary><strong>AWS hacklemeyi sıfırdan kahramana öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamını görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**]'na (https://github.com/sponsors/carlospolop) göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**The PEASS Family**]'yi (https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**]'i (https://opensea.io/collection/the-peass-family) içeren koleksiyonumuz
* **Katılın** 💬 [**Discord grubumuza**](https://discord.gg/hRep4RUj7f) veya [**telegram grubumuza**](https://t.me/peass) veya bizi **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)** takip edin.**
* **Hacking püf noktalarınızı paylaşarak PR'lar göndererek** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına katkıda bulunun.

</details>

## Temel Bilgiler

Bir dosya PHP'ye yüklendiğinde (beklemese bile), **`php[a-zA-Z0-9]{6}`** gibi bir isme sahip geçici bir dosya oluşturur `/tmp` içinde, ancak bazı docker görüntülerinde oluşturulan dosyaların rakamlar içermediğini gördüm.

Yerel dosya dahilinde, **o yüklenen dosyayı dahil edebilirseniz, RCE elde edersiniz**.

Varsayılan olarak **PHP yalnızca tek bir istekte 20 dosya yüklemeye izin verir** (ayarlanır `/etc/php/<version>/apache2/php.ini`):
```
; Maximum number of files that can be uploaded via a single request
max_file_uploads = 20
```
Ayrıca, **potansiyel dosya adedi 62\*62\*62\*62\*62\*62 = 56800235584**

### Diğer teknikler

Diğer teknikler, PHP protokollerine saldırarak (yolu sadece son kısmı kontrol ediyorsanız başarılı olamazsınız), dosyanın yolunu ifşa ederek, beklenen dosyaları kötüye kullanarak veya **PHP'nin bir segmentasyon hatası yaşamasını sağlayarak yüklenen geçici dosyaların silinmemesini sağlamak** üzerine kuruludur.\
Bu teknik, **bir sıfır gün bulma gerektirmeden** son teknikle çok benzerdir.

### Sonsuz bekleme tekniği

Bu teknikte **yalnızca göreceli bir yol kontrol etmemiz gerekir**. Eğer dosyaları yüklemeyi başarabilir ve **LFI'nin hiç bitmemesini sağlarsak**, "yeterince zamanımız" olacak ve **yüklendiği tespit edilen dosyaları** **kaba kuvvet uygulayarak bulabileceğiz**.

Bu tekniğin **avantajları**:

* Bir include içinde bir göreceli yol kontrol etmeniz yeterlidir
* Nginx veya log dosyalarına beklenmedik düzeyde erişim gerektirmez
* Bir segmentasyon hatası oluşturmak için bir sıfır gün gerektirmez
* Bir yol ifşası gerektirmez

Bu tekniğin **ana sorunları** şunlardır:

* Belirli bir dosyanın mevcut olması gereklidir (daha fazla olabilir)
* **Çılgınca** potansiyel dosya adedi: **56800235584**
* Sunucu **rakamları kullanmıyorsa** toplam potansiyel miktar: **19770609664**
* Varsayılan olarak **tek bir istekte 20 dosya** yüklenebilir.
* Kullanılan sunucunun **maksimum eşzamanlı işçi sayısı**.
* Bu sınırlama ve öncekiler bu saldırının çok uzun sürmesine neden olabilir
* **Bir PHP isteği için zaman aşımı**. İdeal olarak bu sonsuz olmalı veya PHP işlemini silmeden geçici yüklenen dosyaları silmelidir, aksi takdirde bu da bir sorun olacaktır

Peki, bir PHP include'ı **asla bitmeyecek şekilde nasıl yapabilirsiniz**? Sadece **`/sys/kernel/security/apparmor/revision`** dosyasını dahil ederek. (**Ne yazık ki Docker konteynerlerinde mevcut değil...**).

Sadece şunu çağırarak deneyin:
```bash
php -a # open php cli
include("/sys/kernel/security/apparmor/revision");
```
## Apache2

Varsayılan olarak, Apache **150 eşzamanlı bağlantıyı** destekler, [https://ubiq.co/tech-blog/increase-max-connections-apache/](https://ubiq.co/tech-blog/increase-max-connections-apache/) adresinde belirtildiği gibi bu sayıyı 8000'e kadar yükseltmek mümkündür. Bu modülle PHP kullanmak için şu adımları izleyin: [https://www.digitalocean.com/community/tutorials/how-to-configure-apache-http-with-mpm-event-and-php-fpm-on-ubuntu-18-04](https://www.digitalocean.com/community/tutorials/how-to-configure-apache-http-with-mpm-event-and-php-fpm-on-ubuntu-18-04).

Varsayılan olarak, (testlerimde gördüğüm kadarıyla) **bir PHP işlemi sonsuza kadar sürebilir**.

Şimdi biraz matematik yapalım:

* **149 bağlantı** kullanarak **149 \* 20 = 2980 geçici dosya** oluşturabiliriz web kabuğumuzla.
* Ardından, potansiyel dosyaları **kaba kuvvet** ile aramak için **son bağlantıyı** kullanın.
* **10 istek/s** hızında zamanlar şunlardır:
* 56800235584 / 2980 / 10 / 3600 \~= **530 saat** (265 saatte %50 olasılık)
* (ondalıksız) 19770609664 / 2980 / 10 / 3600 \~= 185 saat (93 saatte %50 olasılık)

{% hint style="warning" %}
Önceki örnekte **diğer istemcileri tamamen DoS** ediyoruz!
{% endhint %}

Eğer Apache sunucusu iyileştirilirse ve **4000 bağlantıyı** (maksimum sayının yarısı) kullanabilirsek. `3999*20 = 79980` **dosya** oluşturabilir ve **sayı** yaklaşık olarak **19.7 saat** veya **6.9 saat** (10 saat, 3.5 saat %50 olasılık) olur.

## PHP-FMP

Eğer web sayfası PHP betiklerini çalıştırmak için düzenli php modunu kullanmak yerine **PHP-FMP** kullanıyorsa (bu web sayfasının verimliliğini artırır, bu yüzden sıkça karşılaşılır), tekniği iyileştirmek için başka bir şey yapılabilir.

PHP-FMP, **`/etc/php/<php-sürümü>/fpm/pool.d/www.conf`** içinde **`request_terminate_timeout`** parametresini **ayarlamaya** izin verir.\
Bu parametre, **PHP'ye yapılan isteğin** **ne zaman sonlanması gerektiğini** belirtir (varsayılan olarak sonsuzdur, ancak **parametre yorumlanırsa 30 saniyedir**). Bir istek PHP tarafından işlenirken belirtilen saniye sayısına ulaştığında, **sonlandırılır**. Bu, istek geçici dosyalar yüklenirken **php işlemi durdurulduğunda**, bu **dosyaların silinmeyeceği** anlamına gelir. Dolayısıyla, bir isteği o süre boyunca sürdürebilirseniz, silinmeyecek **binlerce geçici dosya oluşturabilirsiniz**, bu da onları bulma sürecini hızlandırır ve tüm bağlantıları tüketerek platforma bir DoS olasılığını azaltır.

Bu nedenle, **DoS'yi önlemek** için bir **saldırganın aynı anda yalnızca 100 bağlantıyı** ve php-fmp tarafından belirlenen **php maksimum işlem süresini** (`request_terminate_timeout`**)** **30 saniye** olarak kullanacağını varsayalım. Dolayısıyla, saniyede oluşturulabilecek **geçici dosya sayısı** `100*20/30 = 66.67` olacaktır.

Sonra, **10000 dosya** oluşturmak için bir saldırganın ihtiyacı olan süre: **`10000/66.67 = 150 saniye`** (100000 dosya oluşturmak için gereken süre ise **25 dakika** olacaktır).

Ardından, saldırgan bu **100 bağlantıyı** kullanarak bir **arama kaba kuvveti** gerçekleştirebilir. **300 istek/s** hızında çalıştığını varsayarsak, bu saldırıyı gerçekleştirmek için gereken süre şöyledir:

* 56800235584 / 10000 / 300 / 3600 \~= **5.25 saat** (2.63 saatte %50 olasılık)
* (100000 dosya ile) 56800235584 / 100000 / 300 / 3600 \~= **0.525 saat** (0.263 saatte %50 olasılık)

Evet, bir EC2 orta boyutlu örneğinde 100000 geçici dosya oluşturmak mümkündür:

<figure><img src="../../.gitbook/assets/image (240).png" alt=""><figcaption></figcaption></figure>

{% hint style="warning" %}
Zaman aşımını tetiklemek için **yeterli olacak şekilde zafiyetli LFI sayfasını** içerdiğinizi unutmayın, böylece sonsuz bir dahil döngüye girer.
{% endhint %}

## Nginx

Varsayılan olarak Nginx'in aynı anda **512 paralel bağlantıyı** desteklediği görünüyor (bu sayı artırılabilir).
