# LFI2RCE kupitia Kusubiri Milele

<details>

<summary><strong>Jifunze kuhusu kuvamia AWS kutoka sifuri hadi shujaa na</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Mtaalam wa Timu Nyekundu ya AWS ya HackTricks)</strong></a><strong>!</strong></summary>

Njia nyingine za kusaidia HackTricks:

* Ikiwa unataka kuona **kampuni yako ikionekana kwenye HackTricks** au **kupakua HackTricks kwa muundo wa PDF** Angalia [**MIPANGO YA KUJIUNGA**](https://github.com/sponsors/carlospolop)!
* Pata [**bidhaa rasmi za PEASS & HackTricks**](https://peass.creator-spring.com)
* Gundua [**Familia ya PEASS**](https://opensea.io/collection/the-peass-family), mkusanyiko wetu wa [**NFTs**](https://opensea.io/collection/the-peass-family) ya kipekee
* **Jiunge na** üí¨ [**Kikundi cha Discord**](https://discord.gg/hRep4RUj7f) au kikundi cha [**telegram**](https://t.me/peass) au **tufuate** kwenye **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Shiriki mbinu zako za kuvamia kwa kuwasilisha PRs kwa** [**HackTricks**](https://github.com/carlospolop/hacktricks) na [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos za github.

</details>

## Taarifa Msingi

Kwa chaguo-msingi wakati faili inapakiwa kwenye PHP (hata kama haitegemei), itaunda faili ya muda katika `/tmp` yenye jina kama **`php[a-zA-Z0-9]{6}`**, ingawa nimeona picha za docker ambapo faili zilizoundwa hazina tarakimu.

Katika kuingiza faili za ndani, **ikiwa unafanikiwa kuingiza faili hiyo iliyopakiwa, utapata RCE**.

Tafadhali kumbuka kwamba kwa chaguo-msingi **PHP inaruhusu kupakia faili 20 katika ombi moja** (imewekwa katika `/etc/php/<version>/apache2/php.ini`):
```
; Maximum number of files that can be uploaded via a single request
max_file_uploads = 20
```
Pia, **idadi ya majina ya faili yanayowezekana ni 62\*62\*62\*62\*62\*62 = 56800235584**

### Mbinu nyingine

Mbinu nyingine inategemea kushambulia itifaki za PHP (hutaweza ikiwa unadhibiti sehemu ya mwisho ya njia), kufichua njia ya faili, kutumia faili zinazotarajiwa, au **kusababisha PHP kupata kosa la segmantasi ili faili za muda zilizopakiwa zisifutwe**.\
Mbinu hii ni **sawa sana na ile iliyotangulia lakini bila ya kuhitaji kutafuta siku ya sifuri**.

### Mbinu ya kusubiri milele

Katika mbinu hii **tunahitaji kudhibiti njia ya kihusishi**. Ikiwa tunaweza kupakia faili na kufanya **LFI isikome kamwe**, tutakuwa na "muda wa kutosha" wa **kufanya nguvu ya kutumia faili zilizopakiwa** na **kupata** mojawapo iliyopakiwa.

**Faida za mbinu hii**:

* Unahitaji tu kudhibiti njia ya kihusishi ndani ya kifungu
* Haitahitaji nginx au kiwango kisichotarajiwa cha ufikiaji wa faili za kuingiza
* Haitahitaji siku ya sifuri kusababisha kosa la segmantasi
* Haitahitaji kufichua njia

**Matatizo makuu** ya mbinu hii ni:

* Inahitaji faili maalum kuwepo (zinaweza kuwa zaidi)
* **Idadi kubwa sana** ya majina ya faili yanayowezekana: **56800235584**
* Ikiwa seva **haikutumii tarakimu** jumla ya idadi inayowezekana ni: **19770609664**
* Kwa chaguo-msingi **faili 20 tu** zinaweza kupakiwa katika **ombi moja**.
* **Idadi kubwa ya wafanyikazi wanaoweza kufanya kazi kwa wakati mmoja** wa seva iliyotumiwa.
* Kikomo hiki pamoja na vingine vya awali vinaweza kufanya shambulio hili kudumu muda mrefu sana
* **Muda wa kusubiri ombi la PHP**. Kimsingi hii inapaswa kuwa ya milele au inapaswa kusitisha mchakato wa PHP bila kufuta faili zilizopakiwa za muda, la sivyo, hii pia itakuwa maumivu

Basi, unawezaje **kusababisha kuingiza kwa PHP isikome kamwe**? Kwa kuingiza faili **`/sys/kernel/security/apparmor/revision`** (**haipatikani katika kontena za Docker** kwa bahati mbaya...).

Jaribu tu kwa kuita:
```bash
php -a # open php cli
include("/sys/kernel/security/apparmor/revision");
```
## Apache2

Kwa chaguo-msingi, Apache inasaidia **mawasiliano 150 ya wakati mmoja**, ikifuata [https://ubiq.co/tech-blog/increase-max-connections-apache/](https://ubiq.co/tech-blog/increase-max-connections-apache/) inawezekana kuboresha idadi hii hadi 8000. Fuata hii kutumia PHP na moduli hiyo: [https://www.digitalocean.com/community/tutorials/how-to-configure-apache-http-with-mpm-event-and-php-fpm-on-ubuntu-18-04](https://www.digitalocean.com/community/tutorials/how-to-configure-apache-http-with-mpm-event-and-php-fpm-on-ubuntu-18-04).

Kwa chaguo-msingi, (kama ninavyoona katika majaribio yangu), **mchakato wa PHP unaweza kudumu milele**.

Hebu fanya hesabu:

* Tunaweza kutumia **mawasiliano 149** kuzalisha **149 \* 20 = faili 2980 za muda** na webshell yetu.
* Kisha, tumia **mawasiliano ya mwisho** kufanya **brute-force** kwenye faili za uwezekano.
* Kwa kasi ya **ombi 10/s** nyakati ni:
* 56800235584 / 2980 / 10 / 3600 \~= **masaa 530** (50% nafasi katika masaa 265)
* (bila tarakimu) 19770609664 / 2980 / 10 / 3600 \~= masaa 185 (50% nafasi katika masaa 93)

{% hint style="warning" %}
Tafadhali elewa kuwa katika mfano uliopita tunakuwa **tunafanya DoS kabisa kwa wateja wengine**!
{% endhint %}

Ikiwa seva ya Apache inaboreshwa na tunaweza kutumia **mawasiliano 4000** (nusu ya njia kufikia idadi kubwa). Tunaweza kuunda `3999*20 = faili 79980` na **idadi** itapunguzwa hadi karibu **masaa 19.7** au **masaa 6.9** (masaa 10, masaa 3.5 50% nafasi).

## PHP-FMP

Ikiwa badala ya kutumia moduli ya kawaida ya php kwa apache kutekeleza skripti za PHP **ukurasa wa wavuti unatumia** **PHP-FMP** (hii inaboresha ufanisi wa ukurasa wa wavuti, hivyo ni kawaida kuipata), kuna kitu kingine kinachoweza kufanywa kuboresha mbinu.

PHP-FMP inaruhusu **kuweka** **parameta** **`request_terminate_timeout`** katika **`/etc/php/<php-version>/fpm/pool.d/www.conf`**.\
Parameta hii inaonyesha idadi kubwa ya sekunde **ombi la PHP linapaswa kumalizika** (isiyo na kikomo kwa chaguo-msingi, lakini **30s ikiwa paramu haijafutwa**). Wakati ombi linashughulikiwa na PHP kwa idadi iliyotajwa ya sekunde, linauawa. Hii inamaanisha, kwamba ikiwa ombi lilikuwa likiweka faili za muda, kwa sababu **usindikaji wa php ulisimamishwa**, faili hizo **hazitafutwa**. Kwa hivyo, ikiwa unaweza kufanya ombi lidumu kwa muda huo, unaweza **kuzalisha faili za muda maelfu** ambazo hazitafutwa, ambayo ita **harakisha mchakato wa kuzipata** na kupunguza uwezekano wa DoS kwa jukwaa kwa kutumia mawasiliano yote.

Kwa hivyo, ili **kuepuka DoS** fikiria kwamba **mshambuliaji atatumia mawasiliano 100 tu** kwa wakati mmoja na muda wa usindikaji wa php kwa **php-fmp** (`request_terminate_timeout`**)** ni **30s**. Kwa hivyo, idadi ya **faili za muda** zinazoweza kuzalishwa **kwa sekunde** ni `100*20/30 = 66.67`.

Kisha, ili kuzalisha **faili 10000** mshambuliaji atahitaji: **`10000/66.67 = sekunde 150`** (kuzalisha **faili 100000** wakati ungekuwa **dakika 25**).

Kisha, mshambuliaji anaweza kutumia **mawasiliano hayo 100** kufanya **brute-force** ya utafutaji. \*\*\*\* Kufikiria kasi ya 300 ombi/s wakati unahitajika kutekeleza hii ni kama ifuatavyo:

* 56800235584 / 10000 / 300 / 3600 \~= **masaa 5.25** (50% nafasi katika masaa 2.63)
* (na faili 100000) 56800235584 / 100000 / 300 / 3600 \~= **masaa 0.525** (50% nafasi katika masaa 0.263)

Ndio, ni rahisi kuzalisha faili 100000 za muda kwenye kifaa cha ukubwa wa kati cha EC2:

<figure><img src="../../.gitbook/assets/image (237).png" alt=""><figcaption></figcaption></figure>

{% hint style="warning" %}
Tafadhali elewa kwamba ili kusababisha muda wa kumalizika itakuwa **ya kutosha kuingiza ukurasa wa LFI wenye kasoro**, ili iingie kwenye mzunguko wa kuingiza wa milele.
{% endhint %}

## Nginx

Inaonekana kwa chaguo-msingi Nginx inasaidia **mawasiliano 512 ya wakati mmoja** (na idadi hii inaweza kuboreshwa).
