# LFI2RCEを使ったEternal waiting

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* **サイバーセキュリティ会社**で働いていますか？ **HackTricksで会社を宣伝**したいですか？または、**PEASSの最新バージョンにアクセスしたり、HackTricksをPDFでダウンロード**したいですか？[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を見つけてください。独占的な[**NFT**](https://opensea.io/collection/the-peass-family)のコレクションです。
* [**公式のPEASS＆HackTricksのグッズ**](https://peass.creator-spring.com)を手に入れましょう。
* [**💬**](https://emojipedia.org/speech-balloon/) [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**telegramグループ**](https://t.me/peass)に**参加**するか、**Twitter**で**フォロー**してください[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**。**
* **ハッキングのトリックを共有するには、PRを** [**hacktricks repo**](https://github.com/carlospolop/hacktricks) **と** [**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **に提出してください。**

</details>

## 基本情報

デフォルトでは、PHPにファイルがアップロードされると（それが期待されていなくても）、**`php[a-zA-Z0-9]{6}`**のような名前の一時ファイルが`/tmp`に生成されます。ただし、一部のDockerイメージでは生成されたファイルに数字が含まれていないことがあります。

ローカルファイルインクルージョンでは、**アップロードされたファイルをインクルードできれば、RCEを取得できます**。

デフォルトでは、**PHPは単一のリクエストで20個のファイルのアップロードしか許可しません**（`/etc/php/<version>/apache2/php.ini`で設定されています）。
```
; Maximum number of files that can be uploaded via a single request
max_file_uploads = 20
```
また、潜在的なファイル名の数は62\*62\*62\*62\*62\*62 = 56800235584です。

### その他の技術

他の技術は、PHPプロトコルへの攻撃に依存しています（パスの最後の部分しか制御できない場合はできません）、ファイルのパスを公開すること、予想されるファイルを悪用すること、またはPHPにセグメンテーションフォールトを引き起こさせることでアップロードされた一時ファイルが削除されないようにすることです。\
この技術は、前のものと非常に似ていますが、ゼロデイを見つける必要はありません。

### 永遠の待ち技術

この技術では、**相対パスを制御するだけで十分です**。ファイルをアップロードし、**LFIが終了しないようにする**ことができれば、アップロードされたファイルのいずれかを**ブルートフォース**して見つけるための「十分な時間」があります。

この技術の**利点**は次のとおりです：

- インクルード内の相対パスの制御のみが必要です
- nginxや予期しないレベルのアクセス権限を必要としません
- セグメンテーションフォールトを引き起こすためのゼロデイは必要ありません
- パスの公開は必要ありません

この技術の**主な問題**は次のとおりです：

- 特定のファイルが存在する必要があります（他にもあるかもしれません）
- **膨大な**潜在的なファイル名の数：**56800235584**
- サーバーが**数字を使用していない**場合、合計の潜在的な数は：**19770609664**
- デフォルトでは、**1つのリクエスト**で**最大20ファイル**しかアップロードできません。
- 使用されるサーバーの**最大並列ワーカー数**
- これらの制限により、この攻撃は長時間にわたる可能性があります
- PHPリクエストの**タイムアウト**。理想的には永遠であるか、PHPプロセスを終了させずに一時的にアップロードされたファイルを削除する必要があります。そうでない場合、これも問題になります

では、PHPのインクルードを**終了させない方法**はどうすればよいでしょうか？単にファイル**`/sys/kernel/security/apparmor/revision`**をインクルードするだけです（残念ながらDockerコンテナでは利用できません）。

以下のように呼び出してみてください：
```bash
php -a # open php cli
include("/sys/kernel/security/apparmor/revision");
```
## Apache2

デフォルトでは、Apacheは**150の同時接続**をサポートしています。[https://ubiq.co/tech-blog/increase-max-connections-apache/](https://ubiq.co/tech-blog/increase-max-connections-apache/)を参考に、この数を最大8000まで増やすことができます。PHPをそのモジュールと共に使用するためには、[https://www.digitalocean.com/community/tutorials/how-to-configure-apache-http-with-mpm-event-and-php-fpm-on-ubuntu-18-04](https://www.digitalocean.com/community/tutorials/how-to-configure-apache-http-with-mpm-event-and-php-fpm-on-ubuntu-18-04)を参照してください。

デフォルトでは（私のテストで確認できるように）、**PHPプロセスは永遠に続く**ことができます。

計算してみましょう：

* **149の接続**を使用して、**149 \* 20 = 2980個の一時ファイル**をウェブシェルで生成できます。
* 次に、**最後の接続**を使用して、潜在的なファイルを**ブルートフォース**します。
* 速度が**10リクエスト/秒**の場合、時間は次のようになります：
* 56800235584 / 2980 / 10 / 3600 \~= **530時間**（50%の確率で265時間）
* （桁を除いて）19770609664 / 2980 / 10 / 3600 \~= 185時間（50%の確率で93時間）

{% hint style="warning" %}
前の例では、他のクライアントを**完全にDoS攻撃**していることに注意してください！
{% endhint %}

Apacheサーバーが改善され、**4000の接続**（最大数の半分）を悪用できる場合、`3999*20 = 79980` **ファイル**を作成し、**時間**は約**19.7時間**または**6.9時間**（10時間、3.5時間、50%の確率）になります。

## PHP-FPM

通常のApacheのphpモジュールではなく、**webページがPHP-FPMを使用**している場合（これにより、webページの効率が向上するため、一般的に使用されます）、テクニックを改善するために他のことができます。

PHP-FPMでは、**`request_terminate_timeout`**パラメータを**`/etc/php/<php-version>/fpm/pool.d/www.conf`**に設定できます。\
このパラメータは、PHPへのリクエストが終了するまでの最大秒数を示します（デフォルトでは無限ですが、パラメータがコメント解除されている場合は**30秒**）。 PHPによってリクエストが処理されている間に指定された秒数が経過すると、リクエストは**終了**されます。つまり、リクエストが一時ファイルをアップロードしていた場合、**phpの処理が停止したため**、それらの**ファイルは削除されません**。したがって、リクエストをその時間だけ続けることができれば、削除されない**数千の一時ファイル**を生成できます。これにより、それらを見つけるプロセスが**高速化**され、すべての接続を消費することによるプラットフォームへのDoSの可能性が低下します。

したがって、DoSを**回避**するために、**攻撃者は同時に100の接続のみを使用する**と仮定し、php-fmpの最大処理時間（`request_terminate_timeout`）が**30秒**であるとします。したがって、**1秒あたり**に生成できる**一時ファイルの数**は`100*20/30 = 66.67`です。

そのため、攻撃者が**10000個のファイル**を生成するために必要な時間は：**`10000/66.67 = 150秒`**です（100000個のファイルを生成するための時間は**25分**です）。

その後、攻撃者はこれらの**100の接続**を使用して**ブルートフォース検索**を実行することができます。300リクエスト/秒の速度を仮定すると、この攻撃を実行するために必要な時間は次のとおりです：

* 56800235584 / 10000 / 300 / 3600 \~= **5.25時間**（50%の確率で2.63時間）
* （100000個のファイルを使用する場合）56800235584 / 100000 / 300 / 3600 \~= **0.525時間**（50%の確率で0.263時間）

はい、EC2の中程度のサイズのインスタンスで100000個の一時ファイルを生成することが可能です：

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (3).png" alt=""><figcaption></figcaption></figure>

{% hint style="warning" %}
タイムアウトをトリガーするためには、脆弱なLFIページを**含めるだけで十分**です。これにより、永遠のインクルードループに入ります。
{% endhint %}

## Nginx

デフォルトでは、Nginxは**同時接続512**をサポートしているようです（この数は改善できます）。
