# LFI2RCE via Espera Eterna

<details>

<summary><strong>Aprenda hacking AWS do zero ao her√≥i com</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Outras maneiras de apoiar o HackTricks:

* Se voc√™ deseja ver sua **empresa anunciada no HackTricks** ou **baixar o HackTricks em PDF** Verifique os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Adquira o [**swag oficial do PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Junte-se ao** üí¨ [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-nos** no **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe seus truques de hacking enviando PRs para os** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) reposit√≥rios do github.

</details>

## Informa√ß√£o B√°sica

Por padr√£o, quando um arquivo √© enviado para o PHP (mesmo que n√£o esteja esperando), ele ir√° gerar um arquivo tempor√°rio em `/tmp` com um nome como **`php[a-zA-Z0-9]{6}`**, embora eu tenha visto algumas imagens docker onde os arquivos gerados n√£o cont√™m d√≠gitos.

Em uma inclus√£o de arquivo local, **se voc√™ conseguir incluir esse arquivo enviado, obter√° RCE**.

Observe que por padr√£o **o PHP permite apenas o envio de 20 arquivos em uma √∫nica solicita√ß√£o** (definido em `/etc/php/<vers√£o>/apache2/php.ini`):
```
; Maximum number of files that can be uploaded via a single request
max_file_uploads = 20
```
Tamb√©m, o **n√∫mero de nomes de arquivos potenciais s√£o 62\*62\*62\*62\*62\*62 = 56800235584**

### Outras t√©cnicas

Outras t√©cnicas dependem de atacar os protocolos PHP (voc√™ n√£o ser√° capaz se controlar apenas a √∫ltima parte do caminho), revelar o caminho do arquivo, abusar de arquivos esperados, ou **fazer o PHP sofrer uma falha de segmenta√ß√£o para que arquivos tempor√°rios enviados n√£o sejam exclu√≠dos**.\
Essa t√©cnica √© **muito semelhante √† √∫ltima, mas sem a necessidade de encontrar uma vulnerabilidade zero day**.

### T√©cnica de espera eterna

Nesta t√©cnica **s√≥ precisamos controlar um caminho relativo**. Se conseguirmos enviar arquivos e fazer o **LFI nunca terminar**, teremos "tempo suficiente" para **for√ßar bruta os arquivos enviados** e **encontrar** qualquer um dos arquivos enviados.

**Pr√≥s desta t√©cnica**:

* Voc√™ s√≥ precisa controlar um caminho relativo dentro de um include
* N√£o requer nginx ou um n√≠vel inesperado de acesso aos arquivos de log
* N√£o requer uma vulnerabilidade zero day para causar uma falha de segmenta√ß√£o
* N√£o requer uma revela√ß√£o de caminho

Os **principais problemas** desta t√©cnica s√£o:

* Necessidade de um arquivo(s) espec√≠fico(s) estar presente (pode haver mais)
* A **quantidade insana** de nomes de arquivos potenciais: **56800235584**
* Se o servidor **n√£o estiver usando d√≠gitos**, o total potencial √©: **19770609664**
* Por padr√£o, **apenas 20 arquivos** podem ser enviados em uma **√∫nica solicita√ß√£o**.
* O **n√∫mero m√°ximo de trabalhadores paralelos** do servidor utilizado.
* Essa limita√ß√£o junto com as anteriores pode fazer com que esse ataque dure muito tempo
* **Tempo limite para uma solicita√ß√£o PHP**. Idealmente, isso deveria ser eterno ou deveria encerrar o processo PHP sem excluir os arquivos tempor√°rios enviados, caso contr√°rio, isso tamb√©m ser√° um problema

Ent√£o, como voc√™ pode **fazer um include PHP nunca terminar**? Apenas incluindo o arquivo **`/sys/kernel/security/apparmor/revision`** (**infelizmente n√£o dispon√≠vel em cont√™ineres Docker**).

Tente apenas chamando:
```bash
php -a # open php cli
include("/sys/kernel/security/apparmor/revision");
```
## Apache2

Por padr√£o, o Apache suporta **150 conex√µes simult√¢neas**, seguindo [https://ubiq.co/tech-blog/increase-max-connections-apache/](https://ubiq.co/tech-blog/increase-max-connections-apache/) √© poss√≠vel aumentar esse n√∫mero para 8000. Siga este tutorial para usar o PHP com esse m√≥dulo: [https://www.digitalocean.com/community/tutorials/how-to-configure-apache-http-with-mpm-event-and-php-fpm-on-ubuntu-18-04](https://www.digitalocean.com/community/tutorials/how-to-configure-apache-http-with-mpm-event-and-php-fpm-on-ubuntu-18-04).

Por padr√£o, (como pude ver nos meus testes), um **processo PHP pode durar eternamente**.

Vamos fazer alguns c√°lculos:

* Podemos usar **149 conex√µes** para gerar **149 \* 20 = 2980 arquivos tempor√°rios** com nossa webshell.
* Em seguida, use a **√∫ltima conex√£o** para **for√ßar** poss√≠veis arquivos.
* A uma velocidade de **10 solicita√ß√µes/s** os tempos s√£o:
* 56800235584 / 2980 / 10 / 3600 \~= **530 horas** (50% de chance em 265h)
* (sem d√≠gitos) 19770609664 / 2980 / 10 / 3600 \~= 185h (50% de chance em 93h)

{% hint style="warning" %}
Note que no exemplo anterior estamos **derrubando completamente outros clientes**!
{% endhint %}

Se o servidor Apache for melhorado e pudermos abusar de **4000 conex√µes** (metade do caminho para o n√∫mero m√°ximo), poder√≠amos criar `3999*20 = 79980` **arquivos** e o **n√∫mero** seria **reduzido** para cerca de **19,7h** ou **6,9h** (10h, 3,5h 50% de chance).

## PHP-FMP

Se em vez de usar o m√≥dulo php regular para o apache executar scripts PHP a **p√°gina da web estiver usando** **PHP-FMP** (isso melhora a efici√™ncia da p√°gina da web, ent√£o √© comum encontr√°-lo), h√° algo mais que pode ser feito para melhorar a t√©cnica.

O PHP-FMP permite **configurar** o **par√¢metro** **`request_terminate_timeout`** em **`/etc/php/<vers√£o-php>/fpm/pool.d/www.conf`**.\
Este par√¢metro indica a quantidade m√°xima de segundos **quando** **a solicita√ß√£o ao PHP deve terminar** (infinito por padr√£o, mas **30s se o par√¢metro estiver descomentado**). Quando uma solicita√ß√£o est√° sendo processada pelo PHP pelo n√∫mero indicado de segundos, ela √© **encerrada**. Isso significa que, se a solicita√ß√£o estava enviando arquivos tempor√°rios, porque o **processamento php foi interrompido**, esses **arquivos n√£o ser√£o exclu√≠dos**. Portanto, se voc√™ puder fazer uma solicita√ß√£o durar esse tempo, voc√™ pode **gerar milhares de arquivos tempor√°rios** que n√£o ser√£o exclu√≠dos, o que **acelerar√° o processo de encontr√°-los** e reduzir√° a probabilidade de um DoS na plataforma ao consumir todas as conex√µes.

Portanto, para **evitar DoS** vamos supor que um **atacante estar√° usando apenas 100 conex√µes** ao mesmo tempo e o tempo m√°ximo de processamento do php pelo **php-fmp** (`request_terminate_timeout`**)** √© de **30s**. Portanto, o n√∫mero de **arquivos tempor√°rios** que podem ser gerados **por segundo** √© `100*20/30 = 66.67`.

Ent√£o, para gerar **10000 arquivos** um atacante precisaria de: **`10000/66.67 = 150s`** (para gerar **100000 arquivos** o tempo seria de **25min**).

Ent√£o, o atacante poderia usar essas **100 conex√µes** para realizar uma **busca de for√ßa bruta**. Supondo uma velocidade de 300 req/s, o tempo necess√°rio para explorar isso √© o seguinte:

* 56800235584 / 10000 / 300 / 3600 \~= **5,25 horas** (50% de chance em 2,63h)
* (com 100000 arquivos) 56800235584 / 100000 / 300 / 3600 \~= **0,525 horas** (50% de chance em 0,263h)

Sim, √© poss√≠vel gerar 100000 arquivos tempor√°rios em uma inst√¢ncia de tamanho m√©dio do EC2:

<figure><img src="../../.gitbook/assets/image (240).png" alt=""><figcaption></figcaption></figure>

{% hint style="warning" %}
Note que para acionar o tempo limite seria **suficiente incluir a p√°gina LFI vulner√°vel**, para que entre em um loop de inclus√£o eterno.
{% endhint %}

## Nginx

Parece que por padr√£o o Nginx suporta **512 conex√µes paralelas** ao mesmo tempo (e esse n√∫mero pode ser melhorado).
