# LFI2RCE via Eternal waiting

<details>

<summary><strong>ゼロからヒーローまでAWSハッキングを学ぶ</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE（HackTricks AWS Red Team Expert）</strong></a><strong>！</strong></summary>

HackTricks をサポートする他の方法:

* **HackTricks で企業を宣伝したい** または **HackTricks をPDFでダウンロードしたい** 場合は [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop) をチェックしてください！
* [**公式PEASS＆HackTricksのグッズ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な [**NFTs**](https://opensea.io/collection/the-peass-family) のコレクションを見つける
* **💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f) に参加するか、[**telegramグループ**](https://t.me/peass) に参加するか、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live) をフォローする。
* **ハッキングテクニックを共有するために、PRを** [**HackTricks**](https://github.com/carlospolop/hacktricks) **と** [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **のGitHubリポジトリに提出してください。**

</details>

## 基本情報

デフォルトでは、PHPにファイルがアップロードされると（それが期待されていなくても）、**`php[a-zA-Z0-9]{6}`** のような名前の一時ファイルが `/tmp` に生成されます。ただし、一部のDockerイメージでは生成されたファイルに数字が含まれていないことがあります。

ローカルファイルインクルージョンでは、**そのアップロードされたファイルをインクルードできれば、RCEを取得できます**。

デフォルトでは、**PHPは単一のリクエストで最大20ファイルのアップロードを許可しています**（`/etc/php/<version>/apache2/php.ini` で設定されています）。
```
; Maximum number of files that can be uploaded via a single request
max_file_uploads = 20
```
また、**潜在的なファイル名の数は62\*62\*62\*62\*62\*62 = 56800235584** です

### その他のテクニック

その他のテクニックは、PHPプロトコルを攻撃することに依存しています（パスの最後の部分しか制御できない場合はできません）、ファイルのパスを開示すること、期待されるファイルを悪用すること、または**PHPにセグメンテーション違反を引き起こさせてアップロードされた一時ファイルが削除されないようにする**ことです。\
このテクニックは、**ゼロデイを見つける必要がない**最後のものと非常に似ています。

### 永遠の待機テクニック

このテクニックでは、**相対パスを制御するだけで十分**です。ファイルをアップロードし、**LFIが終了しないように**することができれば、「十分な時間」があり、**アップロードされたファイルをブルートフォース**して、アップロードされたファイルのいずれかを**見つける**ことができます。

**このテクニックの利点**:

- include内で相対パスを制御するだけでよい
- nginxや予期しないレベルのアクセス権限が不要
- セグメンテーション違反を引き起こすためのゼロデイが不要
- パスの開示が不要

このテクニックの**主な問題点**は:

- 特定のファイルが存在する必要がある（他にもあるかもしれない）
- **潜在的なファイル名の膨大な数: 56800235584**
- サーバーが**数字を使用していない**場合、合計潜在的な数は: **19770609664**
- デフォルトでは、**1つのリクエストで最大20ファイル**しかアップロードできません。
- 使用されているサーバーの**最大並列ワーカー数**。
- これらの制限と前述のものにより、この攻撃が長引く可能性があります
- **PHPリクエストのタイムアウト**。理想的には永遠であるか、PHPプロセスを削除せずに一時的にアップロードされたファイルを削除する必要があります。そうでない場合、これも苦痛になります

では、どのようにして**PHPのincludeを終了させないように**できるでしょうか？単に、ファイル**`/sys/kernel/security/apparmor/revision`**をインクルードするだけです（**Dockerコンテナでは利用できません**残念ながら...）。

試すには、次のように呼び出してください:
```bash
php -a # open php cli
include("/sys/kernel/security/apparmor/revision");
```
## Apache2

デフォルトでは、Apacheは**150の同時接続**をサポートしています。[https://ubiq.co/tech-blog/increase-max-connections-apache/](https://ubiq.co/tech-blog/increase-max-connections-apache/)に従って、この数を最大8000までアップグレードすることが可能です。PHPをそのモジュールと共に使用するためには、[https://www.digitalocean.com/community/tutorials/how-to-configure-apache-http-with-mpm-event-and-php-fpm-on-ubuntu-18-04](https://www.digitalocean.com/community/tutorials/how-to-configure-apache-http-with-mpm-event-and-php-fpm-on-ubuntu-18-04)に従ってください。

デフォルトでは（私のテストで確認できるように）、**PHPプロセスは永遠に続く**ことができます。

計算してみましょう：

- **149の接続**を使用して、**149 \* 20 = 2980個の一時ファイル**をWebシェルで生成できます。
- 次に、**最後の接続**を使用して、潜在的なファイルを**ブルートフォース**します。
- **10リクエスト/秒**の速度で、時間は次のようになります：
  - 56800235584 / 2980 / 10 / 3600 ≈ **530時間**（50%の確率で265時間）
  - （小数点以下を無視）19770609664 / 2980 / 10 / 3600 ≈ 185時間（50%の確率で93時間）

{% hint style="warning" %}
前述の例では、**他のクライアントを完全にDoS攻撃**していることに注意してください！
{% endhint %}

Apacheサーバーが改善され、**4000の接続**を悪用できるようになった場合（最大数の半分まで）、`3999*20 = 79980` **ファイル**を作成でき、その**数**は約**19.7時間**または**6.9時間**（10時間、3.5時間、50%の確率）に短縮されます。

## PHP-FMP

Apacheの通常のphpモジュールを使用する代わりに、**webページがPHP-FMPを使用**している場合（これはWebページの効率を向上させるため、一般的に見つけることができます）、技術を改善するために行うことができるものがあります。

PHP-FMPは、**`/etc/php/<php-version>/fpm/pool.d/www.conf`**で**`request_terminate_timeout`**パラメータを**設定**することを可能にします。\
このパラメータは、PHPへのリクエストが終了する必要がある最大秒数を示します（デフォルトでは無限ですが、パラメータがコメントアウトされている場合は**30秒**）。PHPによってリクエストが処理されている間に、指定された秒数が経過すると、それが**中断**されます。つまり、リクエストが一時ファイルをアップロードしていた場合、**php処理が停止**されたため、それらの**ファイルは削除されません**。したがって、リクエストをその時間続けることができれば、削除されない**数千の一時ファイル**を生成でき、それによりそれらを見つけるプロセスが**高速化**され、すべての接続を消費してプラットフォームにDoSを引き起こす確率が低下します。

したがって、**DoSを回避**するために、**攻撃者が同時に100の接続しか使用しない**と仮定し、**php-fmp**によるphp最大処理時間（`request_terminate_timeout`）が**30秒**であるとします。したがって、**1秒あたり生成できる一時ファイル**の数は`100*20/30 = 66.67`です。

次に、**10000ファイル**を生成するには、攻撃者が必要とする時間は：**`10000/66.67 = 150秒`**です（**100000ファイル**を生成するには、時間は**25分**になります）。

その後、攻撃者はこれらの**100の接続**を使用して**検索ブルートフォース**を実行できます。**300リクエスト/秒**の速度を仮定すると、この攻撃を実行するために必要な時間は次のとおりです：

- 56800235584 / 10000 / 300 / 3600 ≈ **5.25時間**（50%の確率で2.63時間）
- （100000ファイルを使用する場合）56800235584 / 100000 / 300 / 3600 ≈ **0.525時間**（50%の確率で0.263時間）

はい、EC2中サイズのインスタンスで100000の一時ファイルを生成することが可能です：

<figure><img src="../../.gitbook/assets/image (240).png" alt=""><figcaption></figcaption></figure>

{% hint style="warning" %}
タイムアウトをトリガーするためには、**脆弱なLFIページを含めるだけで十分**です。これにより、永遠にインクルードループに入ります。
{% endhint %}

## Nginx

デフォルトでは、Nginxは**同時に512の接続**をサポートしているようです（この数は改善される可能性があります）。
