# LFI2RCE via Eternal waiting

<details>

<summary><strong>ゼロからヒーローまでのAWSハッキングを学ぶ</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE（HackTricks AWS Red Team Expert）</strong></a><strong>！</strong></summary>

HackTricksをサポートする他の方法：

* **HackTricksで企業を宣伝したい**または**HackTricksをPDFでダウンロードしたい**場合は、[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS＆HackTricksスウォッグ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクションを見つける
* **💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)に参加するか、[**telegramグループ**](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)で**フォロー**する。
* **ハッキングトリックを共有するには、PRを** [**HackTricks**](https://github.com/carlospolop/hacktricks) **および** [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **のGitHubリポジトリに提出してください。**

</details>

## 基本情報

デフォルトでは、PHPにファイルがアップロードされると（それが期待されていなくても）、**`php[a-zA-Z0-9]{6}`**のような名前の一時ファイルが`/tmp`に生成されます。ただし、一部のDockerイメージでは、生成されたファイルに数字が含まれていないことがあります。

ローカルファイルインクルージョンでは、**そのアップロードされたファイルをインクルードできれば、RCEを取得できます**。

デフォルトでは、**PHPは単一リクエストで20ファイルのみをアップロードできるように許可しています**（`/etc/php/<version>/apache2/php.ini`で設定）。
```
; Maximum number of files that can be uploaded via a single request
max_file_uploads = 20
```
### 永遠の待ち技術

この技術では、**相対パスを制御するだけで済みます**。ファイルをアップロードし、**LFIを終了させないようにする**ことができれば、**アップロードされたファイルをブルートフォース攻撃**して、**アップロードされたファイルのいずれかを見つける**のに「十分な時間」があります。

**この技術の利点**:

- include内で相対パスを制御するだけで済む
- nginxやログファイルへの予期せぬアクセスレベルは必要ない
- セグメンテーション違反を引き起こすための0日が必要ない
- パスの開示が必要ない

この技術の**主な問題点**は:

- 特定のファイルが存在する必要がある（他にもあるかもしれない）
- **潜在的なファイル名の膨大な数**: **56800235584**
- サーバーが**数字を使用していない**場合、合計潜在的な数は: **19770609664**
- デフォルトでは**1リクエストで最大20ファイル**しかアップロードできない。
- 使用されているサーバーの**最大並列ワーカー数**。
- これらの制限により、この攻撃が長引く可能性があります
- **PHPリクエストのタイムアウト**。理想的には永久にするか、PHPプロセスを削除せずに一時的にアップロードされたファイルを削除する必要があります。そうでない場合、これも問題になります

では、どのようにして**PHP includeを終了させないように**できるでしょうか？単に、ファイル **`/sys/kernel/security/apparmor/revision`** をインクルードするだけです（**Dockerコンテナでは利用できません**残念ながら...）。

試してみるには、次のように呼び出してください:
```bash
php -a # open php cli
include("/sys/kernel/security/apparmor/revision");
```
## Apache2

デフォルトでは、Apacheは**150の同時接続**をサポートしています。[https://ubiq.co/tech-blog/increase-max-connections-apache/](https://ubiq.co/tech-blog/increase-max-connections-apache/)に従って、この数を最大8000までアップグレードすることが可能です。PHPをそのモジュールと共に使用するには、[https://www.digitalocean.com/community/tutorials/how-to-configure-apache-http-with-mpm-event-and-php-fpm-on-ubuntu-18-04](https://www.digitalocean.com/community/tutorials/how-to-configure-apache-http-with-mpm-event-and-php-fpm-on-ubuntu-18-04)に従ってください。

デフォルトでは（私のテストで確認できるように）、**PHPプロセスは永遠に続く**ことができます。

計算してみましょう：

- **149の接続**を使用して、**149 \* 20 = 2980個の一時ファイル**をWebシェルで生成できます。
- 次に、**最後の接続**を使用して、潜在的なファイルを**ブルートフォース**します。
- **10リクエスト/秒**の速度で、時間は次のようになります：
  - 56800235584 / 2980 / 10 / 3600 ≈ **530時間**（50%の確率で265時間）
  - （小数点以下を無視）19770609664 / 2980 / 10 / 3600 ≈ 185時間（50%の確率で93時間）

{% hint style="warning" %}
前述の例では、**他のクライアントを完全にDoS攻撃**していることに注意してください！
{% endhint %}

Apacheサーバーが改善され、**4000の接続**を悪用できるようになれば（最大数の半分まで）、`3999*20 = 79980` **ファイル**を作成し、**数**は約**19.7時間**または**6.9時間**（10時間、3.5時間50%の確率）に短縮されます。

## PHP-FMP

Apacheの通常のphpモジュールを使用する代わりに、**webページがPHP-FMPを使用している場合**（これはWebページの効率を向上させるため、一般的に見つけることができます）、テクニックを改善するために他にもできることがあります。

PHP-FMPは、**`/etc/php/<php-version>/fpm/pool.d/www.conf`**で**`request_terminate_timeout`**パラメータを**設定**できます。\
このパラメータは、PHPへのリクエストが終了する必要がある最大秒数を示します（デフォルトでは無限ですが、パラメータがコメントアウトされている場合は**30秒**）。PHPによってリクエストが処理されている間に、指定された秒数が経過すると、それが**中断**されます。つまり、リクエストが一時ファイルをアップロードしていた場合、**php処理が停止**されたため、それらの**ファイルは削除されません**。したがって、リクエストをその時間だけ続けることができれば、削除されない**数千の一時ファイル**を生成でき、それによりそれらを見つけるプロセスが**高速化**され、すべての接続を消費してプラットフォームにDoSを引き起こす確率が低下します。

したがって、DoSを**回避**するために、**攻撃者が同時に100の接続しか使用しない**と仮定し、php-fmpによるphp最大処理時間（`request_terminate_timeout`）が**30秒**であるとします。したがって、**1秒あたり**に生成できる**一時ファイル**の数は`100*20/30 = 66.67`です。

その後、**10000個のファイル**を生成するには、攻撃者が必要とする時間は：**`10000/66.67 = 150秒`**です（**100000個のファイル**を生成するには、時間は**25分**になります）。

その後、攻撃者はこれらの**100の接続**を使用して**検索ブルートフォース**を実行できます。**300リクエスト/秒**の速度を仮定すると、この攻撃を実行するために必要な時間は次のとおりです：

- 56800235584 / 10000 / 300 / 3600 ≈ **5.25時間**（50%の確率で2.63時間）
- （100000個のファイルを使用する場合）56800235584 / 100000 / 300 / 3600 ≈ **0.525時間**（50%の確率で0.263時間）

はい、EC2中サイズのインスタンスで100000個の一時ファイルを生成することが可能です：

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (3).png" alt=""><figcaption></figcaption></figure>

{% hint style="warning" %}
タイムアウトをトリガーするには、**脆弱なLFIページを含めるだけで十分**です。これにより、永遠にインクルードループに入ります。
{% endhint %}

## Nginx

デフォルトでは、Nginxは**同時に512の接続**をサポートしているようです（この数は改善できます）。
