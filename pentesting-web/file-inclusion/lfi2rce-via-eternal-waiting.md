# LFI2RCEを介した永遠の待機

<details>

<summary><strong>AWSハッキングをゼロからヒーローまで学ぶ</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>！</strong></summary>

HackTricksをサポートする他の方法:

* **HackTricksにあなたの会社を広告したい**、または**HackTricksをPDFでダウンロードしたい**場合は、[**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS & HackTricksグッズ**](https://peass.creator-spring.com)を手に入れましょう。
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクションをチェックしてください。
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)や[**テレグラムグループ**](https://t.me/peass)に**参加する**か、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)を**フォロー**してください。
* [**HackTricks**](https://github.com/carlospolop/hacktricks)と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のgithubリポジトリにPRを提出して、あなたのハッキングのコツを**共有してください**。

</details>

## 基本情報

デフォルトでは、PHPにファイルがアップロードされると（期待していなくても）、`/tmp`に**`php[a-zA-Z0-9]{6}`**という名前の一時ファイルが生成されますが、生成されたファイルに数字が含まれていないdockerイメージも見たことがあります。

ローカルファイルインクルージョンでは、**アップロードされたファイルをインクルードすることに成功すれば、RCEを得ることができます**。

デフォルトでは**PHPは単一のリクエストで20ファイルのみアップロードを許可している**ことに注意してください（`/etc/php/<version>/apache2/php.ini`で設定）。
```
; Maximum number of files that can be uploaded via a single request
max_file_uploads = 20
```
また、**潜在的なファイル名の数は62\*62\*62\*62\*62\*62 = 56800235584です**

### その他の技術

その他の技術は、PHPプロトコルを攻撃すること（パスの最後の部分のみを制御している場合はできません）、ファイルのパスを公開すること、予想されるファイルを悪用すること、または**PHPにセグメンテーションフォールトを引き起こしてアップロードされた一時ファイルが削除されないようにする**ことに依存しています。\
この技術は**最後のものと非常に似ていますが、ゼロデイを見つける必要はありません**。

### 永遠の待機技術

この技術では**相対パスのみを制御する必要があります**。ファイルをアップロードして**LFIを終わらせない**ようにすることができれば、「十分な時間」があり、アップロードされたファイルを**ブルートフォース**して、アップロードされたものを**見つける**ことができます。

**この技術の利点**：

* include内で相対パスのみを制御する必要があります
* nginxやログファイルへの予期しないアクセスレベルは必要ありません
* セグメンテーションフォールトを引き起こすための0デイは必要ありません
* パスの公開は必要ありません

この技術の**主な問題点**は以下の通りです：

* 特定のファイルが存在する必要があります（もっとあるかもしれません）
* 潜在的なファイル名の**狂気の**量：**56800235584**
* サーバーが数字を**使用していない場合**、潜在的な総数は：**19770609664**
* デフォルトでは**単一のリクエストで20ファイル**のみがアップロードできます。
* 使用されるサーバーの**最大並列ワーカー数**。
* この制限と前述の制限により、この攻撃があまりにも長く続く可能性があります
* **PHPリクエストのタイムアウト**。理想的にはこれは永遠であるべきですし、PHPプロセスを削除せずに一時アップロードファイルを削除せずにPHPプロセスを終了させるべきですが、そうでなければこれも問題になります

では、どうやって**PHP includeを永遠に終わらせない**ようにするのでしょうか？ファイル**`/sys/kernel/security/apparmor/revision`**を含めるだけです（残念ながら**Dockerコンテナでは利用できません**...）。

以下を試してみてください：
```bash
php -a # open php cli
include("/sys/kernel/security/apparmor/revision");
```
## Apache2

デフォルトでは、Apacheは**150の同時接続**をサポートしていますが、[https://ubiq.co/tech-blog/increase-max-connections-apache/](https://ubiq.co/tech-blog/increase-max-connections-apache/)に従って、この数を最大8000まで増やすことが可能です。このモジュールをPHPで使用するには、次のリンクを参照してください：[https://www.digitalocean.com/community/tutorials/how-to-configure-apache-http-with-mpm-event-and-php-fpm-on-ubuntu-18-04](https://www.digitalocean.com/community/tutorials/how-to-configure-apache-http-with-mpm-event-and-php-fpm-on-ubuntu-18-04)。

デフォルトでは（私のテストで見る限り）、**PHPプロセスは永遠に続く**可能性があります。

いくつかの計算をしましょう：

* **149の接続**を使用して、ウェブシェルを含む**2980の一時ファイル**を生成できます（149 * 20 = 2980）。
* 次に、**最後の接続**を使用して、潜在的なファイルを**ブルートフォース**します。
* **10リクエスト/秒**の速度で、時間は以下の通りです：
* 56800235584 / 2980 / 10 / 3600 ≈ **530時間**（50%の確率で265時間）
* （小数点なしで）19770609664 / 2980 / 10 / 3600 ≈ 185時間（50%の確率で93時間）

{% hint style="warning" %}
前述の例では、他のクライアントを**完全にDoS攻撃している**ことに注意してください！
{% endhint %}

Apacheサーバーが改善され、**4000の接続**（最大数の半分）を悪用できる場合、`3999*20 = 79980`の**ファイル**を作成でき、**数**は約**19.7時間**または**6.9時間**（10時間、50%の確率で3.5時間）に**削減**されます。

## PHP-FMP

通常のphp modを使用する代わりに、**ウェブページが** **PHP-FMP**を使用している場合（これによりウェブページの効率が向上するため、よく見られます）、技術を改善するために別のことができます。

PHP-FMPでは、**`/etc/php/<php-version>/fpm/pool.d/www.conf`**内で**`request_terminate_timeout`**という**パラメータ**を**設定**できます。\
このパラメータは、**PHPへのリクエストが終了するべき最大秒数**を示します（デフォルトでは無限ですが、パラメータがコメント解除されている場合は**30秒**）。PHPが指定された秒数処理しているリクエストは**終了**します。つまり、リクエストが一時ファイルをアップロードしていた場合、**PHP処理が停止された**ため、それらの**ファイルは削除されません**。したがって、リクエストをその時間だけ続けることができれば、削除されない**数千の一時ファイル**を**生成**でき、それらを見つけるプロセスが**速くなり**、すべての接続を消費してプラットフォームにDoSを引き起こす可能性が減ります。

DoSを**避ける**ために、攻撃者が同時に**100の接続**のみを使用し、**php-fmp**によるphpの最大処理時間（`request_terminate_timeout`**)**が**30秒**であると仮定しましょう。したがって、**秒間**に生成できる**一時ファイル**の数は`100*20/30 = 66.67`です。

その後、攻撃者は**10000ファイル**を生成するために：**`10000/66.67 = 150秒`**が必要です（**100000ファイル**を生成する時間は**25分**です）。

次に、攻撃者はそれらの**100の接続**を使用して**ブルートフォース検索**を実行できます。**** 300 req/sの速度を仮定すると、この利用に必要な時間は以下の通りです：

* 56800235584 / 10000 / 300 / 3600 ≈ **5.25時間**（50%の確率で2.63時間）
* （100000ファイルで）56800235584 / 100000 / 300 / 3600 ≈ **0.525時間**（50%の確率で0.263時間）

はい、EC2の中サイズインスタンスで100000の一時ファイルを生成することは可能です：

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (3).png" alt=""><figcaption></figcaption></figure>

{% hint style="warning" %}
タイムアウトをトリガーするには、脆弱なLFIページを含めるだけで十分であり、それによって永遠のインクルードループに入ることに注意してください。
{% endhint %}

## Nginx

デフォルトでは、Nginxは同時に**512の並行接続**をサポートしているようです（この数は改善可能です）。

<details>

<summary><strong>htARTE（HackTricks AWS Red Team Expert）で</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>AWSハッキングをゼロからヒーローまで学ぶ</strong></a><strong>！</strong></summary>

HackTricksをサポートする他の方法：

* **HackTricksにあなたの会社を広告したい**、または**HackTricksをPDFでダウンロードしたい**場合は、[**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式のPEASS & HackTricksグッズ**](https://peass.creator-spring.com)を入手してください。
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見してください。私たちの独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクションです。
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)に**参加するか**、[**テレグラムグループ**](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)で**フォロー**してください。
* **HackTricks**の[**GitHubリポジトリ**](https://github.com/carlospolop/hacktricks)と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)にPRを提出して、あなたのハッキングのコツを共有してください。

</details>
