# LFI2RCE via Attente √©ternelle

<details>

<summary><strong>Apprenez le piratage AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Autres moyens de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop)!
* Obtenez le [**merchandising officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**La Famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection d'[**NFTs**](https://opensea.io/collection/the-peass-family) exclusifs
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez-moi** sur **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux d√©p√¥ts github** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## Informations de base

Par d√©faut, lorsqu'un fichier est t√©l√©vers√© sur PHP (m√™me s'il ne l'attend pas), il g√©n√©rera un fichier temporaire dans `/tmp` avec un nom tel que **`php[a-zA-Z0-9]{6}`**, bien que j'aie vu des images docker o√π les fichiers g√©n√©r√©s ne contiennent pas de chiffres.

Dans une inclusion de fichier local, **si vous parvenez √† inclure ce fichier t√©l√©vers√©, vous obtiendrez un RCE**.

Notez que par d√©faut **PHP ne permet de t√©l√©verser que 20 fichiers dans une seule requ√™te** (d√©fini dans `/etc/php/<version>/apache2/php.ini`) :
```
; Maximum number of files that can be uploaded via a single request
max_file_uploads = 20
```
Aussi, **le nombre de noms de fichiers potentiels est de 62\*62\*62\*62\*62\*62 = 56800235584**

### Autres techniques

D'autres techniques reposent sur l'attaque de protocoles PHP (vous ne pourrez pas si vous contr√¥lez uniquement la derni√®re partie du chemin), la divulgation du chemin du fichier, l'exploitation de fichiers attendus, ou **faire en sorte que PHP subisse une faute de segmentation pour que les fichiers temporaires t√©l√©charg√©s ne soient pas supprim√©s**.\
Cette technique est **tr√®s similaire √† la pr√©c√©dente mais sans avoir besoin de trouver un zero day**.

### Technique de l'attente √©ternelle

Dans cette technique, **nous avons seulement besoin de contr√¥ler un chemin relatif**. Si nous parvenons √† t√©l√©charger des fichiers et √† faire en sorte que **l'inclusion LFI ne se termine jamais**, nous aurons "suffisamment de temps" pour **forcer le passage des fichiers t√©l√©charg√©s** et **trouver** l'un des fichiers t√©l√©charg√©s.

**Avantages de cette technique** :

* Vous avez juste besoin de contr√¥ler un chemin relatif dans une inclusion
* Ne n√©cessite pas nginx ou un niveau d'acc√®s inattendu aux fichiers journaux
* Ne n√©cessite pas un zero day pour provoquer une faute de segmentation
* Ne n√©cessite pas une divulgation de chemin

Les **principaux probl√®mes** de cette technique sont :

* N√©cessit√© qu'un fichier sp√©cifique soit pr√©sent (il pourrait y en avoir d'autres)
* Le nombre **insens√©** de noms de fichiers potentiels : **56800235584**
* Si le serveur **n'utilise pas de chiffres** le nombre total potentiel est de : **19770609664**
* Par d√©faut, **seulement 20 fichiers** peuvent √™tre t√©l√©charg√©s dans une **seule requ√™te**.
* Le **nombre maximum de travailleurs parall√®les** du serveur utilis√©.
* Cette limite avec les pr√©c√©dentes peut rendre cette attaque trop longue
* **D√©lai d'attente pour une requ√™te PHP**. Id√©alement, cela devrait √™tre √©ternel ou devrait tuer le processus PHP sans supprimer les fichiers temporairement t√©l√©charg√©s, sinon, cela sera √©galement un probl√®me

Alors, comment pouvez-vous **faire en sorte qu'une inclusion PHP ne se termine jamais** ? Tout simplement en incluant le fichier **`/sys/kernel/security/apparmor/revision`** (**malheureusement non disponible dans les conteneurs Docker**).

Essayez-le en appelant :
```bash
php -a # open php cli
include("/sys/kernel/security/apparmor/revision");
```
## Apache2

Par d√©faut, Apache supporte **150 connexions simultan√©es**, en suivant [https://ubiq.co/tech-blog/increase-max-connections-apache/](https://ubiq.co/tech-blog/increase-max-connections-apache/) il est possible d'augmenter ce nombre jusqu'√† 8000. Suivez ceci pour utiliser PHP avec ce module : [https://www.digitalocean.com/community/tutorials/how-to-configure-apache-http-with-mpm-event-and-php-fpm-on-ubuntu-18-04](https://www.digitalocean.com/community/tutorials/how-to-configure-apache-http-with-mpm-event-and-php-fpm-on-ubuntu-18-04).

Par d√©faut, (comme je peux le voir dans mes tests), un **processus PHP peut durer √©ternellement**.

Faisons quelques calculs :

* Nous pouvons utiliser **149 connexions** pour g√©n√©rer **149 \* 20 = 2980 fichiers temporaires** avec notre webshell.
* Ensuite, utiliser la **derni√®re connexion** pour **forcer brutalement** les fichiers potentiels.
* √Ä une vitesse de **10 requ√™tes/s**, les temps sont :
* 56800235584 / 2980 / 10 / 3600 ‚âà **530 heures** (50% de chance en 265h)
* (sans chiffres) 19770609664 / 2980 / 10 / 3600 ‚âà 185h (50% de chance en 93h)

{% hint style="warning" %}
Notez que dans l'exemple pr√©c√©dent, nous sommes en train de **DoS compl√®tement les autres clients** !
{% endhint %}

Si le serveur Apache est am√©lior√© et que nous pouvions abuser de **4000 connexions** (√† mi-chemin du maximum). Nous pourrions cr√©er `3999*20 = 79980` **fichiers** et le **nombre** serait **r√©duit** √† environ **19.7h** ou **6.9h** (10h, 3.5h 50% de chance).

## PHP-FMP

Si au lieu d'utiliser le module php r√©gulier pour apache pour ex√©cuter des scripts PHP, **la page web utilise** **PHP-FMP** (cela am√©liore l'efficacit√© de la page web, donc il est courant de le trouver), il y a autre chose qui peut √™tre fait pour am√©liorer la technique.

PHP-FMP permet de **configurer** le **param√®tre** **`request_terminate_timeout`** dans **`/etc/php/<version-php>/fpm/pool.d/www.conf`**.\
Ce param√®tre indique le nombre maximum de secondes **quand** **la requ√™te √† PHP doit se terminer** (infini par d√©faut, mais **30s si le param√®tre est d√©comment√©**). Lorsqu'une requ√™te est trait√©e par PHP pendant le nombre de secondes indiqu√©, elle est **tu√©e**. Cela signifie que si la requ√™te √©tait en train de t√©l√©charger des fichiers temporaires, parce que le **traitement php a √©t√© arr√™t√©**, ces **fichiers ne seront pas supprim√©s**. Par cons√©quent, si vous pouvez faire durer une requ√™te ce temps, vous pouvez **g√©n√©rer des milliers de fichiers temporaires** qui ne seront pas supprim√©s, ce qui **acc√©l√©rera le processus de les trouver** et r√©duit la probabilit√© d'un DoS sur la plateforme en consommant toutes les connexions.

Donc, pour **√©viter le DoS**, supposons qu'un **attaquant utilisera seulement 100 connexions** en m√™me temps et le temps de traitement maximum par **php-fmp** (`request_terminate_timeout`**) est de **30s**. Par cons√©quent, le nombre de **fichiers temporaires** qui peuvent √™tre g√©n√©r√©s **par seconde** est `100*20/30 = 66.67`.

Ensuite, pour g√©n√©rer **10000 fichiers**, un attaquant aurait besoin : **`10000/66.67 = 150s`** (pour g√©n√©rer **100000 fichiers**, le temps serait de **25min**).

Ensuite, l'attaquant pourrait utiliser ces **100 connexions** pour effectuer une **recherche par force brute**. \*\*\*\* En supposant une vitesse de 300 req/s, le temps n√©cessaire pour exploiter ceci est le suivant :

* 56800235584 / 10000 / 300 / 3600 ‚âà **5.25 heures** (50% de chance en 2.63h)
* (avec 100000 fichiers) 56800235584 / 100000 / 300 / 3600 ‚âà **0.525 heures** (50% de chance en 0.263h)

Oui, il est possible de g√©n√©rer 100000 fichiers temporaires dans une instance EC2 de taille moyenne :

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (3).png" alt=""><figcaption></figcaption></figure>

{% hint style="warning" %}
Notez que pour d√©clencher le d√©lai d'attente, il suffirait d'inclure la page LFI vuln√©rable, pour qu'elle entre dans une boucle d'inclusion √©ternelle.
{% endhint %}

## Nginx

Il semble que par d√©faut Nginx supporte **512 connexions parall√®les** en m√™me temps (et ce nombre peut √™tre am√©lior√©).

<details>

<summary><strong>Apprenez le hacking AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Autres moyens de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop)!
* Obtenez le [**merchandising officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**La Famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection d'[**NFTs**](https://opensea.io/collection/the-peass-family) exclusifs
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Partagez vos astuces de hacking en soumettant des PR aux d√©p√¥ts github** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
