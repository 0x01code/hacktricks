# 通过永久等待实现LFI2RCE

<details>

<summary><strong>从零开始学习AWS黑客技术，成为专家</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE（HackTricks AWS红队专家）</strong></a><strong>！</strong></summary>

支持HackTricks的其他方式：

* 如果您想看到您的**公司在HackTricks中做广告**或**下载PDF格式的HackTricks**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)!
* 获取[**官方PEASS & HackTricks周边产品**](https://peass.creator-spring.com)
* 探索[**PEASS家族**](https://opensea.io/collection/the-peass-family)，我们的独家[**NFTs**](https://opensea.io/collection/the-peass-family)
* **加入** 💬 [**Discord群**](https://discord.gg/hRep4RUj7f) 或 [**电报群**](https://t.me/peass) 或 **关注**我们的**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**。**
* 通过向[**HackTricks**](https://github.com/carlospolop/hacktricks)和[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github仓库提交PR来分享您的黑客技巧。

</details>

## 基本信息

默认情况下，当将文件上传到PHP时（即使PHP不期望），它会在`/tmp`目录中生成一个临时文件，文件名类似于**`php[a-zA-Z0-9]{6}`**，尽管我看到一些Docker镜像生成的文件不包含数字。

在本地文件包含中，**如果您成功包含了上传的文件，您将获得RCE**。

请注意，默认情况下**PHP仅允许在单个请求中上传20个文件**（设置在`/etc/php/<version>/apache2/php.ini`中）：
```
; Maximum number of files that can be uploaded via a single request
max_file_uploads = 20
```
### 永久等待技术

在这种技术中，**我们只需要控制一个相对路径**。如果我们设法上传文件并使**LFI永不结束**，我们将有"足够的时间"来**暴力破解上传的文件**并**找到**其中任何一个。

**这种技术的优点**：

- 您只需要控制包含文件中的相对路径
- 不需要nginx或意外级别的访问日志文件
- 不需要0天来导致分段错误
- 不需要路径泄露

这种技术的**主要问题**包括：

- 需要特定文件存在（可能有更多）
- **潜在文件名的数量巨大**：**56800235584**
- 如果服务器**不使用数字**，则总潜在数量为：**19770609664**
- 默认情况下，**每个请求只能上传20个文件**。
- 所使用服务器的**最大并行工作者数**。
- 这个限制与之前的限制可能导致攻击持续时间过长
- **PHP请求的超时**。理想情况下，这应该是永久的，或者应该在不删除临时上传文件的情况下终止PHP进程，否则这也将是一个问题

那么，您如何**使PHP包含永不结束**？只需包含文件**`/sys/kernel/security/apparmor/revision`**（**不幸的是，在Docker容器中不可用**）。

尝试调用它：
```bash
php -a # open php cli
include("/sys/kernel/security/apparmor/revision");
```
## Apache2

默认情况下，Apache 支持 **150 个并发连接**，根据 [https://ubiq.co/tech-blog/increase-max-connections-apache/](https://ubiq.co/tech-blog/increase-max-connections-apache/) 可以将此数字提升至 8000。按照以下步骤使用 PHP 与该模块：[https://www.digitalocean.com/community/tutorials/how-to-configure-apache-http-with-mpm-event-and-php-fpm-on-ubuntu-18-04](https://www.digitalocean.com/community/tutorials/how-to-configure-apache-http-with-mpm-event-and-php-fpm-on-ubuntu-18-04)。

默认情况下（根据我的测试），**PHP 进程可以永久存在**。

让我们做一些数学计算：

* 我们可以使用 **149 个连接** 生成 **149 \* 20 = 2980 个临时文件**与我们的 Webshell。
* 然后，使用 **最后一个连接** 来 **暴力破解** 潜在文件。
* 以 **10 个请求/秒** 的速度计算，时间为：
* 56800235584 / 2980 / 10 / 3600 \~= **530 小时**（50% 的概率在 265 小时内）
* （去掉小数）19770609664 / 2980 / 10 / 3600 \~= 185 小时（50% 的概率在 93 小时内）

{% hint style="warning" %}
请注意，在上述示例中，我们正在 **完全 DoS 其他客户端**！
{% endhint %}

如果 Apache 服务器得到改进，我们可以滥用 **4000 个连接**（接近最大数量的一半）。我们可以创建 `3999*20 = 79980` **文件**，这将使时间缩短至约 **19.7 小时** 或 **6.9 小时**（10 小时，3.5 小时 50% 的概率）。

## PHP-FMP

如果网页使用 **PHP-FMP** 而不是常规的 PHP 模块来运行 PHP 脚本（这可以提高网页的效率，因此很常见），那么有一些其他方法可以改进技术。

PHP-FMP 允许在 **`/etc/php/<php-version>/fpm/pool.d/www.conf`** 中配置参数 **`request_terminate_timeout`**。\
此参数指示 PHP 请求必须在多少秒内终止（默认情况下为无限，但如果取消注释，则为 **30 秒**）。当 PHP 处理请求达到指定的秒数时，请求将被 **终止**。这意味着，如果请求正在处理中，由于 **PHP 处理被停止**，这些 **文件不会被删除**。因此，如果您可以使请求持续那么长时间，您可以 **生成成千上万个临时文件**，这些文件不会被删除，这将 **加快查找文件的过程**，减少通过消耗所有连接来对平台进行 DoS 的概率。

因此，为了 **避免 DoS**，假设攻击者一次只使用 **100 个连接**，并且由 **php-fmp** 控制的 PHP 最大处理时间（`request_terminate_timeout`）为 **30 秒**。因此，攻击者每秒可以生成的 **临时文件数** 为 `100*20/30 = 66.67`。

然后，要生成 **10000 个文件**，攻击者需要：**`10000/66.67 = 150 秒`**（要生成 **100000 个文件**，时间将为 **25 分钟**）。

然后，攻击者可以使用这些 **100 个连接** 执行 **搜索暴力破解**。假设速度为 300 次/秒，利用此漏洞所需的时间如下：

* 56800235584 / 10000 / 300 / 3600 \~= **5.25 小时**（50% 的概率在 2.63 小时内）
* （有 100000 个文件时）56800235584 / 100000 / 300 / 3600 \~= **0.525 小时**（50% 的概率在 0.263 小时内）

是的，可以在 EC2 中型实例中生成 100000 个临时文件：

<figure><img src="../../.gitbook/assets/image (240).png" alt=""><figcaption></figcaption></figure>

{% hint style="warning" %}
请注意，为了触发超时，**只需包含易受攻击的 LFI 页面**，使其进入永久包含循环。
{% endhint %}

## Nginx

默认情况下，Nginx 支持 **512 个并行连接**（此数字可以提高）。
