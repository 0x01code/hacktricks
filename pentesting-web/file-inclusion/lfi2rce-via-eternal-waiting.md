# LFI2RCE a trav√©s de la espera eterna

<details>

<summary><strong>Aprende hacking en AWS de cero a h√©roe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si quieres ver tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF**, consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Consigue el [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* **√önete al** üí¨ [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠gueme** en **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de github de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## Informaci√≥n B√°sica

Por defecto, cuando se sube un archivo a PHP (incluso si no lo est√° esperando), generar√° un archivo temporal en `/tmp` con un nombre como **`php[a-zA-Z0-9]{6}`**, aunque he visto algunas im√°genes de docker donde los archivos generados no contienen d√≠gitos.

En una inclusi√≥n de archivo local, **si logras incluir ese archivo subido, conseguir√°s RCE**.

Ten en cuenta que por defecto **PHP solo permite subir 20 archivos en una sola petici√≥n** (configurado en `/etc/php/<version>/apache2/php.ini`):
```
; Maximum number of files that can be uploaded via a single request
max_file_uploads = 20
```
Tambi√©n, el **n√∫mero de nombres de archivos potenciales es 62\*62\*62\*62\*62\*62 = 56800235584**

### Otras t√©cnicas

Otras t√©cnicas se basan en atacar protocolos de PHP (no podr√°s si solo controlas la √∫ltima parte de la ruta), revelando la ruta del archivo, abusando de archivos esperados, o **haciendo que PHP sufra una falla de segmentaci√≥n para que los archivos temporales subidos no se eliminen**.\
Esta t√©cnica es **muy similar a la √∫ltima pero sin necesidad de encontrar un zero day**.

### T√©cnica de espera eterna

En esta t√©cnica **solo necesitamos controlar una ruta relativa**. Si logramos subir archivos y hacer que el **LFI nunca termine**, tendremos "suficiente tiempo" para **fuerza bruta en archivos subidos** y **encontrar** cualquiera de los que se hayan subido.

**Pros de esta t√©cnica**:

* Solo necesitas controlar una ruta relativa dentro de un include
* No requiere nginx ni un nivel de acceso inesperado a archivos de registro
* No requiere un 0 day para causar una falla de segmentaci√≥n
* No requiere revelaci√≥n de ruta

Los **problemas principales** de esta t√©cnica son:

* Necesidad de que est√© presente un archivo espec√≠fico(s) (podr√≠a haber m√°s)
* La cantidad **insana** de nombres de archivos potenciales: **56800235584**
* Si el servidor **no utiliza d√≠gitos** la cantidad total potencial es: **19770609664**
* Por defecto **solo se pueden subir 20 archivos** en una **sola solicitud**.
* El **n√∫mero m√°ximo de trabajadores paralelos** del servidor utilizado.
* Este l√≠mite con los anteriores puede hacer que este ataque dure demasiado
* **Tiempo de espera para una solicitud de PHP**. Idealmente, esto deber√≠a ser eterno o deber√≠a matar el proceso de PHP sin eliminar los archivos temporales subidos, si no, esto tambi√©n ser√° un problema

Entonces, ¬øc√≥mo puedes **hacer que un include de PHP nunca termine**? Simplemente incluyendo el archivo **`/sys/kernel/security/apparmor/revision`** (**lamentablemente no disponible en contenedores Docker**).

Pru√©balo llamando:
```bash
php -a # open php cli
include("/sys/kernel/security/apparmor/revision");
```
## Apache2

Por defecto, Apache soporta **150 conexiones concurrentes**, siguiendo [https://ubiq.co/tech-blog/increase-max-connections-apache/](https://ubiq.co/tech-blog/increase-max-connections-apache/) es posible aumentar este n√∫mero hasta 8000. Sigue esto para usar PHP con ese m√≥dulo: [https://www.digitalocean.com/community/tutorials/how-to-configure-apache-http-with-mpm-event-and-php-fpm-on-ubuntu-18-04](https://www.digitalocean.com/community/tutorials/how-to-configure-apache-http-with-mpm-event-and-php-fpm-on-ubuntu-18-04).

Por defecto, (como puedo ver en mis pruebas), un **proceso PHP puede durar eternamente**.

Hagamos algunos c√°lculos:

* Podemos usar **149 conexiones** para generar **149 \* 20 = 2980 archivos temporales** con nuestro webshell.
* Luego, usar la **√∫ltima conexi√≥n** para **fuerza bruta** de archivos potenciales.
* A una velocidad de **10 solicitudes/s** los tiempos son:
* 56800235584 / 2980 / 10 / 3600 \~= **530 horas** (50% de probabilidad en 265h)
* (sin d√≠gitos) 19770609664 / 2980 / 10 / 3600 \~= 185h (50% de probabilidad en 93h)

{% hint style="warning" %}
¬°Nota que en el ejemplo anterior estamos **DoSing completamente a otros clientes**!
{% endhint %}

Si el servidor Apache est√° mejorado y pudi√©ramos abusar de **4000 conexiones** (a mitad de camino hacia el m√°ximo). Podr√≠amos crear `3999*20 = 79980` **archivos** y el **n√∫mero** se **reducir√≠a** a alrededor de **19.7h** o **6.9h** (10h, 3.5h con 50% de probabilidad).

## PHP-FMP

Si en lugar de usar el m√≥dulo php regular para apache para ejecutar scripts PHP, la **p√°gina web est√° usando** **PHP-FMP** (esto mejora la eficiencia de la p√°gina web, por lo que es com√∫n encontrarlo), hay algo m√°s que se puede hacer para mejorar la t√©cnica.

PHP-FMP permite **configurar** el **par√°metro** **`request_terminate_timeout`** en **`/etc/php/<php-version>/fpm/pool.d/www.conf`**.\
Este par√°metro indica la cantidad m√°xima de segundos **cuando** **la solicitud a PHP debe terminar** (infinito por defecto, pero **30s si el par√°metro est√° descomentado**). Cuando una solicitud est√° siendo procesada por PHP el n√∫mero indicado de segundos, es **terminada**. Esto significa, que si la solicitud estaba subiendo archivos temporales, debido a que el **procesamiento de php fue detenido**, esos **archivos no van a ser eliminados**. Por lo tanto, si puedes hacer que una solicitud dure ese tiempo, puedes **generar miles de archivos temporales** que no ser√°n eliminados, lo que **acelerar√° el proceso de encontrarlos** y reduce la probabilidad de un DoS a la plataforma al consumir todas las conexiones.

Entonces, para **evitar DoS** supongamos que un **atacante estar√° usando solo 100 conexiones** al mismo tiempo y el tiempo m√°ximo de procesamiento de php por **php-fmp** (`request_terminate_timeout`**) es **30s**. Por lo tanto, el n√∫mero de **archivos temporales** que se pueden generar **por segundo** es `100*20/30 = 66.67`.

Luego, para generar **10000 archivos** un atacante necesitar√≠a: **`10000/66.67 = 150s`** (para generar **100000 archivos** el tiempo ser√≠a **25min**).

Luego, el atacante podr√≠a usar esas **100 conexiones** para realizar una **b√∫squeda por fuerza bruta**. \*\*\*\* Suponiendo una velocidad de 300 req/s el tiempo necesario para explotar esto es el siguiente:

* 56800235584 / 10000 / 300 / 3600 \~= **5.25 horas** (50% de probabilidad en 2.63h)
* (con 100000 archivos) 56800235584 / 100000 / 300 / 3600 \~= **0.525 horas** (50% de probabilidad en 0.263h)

S√≠, es posible generar 100000 archivos temporales en una instancia EC2 de tama√±o medio:

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (3).png" alt=""><figcaption></figcaption></figure>

{% hint style="warning" %}
Nota que para activar el tiempo de espera ser√≠a **suficiente incluir la p√°gina LFI vulnerable**, para que entre en un bucle de inclusi√≥n eterno.
{% endhint %}

## Nginx

Parece que por defecto Nginx soporta **512 conexiones paralelas** al mismo tiempo (y este n√∫mero puede ser mejorado).

<details>

<summary><strong>Aprende hacking en AWS de cero a h√©roe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si quieres ver a tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** revisa los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Consigue el [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* **√önete al** üí¨ [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠gueme** en **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de github de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
