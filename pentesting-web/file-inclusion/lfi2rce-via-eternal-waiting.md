# LFI2RCE μέσω αιώνιας αναμονής

<details>

<summary><strong>Μάθετε το χάκινγκ του AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι για να υποστηρίξετε το HackTricks:

* Εάν θέλετε να δείτε την **εταιρεία σας να διαφημίζεται στο HackTricks** ή να **κατεβάσετε το HackTricks σε μορφή PDF** ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**The PEASS Family**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Εγγραφείτε στην** 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στην [**ομάδα telegram**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Μοιραστείτε τα χάκινγκ κόλπα σας υποβάλλοντας PRs στα** [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) αποθετήρια του github.

</details>

## Βασικές πληροφορίες

Από προεπιλογή, όταν ένα αρχείο ανεβαίνει στο PHP (ακόμα κι αν δεν το περιμένει), θα δημιουργηθεί ένα προσωρινό αρχείο στο `/tmp` με ένα όνομα όπως **`php[a-zA-Z0-9]{6}`**, αν και έχω δει μερικές εικόνες docker όπου τα δημιουργημένα αρχεία δεν περιέχουν ψηφία.

Σε μια τοπική ενσωμάτωση αρχείου, **αν καταφέρετε να ενσωματώσετε αυτό το ανεβασμένο αρχείο, θα λάβετε RCE**.

Σημειώστε ότι από προεπιλογή **το PHP επιτρέπει μόνο τη μεταφόρτωση 20 αρχείων σε μία μόνο αίτηση** (ορίζεται στο `/etc/php/<version>/apache2/php.ini`):
```
; Maximum number of files that can be uploaded via a single request
max_file_uploads = 20
```
Επίσης, ο **αριθμός των δυνητικών ονομάτων αρχείων είναι 62\*62\*62\*62\*62\*62 = 56800235584**

### Άλλες τεχνικές

Άλλες τεχνικές βασίζονται στην επίθεση σε πρωτόκολλα PHP (δεν θα μπορείτε αν έχετε έλεγχο μόνο στο τελευταίο μέρος της διαδρομής), αποκάλυψη της διαδρομής του αρχείου, κατάχρηση αναμενόμενων αρχείων ή **προκαλώντας σφάλμα στο PHP ώστε τα προσωρινά ανεβασμένα αρχεία να μην διαγράφονται**.\
Αυτή η τεχνική είναι **πολύ παρόμοια με την προηγούμενη, αλλά χωρίς την ανάγκη να βρεθεί μια ευπάθεια**.

### Τεχνική αιώνιας αναμονής

Σε αυτήν την τεχνική, **χρειάζεται μόνο να έχουμε έλεγχο ενός σχετικού μονοπατιού**. Αν καταφέρουμε να ανεβάσουμε αρχεία και να κάνουμε το **LFI να μην τελειώνει ποτέ**, θα έχουμε "αρκετό χρόνο" για να **δοκιμάσουμε όλα τα ανεβασμένα αρχεία** και να **βρούμε** οποιοδήποτε από αυτά που ανέβηκαν.

**Πλεονεκτήματα αυτής της τεχνικής**:

* Χρειάζεστε μόνο έλεγχο ενός σχετικού μονοπατιού μέσα σε ένα include
* Δεν απαιτείται ο server να χρησιμοποιεί nginx ή ένα αναπάντεχο επίπεδο πρόσβασης στα αρχεία καταγραφής
* Δεν απαιτείται μια ευπάθεια για να προκαλέσει σφάλμα στο PHP
* Δεν απαιτείται αποκάλυψη μονοπατιού

Τα **κύρια προβλήματα** αυτής της τεχνικής είναι:

* Χρειάζεται να υπάρχει ένα συγκεκριμένο αρχείο(α) (μπορεί να υπάρχουν περισσότερα)
* Ο **τεράστιος** αριθμός δυνητικών ονομάτων αρχείων: **56800235584**
* Αν ο server **δεν χρησιμοποιεί αριθμούς**, ο συνολικός δυνητικός αριθμός είναι: **19770609664**
* Από προεπιλογή, μπορούν να ανεβάσουν **μόνο 20 αρχεία** σε μία **μόνο αίτηση**.
* Ο **μέγιστος αριθμός παράλληλων εργαζομένων** του χρησιμοποιούμενου server.
* Αυτό το όριο μαζί με τα προηγούμενα μπορεί να καθυστερήσει πολύ αυτήν την επίθεση
* **Χρονικό όριο για μια αίτηση PHP**. Ιδανικά αυτό θα έπρεπε να είναι αιώνιο ή να τερματίζει τη διεργασία PHP χωρίς να διαγράφει τα προσωρινά ανεβασμένα αρχεία, αλλιώς αυτό θα είναι επίσης ενοχλητικό

Έτσι, πώς μπορείτε να **κάνετε ένα PHP include να μην τελειώνει ποτέ**; Απλά περιλάβετε το αρχείο **`/sys/kernel/security/apparmor/revision`** (**δυστυχώς δεν είναι διαθέσιμο σε Docker containers**).

Δοκιμάστε το απλά καλώντας:
```bash
php -a # open php cli
include("/sys/kernel/security/apparmor/revision");
```
## Apache2

Από προεπιλογή, το Apache υποστηρίζει **150 ταυτόχρονες συνδέσεις**, ακολουθώντας το [https://ubiq.co/tech-blog/increase-max-connections-apache/](https://ubiq.co/tech-blog/increase-max-connections-apache/) είναι δυνατόν να αυξηθεί αυτός ο αριθμός έως και 8000. Ακολουθήστε αυτό για να χρησιμοποιήσετε το PHP με αυτήν την επέκταση: [https://www.digitalocean.com/community/tutorials/how-to-configure-apache-http-with-mpm-event-and-php-fpm-on-ubuntu-18-04](https://www.digitalocean.com/community/tutorials/how-to-configure-apache-http-with-mpm-event-and-php-fpm-on-ubuntu-18-04).

Από προεπιλογή, (όπως μπορώ να δω στις δοκιμές μου), ένα **διεργασία PHP μπορεί να διαρκέσει αιώνια**.

Ας κάνουμε μερικούς υπολογισμούς:

* Μπορούμε να χρησιμοποιήσουμε **149 συνδέσεις** για να δημιουργήσουμε **149 \* 20 = 2980 προσωρινά αρχεία** με το webshell μας.
* Στη συνέχεια, χρησιμοποιήστε την **τελευταία σύνδεση** για να **δοκιμάσετε βίαια** πιθανά αρχεία.
* Με ταχύτητα **10 αιτημάτων/δευτ.** οι χρόνοι είναι:
* 56800235584 / 2980 / 10 / 3600 \~= **530 ώρες** (50% πιθανότητα σε 265 ώρες)
* (χωρίς ψηφία) 19770609664 / 2980 / 10 / 3600 \~= 185 ώρες (50% πιθανότητα σε 93 ώρες)

{% hint style="warning" %}
Σημειώστε ότι στο προηγούμενο παράδειγμα είμαστε **εντελώς DoSing άλλους πελάτες**!
{% endhint %}

Εάν ο διακομιστής Apache βελτιωθεί και μπορούμε να καταχραστούμε **4000 συνδέσεις** (στο μισό του μέγιστου αριθμού). Θα μπορούσαμε να δημιουργήσουμε `3999*20 = 79980` **αρχεία** και ο **αριθμός** θα **μειωθεί** σε περίπου **19,7 ώρες** ή **6,9 ώρες** (10 ώρες, 3,5 ώρες 50% πιθανότητα).

## PHP-FMP

Εάν αντί να χρησιμοποιείται η κανονική επέκταση php για την εκτέλεση των σεναρίων PHP στην ιστοσελίδα, η **ιστοσελίδα χρησιμοποιεί PHP-FMP** (αυτό βελτιώνει την αποδοτικότητα της ιστοσελίδας, επομένως είναι συνηθισμένο να το βρίσκουμε), υπάρχει κάτι άλλο που μπορεί να γίνει για να βελτιωθεί η τεχνική.

Το PHP-FMP επιτρέπει να **διαμορφώσετε** τη **παράμετρο** **`request_terminate_timeout`** στο **`/etc/php/<php-version>/fpm/pool.d/www.conf`**.\
Αυτή η παράμετρος υποδεικνύει το μέγιστο χρονικό διάστημα σε δευτερόλεπτα **όταν πρέπει να τερματίσει το αίτημα προς το PHP** (απεριόριστο από προεπιλογή, αλλά **30 δευτ. εάν η παράμετρος είναι ξεσχολιασμένη**). Όταν ένα αίτημα επεξεργάζεται από το PHP για τον αριθμό των δευτερολέπτων που υποδεικνύεται, το αίτημα **τερματίζεται**. Αυτό σημαίνει ότι εάν το αίτημα ανέβαζε προσωρινά αρχεία, επειδή η **επεξεργασία PHP σταμάτησε**, αυτά τα **αρχεία δεν θα διαγραφούν**. Επομένως, εάν μπορείτε να κάνετε ένα αίτημα να διαρκέσει τόσο καιρό, μπορείτε να **δημιουργήσετε χιλιάδες προσωρινά αρχεία** που δεν θα διαγραφούν, τα οποία θα **επιταχύνουν τη διαδικασία εύρεσής τους** και θα μειώσουν την πιθανότητα ενός DoS στην πλατφόρμα από την κατανάλωση όλων των συνδέσεων.

Έτσι, για να **αποφευχθεί ο DoS**, ας υποθέσουμε ότι ένας **επιτιθέμενος θα χρησιμοποιεί μόνο 100 συνδέσεις** ταυτόχρονα και ο μέγιστος χρόνος επεξεργασίας PHP από το **php-fmp** (`request_terminate_timeout`**)** είναι **30 δευτ.** Επομένως, ο αριθμός των **προσωρινών αρχείων** που μπορούν να δημιουργηθούν **ανά δευτερόλεπτο** είναι `100*20/30 = 66.67`.

Στη συνέχεια, για να δημιουργήσετε **10000 αρχεία**, ένας επιτιθέμενος θα χρειαστεί: **`10000/66.67 = 150s`** (για να δημιουργήσετε **100000 αρχεία** ο χρόνος θα είναι **25 λεπτά**).

Στη συνέχεια, ο επιτιθέμενος θα μπορούσε να χρησιμοποιήσει αυτές τις **100 συνδέσεις** για να πραγματοποιήσει μια **αναζήτηση βίαιης δύναμης**. Υποθέτοντας μια ταχ
