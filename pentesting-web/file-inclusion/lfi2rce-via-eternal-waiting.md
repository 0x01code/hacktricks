# LFI2RCE √ºber ewiges Warten

<details>

<summary><strong>Erlernen Sie AWS-Hacking von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen m√∂chten** oder **HackTricks in PDF herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories einreichen.

</details>

## Grundlegende Informationen

Standardm√§√üig generiert PHP beim Hochladen einer Datei (auch wenn es nicht erwartet wird) eine tempor√§re Datei in `/tmp` mit einem Namen wie **`php[a-zA-Z0-9]{6}`**, obwohl ich einige Docker-Images gesehen habe, bei denen die generierten Dateien keine Ziffern enthalten.

Bei einer lokalen Dateieinschlie√üung **erhalten Sie RCE, wenn es Ihnen gelingt, diese hochgeladene Datei einzuschlie√üen**.

Beachten Sie, dass PHP standardm√§√üig **nur das Hochladen von 20 Dateien in einer einzelnen Anfrage zul√§sst** (festgelegt in `/etc/php/<version>/apache2/php.ini`):
```
; Maximum number of files that can be uploaded via a single request
max_file_uploads = 20
```
### Andere Techniken

Andere Techniken beruhen darauf, PHP-Protokolle anzugreifen (Sie werden nicht erfolgreich sein, wenn Sie nur den letzten Teil des Pfads kontrollieren), den Pfad der Datei offenzulegen, erwartete Dateien zu missbrauchen oder PHP dazu zu bringen, einen Segmentierungsfehler zu erleiden, sodass hochgeladene tempor√§re Dateien nicht gel√∂scht werden. Diese Technik ist der letzten sehr √§hnlich, erfordert jedoch kein Zero-Day.

### Ewige Warte-Technik

Bei dieser Technik m√ºssen wir nur einen relativen Pfad kontrollieren. Wenn es uns gelingt, Dateien hochzuladen und die LFI nie enden zu lassen, haben wir "gen√ºgend Zeit", um hochgeladene Dateien per Brute-Force zu durchsuchen und eine beliebige der hochgeladenen Dateien zu finden.

**Vorteile dieser Technik**:

- Es ist nur erforderlich, einen relativen Pfad innerhalb eines Includes zu kontrollieren
- Erfordert weder nginx noch unerwarteten Zugriff auf Logdateien
- Erfordert kein 0-Day, um einen Segmentierungsfehler zu verursachen
- Erfordert keine Offenlegung des Pfads

Die **Hauptprobleme** dieser Technik sind:

- Es m√ºssen bestimmte Datei(en) vorhanden sein (es k√∂nnten mehr vorhanden sein)
- Die enorme Anzahl potenzieller Dateinamen: **56800235584**
- Wenn der Server keine Zahlen verwendet, betr√§gt die Gesamtanzahl potenzieller Dateien: **19770609664**
- Standardm√§√üig k√∂nnen nur **20 Dateien** in einer **einzigen Anfrage** hochgeladen werden.
- Die **maximale Anzahl paralleler Worker** des verwendeten Servers.
- Diese Begrenzung zusammen mit den vorherigen kann dazu f√ºhren, dass dieser Angriff zu lange dauert
- **Timeout f√ºr eine PHP-Anfrage**. Idealerweise sollte dieser ewig sein oder den PHP-Prozess beenden, ohne die tempor√§r hochgeladenen Dateien zu l√∂schen. Andernfalls wird dies auch zu einem Problem.

Wie also k√∂nnen Sie **ein PHP-Include nie enden lassen**? Einfach durch das Einbinden der Datei **`/sys/kernel/security/apparmor/revision`** (**leider nicht verf√ºgbar in Docker-Containern**). Probieren Sie es einfach aus, indem Sie folgendes aufrufen:
```bash
php -a # open php cli
include("/sys/kernel/security/apparmor/revision");
```
## Apache2

Standardm√§√üig unterst√ºtzt Apache **150 gleichzeitige Verbindungen**, gem√§√ü [https://ubiq.co/tech-blog/increase-max-connections-apache/](https://ubiq.co/tech-blog/increase-max-connections-apache/) ist es m√∂glich, diese Zahl auf bis zu 8000 zu erh√∂hen. Folgen Sie diesem Link, um PHP mit diesem Modul zu verwenden: [https://www.digitalocean.com/community/tutorials/how-to-configure-apache-http-with-mpm-event-and-php-fpm-on-ubuntu-18-04](https://www.digitalocean.com/community/tutorials/how-to-configure-apache-http-with-mpm-event-and-php-fpm-on-ubuntu-18-04).

Standardm√§√üig (wie ich in meinen Tests sehen kann) kann ein **PHP-Prozess ewig dauern**.

Lassen Sie uns etwas Mathematik machen:

* Wir k√∂nnen **149 Verbindungen** verwenden, um **149 \* 20 = 2980 tempor√§re Dateien** mit unserer Webshell zu generieren.
* Verwenden Sie dann die **letzte Verbindung**, um potenzielle Dateien **brute-forcen**.
* Bei einer Geschwindigkeit von **10 Anfragen/s** ergeben sich folgende Zeiten:
* 56800235584 / 2980 / 10 / 3600 \~= **530 Stunden** (50% Chance in 265 Stunden)
* (ohne Zahlen) 19770609664 / 2980 / 10 / 3600 \~= 185 Stunden (50% Chance in 93 Stunden)

{% hint style="warning" %}
Beachten Sie, dass wir in diesem Beispiel **andere Clients vollst√§ndig DoSen**!
{% endhint %}

Wenn der Apache-Server verbessert wird und wir **4000 Verbindungen** missbrauchen k√∂nnten (halb so viel wie die maximale Anzahl), k√∂nnten wir `3999*20 = 79980` **Dateien** erstellen und die **Anzahl** w√ºrde auf etwa **19,7 Stunden** oder **6,9 Stunden** reduziert werden (10 Stunden, 3,5 Stunden 50% Chance).

## PHP-FMP

Wenn anstelle des regul√§ren PHP-Moduls f√ºr Apache zum Ausf√ºhren von PHP-Skripten die **Webseite PHP-FMP verwendet** (was die Effizienz der Webseite verbessert, daher ist es √ºblich, es zu finden), gibt es noch etwas anderes, das getan werden kann, um die Technik zu verbessern.

PHP-FMP erm√∂glicht es, den **Parameter** **`request_terminate_timeout`** in **`/etc/php/<php-version>/fpm/pool.d/www.conf`** zu **konfigurieren**.\
Dieser Parameter gibt an, nach wie vielen Sekunden **die Anfrage an PHP beendet werden muss** (standardm√§√üig unendlich, aber **30 Sekunden, wenn der Parameter auskommentiert ist**). Wenn eine Anfrage von PHP verarbeitet wird und die angegebene Anzahl von Sekunden erreicht, wird sie **beendet**. Das bedeutet, dass, wenn die Anfrage tempor√§re Dateien hochgeladen hat, weil die **PHP-Verarbeitung gestoppt wurde**, diese **Dateien nicht gel√∂scht werden**. Daher k√∂nnen Sie, wenn Sie eine Anfrage so lange dauern lassen k√∂nnen, **Tausende tempor√§re Dateien generieren**, die nicht gel√∂scht werden, was den Prozess des Auffindens beschleunigt und die Wahrscheinlichkeit eines DoS auf der Plattform verringert, indem alle Verbindungen verbraucht werden.

Um also einen DoS zu **vermeiden**, nehmen wir an, dass ein **Angreifer nur 100 Verbindungen** gleichzeitig verwendet und die maximale Verarbeitungszeit von PHP durch **PHP-FMP** (`request_terminate_timeout`**)** **30 Sekunden** betr√§gt. Daher kann die Anzahl der **tempor√§ren Dateien**, die pro Sekunde generiert werden k√∂nnen, berechnet werden als `100*20/30 = 66,67`.

Dann w√ºrde ein Angreifer **150 Sekunden** ben√∂tigen, um **10000 Dateien** zu generieren: **`10000/66.67 = 150s`** (um **100000 Dateien** zu generieren, w√ºrde die Zeit **25 Minuten** betragen).

Dann k√∂nnte der Angreifer diese **100 Verbindungen** nutzen, um ein **Brute-Force-Suchmuster** durchzuf√ºhren. Angenommen, eine Geschwindigkeit von 300 Anfragen/s, die ben√∂tigte Zeit, um dies auszunutzen, ist wie folgt:

* 56800235584 / 10000 / 300 / 3600 \~= **5,25 Stunden** (50% Chance in 2,63 Stunden)
* (mit 100000 Dateien) 56800235584 / 100000 / 300 / 3600 \~= **0,525 Stunden** (50% Chance in 0,263 Stunden)

Ja, es ist m√∂glich, 100000 tempor√§re Dateien in einer EC2 mittleren Instanz zu generieren:

<figure><img src="../../.gitbook/assets/image (240).png" alt=""><figcaption></figcaption></figure>

{% hint style="warning" %}
Beachten Sie, dass es ausreicht, die verwundbare LFI-Seite einzuschlie√üen, um den Timeout auszul√∂sen, sodass sie in einer endlosen Include-Schleife landet.
{% endhint %}

## Nginx

Standardm√§√üig unterst√ºtzt Nginx **512 parallele Verbindungen** gleichzeitig (und diese Zahl kann verbessert werden).
