# LFI2RCE poprzez wieczne oczekiwanie

<details>

<summary><strong>Naucz się hakować AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeśli chcesz zobaczyć swoją **firmę reklamowaną w HackTricks** lub **pobrać HackTricks w formacie PDF**, sprawdź [**PLAN SUBSKRYPCYJNY**](https://github.com/sponsors/carlospolop)!
* Zdobądź [**oficjalne gadżety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzinę PEASS**](https://opensea.io/collection/the-peass-family), naszą kolekcję ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Podziel się swoimi sztuczkami hakerskimi, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repozytoriów github.

</details>

## Podstawowe informacje

Domyślnie, gdy plik jest przesyłany do PHP (nawet jeśli nie jest oczekiwany), zostanie wygenerowany tymczasowy plik w `/tmp` o nazwie takiej jak **`php[a-zA-Z0-9]{6}`**, chociaż zdarzyło mi się zobaczyć niektóre obrazy Docker, w których wygenerowane pliki nie zawierają cyfr.

W przypadku lokalnego włączenia pliku, **jeśli uda ci się włączyć ten przesłany plik, uzyskasz RCE**.

Należy zauważyć, że domyślnie **PHP pozwala tylko na przesłanie 20 plików w jednym żądaniu** (ustawione w `/etc/php/<version>/apache2/php.ini`):
```
; Maximum number of files that can be uploaded via a single request
max_file_uploads = 20
```
Również, **liczba potencjalnych nazw plików wynosi 62\*62\*62\*62\*62\*62 = 56800235584**

### Inne techniki

Inne techniki polegają na atakowaniu protokołów PHP (nie będziesz w stanie tego zrobić, jeśli kontrolujesz tylko ostatnią część ścieżki), ujawnianiu ścieżki pliku, nadużywaniu oczekiwanych plików lub **spowodowaniu awarii segmentacji PHP, aby tymczasowe pliki nie były usuwane**.\
Ta technika jest **bardzo podobna do poprzedniej, ale nie wymaga znajdowania luki zero day**.

### Technika wiecznego oczekiwania

W tej technice **wystarczy kontrolować ścieżkę względną**. Jeśli uda nam się przesłać pliki i sprawić, że **LFI nigdy się nie zakończy**, będziemy mieli "wystarczająco dużo czasu", aby **przebrutować przesłane pliki** i **znaleźć** którykolwiek z nich.

**Zalety tej techniki**:

* Wystarczy kontrolować ścieżkę względną wewnątrz include
* Nie wymaga nginx ani nieoczekiwanego poziomu dostępu do plików dziennika
* Nie wymaga luki zero day do spowodowania awarii segmentacji
* Nie wymaga ujawnienia ścieżki

**Główne problemy** tej techniki to:

* Wymaga obecności określonego pliku/plików (może ich być więcej)
* **Niewiarygodna** liczba potencjalnych nazw plików: **56800235584**
* Jeśli serwer **nie używa cyfr**, całkowita potencjalna liczba wynosi: **19770609664**
* Domyślnie **tylko 20 plików** może być przesłanych w **jednym żądaniu**.
* **Maksymalna liczba równoległych pracowników** używanego serwera.
* Te ograniczenia w połączeniu z poprzednimi mogą sprawić, że atak ten potrwa zbyt długo
* **Limit czasu dla żądania PHP**. Idealnie powinien być wieczny lub powinien zabić proces PHP bez usuwania tymczasowych przesłanych plików, jeśli nie, również będzie to problem

Więc, jak można **spowodować, że include PHP nigdy się nie zakończy**? Wystarczy dołączyć plik **`/sys/kernel/security/apparmor/revision`** (**niestety niedostępny w kontenerach Docker**).

Spróbuj tego, po prostu wywołując:
```bash
php -a # open php cli
include("/sys/kernel/security/apparmor/revision");
```
## Apache2

Domyślnie Apache obsługuje **150 równoczesnych połączeń**, zgodnie z [https://ubiq.co/tech-blog/increase-max-connections-apache/](https://ubiq.co/tech-blog/increase-max-connections-apache/) można zwiększyć tę liczbę do 8000. Postępuj zgodnie z tym, aby używać PHP z tym modułem: [https://www.digitalocean.com/community/tutorials/how-to-configure-apache-http-with-mpm-event-and-php-fpm-on-ubuntu-18-04](https://www.digitalocean.com/community/tutorials/how-to-configure-apache-http-with-mpm-event-and-php-fpm-on-ubuntu-18-04).

Domyślnie (jak mogę zobaczyć w moich testach), **proces PHP może trwać wiecznie**.

Zróbmy trochę matematyki:

* Możemy użyć **149 połączeń** do wygenerowania **149 \* 20 = 2980 plików tymczasowych** za pomocą naszego webshell.
* Następnie użyj **ostatniego połączenia** do **brute-force** potencjalnych plików.
* Przy prędkości **10 żądań/s** czasy to:
* 56800235584 / 2980 / 10 / 3600 \~= **530 godzin** (50% szans w 265h)
* (bez cyfr) 19770609664 / 2980 / 10 / 3600 \~= 185h (50% szans w 93h)

{% hint style="warning" %}
Należy zauważyć, że w poprzednim przykładzie **całkowicie DoSujemy innych klientów**!
{% endhint %}

Jeśli serwer Apache zostanie ulepszony i będziemy mogli wykorzystać **4000 połączeń** (połowa maksymalnej liczby). Moglibyśmy utworzyć `3999*20 = 79980` **plików** i **liczba** zmniejszyłaby się do około **19.7h** lub **6.9h** (10h, 3.5h 50% szans).

## PHP-FMP

Jeśli zamiast używać standardowego modułu php dla apache do uruchamiania skryptów PHP, **strona internetowa korzysta z PHP-FMP** (co poprawia wydajność strony internetowej, więc jest to częste), istnieje coś innego, co można zrobić, aby poprawić technikę.

PHP-FMP pozwala na **konfigurację parametru** **`request_terminate_timeout`** w **`/etc/php/<php-version>/fpm/pool.d/www.conf`**.\
Ten parametr wskazuje maksymalną liczbę sekund, **kiedy żądanie do PHP musi się zakończyć** (domyślnie nieskończoność, ale **30s, jeśli parametr jest odkomentowany**). Gdy żądanie jest przetwarzane przez PHP przez określoną liczbę sekund, jest **zabijane**. Oznacza to, że jeśli żądanie przesyłało tymczasowe pliki, ponieważ **przetwarzanie php zostało zatrzymane**, te **pliki nie zostaną usunięte**. Dlatego, jeśli możesz sprawić, że żądanie potrwa tyle czasu, możesz **generować tysiące tymczasowych plików**, które nie zostaną usunięte, co przyspieszy proces ich znalezienia i zmniejszy prawdopodobieństwo DoS dla platformy poprzez zużycie wszystkich połączeń.

Więc, aby **uniknąć DoS**, załóżmy, że **atakujący będzie używał tylko 100 połączeń** jednocześnie, a maksymalny czas przetwarzania PHP przez **php-fmp** (`request_terminate_timeout`**)** wynosi **30s**. Liczba **plików tymczasowych**, które można wygenerować **na sekundę**, wynosi `100*20/30 = 66.67`.

Następnie, aby wygenerować **10000 plików**, atakującemu zajęłoby: **`10000/66.67 = 150s`** (aby wygenerować **100000 plików**, czas wyniósłby **25 minut**).

Następnie, atakujący mógłby użyć tych **100 połączeń** do przeprowadzenia **brute-force**. Przy założeniu prędkości 300 żądań/s czas potrzebny do wykorzystania tej techniki wynosi:

* 56800235584 / 10000 / 300 / 3600 \~= **5.25 godziny** (50% szans w 2.63h)
* (z 100000 plikami) 56800235584 / 100000 / 300 / 3600 \~= **0.525 godziny** (50% szans w 0.263h)

Tak, jest możliwe wygenerowanie 100000 tymczasowych plików na instancji o średnim rozmiarze EC2:

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (3).png" alt=""><figcaption></figcaption></figure>

{% hint style="warning" %}
Należy zauważyć, że w celu wywołania limitu czasu wystarczy **dołączyć podatną stronę LFI**, aby wprowadzić ją w wieczną pętlę include.
{% endhint %}

## Nginx

Wygląda na to, że domyślnie Nginx obsługuje **512 równoczesnych połączeń** (a ta liczba może być zwiększona).
