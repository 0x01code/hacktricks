# LFI2RCE kupitia Kusubiri Milele

<details>

<summary><strong>Jifunze AWS hacking kutoka sifuri hadi shujaa na</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Mtaalam wa Timu Nyekundu ya AWS ya HackTricks)</strong></a><strong>!</strong></summary>

Njia nyingine za kusaidia HackTricks:

* Ikiwa unataka kuona **kampuni yako ikitangazwa kwenye HackTricks** au **kupakua HackTricks kwa PDF** Angalia [**MIPANGO YA USAJILI**](https://github.com/sponsors/carlospolop)!
* Pata [**swag rasmi ya PEASS & HackTricks**](https://peass.creator-spring.com)
* Gundua [**Familia ya PEASS**](https://opensea.io/collection/the-peass-family), mkusanyiko wetu wa [**NFTs**](https://opensea.io/collection/the-peass-family) ya kipekee
* **Jiunge na** üí¨ [**Kikundi cha Discord**](https://discord.gg/hRep4RUj7f) au kikundi cha [**telegram**](https://t.me/peass) au **tufuate** kwenye **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Shiriki mbinu zako za udukuzi kwa kuwasilisha PRs kwa** [**HackTricks**](https://github.com/carlospolop/hacktricks) na [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos za github.

</details>

## Taarifa Msingi

Kwa chaguo-msingi wakati faili inapakiwa kwenye PHP (hata kama haitegemei), itazalisha faili ya muda katika `/tmp` yenye jina kama **`php[a-zA-Z0-9]{6}`**, ingawa nimeona picha za docker ambapo faili zilizozalishwa hazina tarakimu.

Katika kuingiza faili za ndani, **ikiwa unaweza kuingiza faili hiyo iliyopakiwa, utapata RCE**.

Tafadhali kumbuka kwamba kwa chaguo-msingi **PHP inaruhusu kupakia faili 20 katika ombi moja** (imewekwa katika `/etc/php/<version>/apache2/php.ini`):
```
; Maximum number of files that can be uploaded via a single request
max_file_uploads = 20
```
Pia, **idadi ya majina ya faili yanayowezekana ni 62\*62\*62\*62\*62\*62 = 56800235584**

### Mbinu nyingine

Mbinu nyingine inategemea kushambulia itifaki za PHP (hutaweza ikiwa unadhibiti sehemu ya mwisho ya njia), kufichua njia ya faili, kutumia faili zinazotarajiwa, au **kusababisha PHP kupata kosa la segmantation ili faili za muda zilizopakiwa zisifutwe**.\
Mbinu hii ni **sawa sana na ile iliyopita lakini bila ya kuhitaji kutafuta siku ya sifuri**.

### Mbinu ya kusubiri milele

Katika mbinu hii **tunahitaji kudhibiti njia ya kihusishi**. Ikiwa tunaweza kupakia faili na kufanya **LFI isikome kamwe**, tutakuwa na "muda wa kutosha" wa **kufanya nguvu ya kutumia faili zilizopakiwa** na **kupata** moja kati ya zilizopakiwa.

**Faida za mbinu hii**:

* Unahitaji tu kudhibiti njia ya kihusishi ndani ya kifungu
* Haitahitaji nginx au kiwango kisichotarajiwa cha ufikiaji wa faili za logi
* Haitahitaji siku ya sifuri kusababisha kosa la segmantation
* Haitahitaji kufichua njia

**Matatizo makubwa** ya mbinu hii ni:

* Inahitaji faili maalum kuwepo (zinaweza kuwa zaidi)
* **Idadi kubwa sana** ya majina ya faili yanayowezekana: **56800235584**
* Ikiwa seva **haikutumii tarakimu** jumla ya idadi inayowezekana ni: **19770609664**
* Kwa chaguo-msingi **faili 20 tu** zinaweza kupakiwa katika **ombi moja**.
* **Idadi kubwa ya wafanyikazi wanaoweza kufanya kazi kwa wakati mmoja** kwenye seva iliyotumiwa.
* Kikomo hiki pamoja na vikwazo vya awali vinaweza kufanya shambulio hili kudumu muda mrefu sana
* **Muda wa kusubiri ombi la PHP**. Kimsingi hii inapaswa kuwa ya milele au inapaswa kusitisha mchakato wa PHP bila kufuta faili zilizopakiwa za muda, failure hii itakuwa chungu pia

Kwa hivyo, unawezaje **kusababisha kifungu cha PHP kusikome kamwe**? Kwa kuingiza tu faili **`/sys/kernel/security/apparmor/revision`** (**haipatikani kwenye kontena za Docker** kwa bahati mbaya...).

Jaribu tu kwa kuita:
```bash
php -a # open php cli
include("/sys/kernel/security/apparmor/revision");
```
## Apache2

Kwa chaguo-msingi, Apache inasaidia **mawasiliano 150 ya wakati mmoja**, ikifuata [https://ubiq.co/tech-blog/increase-max-connections-apache/](https://ubiq.co/tech-blog/increase-max-connections-apache/) inawezekana kuboresha idadi hii hadi 8000. Fuata hii kutumia PHP na moduli hiyo: [https://www.digitalocean.com/community/tutorials/how-to-configure-apache-http-with-mpm-event-and-php-fpm-on-ubuntu-18-04](https://www.digitalocean.com/community/tutorials/how-to-configure-apache-http-with-mpm-event-and-php-fpm-on-ubuntu-18-04).

Kwa chaguo-msingi, (kama ninavyoona katika majaribio yangu), **mchakato wa PHP unaweza kudumu milele**.

Hebu fanya hesabu:

* Tunaweza kutumia **mawasiliano 149** kuzalisha **149 \* 20 = faili 2980** za muda mfupi na webshell yetu.
* Kisha, tumia **mawasiliano ya mwisho** kufanya **brute-force** kwenye faili za uwezekano.
* Kwa kasi ya **ombi 10/s** nyakati ni:
* 56800235584 / 2980 / 10 / 3600 \~= **masaa 530** (50% nafasi katika masaa 265)
* (bila tarakimu) 19770609664 / 2980 / 10 / 3600 \~= masaa 185 (50% nafasi katika masaa 93)

{% hint style="warning" %}
Tafadhali elewa kwamba katika mfano uliopita tunakuwa **tunafanya DoS kabisa kwa wateja wengine**!
{% endhint %}

Ikiwa seva ya Apache inaboreshwa na tunaweza kutumia **mawasiliano 4000** (nusu ya njia kufikia idadi kubwa). Tunaweza kuunda `3999*20 = 79980` **faili** na **idadi** itapunguzwa hadi takriban **masaa 19.7** au **masaa 6.9** (masaa 10, masaa 3.5 50% nafasi).

## PHP-FMP

Ikiwa badala ya kutumia moduli ya kawaida ya php kwa apache kutekeleza hati za PHP **ukurasa wa wavuti unatumia** **PHP-FMP** (hii inaboresha ufanisi wa ukurasa wa wavuti, hivyo ni kawaida kuipata), kuna kitu kingine kinachoweza kufanywa kuboresha mbinu.

PHP-FMP inaruhusu **kuweka** **parameta** **`request_terminate_timeout`** katika **`/etc/php/<php-version>/fpm/pool.d/www.conf`**.\
Parameta hii inaonyesha idadi kubwa ya sekunde **ombi la PHP linapaswa kumalizika** (isiyo na mwisho kwa chaguo-msingi, lakini **30s ikiwa paramu haijafutwa**). Wakati ombi linapoprocesswa na PHP kwa idadi iliyotajwa ya sekunde, linauawa. Hii inamaanisha, kwamba ikiwa ombi lilikuwa likiweka faili za muda mfupi, kwa sababu **usindikaji wa php ulisimamishwa**, faili hizo **hazitafutwa**. Kwa hivyo, ikiwa unaweza kufanya ombi lidumu kwa muda huo, unaweza **kuzalisha maelfu ya faili za muda mfupi** ambazo hazitafutwa, ambazo zitakusaidia **kupata haraka** na kupunguza uwezekano wa DoS kwa jukwaa kwa kutumia mawasiliano yote.

Kwa hivyo, ili **kuepuka DoS** fikiria kwamba **mshambuliaji atatumia mawasiliano 100 tu** kwa wakati mmoja na muda wa usindikaji wa php kupitia **php-fmp** (`request_terminate_timeout`**)** ni **30s**. Kwa hivyo, idadi ya **faili za muda mfupi** zinazoweza kuzalishwa **kwa sekunde** ni `100*20/30 = 66.67`.

Kisha, ili kuzalisha **faili 10000** mshambuliaji atahitaji: **`10000/66.67 = sekunde 150`** (kuzalisha **faili 100000** muda ungekuwa **dakika 25**).

Kisha, mshambuliaji anaweza kutumia **mawasiliano hayo 100** kufanya **brute-force**. \*\*\*\* Kufikiria kasi ya 300 ombi/s muda unaohitajika kutekeleza hii ni kama ifuatavyo:

* 56800235584 / 10000 / 300 / 3600 \~= **masaa 5.25** (50% nafasi katika masaa 2.63)
* (na faili 100000) 56800235584 / 100000 / 300 / 3600 \~= **masaa 0.525** (50% nafasi katika masaa 0.263)

Ndio, niwezekanavyo kuzalisha faili 100000 za muda mfupi kwenye kifaa cha ukubwa wa kati cha EC2:

<figure><img src="../../.gitbook/assets/image (240).png" alt=""><figcaption></figcaption></figure>

{% hint style="warning" %}
Tafadhali elewa kwamba ili kusababisha muda wa kumalizika itakuwa **ya kutosha kuingiza ukurasa wa LFI wenye kasoro**, ili uingie kwenye mzunguko wa kuingiza milele.
{% endhint %}

## Nginx

Inaonekana kwa chaguo-msingi Nginx inasaidia **mawasiliano 512 ya wakati mmoja** (na idadi hii inaweza kuboreshwa).
