# HTTP Response Smuggling / Desync

<details>

<summary><strong>Erlernen Sie AWS-Hacking von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen** oder **HackTricks in PDF herunterladen** m√∂chten, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories senden.

</details>

**Die Technik dieses Beitrags stammt aus dem Video:** [**https://www.youtube.com/watch?v=suxDcYViwao\&t=1343s**](https://www.youtube.com/watch?v=suxDcYViwao\&t=1343s)

## Desynchronisation der HTTP-Anforderungs-Warteschlange

Zun√§chst missbraucht diese Technik **eine Schwachstelle beim HTTP-Anforderungsschmuggel**, daher m√ºssen Sie wissen, was das ist:

Der **Hauptunterschied** zwischen dieser Technik und einem gew√∂hnlichen HTTP-Anforderungsschmuggel besteht darin, dass **anstatt den Angriff auf die Anforderung des Opfers durch das Hinzuf√ºgen eines Pr√§fixes zu starten**, wir **die Antwort, die das Opfer erh√§lt, durchsickern lassen oder modifizieren**. Dies wird erreicht, indem anstelle des Sendens von 1 Anforderung und einer halben, um den HTTP-Anforderungsschmuggel auszunutzen, **2 vollst√§ndige Anforderungen gesendet werden, um die Antworten der Proxys zu desynchronisieren**.

Dies liegt daran, dass wir in der Lage sein werden, **die Antwortwarteschlange zu desynchronisieren**, sodass die **Antwort** der **legitimen Anforderung des Opfers an den Angreifer gesendet wird** oder indem **Angreifer gesteuerte Inhalte in die Antwort an das Opfer injiziert werden**.

### Desynchronisation der HTTP-Pipeline

HTTP/1.1 erm√∂glicht es, **verschiedene Ressourcen anzufordern, ohne auf vorherige warten zu m√ºssen**. Daher ist es, wenn sich ein **Proxy** dazwischen befindet, die Aufgabe des Proxys, **eine synchronisierte Zuordnung der an den Backend gesendeten Anforderungen und der von dort kommenden Antworten aufrechtzuerhalten**.

Es gibt jedoch ein Problem bei der Desynchronisierung der Antwortwarteschlange. Wenn ein Angreifer einen HTTP-Antwortenschmuggelangriff sendet und die Antworten auf die **urspr√ºngliche Anforderung und die geschmuggelte sofort beantwortet werden**, wird die geschmuggelte Antwort nicht in die Warteschlange der Antwort des Opfers eingef√ºgt, sondern **einfach als Fehler verworfen**.

![](<../.gitbook/assets/image (633).png>)

Daher ist es erforderlich, dass die **geschmuggelte Anforderung mehr Zeit ben√∂tigt, um im Backend-Server verarbeitet zu werden**. Dadurch wird die Kommunikation mit dem Angreifer beendet sein, wenn die geschmuggelte Anforderung verarbeitet wird.

Wenn in dieser speziellen Situation ein **Opfer eine Anforderung gesendet hat** und die **geschmuggelte Anforderung vor** der legitimen Anforderung beantwortet wird, wird die **geschmuggelte Antwort an das Opfer gesendet**. Daher wird der Angreifer die Anforderung "ausf√ºhren", die vom Opfer "ausgef√ºhrt" wird.

Dar√ºber hinaus, wenn der **Angreifer dann eine Anforderung ausf√ºhrt** und die **legitime Antwort** auf die **Anforderung des Opfers vor** der Anforderung des Angreifers beantwortet wird, wird die **Antwort an das Opfer an den Angreifer gesendet**, wodurch die Antwort an das Opfer gestohlen wird (die beispielsweise den Header **Set-Cookie** enthalten kann).

![](<../.gitbook/assets/image (1020).png>)

![](<../.gitbook/assets/image (719).png>)

### Mehrfach verschachtelte Injektionen

Ein weiterer **interessanter Unterschied** zum gew√∂hnlichen **HTTP-Anforderungsschmuggel** besteht darin, dass bei einem gew√∂hnlichen Schmuggelangriff das **Ziel** darin besteht, den **Anfang der Anforderung des Opfers zu modifizieren**, damit eine unerwartete Aktion ausgef√ºhrt wird. Bei einem **HTTP-Antwortenschmuggelangriff**, da Sie **vollst√§ndige Anforderungen senden**, k√∂nnen Sie **in einem Payload Dutzende von Antworten injizieren**, die **Dutzende von Benutzern desynchronisieren**, die die **injizierten Antworten erhalten** werden.

Abgesehen davon, dass Sie so einfacher Dutzende von Exploits auf legitime Benutzer verteilen k√∂nnen, k√∂nnte dies auch dazu verwendet werden, einen **DoS** im Server zu verursachen.

### Exploit-Organisation

Wie bereits erkl√§rt, ist es erforderlich, dass die **erste geschmuggelte Nachricht** in den Server **viel Zeit ben√∂tigt, um verarbeitet zu werden**, um diese Technik auszunutzen.

Diese **zeitintensive Anforderung reicht aus**, wenn Sie nur versuchen, die Antwort des Opfers zu stehlen. Wenn Sie jedoch einen komplexeren Exploit durchf√ºhren m√∂chten, wird dies eine g√§ngige Struktur f√ºr den Exploit sein.

Zun√§chst die **Anfangs**anforderung, die den **HTTP-Anforderungsschmuggel missbraucht**, dann die **zeitintensive Anforderung** und dann **1 oder mehr Payload-Anforderungen**, deren Antworten an die Opfer gesendet werden.

## Ausnutzung der Desynchronisation der HTTP-Antwortwarteschlange

### Erfassen von Anforderungen anderer Benutzer <a href="#capturing-other-users-requests" id="capturing-other-users-requests"></a>

Wie bei bekannten Payloads f√ºr den HTTP-Anforderungsschmuggel k√∂nnen Sie **die Anforderung des Opfers stehlen** mit einem wichtigen Unterschied: In diesem Fall m√ºssen Sie nur sicherstellen, dass der **gesendete Inhalt in der Antwort reflektiert wird**, **kein dauerhafter Speicher** erforderlich ist.

Zun√§chst sendet der Angreifer einen Payload, der eine **endg√ºltige POST-Anforderung mit dem reflektierten Parameter** am Ende und einer gro√üen Content-Length enth√§lt

![](<../.gitbook/assets/image (1053).png>)

Dann, sobald die **urspr√ºngliche Anforderung** (blau) **verarbeitet wurde** und **w√§hrend** die **schl√§frige** Anforderung verarbeitet wird (gelb), wird die **n√§chste Anforderung, die von einem Opfer eintrifft, direkt nach dem reflektierten Parameter in die Warteschlange eingef√ºgt**:

![](<../.gitbook/assets/image (794).png>)

Dann wird das **Opfer** die **Antwort auf die schl√§frige** Anforderung erhalten und wenn in der Zwischenzeit der **Angreifer eine weitere Anforderung sendet**, wird die **Antwort auf die Anforderung mit dem reflektierten Inhalt an ihn gesendet**.

## Antwort-Desynchronisation

Bis zu diesem Punkt haben wir gelernt, wie man HTTP-Anforderungsschmuggelangriffe missbraucht, um die **Anforderung zu steuern**, deren **Antwort** ein **Client** erhalten wird, und wie Sie dann die **Antwort stehlen k√∂nnen, die f√ºr das Opfer gedacht war**.

Aber es ist immer noch m√∂glich, die Antworten noch **weiter zu desynchronisieren**.

Es gibt interessante Anfragen wie **HEAD**-Anfragen, die spezifiziert sind, um **keinen Inhalt im Antwortk√∂rper zu haben** und die (m√ºssen) **die Content-Length der Anforderung enthalten, als ob es eine GET-Anforderung w√§re**.

Daher, wenn ein Angreifer eine **HEAD**-Anforderung injiziert, wie in diesen Bildern:

![](<../.gitbook/assets/image (1107).png>)

Dann, **nachdem die blaue Anforderung an den Angreifer beantwortet wurde**, wird die n√§chste Anforderung des Opfers in die Warteschlange eingef√ºgt:

![](<../.gitbook/assets/image (999).png>)

Dann wird das **Opfer** die **Antwort** auf die **HEAD**-Anforderung erhalten, die **eine Content-Length, aber √ºberhaupt keinen Inhalt enthalten wird**. Daher wird der Proxy diese Antwort **nicht an das Opfer senden**, sondern auf **Inhalt warten**, der tats√§chlich die **Antwort auf die gelbe Anforderung** sein wird (ebenfalls vom Angreifer injiziert):

![](<../.gitbook/assets/image (735).png>)
### Inhaltsverwirrung

Nach dem vorherigen Beispiel, wissend, dass du **den Body** der Anfrage kontrollieren kannst, deren Antwort das Opfer erhalten wird und dass eine **HEAD**-**Antwort** normalerweise in ihren Headern den **Content-Type und die Content-Length** enth√§lt, kannst du eine **Anfrage wie die folgende** senden, um XSS im Opfer zu verursachen, ohne dass die Seite anf√§llig f√ºr XSS ist:

![](<../.gitbook/assets/image (688).png>)

### Cache-Vergiftung

Durch Ausnutzen des zuvor kommentierten Antwort-Desynchronisierungsangriffs Content Confusion, **wenn der Cache die Antwort auf die Anfrage speichert, die vom Opfer durchgef√ºhrt wurde und diese Antwort eine injizierte ist, die XSS verursacht, dann ist der Cache vergiftet**.

B√∂sartige Anfrage, die das XSS-Payload enth√§lt:

![](<../.gitbook/assets/image (614).png>)

B√∂sartige Antwort an das Opfer, die den Header enth√§lt, der dem Cache anzeigt, die Antwort zu speichern:

![](<../.gitbook/assets/image (566).png>)

{% hint style="warning" %}
Beachte, dass in diesem Fall, wenn der **"Angreifer" das Opfer** ist, er jetzt **Cache-Vergiftung in beliebigen URLs** durchf√ºhren kann, da er **die URL steuern kann, die mit der b√∂sartigen Antwort zwischengespeichert wird**.
{% endhint %}

### Web-Cache-T√§uschung

Dieser Angriff √§hnelt dem vorherigen, aber **anstatt ein Payload im Cache einzuf√ºgen, wird der Angreifer Opferinformationen im Cache zwischenspeichern:**

![](<../.gitbook/assets/image (991).png>)

### Antwort-Splitting

Das **Ziel** dieses Angriffs ist es, erneut die **Antwort-Desynchronisierung** auszunutzen, um **den Proxy dazu zu bringen, eine zu 100 % vom Angreifer generierte Antwort zu senden**.

Um dies zu erreichen, muss der Angreifer einen Endpunkt der Webanwendung finden, der **einige Werte in der Antwort reflektiert** und **die Content-Length der HEAD-Antwort kennen**.

Er wird ein **Exploit** wie folgt senden:

![](<../.gitbook/assets/image (911).png>)

Nachdem die erste Anfrage gel√∂st und an den Angreifer zur√ºckgesendet wurde, wird die Anfrage des Opfers in die Warteschlange aufgenommen:

![](<../.gitbook/assets/image (737).png>)

Das Opfer wird als Antwort die **HEAD-Antwort + den Inhalt der Antwort der zweiten Anfrage (der einen Teil der reflektierten Daten enth√§lt)** erhalten:

![](<../.gitbook/assets/image (356).png>)

Beachte jedoch, wie die **reflektierten Daten eine Gr√∂√üe gem√§√ü der Content-Length** der **HEAD**-Antwort hatten, die **eine g√ºltige HTTP-Antwort in der Antwortwarteschlange generierte**.

Daher wird die **n√§chste Anfrage des zweiten Opfers** als **Antwort etwas erhalten, das vollst√§ndig vom Angreifer erstellt wurde**. Da die Antwort vollst√§ndig vom Angreifer erstellt wurde, kann er auch **den Proxy dazu bringen, die Antwort zu zwischenspeichern**.
