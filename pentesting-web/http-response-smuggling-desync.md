# HTTP 响应串联 / Desync

<details>

<summary><strong>从零开始学习 AWS 黑客技术</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE（HackTricks AWS 红队专家）</strong></a><strong>！</strong></summary>

支持 HackTricks 的其他方式：

* 如果您想看到您的公司在 HackTricks 中被广告，或者下载 HackTricks 的 PDF 版本，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 获取[**官方 PEASS & HackTricks 商品**](https://peass.creator-spring.com)
* 探索[**PEASS 家族**](https://opensea.io/collection/the-peass-family)，我们的独家[**NFTs**](https://opensea.io/collection/the-peass-family)
* **加入** 💬 [**Discord 群组**](https://discord.gg/hRep4RUj7f) 或 [**电报群组**](https://t.me/peass) 或在 **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)** 上关注我们**。
* 通过向 [**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github 仓库提交 PR 来分享您的黑客技巧。

</details>

**本文技术取自视频：** [**https://www.youtube.com/watch?v=suxDcYViwao\&t=1343s**](https://www.youtube.com/watch?v=suxDcYViwao\&t=1343s)

## HTTP 请求队列异步

首先，这种技术**滥用了 HTTP 请求串联漏洞**，因此您需要了解这是什么：

这种技术与常见的 HTTP 请求串联的**主要区别**在于，**不是通过向受害者的请求添加前缀来攻击**，而是**泄露或修改受害者接收到的响应**。这是通过**发送两个完整请求以异步代理响应队列**，而不是发送一个半请求来滥用 HTTP 请求串联来实现的。

这是因为我们将能够**异步响应队列**，使得**受害者的合法请求的响应被发送给攻击者**，或者通过**在响应中注入攻击者控制的内容**。

### HTTP 管道异步

HTTP/1.1 允许**请求不需要等待之前的资源**。因此，如果**中间有代理**，则代理的任务是**维护与发送到后端的请求和来自后端的响应的同步匹配**。

然而，存在一个问题，即异步响应队列。如果攻击者发送了一个 HTTP 响应串联攻击，并且对**初始请求和串联请求的响应立即响应**，则串联响应不会被插入到受害者响应队列中，而将**被丢弃为错误**。

因此，**需要串联请求花费更多时间在后端服务器中处理**。因此，当串联请求被处理时，与攻击者的通信将结束。

在这种特定情况下，如果**受害者发送了一个请求**，而**串联请求在合法请求之前得到响应**，则**串联响应将发送给受害者**。因此，攻击者将**控制受害者“执行”的请求**。

此外，如果**攻击者然后执行一个请求**，而**受害者的合法响应**在**攻击者请求之前被回答**。则**受害者的响应将发送给攻击者**，**窃取**了受害者的响应（例如可能包含头部**Set-Cookie**）。

### 多重嵌套注入

与常见的**HTTP 请求串联**的另一个**有趣的区别**是，在常见的串联攻击中，**目标**是**修改受害者请求的开头**，以执行意外操作。在**HTTP 响应串联攻击**中，由于**发送完整请求**，您可以**在一个有效负载中注入数十个响应**，这将**使数十个用户异步**，这些用户将**接收**到**注入的响应**。

除了更容易地**分发数十个漏洞**给合法用户外，这也可以用于在服务器上引起**拒绝服务**。

### 攻击组织

如前所述，为了滥用这种技术，**需要第一个串联消息**进入服务器**需要花费很长时间来处理**。

如果我们只想**尝试窃取受害者的响应**，则这**耗时请求足够**。但如果要执行更复杂的攻击，则这将是攻击的常见结构。

首先是**滥用 HTTP 请求串联**的**初始**请求，然后是**耗时请求**，然后是**1个或多个有效负载请求**，其响应将发送给受害者。

## 滥用 HTTP 响应队列异步

### 捕获其他用户的请求 <a href="#capturing-other-users-requests" id="capturing-other-users-requests"></a>

与已知的 HTTP 请求串联有效载荷一样，您可以通过一个重要的区别**窃取受害者的请求**：在这种情况下，您只需要**发送内容反映在响应中**，**不需要持久存储**。

首先，攻击者发送一个包含**最终 POST 请求和反映参数**的有效负载，以及一个大的 Content-Length

然后，一旦**初始请求**（蓝色）被**处理**，**同时**正在处理**耗时**请求（黄色），**来自受害者的下一个请求**将被**附加到反映参数后的队列中**：

然后，**受害者**将**接收**到**耗时**请求的**响应**，如果**同时** **攻击者发送了另一个请求**，则**反映内容请求的响应将发送给他**。

## 响应异步

到目前为止，我们已经学会了如何滥用 HTTP 请求串联攻击来**控制**客户端将**接收**的**响应的请求**，以及如何**窃取本应发送给受害者的响应**。

但仍然可以**进一步异步**响应。

有一些有趣的请求，如**HEAD**请求，规定**响应体内不得包含任何内容**，并且应（必须）**包含请求的 Content-Length**，就像**GET 请求**一样。

因此，如果攻击者**注入**一个**HEAD**请求，如下图所示：

然后，**一旦蓝色请求被响应给攻击者**，下一个受害者请求将被引入队列：

然后，**受害者**将**接收**到**HEAD**请求的**响应**，其中**将包含 Content-Length 但没有任何内容**。因此，代理**不会将此响应发送**给受害者，而是**等待**一些**内容**，实际上将是**对黄色请求的响应**（同样是攻击者注入的）：
### 内容混淆

根据先前的示例，知道你可以**控制**将要接收受害者的响应的请求的**主体**，而**HEAD** **响应**通常在其标头中包含**Content-Type和Content-Length**，你可以发送以下请求来在受害者中引发XSS，而页面本身并不容易受到XSS攻击：

![](<../.gitbook/assets/image (688).png>)

### 缓存毒化

滥用先前评论的响应解同步内容混淆攻击，**如果缓存存储了受害者执行的请求的响应，并且这个响应是一个注入的响应导致XSS，那么缓存就被毒化了**。

包含XSS有效载荷的恶意请求：

![](<../.gitbook/assets/image (614).png>)

发送给受害者的恶意响应，其中包含指示缓存存储响应的标头：

![](<../.gitbook/assets/image (566).png>)

{% hint style="warning" %}
请注意，在这种情况下，如果**"受害者"是攻击者**，他现在可以在**任意URL中执行缓存毒化**，因为他可以**控制将被缓存的URL**与恶意响应一起。
{% endhint %}

### Web缓存欺骗

这种攻击类似于先前的攻击，但**攻击者不是在缓存中注入有效载荷，而是将受害者信息缓存在缓存中**：

![](<../.gitbook/assets/image (991).png>)

### 响应拆分

这种攻击的**目标**是再次滥用**响应** **解同步**，以便**使代理发送100%由攻击者生成的响应**。

为了实现这一点，攻击者需要找到Web应用程序的一个端点，该端点**在响应中反映一些值**，并且**了解HEAD响应的内容长度**。

他将发送一个**利用**，如下所示：

![](<../.gitbook/assets/image (911).png>)

在第一个请求被解决并发送回攻击者后，**受害者的请求被添加到队列中**：

![](<../.gitbook/assets/image (737).png>)

受害者将作为响应接收**HEAD响应 + 第二个请求响应的内容（包含反映数据的部分）**：

![](<../.gitbook/assets/image (356).png>)

然而，请注意**反映数据的大小符合HEAD响应的Content-Length**，这**在响应队列中生成了一个有效的HTTP响应**。

因此，**第二个受害者的下一个请求**将**接收**到**完全由攻击者制作的响应**。由于响应完全由攻击者制作，他还可以**使代理缓存响应**。
