# HTTP响应劫持/解调

<details>

<summary><strong>从零开始学习AWS黑客技术，成为专家</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE（HackTricks AWS红队专家）</strong></a><strong>！</strong></summary>

支持HackTricks的其他方式：

* 如果您想看到您的**公司在HackTricks中做广告**或**下载PDF格式的HackTricks**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)!
* 获取[**官方PEASS和HackTricks周边产品**](https://peass.creator-spring.com)
* 探索[**PEASS家族**](https://opensea.io/collection/the-peass-family)，我们的独家[**NFTs**](https://opensea.io/collection/the-peass-family)
* **加入** 💬 [**Discord群**](https://discord.gg/hRep4RUj7f) 或 [**电报群**](https://t.me/peass) 或在**Twitter**上关注我 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**。**
* 通过向[**HackTricks**](https://github.com/carlospolop/hacktricks)和[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github仓库提交PR来分享您的黑客技巧。

</details>

**本文技术取自视频：[https://www.youtube.com/watch?v=suxDcYViwao\&t=1343s](https://www.youtube.com/watch?v=suxDcYViwao\&t=1343s)**

## HTTP请求队列解调

首先，这种技术**利用了HTTP请求劫持漏洞**，因此您需要了解这是什么：

这种技术与常见的HTTP请求劫持的**主要区别**在于，**不是通过向受害者的请求添加前缀来攻击**，而是**泄露或修改受害者接收到的响应**。这是通过**发送两个完整请求来解调代理的响应队列**，而不是发送一个半请求来滥用HTTP请求劫持。

这是因为我们将能够**解调响应队列**，使得**受害者的合法请求的响应被发送给攻击者**，或者通过**在响应中注入攻击者控制的内容**。

### HTTP管道解调

HTTP/1.1允许**请求不需要等待前一个资源**就可以请求**不同的资源**。因此，如果**中间有代理**，代理的任务是**维护与发送到后端的请求和来自后端的响应的同步匹配**。

然而，解调响应队列存在问题。如果攻击者发送了一个HTTP响应劫持攻击，并且**对初始请求和劫持的请求的响应立即响应**，则劫持的响应不会被插入到受害者响应的队列中，而会**被丢弃为错误**。

因此，需要**劫持的请求需要更长时间才能在后端服务器中处理**。因此，当劫持的请求被处理时，与攻击者的通信将结束。

在这种特定情况下，如果**受害者发送了一个请求**，而**劫持的请求在合法请求之前得到响应**，则**劫持的响应将发送给受害者**。因此，攻击者将**控制受害者“执行”的请求**。

此外，如果**攻击者然后执行一个请求**，而**受害者的合法响应**在**攻击者请求之前被回答**，则**受害者的响应将发送给攻击者**，**窃取**受害者的响应（例如可能包含**Set-Cookie**标头）。

### 多重嵌套注入

与常见的**HTTP请求劫持**攻击的**有趣区别**是，在常见的劫持攻击中，**目标**是**修改受害者请求的开头**，以执行意外操作。在**HTTP响应劫持攻击**中，由于您**发送完整请求**，您可以**在一个有效负载中注入数十个响应**，这将**解调数十个用户**，这些用户将**接收**到**注入的响应**。

除了更容易地**分发数十个漏洞**给合法用户外，这也可以用于在服务器上引起**拒绝服务**。

### 攻击组织

如前所述，要滥用这种技术，需要**第一个劫持的消息**在服务器中**需要花费很长时间来处理**。

如果只想**尝试窃取受害者的响应**，则这**耗时请求足够**。但如果要执行更复杂的攻击，则这将是攻击的常见结构。

首先是**滥用HTTP请求劫持**的**初始**请求，然后是**耗时请求**，然后是**1个或多个有效负载请求**，其响应将发送给受害者。

## 滥用HTTP响应队列解调

### 捕获其他用户的请求 <a href="#capturing-other-users-requests" id="capturing-other-users-requests"></a>

与已知的HTTP请求劫持有效负载一样，您可以**窃取受害者的请求**，但有一个重要区别：在这种情况下，您只需要**发送内容反映在响应中**，**不需要持久存储**。

首先，攻击者发送一个包含**最终POST请求和反映参数**的有效负载，以及一个较大的Content-Length

然后，一旦**初始请求**（蓝色）被**处理**，**同时**正在处理**耗时请求**（黄色），**来自受害者的下一个请求**将被**附加到反映参数后的队列中**：

然后，**受害者**将**接收**到**耗时**请求的**响应**，如果**同时**攻击者**发送了另一个请求**，则**反映内容请求的响应将发送给他**。

## 响应解调

到目前为止，我们已经学会了如何滥用HTTP请求劫持攻击来**控制**客户端将**接收**的**响应的请求**，以及如何**窃取本应发送给受害者的响应**。

但仍然可以**进一步解调**响应。

有一些有趣的请求，如**HEAD**请求，规定**响应体内不应该有任何内容**，并且应该（必须）**包含请求的Content-Length**，就像**GET请求**一样。

因此，如果攻击者**注入**一个**HEAD**请求，如下图所示：

然后，**一旦蓝色请求被响应给攻击者**，下一个受害者请求将被引入队列：

然后，**受害者**将**接收**到**HEAD**请求的**响应**，其中**将包含Content-Length但没有任何内容**。因此，代理**不会将此响应发送**给受害者，而是**等待**一些**内容**，实际上将是**黄色请求的响应**（也是攻击者注入的）：

### 内容混淆

根据前面的示例，知道您可以**控制**受害者将**接收**的请求的主体，以及**HEAD** **响应**通常在其标头中包含**Content-Type和Content-Length**，您可以**发送如下**请求来**在不易受XSS攻击的情况下导致受害者遭受XSS**：

### 缓存投毒

滥用先前评论的响应解调内容混淆攻击，**如果缓存存储了受害者执行的请求的响应，并且此响应是导致XSS的注入响应，则缓存将被投毒**。

包含XSS有效负载的恶意请求：

受害者的恶意响应，其中包含指示缓存存储响应的标头：

{% hint style="warning" %}
请注意，在这种情况下，如果**“受害者”是攻击者**，他现在可以在**任意URL上执行缓存投毒**，因为他可以**控制将被缓存的URL**与恶意响应。
{% endhint %}

### Web缓存欺骗

这种攻击类似于前一种，但**攻击者将在缓存中缓存受害者信息，而不是在缓存中注入有效负载**：

### 响应分割

这种攻击的**目标**是再次滥用**响应解调**，以便**使代理发送100%由攻击者生成的响应**。

为了实现这一点，攻击者需要找到Web应用程序的一个端点，该端点**在响应中反映一些值**，并且**知道HEAD响应的内容长度**。

他将发送一个**利用**如下的**攻击**：

在第一个请求解决并发送回给攻击者后，**受害者的请求将被添加到队列中**：

受害者将作为响应**接收到**来自**HEAD**请求的**响应**，其中**将包含一个Content-Length但不包含任何内容**。因此，代理**不会将此响应发送**给受害者，而是**等待**一些**内容**，实际上将是**第二个请求响应的一部分（包含反映数据的一部分）**：

然而，请注意，**反映数据的大小符合HEAD响应的Content-Length**，这**在响应队列中生成了一个有效的HTTP响应**。

因此，**第二个受害者的下一个请求**将**接收到**完全由攻击者制作的**响应**。由于响应完全由攻击者制作，他还可以**使代理缓存响应**。
