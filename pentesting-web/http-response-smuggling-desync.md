# HTTP Yanıt Kaçırma / Desenkronizasyon

<details>

<summary><strong>AWS hackleme konusunu sıfırdan kahramana kadar öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Kırmızı Takım Uzmanı)</strong></a><strong> ile!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklam görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**]'na göz atın (https://github.com/sponsors/carlospolop)!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**PEASS Ailesi'ni**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* **💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) katılın veya [**telegram grubuna**](https://t.me/peass) katılın veya bizi **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)** takip edin.**
* **Hacking püf noktalarınızı paylaşarak** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına PR göndererek.

</details>

**Bu yazının tekniği, şu videodan alınmıştır:** [**https://www.youtube.com/watch?v=suxDcYViwao\&t=1343s**](https://www.youtube.com/watch?v=suxDcYViwao\&t=1343s)

## HTTP İstek Kuyruğu Desenkronizasyonu

Bu tekniğin **bir HTTP İstek Kaçırma açığından yararlandığını** unutmayın, bu yüzden bunun ne olduğunu bilmelisiniz:

Bu tekniğin bir standart HTTP İstek kaçırma saldırısından farkı, **kurbanın isteğine bir önek ekleyerek saldırmak yerine**, **kurbanın aldığı yanıtı sızdırmak veya değiştirmek** olacaktır. Bu, HTTP İstek kaçırma saldırısını kötüye kullanmak için 1 istek ve yarım göndermek yerine, **proxy yanıtlarını desenkronize etmek için 2 tam istek göndermek** anlamına gelir.

Bu, **yanıt kuyruğunu desenkronize edebileceğimiz için**, **kurbanın meşru isteğinden gelen yanıtın saldırgan tarafından gönderilmesine** veya **kurbanın yanıtına saldırgan tarafından kontrol edilen içerik enjekte edilmesine** olanak tanır.

### HTTP Boru Hattı Desenkronizasyonu

HTTP/1.1, **önceki istekleri beklemeye gerek olmadan farklı kaynaklar istemeyi** sağlar. Bu nedenle, bir **proxy** varsa, **arka uca gönderilen isteklerin ve oradan gelen yanıtların senkronize eşleşmesini sağlamak** proxy'nin görevidir.

Ancak, yanıtların kuyruğunu desenkronize etme sorunu vardır. Bir saldırgan bir HTTP Yanıt kaçırma saldırısı gönderirse ve **ilk istek ve kaçırılan yanıtlar hemen yanıtlanırsa**, kaçırılan yanıt, kurbanın yanıt kuyruğuna **eklenmeyecek, sadece bir hata olarak atılacaktır**.

Bu nedenle, **kaçırılan isteğin işlenmesi için daha fazla zaman alması gerekmektedir**. Bu nedenle, kaçırılan istek işlendiğinde, saldırganla iletişim kurulmuş olacaktır.

Eğer bu belirli durumda bir **kurban bir istek göndermişse** ve **kaçırılan istek önce yanıtlanırsa**, **kaçırılan yanıt kurbanın alacağı** şekilde gönderilecektir. Bu nedenle, saldırgan, kurban tarafından "gerçekleştirilen" isteği **kontrol edecektir**.

Dahası, **saldırgan daha sonra bir istek yaparsa** ve **kurbanın meşru yanıtı**, **saldırganın isteğinden önce yanıtlanırsa**, **kurbanın yanıtı saldırgana gönderilecektir**, kurbanın yanıtını (örneğin **Set-Cookie** başlığını içerebilir) **çalacaktır**.

### Birden Fazla İç İçe Enjeksiyon

Ortak **HTTP İstek Kaçırma** saldırısından farklı olarak, bir ortak kaçırma saldırısında, **hedefin isteğinin başlangıcını değiştirmenin** amaçlandığıdır. **HTTP Yanıt kaçırma saldırısında**, tam istekler gönderdiğinizden, bir yükte onlarca yanıtı **enjekte edebilirsiniz** ve bu, **enjekte edilen yanıtları alan onlarca kullanıcıyı desenkronize edecektir**.

Meşru kullanıcılara daha kolay bir şekilde onlarca saldırıyı **dağıtabilme** yeteneğinin yanı sıra, bu, sunucuda bir **Hizmet Dışı Bırakma**'ya neden olmak için de kullanılabilir.

### Saldırı Organizasyonu

Bu tekniği kötüye kullanmak için, **sunucuya ilk kaçırılan mesajın işlenmesinin uzun zaman alması gerekmektedir**.

Bu **zaman alıcı istek, kurbanın yanıtını çalmayı denemek** istiyorsanız yeterlidir. Ancak daha karmaşık bir saldırı gerçekleştirmek istiyorsanız, bu saldırı için yaygın bir yapı olacaktır.

Öncelikle, **HTTP İstek Kaçırma**'yı kötüye kullanarak **ilk** istek, ardından **zaman alan istek** ve ardından **kurbanlara gönderilecek yanıtların** gönderileceği **1 veya daha fazla yük isteği**.

## HTTP Yanıt Kuyruğu Desenkronizasyonunu Kötüye Kullanma

### Diğer kullanıcıların isteklerini yakalama <a href="#capturing-other-users-requests" id="capturing-other-users-requests"></a>

Bilinen HTTP İstek Kaçırma payloadları gibi, bu durumda **kurbanın isteğini çalabilirsiniz** ancak önemli bir farkla: Bu durumda, **yanıtta yansıtılacak içeriğe ihtiyacınız vardır**, **kalıcı depolama gerekmez**.

Öncelikle, saldırgan, sonunda yansıtılan parametreye sahip bir **son POST isteği içeren bir yük** ve büyük bir Content-Length içeren bir yük gönderir.

![](<../.gitbook/assets/image (1053).png>)

Sonra, **ilk istek** (mavi) **işlendikten sonra** ve **uyuyan** istek işlenirken (sarı) **kurban tarafından gelen bir sonraki istek**, **yansıtılan parametrenin hemen ardından kuyruğa eklenecektir**:

![](<../.gitbook/assets/image (794).png>)

Sonra, **kurban**, **uyuyan** isteğin yanıtını alacak ve bu arada **saldırgan başka bir istek gönderirse**, **yansıtılan içerik isteğinden gelen yanıt ona gönderilecektir**.

## Yanıt Desenkronizasyonu

Bu noktaya kadar, HTTP İstek Kaçırma saldırılarını kötüye kullanarak bir **istemcinin alacağı yanıtı kontrol etmeyi** ve ardından **kurban için amaçlanan yanıtı çalmayı** öğrendik.

Ancak yanıtları **daha da fazla desenkronize etmek mümkündür**.

**HEAD** isteği gibi ilginç istekler vardır ki, bu isteklerin **yanıt gövdesinde hiçbir içerik olmaması gerektiği** belirtilmiştir ve (zorunlu olarak) **GET isteği gibi Content-Length** içermesi gerekmektedir.

Bu nedenle, bir saldırgan, bu görüntülerde olduğu gibi bir **HEAD** isteği enjekte ederse:

![](<../.gitbook/assets/image (1107).png>)

Sonra, **mavi olan saldırgana yanıtlandıktan sonra**, bir sonraki kurbanın isteği kuyruğa eklenecektir:

![](<../.gitbook/assets/image (999).png>)

Sonra, **kurban**, **HEAD** isteğinden gelen yanıtı alacak, bu yanıt **hiçbir içerik içermesine rağmen Content-Length içerecektir**. Bu nedenle, proxy, bu yanıtı kurbanın yanıtına göndermeyecek, ancak bir **içerik bekleyecek**, bu içerik aslında **saldırgan tarafından da enjekte edilen sarı isteğin yanıtı olacaktır**:

![](<../.gitbook/assets/image (735).png>)
### İçerik Karışıklığı

Önceki örneği takip ederek, **yanıtı alacak kurbanın vücudunu kontrol edebileceğinizi** ve bir **HEAD yanıtının genellikle başlıklarında** **Content-Type ve Content-Length**'in bulunduğunu bilerek, XSS'ye neden olmak için aşağıdaki gibi bir istek gönderebilirsiniz:

![](<../.gitbook/assets/image (688).png>)

### Önbellek Zehirlenmesi

Önceki yorumlanmış yanıt desenkronizasyonu İçerik Karışıklığı saldırısını istismar ederek, **önbelleğin, kurban tarafından gerçekleştirilen isteğin yanıtını sakladığını ve bu yanıtın XSS'e neden olan bir enjekte edilmiş yanıt olduğunu** varsayarsak, önbellek zehirlenir.

XSS yükü içeren kötü niyetli istek:

![](<../.gitbook/assets/image (614).png>)

Önbelleğe yanıtı saklaması için başlığı içeren kurbanı hedefleyen kötü niyetli yanıt:

![](<../.gitbook/assets/image (566).png>)

{% hint style="warning" %}
Bu durumda **"kurban" saldırgan ise** artık **rastgele URL'lerde önbellek zehirlenmesi yapabilir** çünkü kötü niyetli yanıtla **önbelleğe alınacak URL'yi kontrol edebilir**.
{% endhint %}

### Web Önbellek Aldatmacası

Bu saldırı öncekine benzer, ancak **önbelleğe bir yük enjekte etmek yerine, saldırgan kurban bilgilerini önbelleğe alacak:**

![](<../.gitbook/assets/image (991).png>)

### Yanıt Bölünmesi

Bu saldırının **amacı**, **yanıt desenkronizasyonunu** tekrar kötüye kullanarak **proxy'nin %100 saldırgan tarafından oluşturulan bir yanıt göndermesini sağlamaktır**.

Bunu başarmak için, saldırganın, **yanıtın içinde bazı değerleri yansıtan bir web uygulamasının bir uç noktasını bulması** ve **HEAD yanıtının içeriğinin uzunluğunu bilmesi** gerekir.

Şu şekilde bir **saldırı** gönderecektir:

![](<../.gitbook/assets/image (911).png>)

İlk istek çözüldükten ve saldırgana geri gönderildikten sonra, **kurbanın isteği sıraya eklenir**:

![](<../.gitbook/assets/image (737).png>)

Kurban, yanıt olarak **HEAD yanıtını + ikinci isteğin yanıtının içeriğini (yansıtılan verilerin bir kısmını içeren)** alacaktır:

![](<../.gitbook/assets/image (356).png>)

Ancak, **yansıtılan verilerin, HEAD yanıtının Content-Length'ine göre bir boyuta sahip olduğuna** dikkat edin, bu da **yanıt sırasında geçerli bir HTTP yanıtı oluşturdu**.

Bu nedenle, **ikinci kurbanın sonraki isteği**, **tamamen saldırgan tarafından oluşturulan bir yanıt alacak**. Yanıt tamamen saldırgan tarafından oluşturulduğundan, aynı zamanda **proxy'nin yanıtı önbelleğe almasını sağlayabilir**.
