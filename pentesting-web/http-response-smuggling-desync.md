# HTTP响应走私/解同步

<details>

<summary><strong>从零开始学习AWS黑客攻击直到成为英雄</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS红队专家)</strong></a><strong>！</strong></summary>

支持HackTricks的其他方式：

* 如果您想在**HackTricks中看到您的公司广告**或**下载HackTricks的PDF**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 获取[**官方PEASS & HackTricks商品**](https://peass.creator-spring.com)
* 发现[**PEASS家族**](https://opensea.io/collection/the-peass-family)，我们独家的[**NFTs系列**](https://opensea.io/collection/the-peass-family)
* **加入** 💬 [**Discord群组**](https://discord.gg/hRep4RUj7f) 或 [**telegram群组**](https://t.me/peass) 或在 **Twitter** 🐦 上**关注**我 [**@carlospolopm**](https://twitter.com/carlospolopm)**。**
* **通过向** [**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github仓库提交PR来分享您的黑客技巧。

</details>

## HTTP请求队列解同步

首先，这项技术**利用了HTTP请求走私漏洞**，所以你需要知道它是什么：

这项技术与常见的HTTP请求走私的**主要区别**在于，**不是**通过**在受害者的请求前添加前缀来攻击**，而是要**泄露或修改受害者收到的响应**。这是通过发送2个完整的请求来解同步代理响应队列，而不是发送1个半请求来滥用HTTP请求走私。

这是因为我们将能够**解同步响应队列**，所以**受害者的合法请求的响应会被发送给攻击者**，或者通过**在发送给受害者的响应中注入攻击者控制的内容**。

### HTTP管道解同步

HTTP/1.1允许请求**不同的资源而不需要等待前一个资源**。因此，如果中间有**代理**，代理的任务是**保持发送到后端的请求与从后端来的响应的同步匹配**。

然而，解同步响应队列存在一个问题。如果攻击者发送一个HTTP响应走私攻击，并且对**初始请求和走私请求的响应立即被回复**，走私的响应不会被插入到受害者响应的队列中，而是**会被当作错误丢弃**。

![](<../.gitbook/assets/image (635) (1) (1) (1).png>)

因此，需要**走私的请求**在后端服务器内**处理的时间更长**。因此，当走私请求被处理时，与攻击者的通信已经结束。

如果在这种特定情况下，**受害者已经发送了一个请求**，并且在合法请求之前回复了**走私请求**，**走私的响应将被发送给受害者**。因此，攻击者将**控制受害者“执行”的请求**。

此外，如果**攻击者随后执行了一个请求**，并且对**受害者**请求的**合法响应**在攻击者的请求之前**被回答**。**受害者的响应将被发送给攻击者**，**窃取**了原本属于受害者的响应（例如可能包含**Set-Cookie**头的响应）。

![](<../.gitbook/assets/image (658) (1).png>)

![](<../.gitbook/assets/image (655) (1) (1) (1).png>)

### 多重嵌套注入

与常见的**HTTP请求走私**相比，另一个**有趣的区别**在于，在常见的走私攻击中，**目标**是**修改受害者请求的开头**，使其执行意外的操作。在**HTTP响应走私攻击**中，由于你**发送完整的请求**，你可以在一个有效载荷中**注入数十个响应**，这些响应将**解同步数十个用户**，他们将**接收**到**注入的响应**。

除了能够更容易地**分发数十个漏洞**给合法用户外，这也可以用来对服务器造成**DoS**。

### 利用组织

如前所述，为了滥用这项技术，需要**第一个走私的消息**进入服务器**需要很长时间来处理**。

如果我们只是想**尝试窃取受害者的响应**，这个**耗时的请求就足够了**。但如果你想执行一个更复杂的利用，这将是利用的常见结构。

首先是利用**HTTP请求走私**的**初始**请求，然后是**耗时的请求**，然后是**一个或多个有效载荷请求**，其响应将被发送给受害者。

## 滥用HTTP响应队列解同步

### 捕获其他用户的请求 <a href="#capturing-other-users-requests" id="capturing-other-users-requests"></a>

与已知的HTTP请求走私有效载荷一样，你可以**窃取受害者的请求**，但有一个重要的区别：在这种情况下，你只需要发送的内容**反映在响应中**，**不需要持久存储**。

首先，攻击者发送一个包含**最终POST请求和反映参数**的有效载荷，并且Content-Length很大

![](<../.gitbook/assets/image (625).png>)

然后，一旦**初始请求**（蓝色）被**处理**，并且**在**处理**睡眠**请求（黄色）时，**下一个来自受害者的请求**将会被**追加到队列中，紧跟在反映参数之后**：

![](<../.gitbook/assets/image (634) (1).png>)

然后，**受害者**将**接收**到**睡眠**请求的**响应**，如果与此同时**攻击者****发送了**另一个**请求**，**反映内容请求的响应将被发送给他**。

## 响应解同步

到目前为止，我们已经学会了如何滥用HTTP请求走私攻击来**控制**客户端将要**接收**其**响应的请求**，以及你如何可以**窃取原本属于受害者的响应**。

但是，仍然有可能**进一步解同步响应**。

有一些像**HEAD**请求这样的有趣请求，它们被指定为响应体内**没有任何内容**，并且应该（必须）**包含Content-Length**，就像**如果它是一个GET请求**一样。

因此，如果攻击者**注入**了一个**HEAD**请求，如下图所示：

![](<../.gitbook/assets/image (626).png>)

然后，**一旦蓝色的响应被发送给攻击者**，下一个受害者的请求将被引入队列：

![](<../.gitbook/assets/image (651) (1) (1) (1) (1) (1) (1).png>)

然后，**受害者**将**接收**到**HEAD**请求的**响应**，这将**包含Content-Length但根本没有内容**。因此，代理**不会将此响应**发送给受害者，而是会**等待**一些**内容**，实际上将是**对黄色请求的响应**（也由攻击者注入）：

![](<../.gitbook/assets/image (627) (1).png>)

### 内容混淆

根据前面的例子，知道你可以**控制受害者将接收其响应的请求体**，并且**HEAD响应**通常在其头部包含**Content-Type和Content-Length**，你可以**发送如下请求**来**在受害者页面上引起XSS**，而无需页面本身存在XSS漏洞：

![](<../.gitbook/assets/image (654) (1) (1) (1) (1).png>)

### 缓存投毒

利用前面评论过的响应解同步内容混淆攻击，**如果缓存存储了受害者执行的请求的响应，并且这个响应是注入的导致XSS的响应，那么缓存就被投毒了**。

包含XSS有效载荷的恶意请求：

![](<../.gitbook/assets/image (644) (1).png>)

发送给受害者的恶意响应，其中包含指示缓存存储响应的头部：

![](<../.gitbook/assets/image (629) (1).png>)

{% hint style="warning" %}
请注意，在这种情况下，如果**“受害者”是攻击者**，他现在可以在任意URL上执行**缓存投毒**，因为他可以**控制将要被缓存的URL**与恶意响应。
{% endhint %}

### Web缓存欺骗

这种攻击与前一种类似，但**不是在缓存中注入有效载荷，攻击者将缓存受害者的信息到缓存中**：

![](<../.gitbook/assets/image (643) (1) (1).png>)

### 响应分割

这种攻击的**目标**是再次滥用**响应解同步**，以便**使代理发送100%由攻击者生成的响应**。

为了实现这一点，攻击者需要找到一个Web应用程序的端点，该端点在响应中**反映了一些值**，并且**知道HEAD响应的内容长度**。

他将发送一个**利用**，如下所示：

![](<../.gitbook/assets/image (649) (1) (1) (1).png>)

在第一个请求被解决并发送回攻击者之后，**受害者的请求被添加到队列中**：

![](<../.gitbook/assets/image (661) (1) (1) (1).png>)

受害者将收到作为响应的**HEAD响应 + 第二个请求响应的内容（包含部分反映的数据）**：

![](<../.gitbook/assets/image (633) (1).png>)

然而，请注意反映的数据的大小是根据**HEAD**响应的**Content-Length**，它**生成了响应队列中的有效HTTP响应**。

因此，**第二个受害者的下一个请求**将会**接收到完全由攻击者制作的响应**。由于响应完全由攻击者制作，他也可以**让代理缓存响应**。

## 参考资料

* 不要忘记查看这个视频，非常好地解释了所有这些技术：[https://www.youtube.com/watch?v=suxDcYViwao\&t=1343s](https://www.youtube.com/watch?v=suxDcYViwao\&t=1343s)

<details>

<summary><strong>从零开始学习AWS黑客攻击直到成为英雄</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS红队专家)</strong></a><strong>！</strong></summary>

支持HackTricks的其他方式：

* 如果您想在**HackTricks中看到您的公司广告**或**下载HackTricks的PDF**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 获取[**官方PEASS & HackTricks商品**](https://peass.creator-spring.com)
* 发现[**PEASS家族**](https://opensea.io/collection/the-peass-family)，我们独家的[**NFTs系列**](https://opensea.io/collection/the-peass-family)
* **加入** 💬 [**Discord群组**](https://discord.gg/hRep4RUj7f) 或 [**telegram群组**](https://t.me/peass) 或在 **Twitter** 🐦 上**关注**我 [**@carlospolopm**](https://twitter.com/carlospolopm)**。**
* **通过向** [**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github仓库提交PR来分享您的黑客技巧。

</details>
