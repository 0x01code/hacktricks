# Smuggling / Desincronizzazione delle Risposte HTTP

<details>

<summary><strong>Impara l'hacking AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Esperto Red Team AWS di HackTricks)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata in HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PIANI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**La Famiglia PEASS**](https://opensea.io/collection/the-peass-family), la nostra collezione di [**NFT esclusivi**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR a** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos di github.

</details>

**La tecnica di questo post √® stata presa dal video:** [**https://www.youtube.com/watch?v=suxDcYViwao\&t=1343s**](https://www.youtube.com/watch?v=suxDcYViwao\&t=1343s)

## Desincronizzazione della Coda delle Richieste HTTP

Innanzitutto, questa tecnica **sfrutta una vulnerabilit√† di Smuggling delle Richieste HTTP**, quindi √® necessario sapere cos'√®:

La **differenza principale** tra questa tecnica e un comune Smuggling delle Richieste HTTP √® che **anzich√© attaccare la richiesta della vittima aggiungendo un prefisso ad essa**, andremo a **rivelare o modificare la risposta che la vittima riceve**. Questo viene fatto inviando **2 richieste complete per desincronizzare la coda delle risposte dei proxy** anzich√© inviare 1 richiesta e mezza per abusare del Smuggling delle Richieste HTTP.

Questo perch√© saremo in grado di **desincronizzare la coda delle risposte** in modo che la **risposta** dalla **richiesta legittima** della **vittima venga inviata all'attaccante**, o **iniettando contenuti controllati dagli attaccanti nella risposta alla vittima**.

### Desincronizzazione della Pipeline HTTP

HTTP/1.1 consente di richiedere **risorse diverse senza dover attendere quelle precedenti**. Pertanto, se c'√® un **proxy** in mezzo, √® compito dei proxy **mantenere una corrispondenza sincronizzata delle richieste inviate al backend e delle risposte che arrivano da esso**.

Tuttavia, c'√® un problema nella desincronizzazione della coda delle risposte. Se un attaccante invia un attacco di Smuggling delle Risposte HTTP e le risposte alla **richiesta iniziale e a quella contrabbandata vengono risposte immediatamente**, la risposta contrabbandata non verr√† inserita nella coda della risposta della vittima ma verr√† **semplicemente scartata come errore**.

Pertanto, √® necessario che la **richiesta contrabbandata richieda pi√π tempo per essere elaborata** all'interno del server di backend. Pertanto, quando la richiesta contrabbandata viene elaborata, la comunicazione con l'attaccante sar√† terminata.

Se in questa situazione specifica una **vittima ha inviato una richiesta** e la **richiesta contrabbandata viene risposta prima** della richiesta legittima, la **risposta contrabbandata verr√† inviata alla vittima**. Pertanto, l'attaccante **controller√† la richiesta "eseguita" dalla vittima**.

Inoltre, se l'**attaccante esegue una richiesta** e la **risposta legittima** alla **richiesta della vittima viene risposta prima** della richiesta dell'attaccante. La **risposta alla vittima verr√† inviata all'attaccante**, **rubando** la risposta alla vittima (che potrebbe contenere ad esempio l'intestazione **Set-Cookie**).

### Iniezioni Multiple Nidificate

Un'altra **differenza interessante** con il comune **Smuggling delle Richieste HTTP** √® che, in un comune attacco di smuggling, l'**obiettivo** √® **modificare l'inizio della richiesta delle vittime** in modo che esegua un'azione inaspettata. In un **attacco di Smuggling delle Risposte HTTP**, poich√© si stanno **inviando richieste complete**, √® possibile **iniettare in un payload decine di risposte** che **desincronizzeranno decine di utenti** che **riceveranno** le **risposte iniettate**.

Oltre a poter **distribuire pi√π facilmente decine di exploit** tra gli utenti legittimi, ci√≤ potrebbe anche essere utilizzato per causare un **DoS** nel server.

### Organizzazione dell'Exploit

Come spiegato in precedenza, per abusare di questa tecnica, √® necessario che il **primo messaggio contrabbandato** nel server **richieda molto tempo per essere elaborato**.

Questa **richiesta che richiede tempo √® sufficiente** se si vuole solo **provare a rubare la risposta delle vittime**. Ma se si desidera eseguire un exploit pi√π complesso, questa sar√† una struttura comune per l'exploit.

Prima di tutto la **richiesta iniziale che abusa del** **Smuggling delle Richieste HTTP**, quindi la **richiesta che richiede tempo** e quindi **1 o pi√π richieste di payload** le cui risposte saranno inviate alle vittime.

## Abuso della Desincronizzazione della Coda delle Risposte HTTP

### Cattura delle richieste di altri utenti <a href="#capturing-other-users-requests" id="capturing-other-users-requests"></a>

Come con i payload noti di Smuggling delle Richieste HTTP, √® possibile **rubare la richiesta delle vittime** con una differenza importante: in questo caso √® sufficiente che il **contenuto inviato venga riflesso nella risposta**, **non √® necessario alcuno storage persistente**.

Innanzitutto, l'attaccante invia un payload contenente una **richiesta POST finale con il parametro riflesso** alla fine e un grande Content-Length

![](<../.gitbook/assets/image (1053).png>)

Quindi, una volta che la **richiesta iniziale** (blu) √® stata **elaborata** e **mentre** quella **lenta** viene elaborata (gialla) la **prossima richiesta che arriva da una vittima** verr√† **aggiunta in coda subito dopo il parametro riflesso**:

![](<../.gitbook/assets/image (794).png>)

Quindi, la **vittima** ricever√† la **risposta alla richiesta lenta** e se nel frattempo l'**attaccante ha inviato un'altra richiesta**, la **risposta dalla richiesta di contenuto riflesso gli verr√† inviata**.

## Desincronizzazione della Risposta

Fino a questo punto, abbiamo imparato come abusare degli attacchi di Smuggling delle Richieste HTTP per **controllare** la **richiesta** **la cui** **risposta** un **client** sta per **ricevere** e come √® possibile quindi **rubare la risposta che era destinata alla vittima**.

Ma √® ancora possibile **desincronizzare ancora di pi√π** le risposte.

Ci sono richieste interessanti come la richiesta **HEAD** che sono specificate per non avere **alcun contenuto nel corpo delle risposte** e che dovrebbero (devono) **contenere il Content-Length** della richiesta come **se fosse una richiesta GET**.

Pertanto, se un attaccante **inietta** una richiesta **HEAD**, come in queste immagini:

![](<../.gitbook/assets/image (1107).png>)

Quindi, **una volta che la richiesta blu √® stata risposta all'attaccante**, la prossima richiesta della vittima verr√† introdotta nella coda:

![](<../.gitbook/assets/image (999).png>)

Quindi, la **vittima** ricever√† la **risposta** dalla **richiesta HEAD**, che **conterr√† un Content-Length ma nessun contenuto**. Pertanto, il proxy **non invier√† questa risposta** alla vittima, ma **aspetter√†** del **contenuto**, che in realt√† sar√† la **risposta alla richiesta gialla** (anch'essa iniettata dall'attaccante):

![](<../.gitbook/assets/image (735).png>)
### Confusione del Contenuto

Seguendo l'esempio precedente, sapendo che puoi **controllare il corpo** della richiesta il cui risposta ricever√† la vittima e che una risposta **HEAD** di solito contiene nei suoi header il **Content-Type e il Content-Length**, puoi **inviare una richiesta come la seguente** per **causare XSS** nella vittima senza che la pagina sia vulnerabile a XSS:

![](<../.gitbook/assets/image (688).png>)

### Avvelenamento della Cache

Abusando dell'attacco di Confusione del Contenuto della risposta precedentemente commentato, **se la cache memorizza la risposta alla richiesta effettuata dalla vittima e questa risposta √® iniettata causando un XSS, allora la cache √® avvelenata**.

Richiesta malevola contenente il payload XSS:

![](<../.gitbook/assets/image (614).png>)

Risposta malevola alla vittima che contiene l'header che indica alla cache di memorizzare la risposta:

![](<../.gitbook/assets/image (566).png>)

{% hint style="warning" %}
Nota che in questo caso se il **"vittima" √® l'attaccante** ora pu√≤ eseguire **avvelenamento della cache in URL arbitrari** poich√© pu√≤ **controllare l'URL che verr√† memorizzato nella cache** con la risposta malevola.
{% endhint %}

### Inganno della Cache Web

Questo attacco √® simile al precedente, ma **anzich√© iniettare un payload all'interno della cache, l'attaccante memorizzer√† le informazioni della vittima all'interno della cache:**

![](<../.gitbook/assets/image (991).png>)

### Divisione della Risposta

Lo **obiettivo** di questo attacco √® abusare nuovamente della **desincronizzazione della risposta** per **far s√¨ che il proxy invii una risposta generata al 100% dall'attaccante**.

Per raggiungere questo obiettivo, l'attaccante deve trovare un endpoint dell'applicazione web che **riflette alcuni valori all'interno della risposta** e **conoscere la lunghezza del contenuto della risposta HEAD**.

Invier√† un **exploit** come:

![](<../.gitbook/assets/image (911).png>)

Dopo che la prima richiesta √® risolta e inviata all'attaccante, la **richiesta della vittima viene aggiunta nella coda**:

![](<../.gitbook/assets/image (737).png>)

La vittima ricever√† come risposta il **HEAD response + il contenuto della risposta della seconda richiesta (contenente parte dei dati riflessi):**

![](<../.gitbook/assets/image (356).png>)

Tuttavia, nota come i **dati riflessi avevano una dimensione in base al Content-Length** della risposta **HEAD** che **ha generato una risposta HTTP valida nella coda delle risposte**.

Pertanto, la **prossima richiesta del secondo vittima** ricever√† come **risposta qualcosa completamente creato dall'attaccante**. Poich√© la risposta √® completamente creata dall'attaccante, pu√≤ anche **far memorizzare nella cache il la risposta**.
