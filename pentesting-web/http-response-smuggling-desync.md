# HTTPレスポンススマグリング/デシンク

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)でゼロからヒーローまでAWSハッキングを学ぶ</strong></summary>

HackTricksをサポートする他の方法:

* **HackTricksにあなたの会社を広告したい**、または**HackTricksをPDFでダウンロードしたい**場合は、[**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS & HackTricksグッズ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見する、私たちの独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクション
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)に**参加する**か、[**テレグラムグループ**](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)を**フォローする**。
* **HackTricks**のPRを提出して、あなたのハッキングのコツを共有してください。[**HackTricks**](https://github.com/carlospolop/hacktricks)および[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のgithubリポジトリ。

</details>

## HTTPリクエストキューの非同期化

まず、このテクニックは**HTTPリクエストスマグリングの脆弱性を悪用する**ので、それが何であるかを知る必要があります。

このテクニックと一般的なHTTPリクエストスマグリングの**主な違い**は、**被害者のリクエストを攻撃する代わりに**、**被害者が受け取るレスポンスを漏洩させたり変更したりする**ことです。これは、HTTPリクエストスマグリングを悪用するために1回と半分のリクエストを送るのではなく、**プロキシのレスポンスキューを非同期化するために2つの完全なリクエストを送信する**ことによって行われます。

これにより、**レスポンスキューを非同期化**することができ、**正当なリクエストのレスポンスが攻撃者に送信される**か、**攻撃者が制御するコンテンツを被害者へのレスポンスに注入する**ことができます。

### HTTPパイプラインデシンク

HTTP/1.1では、**前のリソースの応答を待たずに異なるリソースを要求することができます**。したがって、**中間にプロキシがある場合**、それはバックエンドに送信されたリクエストとそれからのレスポンスの同期されたマッチを維持するプロキシの仕事です。

しかし、レスポンスキューを非同期化する問題があります。攻撃者がHTTPレスポンススマグリング攻撃を送信し、**最初のリクエストとスマグリングされたリクエストに対するレスポンスが即座に応答された場合**、スマグリングされたレスポンスは被害者のレスポンスキューに挿入されるのではなく、**エラーとして単に破棄されます**。

![](<../.gitbook/assets/image (635) (1) (1) (1).png>)

したがって、**スマグリングされたリクエスト**がバックエンドサーバー内で**処理されるのに時間がかかる**必要があります。そのため、スマグリングされたリクエストが処理される頃には、攻撃者との通信は終了しています。

この特定の状況で、**被害者がリクエストを送信**し、スマグリングされたリクエストが正当なリクエストよりも先に応答された場合、**スマグリングされたレスポンスが被害者に送信されます**。したがって、攻撃者は**被害者によって"実行された"リクエストを制御する**ことになります。

さらに、攻撃者がその後リクエストを**実行し**、**被害者**のリクエストに対する**正当なレスポンス**が攻撃者のリクエストよりも**先に応答された場合**。**被害者へのレスポンスが攻撃者に送信され**、被害者のレスポンス（例えば**Set-Cookie**ヘッダーを含むことがある）を**盗む**ことになります。

![](<../.gitbook/assets/image (658) (1).png>)

![](<../.gitbook/assets/image (655) (1) (1) (1).png>)

### 複数のネストされたインジェクション

一般的な**HTTPリクエストスマグリング**とのもう一つの**興味深い違い**は、一般的なスマグリング攻撃では、**被害者のリクエストの始まりを変更して予期しないアクションを実行させる**ことが**目的**です。**HTTPレスポンススマグリング攻撃**では、**完全なリクエストを送信している**ため、**一つのペイロードに数十のレスポンスを注入**し、**数十のユーザーを非同期化**させ、**注入されたレスポンスを受け取る**ことができます。

正当なユーザーに対して**数十のエクスプロイトをより簡単に配布する**ことができるだけでなく、これを使用してサーバーに**DoSを引き起こす**こともできます。

### エクスプロイトの組織化

前述のように、このテクニックを悪用するためには、サーバーに**最初にスマグリングされたメッセージが処理されるのに非常に時間がかかる**必要があります。

この**時間を要するリクエストは、被害者のレスポンスを盗もうとするだけなら十分**です。しかし、より複雑なエクスプロイトを実行したい場合、これがエクスプロイトの一般的な構造になります。

まず、**HTTPリクエストスマグリングを悪用する初期のリクエスト**、次に**時間を要するリクエスト**、そしてその後に**1つ以上のペイロードリクエスト**が続き、そのレスポンスが被害者に送信されます。

## HTTPレスポンスキューの非同期化の悪用

### 他のユーザーのリクエストのキャプチャ <a href="#capturing-other-users-requests" id="capturing-other-users-requests"></a>

HTTPリクエストスマグリングで知られているペイロードと同様に、**被害者のリクエストを盗む**ことができますが、重要な違いが一つあります：この場合、**反映されたコンテンツをレスポンスに送信するだけで**、**永続的なストレージ**は必要ありません。

まず、攻撃者は最後に反映されたパラメータを含む**最終的なPOSTリクエストと大きなContent-Lengthを含むペイロードを送信します**

![](<../.gitbook/assets/image (625).png>)

次に、**初期のリクエスト**（青）が**処理され**、**スリーピーな**ものが処理されている間（黄色）、**次に到着する被害者のリクエスト**は、反映されたパラメータの直後にキューに**追加されます**：

![](<../.gitbook/assets/image (634) (1).png>)

その後、**被害者**は**スリーピーな**リクエストへの**レスポンスを受け取り**、その間に**攻撃者が**別の**リクエストを送信した場合**、**反映されたコンテンツのリクエストへのレスポンスが彼に送信されます**。

## レスポンスの非同期化

ここまでで、HTTPリクエストスマグリング攻撃を悪用して**クライアントが受け取るレスポンスのリクエストを制御する**方法と、その後**被害者に意図されたレスポンスを盗む**方法を学びました。

しかし、レスポンスをさらに非同期化することも可能です。

**HEAD**リクエストのような興味深いリクエストがあります。これはレスポンスの本文に**何も含まれていない**とされており、**GETリクエストであったかのようにContent-Lengthを含むべき**です（必須）。

したがって、攻撃者が**HEAD**リクエストを**注入する**場合、この画像のように：

![](<../.gitbook/assets/image (626).png>)

次に、**青いものが攻撃者に応答された後**、次の被害者のリクエストがキューに導入されます：

![](<../.gitbook/assets/image (651) (1) (1) (1) (1) (1) (1).png>)

その後、**被害者**は**HEAD**リクエストからの**レスポンスを受け取り**ますが、これには**Content-Lengthは含まれますが、内容はまったく含まれていません**。したがって、プロキシはこのレスポンスを被害者に**送信せず**、**内容を待つ**ことになりますが、実際には**黄色のリクエストへのレスポンス**（攻撃者によって注入されたもの）になります：

![](<../.gitbook/assets/image (627) (1).png>)

### コンテンツの混乱

前の例に従って、被害者が受け取るレスポンスの本文を**制御できる**ことと、**HEAD** **レスポンス**が通常、そのヘッダーに**Content-TypeとContent-Lengthを含む**ことを知っていると、次のようなリクエストを**送信して**、ページがXSSに脆弱でなくても被害者にXSSを**引き起こす**ことができます：

![](<../.gitbook/assets/image (654) (1) (1) (1) (1).png>)

### キャッシュポイズニング

前述のレスポンス非同期化コンテンツ混乱攻撃を悪用して、**キャッシュが被害者によって実行されたリクエストへのレスポンスを保存し、このレスポンスがXSSを引き起こす注入されたものである場合、キャッシュが汚染されます**。

XSSペイロードを含む悪意のあるリクエスト：

![](<../.gitbook/assets/image (644) (1).png>)

キャッシュにレスポンスを保存するように指示するヘッダーを含む被害者への悪意のあるレスポンス：

![](<../.gitbook/assets/image (629) (1).png>)

{% hint style="warning" %}
この場合、**"被害者"が攻撃者である場合**、彼は**悪意のあるレスポンスでキャッシュされるURLを制御できる**ので、任意のURLで**キャッシュポイズニングを実行できる**ことに注意してください。
{% endhint %}

### Webキャッシュデセプション

この攻撃は前のものに似ていますが、**キャッシュ内にペイロードを注入する代わりに、攻撃者は被害者の情報をキャッシュ内にキャッシュします**：

![](<../.gitbook/assets/image (643) (1) (1).png>)

### レスポンススプリッティング

この攻撃の**目的**は、再び**レスポンスの非同期化を悪用して**、プロキシに**100%攻撃者が生成したレスポンスを送信させる**ことです。

これを達成するために、攻撃者はレスポンス内でいくつかの値を**反映するWebアプリケーションのエンドポイントを見つけ**、**HEADレスポンスのコンテンツの長さを知る**必要があります。

彼は次のような**エクスプロイトを送信します**：

![](<../.gitbook/assets/image (649) (1) (1) (1).png>)

最初のリクエストが解決されて攻撃者に送り返された後、**被害者のリクエストがキューに追加されます**：

![](<../.gitbook/assets/image (661) (1) (1) (1).png>)

被害者は**HEADレスポンス + 2番目のリクエストのレスポンスの内容（反映されたデータの一部を含む）**としてレスポンスを受け取ります：

![](<../.gitbook/assets/image (633) (1).png>)

しかし、**HEAD**レスポンスの**Content-Length**に応じたサイズを持つ**反映されたデータ**が、レスポンスキューで**有効なHTTPレスポンスを生成した**ことに注意してください。

したがって、**2番目の被害者の次のリクエスト**
