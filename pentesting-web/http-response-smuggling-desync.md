# HTTP Response Smuggling / Desync

<details>

<summary><strong>Lernen Sie AWS-Hacking von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks bewerben m√∂chten** oder **HackTricks als PDF herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegramm-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) Github-Repositories senden.

</details>

**Die Technik dieses Beitrags wurde aus dem Video √ºbernommen: [https://www.youtube.com/watch?v=suxDcYViwao\&t=1343s](https://www.youtube.com/watch?v=suxDcYViwao\&t=1343s)**


## Desynchronisation der HTTP-Anforderungs-Warteschlange

Zun√§chst einmal **missbraucht diese Technik eine Schwachstelle beim HTTP-Anforderungsschmuggel**, daher m√ºssen Sie wissen, was das ist:

Der **Hauptunterschied** zwischen dieser Technik und einem gew√∂hnlichen HTTP-Anforderungsschmuggel besteht darin, dass wir **anstatt** den **Angriff** auf die **Anforderung des Opfers** **durch das Hinzuf√ºgen eines Pr√§fixes** durchf√ºhren, die **Antwort, die das Opfer erh√§lt, durchsickern lassen oder modifizieren**. Dies geschieht, indem wir anstelle von 1,5 Anfragen, um den HTTP-Anforderungsschmuggel auszunutzen, **2 vollst√§ndige Anfragen senden, um die Warteschlange der Proxy-Antworten zu desynchronisieren**.

Dies liegt daran, dass wir in der Lage sein werden, die **Antwortwarteschlange zu desynchronisieren**, sodass die **Antwort** der **legitimen Anforderung des Opfers an den Angreifer gesendet wird**, oder indem der Antwort an das Opfer **vom Angreifer kontrollierter Inhalt** eingef√ºgt wird.

### Desynchronisation der HTTP-Pipeline

HTTP/1.1 erm√∂glicht es, **verschiedene Ressourcen anzufordern, ohne auf vorherige Ressourcen warten zu m√ºssen**. Wenn sich also ein **Proxy dazwischen befindet**, ist es die Aufgabe des Proxys, **eine synchronisierte √úbereinstimmung der Anfragen, die an das Backend gesendet werden, und der Antworten, die von dort kommen, aufrechtzuerhalten**.

Es gibt jedoch ein Problem bei der Desynchronisierung der Antwortwarteschlange. Wenn ein Angreifer einen HTTP-Antwortschmuggelangriff sendet und die Antworten auf die **urspr√ºngliche Anforderung und die geschmuggelte Anforderung sofort beantwortet werden**, wird die geschmuggelte Antwort nicht in die Warteschlange der Opferantwort eingef√ºgt, sondern **einfach als Fehler verworfen**.

![](<../.gitbook/assets/image (635) (1) (1) (1).png>)

Daher ist es erforderlich, dass die **geschmuggelte Anforderung** **mehr Zeit ben√∂tigt, um im Backend-Server verarbeitet zu werden**. Wenn die geschmuggelte Anforderung in dieser speziellen Situation **beantwortet wird, bevor das legitime Opfer die Anforderung gesendet hat**, wird die **geschmuggelte Antwort an das Opfer gesendet**. Der Angreifer wird daher die Anforderung "ausf√ºhren", die das Opfer durchf√ºhrt.

Dar√ºber hinaus, wenn der **Angreifer dann eine Anforderung ausf√ºhrt** und die **legitime Antwort** auf die **Anforderung des Opfers vor dem** Anforderung des Angreifers **beantwortet wird**, wird die **Antwort an das Opfer an den Angreifer gesendet**, wodurch die Antwort an das Opfer gestohlen wird (die beispielsweise den Header **Set-Cookie** enthalten kann).

![](<../.gitbook/assets/image (658) (1).png>)

![](<../.gitbook/assets/image (655) (1) (1) (1).png>)

### Mehrfache verschachtelte Injektionen

Ein weiterer **interessanter Unterschied** zum gew√∂hnlichen **HTTP-Anforderungsschmuggel** besteht darin, dass bei einem gew√∂hnlichen Schmuggelangriff das **Ziel** darin besteht, den Anfang der Anforderung des Opfers zu **modifizieren**, damit es eine unerwartete Aktion ausf√ºhrt. Bei einem **HTTP-Antwortschmuggelangriff** k√∂nnen Sie jedoch **vollst√§ndige Anfragen senden**, sodass Sie in einem Payload mehrere Antworten injizieren k√∂nnen, die **mehrere Benutzer desynchronisieren**, die die **injizierten Antworten empfangen**.

Neben der M√∂glichkeit, **mehrere Exploits leichter auf legitime Benutzer zu verteilen**, k√∂nnte dies auch dazu verwendet werden, einen **DoS-Angriff** auf den Server auszuf√ºhren.

### Exploit-Organisation

Wie bereits erkl√§rt, ist es f√ºr den Missbrauch dieser Technik erforderlich, dass die **erste geschmuggelte Nachricht** in den Server **viel Zeit ben√∂tigt, um verarbeitet zu werden**.

Diese **zeitintensive Anforderung reicht aus**, wenn wir nur die Antwort des Opfers stehlen m√∂chten. Wenn Sie jedoch einen komplexeren Exploit durchf√ºhren m√∂chten, wird dies eine g√§ngige Struktur f√ºr den Exploit sein.

Zun√§chst die **anf√§ngliche Anforderung**, die den **HTTP-Anforderungsschmuggel** ausnutzt, dann die **zeitintensive Anforderung** und dann **1 oder mehrere Payload-Anforderungen**, deren Antworten an die Opfer gesendet werden.

## Missbrauch der Desynchronisation der HTTP-Antwortwarteschlange

### Erfassen von Anforderungen anderer Benutzer <a href="#capturing-other-users-requests" id="capturing-other-users-requests"></a>

Wie bei bekannten Payloads f√ºr den HTTP-Anforderungsschmuggel k√∂nnen Sie die Anforderungen des Opfers stehlen, jedoch mit einem wichtigen Unterschied: In diesem Fall ben√∂tigen Sie nur den **gesendeten Inhalt, der in der Antwort reflektiert wird**, es ist **kein persistenter Speicher** erforderlich.

Zun√§chst sendet der Angreifer einen Payload, der eine **abschlie√üende POST-Anforderung mit dem reflektierten Parameter** am Ende und einer gro√üen Content-Length enth√§lt.

![](<../.gitbook/assets/image (625).png>)

Dann, sobald die **anf√§ngliche Anforderung** (blau) **verarbeitet wurde** und **w√§hrend** die **schl√§frige Anforderung** (gelb) **verarbeitet wird**, wird die **n√§chste Anforderung, die von einem Opfer eintrifft, direkt nach dem reflektierten Parameter in die Warteschlange eingef√ºgt**:

![](<../.gitbook/assets/image (634) (1).png>)

Dann wird das **Opfer** die **Antwort auf die schl√§frige** Anforderung **erhalten** und wenn in der Zwischenzeit der **Angreifer eine weitere Anforderung sendet**, wird die **Antwort auf die Anforderung mit dem reflektierten Inhalt an ihn gesendet**.

## Desynchronisation der Antwort

Bis zu diesem Punkt haben wir gelernt, wie man den HTTP-Anforderungsschmuggelangriff missbraucht, um die **Anforderung zu kontrollieren, deren Antwort ein Client erhalten wird**, und wie man dann die Antwort stiehlt, die f√ºr das Opfer bestimmt war.

Aber es ist immer noch m√∂glich, die Antworten noch weiter zu **desynchronisieren**.

Es gibt interessante Anfragen wie **HEAD**-Anfragen, bei denen angegeben ist, dass **kein Inhalt im Antwortk√∂rper enthalten ist** und dass sie (m√ºssen) **die Content-Length
### Verwirrung des Inhalts

Nach dem vorherigen Beispiel, wissend dass du den **Inhalt des Anfragek√∂rpers** kontrollieren kannst, dessen Antwort der Opfer erhalten wird und dass eine **HEAD-Antwort** normalerweise in ihren Headern den **Content-Type und die Content-Length** enth√§lt, kannst du eine **Anfrage wie die folgende** senden, um XSS im Opfer zu verursachen, ohne dass die Seite anf√§llig f√ºr XSS ist:

![](<../.gitbook/assets/image (654) (1) (1) (1) (1).png>)

### Cache-Vergiftung

Durch Ausnutzen des zuvor kommentierten Angriffs auf die Desynchronisation der Antwort "Content Confusion", **wenn der Cache die Antwort auf die Anfrage speichert, die vom Opfer durchgef√ºhrt wurde und diese Antwort eine injizierte ist, die XSS verursacht, dann ist der Cache vergiftet**.

B√∂sartige Anfrage mit dem XSS-Payload:

![](<../.gitbook/assets/image (644) (1).png>)

B√∂sartige Antwort an das Opfer, die den Header enth√§lt, der dem Cache anzeigt, die Antwort zu speichern:

![](<../.gitbook/assets/image (629) (1).png>)

{% hint style="warning" %}
Beachte, dass in diesem Fall, wenn das **"Opfer" der Angreifer** ist, er jetzt **Cache-Vergiftung in beliebigen URLs** durchf√ºhren kann, da er **die URL kontrollieren kann, die mit der b√∂sartigen Antwort zwischengespeichert wird**.
{% endhint %}

### Web-Cache-T√§uschung

Dieser Angriff ist √§hnlich wie der vorherige, aber **statt einen Payload in den Cache einzuf√ºgen, wird der Angreifer Opferinformationen im Cache zwischenspeichern**:

![](<../.gitbook/assets/image (643) (1) (1).png>)

### Antwort-Splitting

Das **Ziel** dieses Angriffs ist es erneut, die **Desynchronisation der Antwort** auszunutzen, um einen **100%ig vom Angreifer generierten Antwort** an den Proxy zu senden.

Um dies zu erreichen, muss der Angreifer einen Endpunkt der Webanwendung finden, der **einige Werte in der Antwort reflektiert** und die L√§nge des Inhalts der HEAD-Antwort kennen.

Er wird einen **Exploit** wie folgt senden:

![](<../.gitbook/assets/image (649) (1) (1) (1).png>)

Nachdem die erste Anfrage gel√∂st und an den Angreifer zur√ºckgesendet wurde, wird die **Anfrage des Opfers in die Warteschlange aufgenommen**:

![](<../.gitbook/assets/image (661) (1) (1) (1).png>)

Das Opfer erh√§lt als Antwort die **HEAD-Antwort + den Inhalt der Antwort der zweiten Anfrage (der einen Teil der reflektierten Daten enth√§lt):**

![](<../.gitbook/assets/image (633) (1).png>)

Beachte jedoch, wie die **reflektierten Daten eine Gr√∂√üe entsprechend der Content-Length** der **HEAD**-Antwort hatten, die eine g√ºltige HTTP-Antwort in der Antwortwarteschlange **erzeugte**.

Daher wird die **n√§chste Anfrage des zweiten Opfers** als **Antwort etwas erhalten, das vollst√§ndig vom Angreifer erstellt wurde**. Da die Antwort vollst√§ndig vom Angreifer erstellt wurde, kann er auch **den Proxy dazu bringen, die Antwort zu zwischenspeichern**.


<details>

<summary><strong>Lerne AWS-Hacking von Null auf Held mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn du dein **Unternehmen in HackTricks bewerben m√∂chtest** oder **HackTricks als PDF herunterladen m√∂chtest**, sieh dir die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop) an!
* Hol dir das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecke [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Trete der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folge** uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Teile deine Hacking-Tricks, indem du PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **GitHub-Repos** sendest.

</details>
