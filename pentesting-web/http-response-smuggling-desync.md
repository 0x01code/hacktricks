# HTTP Response Smuggling / Desync

<details>

<summary><strong>Aprende a hackear AWS desde cero hasta convertirte en un experto con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si quieres ver tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** Consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Obt√©n la [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **√önete al** üí¨ [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠guenos** en **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Comparte tus trucos de hacking enviando PRs a** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repositorios de github.

</details>

**La t√©cnica de este post fue tomada del video:** [**https://www.youtube.com/watch?v=suxDcYViwao\&t=1343s**](https://www.youtube.com/watch?v=suxDcYViwao\&t=1343s)

## Desincronizaci√≥n de la Cola de Solicitudes HTTP

En primer lugar, esta t√©cnica **abusa de una vulnerabilidad de Desincronizaci√≥n de Solicitudes HTTP**, por lo que necesitas saber qu√© es eso:

La **principal** **diferencia** entre esta t√©cnica y una desincronizaci√≥n com√∫n de solicitudes HTTP es que **en lugar de atacar la solicitud de la v√≠ctima agregando un prefijo a la misma**, vamos a **filtrar o modificar la respuesta que recibe la v√≠ctima**. Esto se logra enviando 2 solicitudes completas para desincronizar la cola de respuestas de los proxies en lugar de enviar 1 solicitud y media para abusar de la desincronizaci√≥n de solicitudes HTTP.

Esto se debe a que vamos a poder **desincronizar la cola de respuestas** para que la **respuesta** de la **solicitud leg√≠tima** de la **v√≠ctima sea enviada al atacante**, o **inyectando contenido controlado por el atacante en la respuesta a la v√≠ctima**.

### Desincronizaci√≥n de Pipelining HTTP

HTTP/1.1 permite solicitar **diferentes recursos sin necesidad de esperar los anteriores**. Por lo tanto, si hay un **proxy** en el **medio**, es tarea de los proxies **mantener una coincidencia sincronizada de las solicitudes enviadas al backend y las respuestas que provienen de √©l**.

Sin embargo, hay un problema al desincronizar la cola de respuestas. Si un atacante env√≠a un ataque de desincronizaci√≥n de respuestas HTTP y las respuestas a la **solicitud inicial y la solicitada** se responden inmediatamente, la respuesta solicitada no se insertar√° en la cola de respuesta de la v√≠ctima, sino que **se descartar√° como un error**.

![](<../.gitbook/assets/image (633).png>)

Por lo tanto, es necesario que la **solicitud solicitada** **tome m√°s tiempo en ser procesada** dentro del servidor backend. Por lo tanto, cuando la solicitud solicitada se procese, la comunicaci√≥n con el atacante habr√° terminado.

En esta situaci√≥n espec√≠fica, si una **v√≠ctima ha enviado una solicitud** y la **solicitud solicitada se responde antes** de la solicitud leg√≠tima, la **respuesta solicitada se enviar√° a la v√≠ctima**. Por lo tanto, el atacante estar√° **controlando la solicitud "realizada" por la v√≠ctima**.

Adem√°s, si el **atacante luego realiza una solicitud** y la **respuesta leg√≠tima** a la **solicitud de la v√≠ctima se responde** **antes** de la solicitud del atacante. La **respuesta a la v√≠ctima se enviar√° al atacante**, **robando** la respuesta a la v√≠ctima (que puede contener, por ejemplo, el encabezado **Set-Cookie**).

![](<../.gitbook/assets/image (1020).png>)

![](<../.gitbook/assets/image (719).png>)

### Inyecciones Anidadas M√∫ltiples

Otra **diferencia interesante** con el **ataque com√∫n de Desincronizaci√≥n de Solicitudes HTTP** es que, en un ataque com√∫n de desincronizaci√≥n, el **objetivo** es **modificar el inicio de la solicitud de la v√≠ctima** para que realice una acci√≥n inesperada. En un **ataque de desincronizaci√≥n de respuestas HTTP**, al **enviar solicitudes completas**, puedes **inyectar en una carga √∫til decenas de respuestas** que **desincronizar√°n a decenas de usuarios** que **recibir√°n** las **respuestas inyectadas**.

Adem√°s de poder **distribuir m√°s f√°cilmente decenas de exploits** entre usuarios leg√≠timos, esto tambi√©n podr√≠a usarse para causar un **DoS** en el servidor.

### Organizaci√≥n de Exploits

Como se explic√≥ anteriormente, para abusar de esta t√©cnica, es necesario que el **primer mensaje solicitado** en el servidor **tome mucho tiempo en ser procesado**.

Esta **solicitud que consume tiempo es suficiente** si solo queremos **intentar robar la respuesta de las v√≠ctimas**. Pero si deseas realizar un exploit m√°s complejo, esta ser√° una estructura com√∫n para el exploit.

Primero la **solicitud inicial** abusando de la **Desincronizaci√≥n de Solicitudes HTTP**, luego la **solicitud que consume tiempo** y luego **1 o m√°s solicitudes de carga √∫til** cuyas respuestas se enviar√°n a las v√≠ctimas.

## Abusando de la Desincronizaci√≥n de la Cola de Respuestas HTTP

### Capturando las solicitudes de otros usuarios <a href="#capturing-other-users-requests" id="capturing-other-users-requests"></a>

Al igual que con las cargas √∫tiles conocidas de Desincronizaci√≥n de Solicitudes HTTP, puedes **robar la solicitud de las v√≠ctimas** con una diferencia importante: En este caso, solo necesitas que el **contenido enviado se refleje en la respuesta**, **no se necesita almacenamiento persistente**.

Primero, el atacante env√≠a una carga √∫til que contiene una **solicitud POST final con el par√°metro reflejado** al final y un Content-Length grande

![](<../.gitbook/assets/image (1053).png>)

Luego, una vez que la **solicitud inicial** (azul) fue **procesada** y **mientras** la **lenta** se est√° procesando (amarilla), la **pr√≥xima solicitud que llega de una v√≠ctima** se va a **agregar en la cola justo despu√©s del par√°metro reflejado**:

![](<../.gitbook/assets/image (794).png>)

Entonces, la **v√≠ctima** **recibir√°** la **respuesta a la solicitud lenta** y si en ese momento el **atacante** **env√≠a otra solicitud**, la **respuesta de la solicitud de contenido reflejado se le enviar√°**.

## Desincronizaci√≥n de Respuestas

Hasta este punto, hemos aprendido c√≥mo abusar de los ataques de Desincronizaci√≥n de Solicitudes HTTP para **controlar** la **solicitud** cuya **respuesta** un **cliente** va a **recibir** y c√≥mo luego **robar la respuesta que estaba destinada a la v√≠ctima**.

Pero a√∫n es posible **desincronizar a√∫n m√°s** las respuestas.

Existen solicitudes interesantes como la solicitud **HEAD** que se especifican para no tener **ning√∫n contenido dentro del cuerpo de las respuestas** y que deben (deben) **contener el Content-Length** de la solicitud como **si fuera una solicitud GET**.

Por lo tanto, si un atacante **inyecta** una solicitud **HEAD**, como en estas im√°genes:

![](<../.gitbook/assets/image (1107).png>)

Entonces, **una vez que la azul es respondida al atacante**, la pr√≥xima solicitud de la v√≠ctima se introducir√° en la cola:

![](<../.gitbook/assets/image (999).png>)

Entonces, la **v√≠ctima** **recibir√°** la **respuesta** de la **solicitud HEAD**, que **va a contener un Content-Length pero sin contenido alguno**. Por lo tanto, el proxy **no enviar√° esta respuesta** a la v√≠ctima, sino que **esperar√°** alg√∫n **contenido**, que en realidad ser√° la **respuesta a la solicitud amarilla** (tambi√©n inyectada por el atacante):

![](<../.gitbook/assets/image (735).png>)
### Confusi√≥n de Contenido

Siguiendo el ejemplo anterior, sabiendo que puedes **controlar el cuerpo** de la solicitud cuya respuesta va a recibir la v√≠ctima y que una respuesta **HEAD** generalmente contiene en sus encabezados el **Content-Type y el Content-Length**, puedes **enviar una solicitud como la siguiente** para **causar XSS** en la v√≠ctima sin que la p√°gina sea vulnerable a XSS:

![](<../.gitbook/assets/image (688).png>)

### Envenenamiento de Cach√©

Abusando del ataque de Confusi√≥n de Contenido por desincronizaci√≥n de respuesta previamente comentado, **si la cach√© almacena la respuesta a la solicitud realizada por la v√≠ctima y esta respuesta es una inyectada que causa un XSS, entonces la cach√© queda envenenada**.

Solicitud maliciosa que contiene el payload XSS:

![](<../.gitbook/assets/image (614).png>)

Respuesta maliciosa a la v√≠ctima que contiene el encabezado que indica a la cach√© que almacene la respuesta:

![](<../.gitbook/assets/image (566).png>)

{% hint style="warning" %}
Ten en cuenta que en este caso si el **"atacante" es la v√≠ctima** ahora puede realizar **envenenamiento de cach√© en URLs arbitrarias** ya que puede **controlar la URL que va a ser almacenada en cach√©** con la respuesta maliciosa.
{% endhint %}

### Enga√±o de Cach√© Web

Este ataque es similar al anterior, pero **en lugar de inyectar un payload dentro de la cach√©, el atacante almacenar√° informaci√≥n de la v√≠ctima dentro de la cach√©:**

![](<../.gitbook/assets/image (991).png>)

### Divisi√≥n de Respuesta

El **objetivo** de este ataque es abusar nuevamente de la **desincronizaci√≥n de respuesta** para **hacer que el proxy env√≠e una respuesta generada al 100% por el atacante**.

Para lograr esto, el atacante necesita encontrar un punto final de la aplicaci√≥n web que est√© **reflejando algunos valores dentro de la respuesta** y **conocer la longitud del contenido de la respuesta HEAD**.

Enviar√≠a un **exploit** como:

![](<../.gitbook/assets/image (911).png>)

Despu√©s de que se resuelva y env√≠e la primera solicitud al atacante, la **solicitud de la v√≠ctima se agrega a la cola**:

![](<../.gitbook/assets/image (737).png>)

La v√≠ctima recibir√° como respuesta el **HEAD response + el contenido de la respuesta de la segunda solicitud (que contiene parte de los datos reflejados):**

![](<../.gitbook/assets/image (356).png>)

Sin embargo, observa c√≥mo los **datos reflejados ten√≠an un tama√±o de acuerdo con el Content-Length** de la respuesta **HEAD** que **gener√≥ una respuesta HTTP v√°lida en la cola de respuestas**.

Por lo tanto, la **pr√≥xima solicitud de la segunda v√≠ctima** recibir√° como **respuesta algo completamente creado por el atacante**. Como la respuesta est√° completamente creada por el atacante, tambi√©n puede **hacer que la cach√© del proxy almacene la respuesta**.
