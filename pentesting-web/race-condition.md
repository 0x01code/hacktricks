# Condici√≥n de Carrera

<figure><img src="../.gitbook/assets/image (3) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Utiliza [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) para construir y **automatizar flujos de trabajo** con las herramientas comunitarias m√°s avanzadas del mundo.\
Obt√©n acceso hoy mismo:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* ¬øTrabajas en una **empresa de ciberseguridad**? ¬øQuieres que tu **empresa sea anunciada en HackTricks**? ¬øO quieres tener acceso a la **√∫ltima versi√≥n de PEASS o descargar HackTricks en PDF**? ¬°Consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Obt√©n el [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* **√önete al** [**üí¨**](https://emojipedia.org/speech-balloon/) [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de Telegram**](https://t.me/peass) o **s√≠gueme** en **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Comparte tus trucos de hacking enviando PRs al** [**repositorio de hacktricks**](https://github.com/carlospolop/hacktricks) **y al** [**repositorio de hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## Explotando la Condici√≥n de Carrera

El principal problema de abusar de las CC es que necesitas que las solicitudes se procesen en paralelo con una diferencia de tiempo muy corta (generalmente >1ms). En la siguiente secci√≥n, se proponen diferentes soluciones para hacer esto posible.

<figure><img src="../.gitbook/assets/image (5) (1).png" alt=""><figcaption></figcaption></figure>

### Ataque de un solo paquete (HTTP/2) / Sincronizaci√≥n del √∫ltimo byte (HTTP/1.1)

HTTP2 permite enviar **2 solicitudes en una sola conexi√≥n TCP** (mientras que en HTTP/1.1 deben ser secuenciales).\
El uso de un solo paquete TCP elimina por completo el efecto del jitter de la red, por lo que esto claramente tiene potencial para ataques de condici√≥n de carrera. Sin embargo, **dos solicitudes no son suficientes para un ataque de carrera confiable** gracias al **jitter del lado del servidor** - variaciones en el tiempo de procesamiento de las solicitudes de la aplicaci√≥n causadas por variables incontrolables como la contenci√≥n de la CPU.

Pero, utilizando la t√©cnica de '**sincronizaci√≥n del √∫ltimo byte**' de HTTP/1.1, es posible enviar previamente la mayor parte de los datos reteniendo un fragmento peque√±o de cada solicitud y luego 'completar' **20-30 solicitudes con un solo paquete TCP**.

Para **enviar previamente la mayor parte de cada solicitud**:

* Si la solicitud no tiene cuerpo, env√≠a todas las cabeceras, pero no establezcas la bandera END\_STREAM. Ret√©n un marco de datos vac√≠o con END\_STREAM establecido.
* Si la solicitud tiene un cuerpo, env√≠a las cabeceras y todos los datos del cuerpo excepto el √∫ltimo byte. Ret√©n un marco de datos que contenga el √∫ltimo byte.

A continuaci√≥n, **prep√°rate para enviar los marcos finales**:

* Espera 100 ms para asegurarte de que se hayan enviado los marcos iniciales.
* Aseg√∫rate de que TCP\_NODELAY est√© desactivado: es crucial que el algoritmo de Nagle agrupe los marcos finales.
* Env√≠a un paquete de ping para calentar la conexi√≥n local. Si no haces esto, la pila de red del sistema operativo colocar√° el primer marco final en un paquete separado.

Finalmente, env√≠a los marcos retenidos. Deber√≠as poder verificar que llegaron en un solo paquete utilizando Wireshark.

{% hint style="info" %}
Ten en cuenta que esto **no funciona para archivos est√°ticos** en ciertos servidores, pero como los archivos est√°ticos no son relevantes para los ataques de condici√≥n de carrera, esto no es relevante para los ataques de CC.
{% endhint %}

Utilizando esta t√©cnica, puedes hacer que 20-30 solicitudes lleguen al servidor simult√°neamente, sin importar el jitter de la red:

<figure><img src="../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

**Adapt√°ndose a la arquitectura objetivo**

Vale la pena se√±alar que muchas aplicaciones se encuentran detr√°s de un servidor frontal, y estos pueden decidir reenviar algunas solicitudes a trav√©s de conexiones existentes hacia el backend, y crear conexiones nuevas para otras.

Como resultado, es importante no atribuir el tiempo inconsistente de las solicitudes al comportamiento de la aplicaci√≥n, como mecanismos de bloqueo que solo permiten que un solo hilo acceda a un recurso a la vez. Adem√°s, el enrutamiento de solicitudes del servidor frontal se realiza a menudo por conexi√≥n, por lo que es posible que puedas suavizar el tiempo de las solicitudes realizando un calentamiento de conexi√≥n en el lado del servidor: **enviando algunas solicitudes inconsecuentes a trav√©s de tu conexi√≥n antes de realizar el ataque** (esto es simplemente enviar varias solicitudes antes de comenzar el ataque real).

#### Mecanismos de bloqueo basados en sesiones <a href="#session-based-locking-mechanisms" id="session-based-locking-mechanisms"></a>

Algunos frameworks intentan evitar la corrupci√≥n accidental de datos mediante el uso de alg√∫n tipo de **bloqueo de solicitud**. Por ejemplo, el m√≥dulo de controlador de sesi√≥n nativo de **PHP solo procesa una solicitud por sesi√≥n a la vez**.

Es extremadamente importante detectar este tipo de comportamiento, ya que de lo contrario puede ocultar vulnerabilidades f√°cilmente explotables. Si notas que todas tus solicitudes se est√°n procesando de manera secuencial, intenta enviar cada una de ellas utilizando un token de sesi√≥n diferente.
#### **Abuso de l√≠mites de velocidad o recursos**

Si el calentamiento de la conexi√≥n no marca ninguna diferencia, existen varias soluciones para este problema.

Usando Turbo Intruder, puedes introducir un breve retraso en el lado del cliente. Sin embargo, como esto implica dividir tus solicitudes de ataque reales en varios paquetes TCP, no podr√°s utilizar la t√©cnica de ataque de un solo paquete. Como resultado, en objetivos con alta variabilidad, es poco probable que el ataque funcione de manera confiable, independientemente del retraso que establezcas.

<figure><img src="../.gitbook/assets/image (2) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

En su lugar, es posible que puedas resolver este problema abusando de una caracter√≠stica de seguridad com√∫n.

Los servidores web a menudo **retrasan el procesamiento de las solicitudes si se env√≠an demasiado r√°pido**. Al enviar una gran cantidad de solicitudes falsas para provocar intencionalmente el l√≠mite de velocidad o recursos, es posible que puedas causar un retraso adecuado en el lado del servidor. Esto hace que el ataque de un solo paquete sea viable incluso cuando se requiere una ejecuci√≥n retrasada.

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

{% hint style="warning" %}
Para obtener m√°s informaci√≥n sobre esta t√©cnica, consulta el informe original en [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
{% endhint %}

#### Ejemplos de ataque

* **Tubo Intruder - Ataque de un solo paquete HTTP2 (1 punto final)**: Puedes enviar la solicitud a **Turbo Intruder** (`Extensiones` -> `Turbo Intruder` -> `Enviar a Turbo Intruder`), puedes cambiar en la solicitud el valor que deseas forzar por **`%s`** como en `csrf=Bn9VQB8OyefIs3ShR2fPESR0FzzulI1d&username=carlos&password=%s` y luego seleccionar **`examples/race-single-packer-attack.py`** del men√∫ desplegable:

<figure><img src="../.gitbook/assets/image (4) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Si vas a **enviar diferentes valores**, puedes modificar el c√≥digo con este que utiliza una lista de palabras del portapapeles:
```python
passwords = wordlists.clipboard
for password in passwords:
engine.queue(target.req, password, gate='race1')
```
{% hint style="warning" %}
Si la web no admite HTTP2 (solo HTTP1.1), utiliza `Engine.THREADED` o `Engine.BURP` en lugar de `Engine.BURP2`.
{% endhint %}

* **Tubo Intruder - Ataque de un solo paquete HTTP2 (Varios endpoints)**: En caso de que necesites enviar una solicitud a 1 endpoint y luego m√∫ltiples solicitudes a otros endpoints para desencadenar la RCE, puedes modificar el script `race-single-packet-attack.py` de la siguiente manera:
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=1,
engine=Engine.BURP2
)

# Hardcode the second request for the RC
confirmationReq = '''POST /confirm?token[]= HTTP/2
Host: 0a9c00370490e77e837419c4005900d0.web-security-academy.net
Cookie: phpsessionid=MpDEOYRvaNT1OAm0OtAsmLZ91iDfISLU
Content-Length: 0

'''

# For each attempt (20 in total) send 50 confirmation requests.
for attempt in range(20):
currentAttempt = str(attempt)
username = 'aUser' + currentAttempt

# queue a single registration request
engine.queue(target.req, username, gate=currentAttempt)

# queue 50 confirmation requests - note that this will probably sent in two separate packets
for i in range(50):
engine.queue(confirmationReq, gate=currentAttempt)

# send all the queued requests for this attempt
engine.openGate(currentAttempt)
```
* Tambi√©n est√° disponible en **Repeater** a trav√©s de la nueva opci√≥n '**Enviar grupo en paralelo**' en Burp Suite.
* Para **limit-overrun**, simplemente puedes agregar la **misma solicitud 50 veces** en el grupo.
* Para **calentar la conexi√≥n**, puedes **agregar** al **principio** del **grupo** algunas **solicitudes** a alguna parte no est√°tica del servidor web.
* Para **retrasar** el proceso **entre** el procesamiento **de una solicitud y otra** en 2 pasos de subestado, puedes **agregar solicitudes adicionales entre** ambas solicitudes.
* Para un RC de **multi-endpoint**, puedes comenzar enviando la **solicitud** que **va al estado oculto** y luego **50 solicitudes** justo despu√©s de ella que **explotan el estado oculto**.

<figure><img src="../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

### Raw BF

Antes de la investigaci√≥n anterior, estos eran algunos payloads utilizados que intentaban enviar los paquetes lo m√°s r√°pido posible para causar un RC.

* **Repeater:** Consulta los ejemplos de la secci√≥n anterior.
* **Intruder**: Env√≠a la **solicitud** a **Intruder**, establece el **n√∫mero de hilos** en **30** dentro del men√∫ **Opciones** y selecciona como payload **Cargas √∫tiles nulas** y genera **30**.
* **Turbo Intruder**
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
pipeline=False
)
a = ['Session=<session_id_1>','Session=<session_id_2>','Session=<session_id_3>']
for i in range(len(a)):
engine.queue(target.req,a[i], gate='race1')
# open TCP connections and send partial requests
engine.start(timeout=10)
engine.openGate('race1')
engine.complete(timeout=60)

def handleResponse(req, interesting):
table.add(req)
```
* **Python - asyncio**

La biblioteca `asyncio` de Python es una herramienta poderosa para escribir c√≥digo as√≠ncrono y concurrente. Permite realizar operaciones de entrada/salida (E/S) de manera eficiente y manejar m√∫ltiples tareas de forma concurrente.

La programaci√≥n as√≠ncrona es especialmente √∫til en situaciones en las que se requiere realizar m√∫ltiples tareas simult√°neamente, como en el caso de las pruebas de penetraci√≥n. Una t√©cnica com√∫nmente utilizada en las pruebas de penetraci√≥n es la condici√≥n de carrera.

Una condici√≥n de carrera ocurre cuando dos o m√°s procesos o hilos intentan acceder y modificar un recurso compartido al mismo tiempo, lo que puede llevar a resultados inesperados o inseguros. En el contexto de las pruebas de penetraci√≥n web, una condici√≥n de carrera puede ser explotada para obtener acceso no autorizado o realizar acciones maliciosas.

Para aprovechar una condici√≥n de carrera en una aplicaci√≥n web, es necesario identificar un punto de vulnerabilidad donde se pueda manipular el estado de la aplicaci√≥n. Esto puede ser, por ejemplo, una operaci√≥n de actualizaci√≥n de perfil de usuario o una transacci√≥n financiera.

Una vez identificado el punto de vulnerabilidad, se pueden realizar m√∫ltiples solicitudes simult√°neas para intentar explotar la condici√≥n de carrera. Esto se puede lograr utilizando la biblioteca `asyncio` de Python para enviar solicitudes concurrentes y controlar el orden de ejecuci√≥n.

Es importante tener en cuenta que la explotaci√≥n de una condici√≥n de carrera es una actividad ilegal y solo debe realizarse con el consentimiento expl√≠cito del propietario del sistema. Las pruebas de penetraci√≥n √©ticas son una forma leg√≠tima de evaluar la seguridad de un sistema, siempre y cuando se realicen dentro de los l√≠mites legales y √©ticos establecidos.
```python
import asyncio
import httpx

async def use_code(client):
resp = await client.post(f'http://victim.com', cookies={"session": "asdasdasd"}, data={"code": "123123123"})
return resp.text

async def main():
async with httpx.AsyncClient() as client:
tasks = []
for _ in range(20): #20 times
tasks.append(asyncio.ensure_future(use_code(client)))

# Get responses
results = await asyncio.gather(*tasks, return_exceptions=True)

# Print results
for r in results:
print(r)

# Async2sync sleep
await asyncio.sleep(0.5)
print(results)

asyncio.run(main())
```
## **Metodolog√≠a de RC**

### L√≠mite-desbordamiento / TOCTOU

Este es el tipo m√°s b√°sico de condici√≥n de carrera donde se presentan vulnerabilidades en lugares que limitan la cantidad de veces que se puede realizar una acci√≥n. Como usar el mismo c√≥digo de descuento varias veces en una tienda web. Un ejemplo muy f√°cil se puede encontrar en [este informe](https://medium.com/@pravinponnusamy/race-condition-vulnerability-found-in-bug-bounty-program-573260454c43) o en [este error](https://hackerone.com/reports/759247).

Existen muchas variaciones de este tipo de ataque, que incluyen:

* Canjear una tarjeta de regalo varias veces
* Calificar un producto varias veces
* Retirar o transferir dinero en exceso de su saldo de cuenta
* Reutilizar una soluci√≥n CAPTCHA √∫nica
* Saltarse un l√≠mite de tasa de anti-fuerza bruta

### **Subestados ocultos**

Otra condici√≥n de carrera m√°s complicada explotar√° subestados en el estado de la m√°quina que podr√≠an permitir a un atacante abusar de estados a los que nunca se supon√≠a que deb√≠a tener acceso, pero hay una peque√±a ventana para que el atacante acceda a ellos.

1. **Predecir subestados ocultos e interesantes potenciales**

El primer paso es identificar todos los puntos finales que ya sea escriben en √©l o leen datos de √©l y luego usan esos datos para algo importante. Por ejemplo, los usuarios pueden almacenarse en una tabla de base de datos que se modifica mediante el registro, la edici√≥n de perfiles, la iniciaci√≥n de restablecimiento de contrase√±a y la finalizaci√≥n de restablecimiento de contrase√±a.

Podemos usar tres preguntas clave para descartar los puntos finales que es poco probable que causen colisiones. Para cada objeto y los puntos finales asociados, pregunte:

* **¬øC√≥mo se almacena el estado?**

Los datos que se almacenan en una estructura de datos persistente en el servidor son ideales para la explotaci√≥n. Algunos puntos finales almacenan su estado completamente en el lado del cliente, como los restablecimientos de contrase√±a que funcionan enviando un JWT por correo electr√≥nico; estos se pueden omitir de manera segura.

Las aplicaciones a menudo almacenan alg√∫n estado en la sesi√≥n del usuario. Estos a menudo est√°n algo protegidos contra subestados, m√°s sobre eso m√°s adelante.

* **¬øEstamos editando o agregando?**

Las operaciones que editan datos existentes (como cambiar la direcci√≥n de correo electr√≥nico principal de una cuenta) tienen un amplio potencial de colisi√≥n, mientras que las acciones que simplemente se agregan a los datos existentes (como agregar una direcci√≥n de correo electr√≥nico adicional) es poco probable que sean vulnerables a algo m√°s que ataques de l√≠mite-desbordamiento.

* **¬øEn qu√© se basa la operaci√≥n?**

La mayor√≠a de los puntos finales operan en un registro espec√≠fico, que se busca utilizando una "clave", como un nombre de usuario, un token de restablecimiento de contrase√±a o un nombre de archivo. Para un ataque exitoso, necesitamos dos operaciones que usen la misma clave. Por ejemplo, imagine dos implementaciones plausibles de restablecimiento de contrase√±a:

<figure><img src="../.gitbook/assets/image (2) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

2. **Buscar pistas**

En este punto, es hora de lanzar algunos ataques de RC sobre los puntos finales potencialmente interesantes para tratar de encontrar resultados inesperados en comparaci√≥n con los regulares. Cualquier desviaci√≥n de la respuesta esperada, como un cambio en una o m√°s respuestas, o un efecto de segundo orden como diferentes contenidos de correo electr√≥nico o un cambio visible en su sesi√≥n, podr√≠a ser una pista que indique que algo est√° mal.

3. **Demostrar el concepto**

El √∫ltimo paso es demostrar el concepto y convertirlo en un ataque viable.

Cuando env√≠e un lote de solicitudes, es posible que descubra que un par de solicitudes tempranas desencadena un estado final vulnerable, pero las solicitudes posteriores lo sobrescriben/invalidan y el estado final no se puede explotar. En este escenario, querr√° eliminar todas las solicitudes innecesarias: dos deber√≠an ser suficientes para explotar la mayor√≠a de las vulnerabilidades. Sin embargo, reducir a dos solicitudes har√° que el ataque sea m√°s sensible al tiempo, por lo que es posible que deba intentar el ataque varias veces o automatizarlo.

### Ataques sensibles al tiempo

A veces, es posible que no encuentre condiciones de carrera, pero las t√©cnicas para entregar solicitudes con un tiempo preciso a√∫n pueden revelar la presencia de otras vulnerabilidades.

Un ejemplo de esto es cuando se utilizan marcas de tiempo de alta resoluci√≥n en lugar de cadenas aleatorias seguras criptogr√°ficamente para generar tokens de seguridad.

Considere un token de restablecimiento de contrase√±a que solo se aleatoriza utilizando una marca de tiempo. En este caso, podr√≠a ser posible desencadenar dos restablecimientos de contrase√±a para dos usuarios diferentes, que ambos usan el mismo token. Todo lo que necesita hacer es sincronizar las solicitudes para que generen la misma marca de tiempo.

{% hint style="warning" %}
Para confirmar, por ejemplo, la situaci√≥n anterior, simplemente podr√≠a solicitar **2 tokens de restablecimiento de contrase√±a al mismo tiempo** (usando un ataque de paquete √∫nico) y verificar si son **iguales**.
{% endhint %}

Consulte el [ejemplo en este laboratorio](https://portswigger.net/web-security/race-conditions/lab-race-conditions-exploiting-time-sensitive-vulnerabilities).

## Estudios de caso de subestados ocultos

### Pagar y agregar un art√≠culo

[Consulte este laboratorio](https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-insufficient-workflow-validation) para ver c√≥mo **pagar** en una tienda y **agregar un art√≠culo adicional** que no necesitar√° pagar.

### Confirmar otros correos electr√≥nicos

La idea es **verificar una direcci√≥n de correo electr√≥nico y cambiarla a otra al mismo tiempo** para averiguar si la plataforma verifica la nueva direcci√≥n cambiada.

### Cambiar el correo electr√≥nico a 2 direcciones de correo electr√≥nico basadas en cookies

Seg√∫n [este informe](https://portswigger.net/research/smashing-the-state-machine), Gitlab era vulnerable a una toma de control de esta manera porque podr√≠a **enviar el token de verificaci√≥n de correo electr√≥nico de un correo electr√≥nico al otro correo electr√≥nico**.

Tambi√©n puede consultar [este laboratorio](https://portswigger.net/web-security/race-conditions/lab-race-conditions-single-endpoint) para obtener m√°s informaci√≥n al respecto.

### Estados ocultos de la base de datos / Bypass de confirmaci√≥n

Si se utilizan **2 escrituras diferentes** para **agregar informaci√≥n** dentro de una **base de datos**, hay una peque√±a porci√≥n de tiempo en la que solo se ha escrito el primer dato dentro de la base de datos. Por ejemplo, al crear un usuario, el **nombre de usuario** y la **contrase√±a** podr√≠an ser **escritos** y luego se escribe el token para confirmar la cuenta reci√©n creada. Esto significa que durante un breve per√≠odo de tiempo, el **token para confirmar una cuenta es nulo**.

Por lo tanto, **registrarse en una cuenta y enviar varias solicitudes con un token vac√≠o** (`token=` o `token[]=` o cualquier otra variaci√≥n) para confirmar la cuenta de inmediato podr√≠a permitir confirmar una cuenta donde no se controla el correo electr√≥nico.

Consulte [este laboratorio](https://portswigger.net/web-security/race-conditions/lab-race-conditions-partial-construction) para ver un ejemplo.
### Bypass 2FA

El siguiente pseudo-c√≥digo demuestra c√≥mo un sitio web podr√≠a ser vulnerable a una variaci√≥n de carrera de este ataque:
```python
session['userid'] = user.userid
if user.mfa_enabled:
session['enforce_mfa'] = True
# generate and send MFA code to user
# redirect browser to MFA code entry form
```
Como puedes ver, esto es en realidad una **secuencia de m√∫ltiples pasos dentro de una sola solicitud**. Lo m√°s importante es que pasa por un subestado en el que el **usuario tiene temporalmente una sesi√≥n v√°lida iniciada**, pero a√∫n no se est√° aplicando la autenticaci√≥n multifactor (MFA). Un atacante podr√≠a potencialmente explotar esto enviando una solicitud de inicio de sesi√≥n junto con una solicitud a un punto final sensible y autenticado.

### Persistencia eterna de OAuth2

Existen varios [**proveedores de OAuth**](https://en.wikipedia.org/wiki/List\_of\_OAuth\_providers). Estos servicios te permitir√°n crear una aplicaci√≥n y autenticar a los usuarios que el proveedor ha registrado. Para hacerlo, el **cliente** deber√° **permitir que tu aplicaci√≥n** acceda a algunos de sus datos dentro del **proveedor de OAuth**.\
Hasta aqu√≠, solo es un inicio de sesi√≥n com√∫n con Google/LinkedIn/GitHub... donde se te muestra una p√°gina que dice: "_La aplicaci√≥n \<InsertCoolName> quiere acceder a tu informaci√≥n, ¬øquieres permitirlo?_"

#### Condici√≥n de carrera en `authorization_code`

El **problema** aparece cuando **lo aceptas** y autom√°ticamente env√≠a un **`authorization_code`** a la aplicaci√≥n maliciosa. Luego, esta aplicaci√≥n **abusa de una condici√≥n de carrera en el proveedor de servicios de OAuth** para generar m√°s de un AT/RT (Token de Autenticaci√≥n/Token de Actualizaci√≥n) a partir del **`authorization_code`** para tu cuenta. B√°sicamente, aprovechar√° el hecho de que has aceptado que la aplicaci√≥n acceda a tus datos para **crear varias cuentas**. Luego, si **dejas de permitir que la aplicaci√≥n acceda a tus datos, se eliminar√° un par de AT/RT, pero los dem√°s seguir√°n siendo v√°lidos**.

#### Condici√≥n de carrera en `Refresh Token`

Una vez que hayas **obtenido un RT v√°lido**, podr√≠as intentar **abusar de √©l para generar varios AT/RT**, e incluso si el usuario cancela los permisos para que la aplicaci√≥n maliciosa acceda a sus datos, **varios RT seguir√°n siendo v√°lidos**.

## **RC en WebSockets**

En [**WS\_RaceCondition\_PoC**](https://github.com/redrays-io/WS\_RaceCondition\_PoC) puedes encontrar un PoC en Java para enviar mensajes de WebSocket en **paralelo** y abusar de las **condiciones de carrera tambi√©n en WebSockets**.

## Referencias

* [https://hackerone.com/reports/759247](https://hackerone.com/reports/759247)
* [https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html](https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html)
* [https://hackerone.com/reports/55140](https://hackerone.com/reports/55140)
* [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
* [https://portswigger.net/web-security/race-conditions](https://portswigger.net/web-security/race-conditions)

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* ¬øTrabajas en una **empresa de ciberseguridad**? ¬øQuieres ver tu **empresa anunciada en HackTricks**? ¬øO quieres tener acceso a la **√∫ltima versi√≥n de PEASS o descargar HackTricks en PDF**? ¬°Consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Obt√©n el [**merchandising oficial de PEASS y HackTricks**](https://peass.creator-spring.com)
* **√önete al** [**üí¨**](https://emojipedia.org/speech-balloon/) [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de Telegram**](https://t.me/peass) o **s√≠gueme** en **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Comparte tus trucos de hacking enviando PRs al** [**repositorio de hacktricks**](https://github.com/carlospolop/hacktricks) **y al** [**repositorio de hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

<figure><img src="../.gitbook/assets/image (3) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Utiliza [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) para construir y **automatizar f√°cilmente flujos de trabajo** con las herramientas comunitarias m√°s avanzadas del mundo.\
Obt√©n acceso hoy mismo:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}
