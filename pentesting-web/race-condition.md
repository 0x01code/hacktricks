# Wedloop Toestand

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Gebruik [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) om maklik en outomatiese werkstrome te bou wat aangedryf word deur die w√™reld se mees gevorderde gemeenskapsinstrumente.\
Kry Vandag Toegang:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>Leer AWS-hacking van nul tot held met</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Ander maniere om HackTricks te ondersteun:

* As jy wil sien dat jou **maatskappy geadverteer word in HackTricks** of **HackTricks aflaai in PDF-formaat** Kyk na die [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Kry die [**amptelike PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ontdek [**The PEASS Family**](https://opensea.io/collection/the-peass-family), ons versameling eksklusiewe [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Sluit aan by die** üí¨ [**Discord-groep**](https://discord.gg/hRep4RUj7f) of die [**telegram-groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Deel jou haktruuks deur PR's in te dien by die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github-repos.

</details>

{% hint style="warning" %}
Vir 'n dieper begrip van hierdie tegniek, kyk na die oorspronklike verslag by [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
{% endhint %}

## Verbetering van Wedloop Toestand Aanvalle

Die grootste struikelblok om voordeel te trek uit wedloop toestande is om seker te maak dat verskeie versoek aan dieselfde tyd hanteer word, met **baie min verskil in hul verwerkingstye‚Äîidealiter, minder as 1ms**.

Hier kan jy 'n paar tegnieke vind vir die Synchronisering van Versoeke:

#### HTTP/2 Enkel-Pakket Aanval teenoor HTTP/1.1 Laaste-Byte Synchronisering

- **HTTP/2**: Ondersteun die stuur van twee versoeke oor 'n enkele TCP-verbinding, wat die impak van netwerkfluktuasie verminder. Tog mag twee versoeke as gevolg van variasies aan die kant van die bediener nie voldoende wees vir 'n konsekwente wedloop toestand aanval nie.
- **HTTP/1.1 'Laaste-Byte Sync'**: Maak dit moontlik om die meeste dele van 20-30 versoeke vooraf te stuur, terwyl 'n klein fragment weerhou word en dan saam gestuur word om gelyktydige aankoms by die bediener te bereik.

**Voorbereiding vir Laaste-Byte Sync** behels:
1. Stuur koppe en liggaamsdata sonder die finale byte sonder om die stroom te be√´indig.
2. Pauzeer vir 100ms na die aanvanklike stuur.
3. Deaktiveer TCP_NODELAY om Nagle se algoritme te gebruik vir die groepering van finale raamwerke.
4. Pinging om die verbinding op te warm.

Die daaropvolgende stuur van weerhouden raamwerke behoort in 'n enkele pakkie aan te kom, wat verifieer kan word deur middel van Wireshark. Hierdie metode is nie van toepassing op statiese l√™ers wat nie tipies betrokke is by wedloop toestand aanvalle nie.

### Aanpassing aan Bedienerargitektuur

Om die teiken se argitektuur te verstaan, is van kritieke belang. Vooraan bedieners mag versoeke anders roeteer, wat die tydsberekening be√Ønvloed. Voorsorgmaatre√´ls vir die opwarm van bedienerkant, deur middel van onbeduidende versoeke, kan versoektydsberekening normaliseer.

#### Hantering van Sessie-Gebaseerde Sluiting

Raamwerke soos PHP se sessiehanterer serialize versoeke per sessie, wat moontlik kwesbaarhede kan verdoesel. Die gebruik van verskillende sessietokens vir elke versoek kan hierdie probleem omseil.

#### Oorkomming van Tempo- of Hulpbronbeperkings

As die opwarm van die verbinding nie effektief is nie, kan die doelbewuste veroorsaking van webbedieners se tempo- of hulpbronbeperkingsvertragings deur middel van 'n vloed van dummiversoeke die enkel-pakket aanval vergemaklik deur 'n bedienervertragingskondusiewe wedloop toestand te veroorsaak.


## Aanval Voorbeelde

* **Tubo Intruder - HTTP2 enkel-pakket aanval (1 eindpunt)**: Jy kan die versoek na **Turbo intruder** stuur (`Extensions` -> `Turbo Intruder` -> `Send to Turbo Intruder`), jy kan die waarde wat jy wil kragtig afdwing vir **`%s`** soos in `csrf=Bn9VQB8OyefIs3ShR2fPESR0FzzulI1d&username=carlos&password=%s` en kies dan die **`examples/race-single-packer-attack.py`** uit die keuselys:

<figure><img src="../.gitbook/assets/image (4) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

As jy **verskillende waardes wil stuur**, kan jy die kode wysig met hierdie een wat 'n woordelys van die knipbord gebruik:
```python
passwords = wordlists.clipboard
for password in passwords:
engine.queue(target.req, password, gate='race1')
```
{% hint style="warning" %}
As die web nie HTTP2 ondersteun nie (slegs HTTP1.1) gebruik `Engine.THREADED` of `Engine.BURP` in plaas van `Engine.BURP2`.
{% endhint %}

* **Tubo Intruder - HTTP2 enkel-pakket aanval (Verskeie eindpunte)**: In die geval waar jy 'n versoek na 1 eindpunt moet stuur en dan meerdere na ander eindpunte om die RCE te aktiveer, kan jy die `race-single-packet-attack.py` skrips verander na iets soos:
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=1,
engine=Engine.BURP2
)

# Hardcode the second request for the RC
confirmationReq = '''POST /confirm?token[]= HTTP/2
Host: 0a9c00370490e77e837419c4005900d0.web-security-academy.net
Cookie: phpsessionid=MpDEOYRvaNT1OAm0OtAsmLZ91iDfISLU
Content-Length: 0

'''

# For each attempt (20 in total) send 50 confirmation requests.
for attempt in range(20):
currentAttempt = str(attempt)
username = 'aUser' + currentAttempt

# queue a single registration request
engine.queue(target.req, username, gate=currentAttempt)

# queue 50 confirmation requests - note that this will probably sent in two separate packets
for i in range(50):
engine.queue(confirmationReq, gate=currentAttempt)

# send all the queued requests for this attempt
engine.openGate(currentAttempt)
```
* Dit is ook beskikbaar in **Repeater** via die nuwe '**Stuur groep parallel**' opsie in Burp Suite.
* Vir **limiet-oortreding** kan jy net die **gelyke versoek 50 keer** in die groep voeg.
* Vir **verbindingsopwarming** kan jy aan die **begin** van die **groep** 'n paar **versoeke** byvoeg na 'n nie-statiese deel van die webbediener.
* Vir **vertraging** tussen die verwerking van **een versoek en 'n ander** in 'n 2 substaat-stappe, kan jy ekstra versoek byvoeg tussen beide versoek.
* Vir 'n **multi-eindpunt** RC kan jy begin om die **versoek** te stuur wat **na die verborge toestand gaan** en dan **50 versoek** net daarna wat die verborge toestand **uitbuit**.

<figure><img src="../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

### Rou BF

Voor die vorige navorsing was hierdie payloads gebruik wat net probeer het om die pakkies so vinnig as moontlik te stuur om 'n RC te veroorsaak.

* **Repeater:** Kyk na die voorbeelde uit die vorige afdeling.
* **Intruder**: Stuur die **versoek** na **Intruder**, stel die **aantal drade** in op **30** binne die **Opsies-menu** en kies as payload **Null payloads** en genereer **30**.
* **Turbo Intruder**
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
pipeline=False
)
a = ['Session=<session_id_1>','Session=<session_id_2>','Session=<session_id_3>']
for i in range(len(a)):
engine.queue(target.req,a[i], gate='race1')
# open TCP connections and send partial requests
engine.start(timeout=10)
engine.openGate('race1')
engine.complete(timeout=60)

def handleResponse(req, interesting):
table.add(req)
```
* **Python - asyncio**
```python
import asyncio
import httpx

async def use_code(client):
resp = await client.post(f'http://victim.com', cookies={"session": "asdasdasd"}, data={"code": "123123123"})
return resp.text

async def main():
async with httpx.AsyncClient() as client:
tasks = []
for _ in range(20): #20 times
tasks.append(asyncio.ensure_future(use_code(client)))

# Get responses
results = await asyncio.gather(*tasks, return_exceptions=True)

# Print results
for r in results:
print(r)

# Async2sync sleep
await asyncio.sleep(0.5)
print(results)

asyncio.run(main())
```
## **RC Metodologie**

### Limiet-oortreding / TOCTOU

Dit is die mees basiese tipe van 'n wedloopvoorwaarde waar **kwesbaarhede** voorkom op plekke wat **die aantal kere wat jy 'n aksie kan uitvoer beperk**. Soos om dieselfde afslagkode verskeie kere in 'n webwinkel te gebruik. 'n Baie maklike voorbeeld kan gevind word in [**hierdie verslag**](https://medium.com/@pravinponnusamy/race-condition-vulnerability-found-in-bug-bounty-program-573260454c43) of in [**hierdie fout**](https://hackerone.com/reports/759247)**.**

Daar is baie variasies van hierdie soort aanval, insluitend:

* Die herwinning van 'n geskenkkaart verskeie kere
* Die beoordeling van 'n produk verskeie kere
* Die onttrekking of oordrag van kontant wat jou rekeningsaldo oorskry
* Die hergebruik van 'n enkele CAPTCHA-oplossing
* Die omseil van 'n anti-brute-force tempo-beperking

### **Versteekte subtoestande**

Die uitbuiting van komplekse wedloopvoorwaardes behels dikwels die benutting van kort geleenthede om te interaksieer met versteekte of **onbedoelde masjien-subtoestande**. Hier is hoe om dit aan te pak:

1. **Identifiseer Potensi√´le Versteekte Subtoestande**
- Begin deur eindpunte te identifiseer wat kritieke data wysig of interaksieer, soos gebruikersprofiel of wagwoordherstelprosesse. Fokus op:
- **Stoor**: Gee voorkeur aan eindpunte wat bedienerkant volgehoue data manipuleer bo diegene wat kli√´ntkant data hanteer.
- **Aksie**: Soek na operasies wat bestaande data wysig, wat meer geneig is om uitbuitbare toestande te skep in vergelyking met diegene wat nuwe data byvoeg.
- **Sleutel**: Suksesvolle aanvalle behels gewoonlik operasies wat gesleutel is op dieselfde identifiseerder, bv. gebruikersnaam of herstelteken.

2. **Voer Aanvanklike Ondersoek uit**
- Toets die ge√Ødentifiseerde eindpunte met wedloopvoorwaarde-aanvalle en let op enige afwykings van verwagte uitkomste. Onverwagte reaksies of veranderinge in programgedrag kan 'n kwesbaarheid aandui.

3. **Wys die Kwesbaarheid**
- Beperk die aanval tot die minimum aantal versoekings wat nodig is om die kwesbaarheid uit te buit, dikwels net twee. Hierdie stap mag verskeie pogings of outomatisering vereis as gevolg van die presiese tydsberekening wat betrokke is.

### Tydgevoelige Aanvalle

Presisie in die tydsberekening van versoekings kan kwesbaarhede aan die lig bring, veral wanneer voorspelbare metodes soos tydstempels gebruik word vir sekuriteitstokens. Byvoorbeeld, die genereer van wagwoordhersteltegnies gebaseer op tydstempels kan identiese tekens vir gelyktydige versoekings toelaat.

**Om Uit te Buit:**
- Gebruik presiese tydsberekening, soos 'n enkele pakketaanval, om gelyktydige wagwoordherstelversoeke te maak. Identiese tekens dui op 'n kwesbaarheid.

**Voorbeeld:**
- Vra om gelyktydige twee wagwoordhersteltekens en vergelyk hulle. As die tekens ooreenstem, dui dit op 'n fout in die teken-generering.

**Kyk na hierdie [PortSwigger-laboratorium](https://portswigger.net/web-security/race-conditions/lab-race-conditions-exploiting-time-sensitive-vulnerabilities) om dit te probeer.**


## Versteekte subtoestande gevallestudies

### Betaal & voeg 'n Item by

Kyk na hierdie [**PortSwigger-laboratorium**](https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-insufficient-workflow-validation) om te sien hoe om **te betaal** in 'n winkel en 'n ekstra item by te voeg waarvoor jy **nie hoef te betaal nie**.

### Bevestig ander e-posse

Die idee is om **'n e-posadres te verifieer en dit terselfdertyd na 'n ander adres te verander** om uit te vind of die platform die nuwe een verifieer.

### Verander e-pos na 2 e-posse-adresse op grond van koekie

Volgens [**hierdie navorsing**](https://portswigger.net/research/smashing-the-state-machine) was Gitlab vatbaar vir 'n oorname op hierdie manier omdat dit dalk die **e-posverifikasietoken van een e-pos na die ander e-pos stuur**.

**Kyk na hierdie [PortSwigger-laboratorium](https://portswigger.net/web-security/race-conditions/lab-race-conditions-single-endpoint) om dit te probeer.**

### Versteekte databasestatusse / Bevestigingsomseiling

As **2 verskillende skrywes** gebruik word om **inligting** in 'n **databasis** by te voeg, is daar 'n klein tydperk waarin **slegs die eerste data in die databasis geskryf is**. Byvoorbeeld, wanneer 'n gebruiker geskep word, kan die **gebruikersnaam** en **wagwoord** geskryf word en **dan die teken** om die nuutgeskepte rekening te bevestig, word geskryf. Dit beteken dat die **teken om 'n rekening te bevestig vir 'n kort tydperk nul is**.

Daarom kan **die registreer van 'n rekening en die stuur van verskeie versoekings met 'n le√´ teken** (`token=` of `token[]=` of enige ander variasie) om die rekening onmiddellik te bevestig, dit moontlik maak om 'n rekening te bevestig waar jy nie die e-pos beheer nie.

**Kyk na hierdie [PortSwigger-laboratorium](https://portswigger.net/web-security/race-conditions/lab-race-conditions-partial-construction) om dit te probeer.**

### Omseil 2FA

Die volgende pseudokode is vatbaar vir 'n wedloopvoorwaarde omdat in 'n baie kort tydperk die **2FA nie afgedwing word nie** terwyl die sessie geskep word:
```python
session['userid'] = user.userid
if user.mfa_enabled:
session['enforce_mfa'] = True
# generate and send MFA code to user
# redirect browser to MFA code entry form
```
### OAuth2 ewige volharding

Daar is verskeie [**OAUth-verskaffers**](https://en.wikipedia.org/wiki/List\_of\_OAuth\_providers). Hierdie dienste stel jou in staat om 'n aansoek te skep en gebruikers te verifieer wat deur die verskaffer geregistreer is. Om dit te doen, sal die **kli√´nt** jou aansoek moet **toelaat om toegang te verkry tot sommige van hul data binne die OAUth-verskaffer**.\
Tot dusver net 'n gewone aanmelding met Google/LinkedIn/GitHub... waar jy 'n bladsy te sien kry wat s√™: "_Application \<InsertCoolName> wil toegang tot jou inligting h√™, wil jy dit toelaat?_"

#### Wedloopvoorwaarde in `authorization_code`

Die **probleem** ontstaan wanneer jy dit **aanvaar** en outomaties 'n **`authorization_code`** na die kwaadwillige aansoek stuur. Hierdie aansoek misbruik dan 'n wedloopvoorwaarde in die OAUth-diensverskaffer om meer as een AT/RT (_Authentication Token/Refresh Token_) van die **`authorization_code`** vir jou rekening te genereer. Dit sal basies misbruik maak van die feit dat jy die aansoek toegelaat het om toegang tot jou data te verkry om **verskeie rekeninge te skep**. As jy dan **ophou om die aansoek toe te laat om toegang tot jou data te verkry, sal een stel AT/RT verwyder word, maar die ander een sal steeds geldig wees**.

#### Wedloopvoorwaarde in `Refresh Token`

Sodra jy 'n geldige RT het, kan jy probeer om dit te misbruik om verskeie AT/RT te genereer, en selfs as die gebruiker die toestemmings vir die kwaadwillige aansoek kanselleer om toegang tot sy data te verkry, sal **verskeie RTs steeds geldig wees**.

## **RC in WebSockets**

In [**WS\_RaceCondition\_PoC**](https://github.com/redrays-io/WS\_RaceCondition\_PoC) kan jy 'n PoC in Java vind om websockets-boodskappe **gelyktydig** te stuur om ook **wedloopvoorwaardes in WebSockets** te misbruik.

## Verwysings

* [https://hackerone.com/reports/759247](https://hackerone.com/reports/759247)
* [https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html](https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html)
* [https://hackerone.com/reports/55140](https://hackerone.com/reports/55140)
* [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
* [https://portswigger.net/web-security/race-conditions](https://portswigger.net/web-security/race-conditions)

<details>

<summary><strong>Leer AWS-hacking van nul tot held met</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Ander maniere om HackTricks te ondersteun:

* As jy jou **maatskappy in HackTricks wil adverteer** of **HackTricks in PDF wil aflaai**, kyk na die [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Kry die [**amptelike PEASS & HackTricks-uitrusting**](https://peass.creator-spring.com)
* Ontdek [**The PEASS Family**](https://opensea.io/collection/the-peass-family), ons versameling eksklusiewe [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Sluit aan by die** üí¨ [**Discord-groep**](https://discord.gg/hRep4RUj7f) of die [**telegram-groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Deel jou haktruuks deur PR's in te dien by die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github-opslag.

</details>

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Gebruik [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) om maklik werkstrome te bou en outomatiseer met behulp van die w√™reld se mees gevorderde gemeenskapsinstrumente.\
Kry vandag toegang:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}
