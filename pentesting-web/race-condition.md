# Condition de course

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Utilisez [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) pour construire et **automatiser des flux de travail** aliment√©s par les outils communautaires **les plus avanc√©s** au monde.\
Obtenez l'acc√®s aujourd'hui :

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>Apprenez le piratage AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Autres moyens de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop)!
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**La Famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection d'[**NFTs**](https://opensea.io/collection/the-peass-family) exclusifs
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux d√©p√¥ts github** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## Exploiter les conditions de course

Le principal probl√®me de l'exploitation des conditions de course est que vous avez besoin que les requ√™tes soient trait√©es en parall√®le avec un tr√®s court intervalle de temps (g√©n√©ralement >1ms). Dans la section suivante, diff√©rentes solutions sont propos√©es pour rendre cela possible.

<figure><img src="../.gitbook/assets/image (5) (1) (1).png" alt=""><figcaption></figcaption></figure>

### Attaque par paquet unique (HTTP/2) / Synchronisation du dernier octet (HTTP/1.1)

HTTP2 permet d'envoyer **2 requ√™tes dans une seule connexion TCP** (alors qu'en HTTP/1.1 elles doivent √™tre s√©quentielles).\
L'utilisation d'un seul paquet TCP √©limine compl√®tement **l'effet du jitter r√©seau**, ce qui a clairement un potentiel pour les attaques par condition de course aussi. Cependant, **deux requ√™tes ne suffisent pas pour une attaque de course fiable** √† cause du **jitter c√¥t√© serveur** - variations dans le temps de traitement des requ√™tes de l'application caus√©es par des variables incontr√¥lables comme la contention CPU.

Mais, en utilisant la technique de '**synchronisation du dernier octet**' avec HTTP/1.1, il est possible de pr√©-envoyer la majeure partie des donn√©es en retenant un petit fragment de chaque requ√™te, puis de 'compl√©ter' **20-30 requ√™tes avec un seul paquet TCP**.

Pour **pr√©-envoyer la majeure partie de chaque requ√™te** :

* Si la requ√™te n'a pas de corps, envoyez tous les en-t√™tes, mais ne d√©finissez pas le drapeau END\_STREAM. Retenez un cadre de donn√©es vide avec END\_STREAM d√©fini.
* Si la requ√™te a un corps, envoyez les en-t√™tes et toutes les donn√©es du corps sauf le dernier octet. Retenez un cadre de donn√©es contenant le dernier octet.

Ensuite, **pr√©parez-vous √† envoyer les cadres finaux** :

* Attendez 100ms pour vous assurer que les cadres initiaux ont √©t√© envoy√©s.
* Assurez-vous que TCP\_NODELAY est d√©sactiv√© - il est crucial que l'algorithme de Nagle regroupe les cadres finaux.
* Envoyez un paquet ping pour r√©chauffer la connexion locale. Si vous ne faites pas cela, la pile r√©seau du syst√®me d'exploitation placera le premier cadre final dans un paquet s√©par√©.

Enfin, envoyez les cadres retenus. Vous devriez pouvoir v√©rifier qu'ils ont atterri dans un seul paquet en utilisant Wireshark.

{% hint style="info" %}
Notez que cela **ne fonctionne pas pour les fichiers statiques** sur certains serveurs, mais les fichiers statiques ne sont pas pertinents pour les attaques par condition de course.
{% endhint %}

En utilisant cette technique, vous pouvez faire en sorte que 20-30 requ√™tes arrivent simultan√©ment au serveur - ind√©pendamment du jitter r√©seau :

<figure><img src="../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

**Adaptation √† l'architecture cible**

Il convient de noter que de nombreuses applications sont situ√©es derri√®re un serveur frontal, et celles-ci peuvent d√©cider de transf√©rer certaines requ√™tes via des connexions existantes vers le back-end, et de cr√©er de nouvelles connexions pour d'autres.

En cons√©quence, il est important de ne pas attribuer un temps de traitement des requ√™tes incoh√©rent au comportement de l'application, tel que des m√©canismes de verrouillage qui ne permettent qu'√† un seul thread d'acc√©der √† une ressource √† la fois. De plus, le routage des requ√™tes frontales est souvent effectu√© sur une base par connexion, donc vous pourriez √™tre en mesure de lisser le temps de traitement des requ√™tes en effectuant un r√©chauffement de connexion c√¥t√© serveur - **envoyer quelques requ√™tes insignifiantes dans votre connexion avant de r√©aliser l'attaque** (cela consiste juste √† envoyer plusieurs requ√™tes avant de commencer l'attaque r√©elle).

#### M√©canismes de verrouillage bas√©s sur la session <a href="#session-based-locking-mechanisms" id="session-based-locking-mechanisms"></a>

Certains frameworks tentent de pr√©venir la corruption accidentelle des donn√©es en utilisant une forme de **verrouillage des requ√™tes**. Par exemple, le module de gestion de session natif de **PHP** ne traite qu'**une requ√™te par session √† la fois**.

Il est extr√™mement important de rep√©rer ce type de comportement car il peut sinon masquer des vuln√©rabilit√©s trivialement exploitables. Si vous remarquez que toutes vos requ√™tes sont trait√©es s√©quentiellement, essayez d'envoyer chacune d'elles en utilisant un jeton de session diff√©rent.

#### **Abuser des limites de taux ou de ressources**

Si le r√©chauffement de la connexion ne fait aucune diff√©rence, il existe diverses solutions √† ce probl√®me.

En utilisant Turbo Intruder, vous pouvez introduire un court d√©lai c√¥t√© client. Cependant, comme cela implique de diviser vos requ√™tes d'attaque r√©elles en plusieurs paquets TCP, vous ne pourrez pas utiliser la technique d'attaque par paquet unique. En cons√©quence, sur des cibles √† fort jitter, l'attaque est peu susceptible de fonctionner de mani√®re fiable, quel que soit le d√©lai que vous d√©finissez.

<figure><img src="../.gitbook/assets/image (2) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Au lieu de cela, vous pourriez √™tre en mesure de r√©soudre ce probl√®me en abusant d'une fonctionnalit√© de s√©curit√© courante.

Les serveurs Web retardent souvent le traitement des requ√™tes si trop sont envoy√©es trop rapidement. En envoyant un grand nombre de requ√™tes factices pour d√©clencher intentionnellement la limite de taux ou de ressources, vous pourriez √™tre en mesure de provoquer un d√©lai c√¥t√© serveur appropri√©. Cela rend l'attaque par paquet unique viable m√™me lorsque l'ex√©cution retard√©e est requise.

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

{% hint style="warning" %}
Pour plus d'informations sur cette technique, consultez le rapport original sur [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
{% endhint %}

#### Exemples d'attaque

* **Tubo Intruder - Attaque par paquet unique HTTP2 (1 point de terminaison)** : Vous pouvez envoyer la requ√™te √† **Turbo intruder** (`Extensions` -> `Turbo Intruder` -> `Envoyer √† Turbo Intruder`), vous pouvez changer dans la requ√™te la valeur que vous souhaitez forcer par brute force pour **`%s`** comme dans `csrf=Bn9VQB8OyefIs3ShR2fPESR0FzzulI1d&username=carlos&password=%s` puis s√©lectionnez **`examples/race-single-packer-attack.py`** dans le menu d√©roulant :

<figure><img src="../.gitbook/assets/image (4) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Si vous allez **envoyer diff√©rentes valeurs**, vous pourriez modifier le code avec celui qui utilise une liste de mots du presse-papiers :
```python
passwords = wordlists.clipboard
for password in passwords:
engine.queue(target.req, password, gate='race1')
```
{% hint style="warning" %}
Si le web ne prend pas en charge HTTP2 (seulement HTTP1.1), utilisez `Engine.THREADED` ou `Engine.BURP` au lieu de `Engine.BURP2`.
{% endhint %}

* **Tubo Intruder - Attaque en un seul paquet HTTP2 (Plusieurs points de terminaison)** : Si vous devez envoyer une requ√™te √† 1 point de terminaison puis plusieurs √† d'autres points de terminaison pour d√©clencher le RCE, vous pouvez modifier le script `race-single-packet-attack.py` avec quelque chose comme :
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=1,
engine=Engine.BURP2
)

# Hardcode the second request for the RC
confirmationReq = '''POST /confirm?token[]= HTTP/2
Host: 0a9c00370490e77e837419c4005900d0.web-security-academy.net
Cookie: phpsessionid=MpDEOYRvaNT1OAm0OtAsmLZ91iDfISLU
Content-Length: 0

'''

# For each attempt (20 in total) send 50 confirmation requests.
for attempt in range(20):
currentAttempt = str(attempt)
username = 'aUser' + currentAttempt

# queue a single registration request
engine.queue(target.req, username, gate=currentAttempt)

# queue 50 confirmation requests - note that this will probably sent in two separate packets
for i in range(50):
engine.queue(confirmationReq, gate=currentAttempt)

# send all the queued requests for this attempt
engine.openGate(currentAttempt)
```
* Il est √©galement disponible dans **Repeater** via la nouvelle option '**Envoyer le groupe en parall√®le**' dans Burp Suite.
* Pour un **d√©passement de limite**, vous pourriez simplement ajouter **la m√™me requ√™te 50 fois** dans le groupe.
* Pour le **pr√©chauffage de connexion**, vous pourriez **ajouter** au **d√©but** du **groupe** quelques **requ√™tes** vers une partie non statique du serveur web.
* Pour **retarder** le processus **entre** le traitement **d'une requ√™te et d'une autre** en 2 √©tapes de sous-√©tats, vous pourriez **ajouter des requ√™tes suppl√©mentaires entre** les deux requ√™tes.
* Pour un RC **multi-point d'acc√®s**, vous pourriez commencer par envoyer la **requ√™te** qui **va vers l'√©tat cach√©** puis **50 requ√™tes** juste apr√®s qui **exploitent l'√©tat cach√©**.

<figure><img src="../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

### BF Brut

Avant les recherches pr√©c√©dentes, voici quelques charges utiles utilis√©es qui tentaient simplement d'envoyer les paquets aussi rapidement que possible pour provoquer un RC.

* **Repeater :** V√©rifiez les exemples de la section pr√©c√©dente.
* **Intruder :** Envoyez la **requ√™te** √† **Intruder**, r√©glez le **nombre de threads** √† **30** dans le **menu Options**, s√©lectionnez comme charge utile **Null payloads** et g√©n√©rez **30**.
* **Turbo Intruder**
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
pipeline=False
)
a = ['Session=<session_id_1>','Session=<session_id_2>','Session=<session_id_3>']
for i in range(len(a)):
engine.queue(target.req,a[i], gate='race1')
# open TCP connections and send partial requests
engine.start(timeout=10)
engine.openGate('race1')
engine.complete(timeout=60)

def handleResponse(req, interesting):
table.add(req)
```
* **Python - asyncio**
```python
import asyncio
import httpx

async def use_code(client):
resp = await client.post(f'http://victim.com', cookies={"session": "asdasdasd"}, data={"code": "123123123"})
return resp.text

async def main():
async with httpx.AsyncClient() as client:
tasks = []
for _ in range(20): #20 times
tasks.append(asyncio.ensure_future(use_code(client)))

# Get responses
results = await asyncio.gather(*tasks, return_exceptions=True)

# Print results
for r in results:
print(r)

# Async2sync sleep
await asyncio.sleep(0.5)
print(results)

asyncio.run(main())
```
## **M√©thodologie RC**

### D√©passement de limite / TOCTOU

C'est le type le plus basique de condition de concurrence o√π les **vuln√©rabilit√©s** **apparaissent** dans des endroits qui **limitent le nombre de fois o√π vous pouvez effectuer une action**. Comme utiliser plusieurs fois le m√™me code de r√©duction dans une boutique en ligne. Un exemple tr√®s simple peut √™tre trouv√© dans [**ce rapport**](https://medium.com/@pravinponnusamy/race-condition-vulnerability-found-in-bug-bounty-program-573260454c43) ou dans [**ce bug**](https://hackerone.com/reports/759247).

Il existe de nombreuses variations de ce type d'attaque, y compris :

* Utiliser plusieurs fois une carte cadeau
* Noter plusieurs fois un produit
* Retirer ou transf√©rer de l'argent au-del√† du solde de votre compte
* R√©utiliser une seule solution CAPTCHA
* Contourner une limite de taux anti-force brute

### **Sous-√©tats cach√©s**

D'autres RC plus compliqu√©s exploiteront les **sous-√©tats dans l'√©tat de la machine** qui pourraient permettre √† un attaquant d'**abuser** d'√©tats auxquels il n'√©tait **jamais cens√© avoir acc√®s**, mais il existe une **petite fen√™tre** pour que l'attaquant y acc√®de.

1. **Pr√©dire les sous-√©tats cach√©s et int√©ressants potentiels**

La premi√®re √©tape consiste √† identifier tous les points de terminaison qui √©crivent dessus, ou lisent des donn√©es √† partir de celui-ci, puis utilisent ces donn√©es pour quelque chose d'important. Par exemple, les utilisateurs peuvent √™tre stock√©s dans une table de base de donn√©es qui est modifi√©e par l'inscription, les modifications de profil, l'initiation de r√©initialisation de mot de passe et la finalisation de r√©initialisation de mot de passe.

Nous pouvons utiliser trois questions cl√©s pour √©carter les points de terminaison qui sont peu susceptibles de provoquer des collisions. Pour chaque objet et les points de terminaison associ√©s, demandez :

* **Comment l'√©tat est-il stock√© ?**

Les donn√©es stock√©es dans une structure de donn√©es persistante c√¥t√© serveur sont id√©ales pour l'exploitation. Certains points de terminaison stockent leur √©tat enti√®rement c√¥t√© client, comme les r√©initialisations de mot de passe qui fonctionnent en envoyant un JWT par e-mail - ceux-ci peuvent √™tre ignor√©s en toute s√©curit√©.

Les applications stockent souvent un certain √©tat dans la session utilisateur. Celles-ci sont souvent quelque peu prot√©g√©es contre les sous-√©tats - plus de d√©tails √† venir.

* **Modifions-nous ou ajoutons-nous ?**

Les op√©rations qui modifient des donn√©es existantes (telles que le changement de l'adresse e-mail principale d'un compte) ont un potentiel de collision important, tandis que les actions qui ajoutent simplement √† des donn√©es existantes (telles que l'ajout d'une adresse e-mail suppl√©mentaire) sont peu susceptibles d'√™tre vuln√©rables √† autre chose que des attaques de d√©passement de limite.

* **Sur quoi l'op√©ration est-elle bas√©e ?**

La plupart des points de terminaison op√®rent sur un enregistrement sp√©cifique, qui est recherch√© √† l'aide d'une 'cl√©', telle qu'un nom d'utilisateur, un jeton de r√©initialisation de mot de passe ou un nom de fichier. Pour une attaque r√©ussie, nous avons besoin de deux op√©rations qui utilisent la m√™me cl√©. Par exemple, imaginez deux impl√©mentations plausibles de r√©initialisation de mot de passe :

<figure><img src="../.gitbook/assets/image (2) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

2. **Chercher des indices**

√Ä ce stade, il est temps de **lancer des attaques RC** sur les points de terminaison potentiellement int√©ressants pour essayer de trouver des r√©sultats inattendus par rapport aux r√©sultats habituels. **Tout √©cart par rapport √† la r√©ponse attendue**, comme un changement dans une ou plusieurs r√©ponses, ou un effet secondaire comme un contenu d'e-mail diff√©rent ou un changement visible dans votre session, pourrait √™tre un indice indiquant que quelque chose ne va pas.

3. **Prouver le concept**

La derni√®re √©tape consiste √† **prouver le concept et √† le transformer en une attaque viable**.

Lorsque vous envoyez un lot de requ√™tes, vous pouvez constater qu'une paire de requ√™tes initiales d√©clenche un √©tat final vuln√©rable, mais que les requ√™tes ult√©rieures l'√©crasent/l'invalident et que l'√©tat final n'est pas exploitable. Dans ce sc√©nario, vous voudrez √©liminer toutes les requ√™tes inutiles - deux devraient suffire pour exploiter la plupart des vuln√©rabilit√©s. Cependant, r√©duire √† deux requ√™tes rendra l'attaque plus sensible au timing, vous devrez donc peut-√™tre r√©essayer l'attaque plusieurs fois ou l'automatiser.

### Attaques sensibles au temps

Parfois, vous ne trouverez peut-√™tre pas de conditions de concurrence, mais les **techniques pour envoyer des requ√™tes avec un timing pr√©cis** peuvent encore r√©v√©ler la pr√©sence d'autres vuln√©rabilit√©s.

Un tel exemple est lorsque des **horodatages de haute r√©solution sont utilis√©s au lieu de cha√Ænes al√©atoires cryptographiquement** s√©curis√©es pour g√©n√©rer des jetons de s√©curit√©.

Consid√©rez un **jeton de r√©initialisation de mot de passe qui est seulement randomis√© en utilisant un horodatage**. Dans ce cas, il pourrait √™tre possible de **d√©clencher deux r√©initialisations de mot de passe pour deux utilisateurs diff√©rents**, qui utilisent tous les deux le **m√™me jeton**. Tout ce que vous avez √† faire est de synchroniser les requ√™tes pour qu'elles g√©n√®rent le m√™me horodatage.

{% hint style="warning" %}
Pour confirmer par exemple la situation pr√©c√©dente, vous pourriez simplement demander **2 jetons de r√©initialisation de mot de passe en m√™me temps** (en utilisant une attaque par paquet unique) et v√©rifier s'ils sont les **m√™mes**.
{% endhint %}

V√©rifiez [**l'exemple dans ce laboratoire**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-exploiting-time-sensitive-vulnerabilities).

## √âtudes de cas de sous-√©tats cach√©s

### Payer & ajouter un article

[**V√©rifiez ce laboratoire**](https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-insufficient-workflow-validation) pour voir comment **payer** dans un magasin et **ajouter un article suppl√©mentaire** que vous **n'aurez pas √† payer**.

### Confirmer d'autres e-mails

L'id√©e est de **v√©rifier une adresse e-mail et de la changer pour une autre en m√™me temps** pour d√©couvrir si la plateforme v√©rifie la nouvelle qui a √©t√© chang√©e.

### Changer d'e-mail en 2 adresses e-mail bas√©es sur les cookies

Selon [**ce compte-rendu**](https://portswigger.net/research/smashing-the-state-machine), Gitlab √©tait vuln√©rable √† une prise de contr√¥le de cette mani√®re car il pourrait **envoyer** le **jeton de v√©rification d'e-mail d'un e-mail √† l'autre e-mail**.

Vous pouvez √©galement v√©rifier [**ce laboratoire**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-single-endpoint) pour en savoir plus √† ce sujet.

### √âtats de base de donn√©es cach√©s / Contournement de confirmation

Si **2 √©critures diff√©rentes** sont utilis√©es pour **ajouter** des **informations** dans une **base de donn√©es**, il existe une petite portion de temps o√π **seules les premi√®res donn√©es ont √©t√© √©crites** dans la base de donn√©es. Par exemple, lors de la cr√©ation d'un utilisateur, le **nom d'utilisateur** et le **mot de passe** pourraient √™tre **√©crits** et **ensuite le jeton** pour confirmer le compte nouvellement cr√©√© est √©crit. Cela signifie que pendant un court moment, le **jeton pour confirmer un compte est nul**.

Par cons√©quent, **enregistrer un compte et envoyer plusieurs requ√™tes avec un jeton vide** (`token=` ou `token[]=` ou toute autre variation) pour confirmer le compte imm√©diatement pourrait permettre de **confirmer un compte** o√π vous ne contr√¥lez pas l'e-mail.

V√©rifiez [**ce laboratoire**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-partial-construction) pour voir un exemple.

### Contourner le 2FA

Le pseudo-code suivant montre comment un site Web pourrait √™tre vuln√©rable √† une variation de course de cette attaque :
```python
session['userid'] = user.userid
if user.mfa_enabled:
session['enforce_mfa'] = True
# generate and send MFA code to user
# redirect browser to MFA code entry form
```
Comme vous pouvez le voir, il s'agit en fait d'une **s√©quence multi-√©tapes dans la dur√©e d'une seule requ√™te**. Plus important encore, elle passe par un sous-√©tat dans lequel l'**utilisateur a temporairement une session valide connect√©e**, **mais l'authentification multifacteur n'est pas encore appliqu√©e**. Un attaquant pourrait potentiellement exploiter cela en envoyant une demande de connexion avec une demande √† un point de terminaison sensible et authentifi√©.

### Persistance √©ternelle OAuth2

Il existe plusieurs [**fournisseurs OAuth**](https://en.wikipedia.org/wiki/List_of_OAuth_providers). Ces services vous permettent de cr√©er une application et d'authentifier les utilisateurs que le fournisseur a enregistr√©s. Pour ce faire, le **client** devra **autoriser votre application** √† acc√©der √† certaines de leurs donn√©es √† l'int√©rieur du **fournisseur OAuth**.\
Jusqu'ici, juste une connexion classique avec google/linkdin/github... o√π une page s'affiche disant : "_L'application \<InsertCoolName> souhaite acc√©der √† vos informations, voulez-vous l'autoriser ?_"

#### Condition de concurrence dans `authorization_code`

Le **probl√®me** appara√Æt lorsque vous **l'acceptez** et qu'un **`authorization_code`** est automatiquement envoy√© √† l'application malveillante. Ensuite, cette **application abuse d'une condition de concurrence dans le fournisseur de services OAuth pour g√©n√©rer plus d'un AT/RT** (_Token d'Authentification/Token de Rafra√Æchissement_) √† partir du **`authorization_code`** pour votre compte. En gros, elle abuse du fait que vous avez accept√© l'application pour acc√©der √† vos donn√©es pour **cr√©er plusieurs comptes**. Ensuite, si vous **arr√™tez d'autoriser l'application √† acc√©der √† vos donn√©es, une paire d'AT/RT sera supprim√©e, mais les autres resteront valides**.

#### Condition de concurrence dans `Refresh Token`

Une fois que vous avez **obtenu un RT valide**, vous pourriez essayer de **l'abuser pour g√©n√©rer plusieurs AT/RT** et **m√™me si l'utilisateur annule les permissions** pour que l'application malveillante acc√®de √† ses donn√©es, **plusieurs RT resteront valides**.

## **RC dans WebSockets**

Dans [**WS_RaceCondition_PoC**](https://github.com/redrays-io/WS_RaceCondition_PoC), vous pouvez trouver un PoC en Java pour envoyer des messages websocket en **parall√®le** pour abuser des **conditions de concurrence √©galement dans les Web Sockets**.

## R√©f√©rences

* [https://hackerone.com/reports/759247](https://hackerone.com/reports/759247)
* [https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html](https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html)
* [https://hackerone.com/reports/55140](https://hackerone.com/reports/55140)
* [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
* [https://portswigger.net/web-security/race-conditions](https://portswigger.net/web-security/race-conditions)

<details>

<summary><strong>Apprenez le hacking AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Autres moyens de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop)!
* Obtenez le [**merchandising officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**La Famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection d'[**NFTs**](https://opensea.io/collection/the-peass-family) exclusifs
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Partagez vos astuces de hacking en soumettant des PR aux d√©p√¥ts github** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Utilisez [**Trickest**](https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks) pour construire et **automatiser des workflows** gr√¢ce aux outils communautaires **les plus avanc√©s**.\
Obtenez l'acc√®s aujourd'hui :

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}
