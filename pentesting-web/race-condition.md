# Ανταγωνιστική Κατάσταση (Race Condition)

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Χρησιμοποιήστε το [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) για να δημιουργήσετε και να αυτοματοποιήσετε εργασιακές διαδικασίες με τα πιο προηγμένα εργαλεία της κοινότητας.\
Αποκτήστε πρόσβαση σήμερα:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>Μάθετε το hacking του AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι για να υποστηρίξετε το HackTricks:

* Αν θέλετε να δείτε την εταιρεία σας να διαφημίζεται στο HackTricks ή να κατεβάσετε το HackTricks σε μορφή PDF, ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**την Οικογένεια PEASS**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Εγγραφείτε στη** 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στη [**ομάδα telegram**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Μοιραστείτε τα κόλπα σας στο hacking υποβάλλοντας PRs στα** [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) αποθετήρια του github.

</details>

{% hint style="warning" %}
Για να αποκτήσετε μια βαθιά κατανόηση αυτής της τεχνικής, ελέγξτε την αρχική αναφορά στο [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
{% endhint %}

## Ενισχύοντας τις Επιθέσεις Ανταγωνιστικής Κατάστασης

Ο κύριος εμπόδιος για την εκμετάλλευση των ανταγωνιστικών καταστάσεων είναι να διασφαλιστεί ότι πολλαπλά αιτήματα χειρίζονται ταυτόχρονα, με **πολύ μικρή διαφορά στους χρόνους επεξεργασίας τους - ιδανικά, λιγότερο από 1ms**.

Εδώ μπορείτε να βρείτε μερικές τεχνικές για τον συγχρονισμό των αιτημάτων:

#### Επίθεση με μονό πακέτο HTTP/2 έναντι Συγχρονισμού Τελευταίου Byte HTTP/1.1

- **HTTP/2**: Υποστηρίζει την αποστολή δύο αιτημάτων μέσω μιας μόνο σύνδεσης TCP, μειώνοντας την επίδραση της αστάθειας του δικτύου. Ωστόσο, λόγω ποικίλων παραλλαγών στην πλευρά του διακομιστή, δύο αιτήματα ενδέχεται να μην επαρκούν για μια συνεπή εκμετάλλευση ανταγωνιστικής κατάστασης.
- **Συγχρονισμός Τελευταίου Byte HTTP/1.1**: Επιτρέπει την προαποστολή του μεγαλύτερου μέρους των 20-30 αιτημάτων, κρατώντας ένα μικρό απόσπασμα που στέλνεται μαζί, επιτυγχάνοντας την ταυτόχρονη άφιξή τους στον διακομιστή.

Η **προετοιμασία για τον Συγχρονισμό Τελευταίου Byte** περιλαμβάνει:
1. Αποστολή κεφαλίδων και δεδομένων σώματος χωρίς το τελευταίο byte χωρίς να τερματίζεται η ροή.
2. Παύση για 100ms μετά την αρχική αποστολή.
3. Απενεργοποίηση του TCP_NODELAY για τη χρήση του αλγορίθμου Nagle για την ομαδοποίηση των τελικών πλαισίων.
4. Αποστολή ping για προθέρμανση της σύνδεσης.

Η επόμενη αποστολή των παρακρατημένων πλαισίων θα πρέπει να οδηγήσει στην άφιξή τους σε ένα μόνο πακέτο, που μπορεί να επαληθευτεί μέσω του Wireshark. Αυτή η μέθοδος δεν ισχύει για στατικά αρχεία, τα οποία συνήθως δεν εμπλέκονται σε επιθέσεις ανταγωνιστικής κατάστασης.

### Προσαρμογή στην Αρχιτεκτονική του Διακομιστή

Η κατανόηση της αρχιτεκτονικής του στόχου είναι κρίσιμη. Οι διακομιστές προσκείμενοι στο μπροστινό μέρος μπορεί να δρομολογούν αιτήματα με διαφορετικό τρόπο, επηρεάζοντας τον χρόνο. Η προεντατική προθέρμανση της σύνδεσης από την πλευρά του διακομιστή, μέσω ασήμαντων αιτημάτων, μπορεί να κανονικοποιήσει τον χρόνο των αιτημάτων.

#### Χειρισμός Κλειδώματος βάσει Συνεδρίας

Πλαίσια όπως το session handler της PHP σειριοποιούν τα αιτήματα ανά συνεδρία, παραμορφώνοντας πιθανώς τις ευπάθειες.
```python
passwords = wordlists.clipboard
for password in passwords:
engine.queue(target.req, password, gate='race1')
```
{% hint style="warning" %}
Εάν ο ιστότοπος δεν υποστηρίζει HTTP2 (μόνο HTTP1.1), χρησιμοποιήστε το `Engine.THREADED` ή το `Engine.BURP` αντί για το `Engine.BURP2`.
{% endhint %}

* **Tubo Intruder - Επίθεση με μονοπακέτο HTTP2 (Πολλά endpoints)**: Στην περίπτωση που χρειάζεστε να στείλετε ένα αίτημα σε ένα endpoint και στη συνέχεια πολλά σε άλλα endpoints για να ενεργοποιήσετε το RCE, μπορείτε να αλλάξετε το σενάριο `race-single-packet-attack.py` με κάτι όπως:
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=1,
engine=Engine.BURP2
)

# Hardcode the second request for the RC
confirmationReq = '''POST /confirm?token[]= HTTP/2
Host: 0a9c00370490e77e837419c4005900d0.web-security-academy.net
Cookie: phpsessionid=MpDEOYRvaNT1OAm0OtAsmLZ91iDfISLU
Content-Length: 0

'''

# For each attempt (20 in total) send 50 confirmation requests.
for attempt in range(20):
currentAttempt = str(attempt)
username = 'aUser' + currentAttempt

# queue a single registration request
engine.queue(target.req, username, gate=currentAttempt)

# queue 50 confirmation requests - note that this will probably sent in two separate packets
for i in range(50):
engine.queue(confirmationReq, gate=currentAttempt)

# send all the queued requests for this attempt
engine.openGate(currentAttempt)
```
* Είναι επίσης διαθέσιμο στο **Repeater** μέσω της νέας επιλογής '**Αποστολή ομάδας παράλληλα**' στο Burp Suite.
* Για το **limit-overrun** μπορείτε απλά να προσθέσετε το **ίδιο αίτημα 50 φορές** στην ομάδα.
* Για το **connection warming**, μπορείτε να **προσθέσετε** στην **αρχή** της **ομάδας** μερικά **αιτήματα** προς κάποιο μη στατικό μέρος του διακομιστή ιστού.
* Για την **καθυστέρηση** της διαδικασίας **μεταξύ** της επεξεργασίας **ενός αιτήματος και ενός άλλου** σε 2 υποκαταστάσεις βήματα, μπορείτε να **προσθέσετε επιπλέον αιτήματα μεταξύ** των δύο αιτημάτων.
* Για ένα **πολυ-τελικό σημείο** RC μπορείτε να ξεκινήσετε την αποστολή του **αιτήματος που πηγαίνει στην κρυφή κατάσταση** και στη συνέχεια **50 αιτήματα** αμέσως μετά που **εκμεταλλεύονται την κρυφή κατάσταση**.

<figure><img src="../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

### Ακατέργαστο BF

Πριν από την προηγούμενη έρευνα, αυτά ήταν μερικά από τα φορτία που χρησιμοποιήθηκαν και απλά προσπάθησαν να στείλουν τα πακέτα όσο το δυνατόν πιο γρήγορα για να προκαλέσουν ένα RC.

* **Repeater:** Ελέγξτε τα παραδείγματα από την προηγούμενη ενότητα.
* **Intruder**: Στείλτε το **αιτημα** στο **Intruder**, ορίστε τον **αριθμό των νημάτων** σε **30** μέσα στο μενού **Επιλογές** και, επιλέξτε ως φορτίο **Κενά φορτία** και δημιουργήστε **30**.
* **Turbo Intruder**
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
pipeline=False
)
a = ['Session=<session_id_1>','Session=<session_id_2>','Session=<session_id_3>']
for i in range(len(a)):
engine.queue(target.req,a[i], gate='race1')
# open TCP connections and send partial requests
engine.start(timeout=10)
engine.openGate('race1')
engine.complete(timeout=60)

def handleResponse(req, interesting):
table.add(req)
```
* **Python - asyncio**

Το asyncio είναι ένα πακέτο της Python που παρέχει μια βιβλιοθήκη για την ανάπτυξη ασύγχρονων (asynchronous) εφαρμογών. Με το asyncio, μπορούμε να γράψουμε κώδικα που εκτελείται παράλληλα και αποτελεσματικά, χωρίς να απαιτείται η δημιουργία πολλαπλών νημάτων.

Η βασική ιδέα πίσω από το asyncio είναι η χρήση των coroutines για την αντιμετώπιση των ασύγχρονων εργασιών. Οι coroutines είναι συναρτήσεις που μπορούν να διακόπτονται και να συνεχίζονται αργότερα, επιτρέποντας την εκτέλεση άλλων εργασιών κατά τη διάρκεια της αναμονής για αποτελέσματα από εξωτερικούς πόρους.

Με το asyncio, μπορούμε να χρησιμοποιήσουμε τις coroutines για να εκτελέσουμε ασύγχρονες εργασίες, όπως αιτήσεις δικτύου, χωρίς να απαιτείται η δημιουργία νέων νημάτων. Αυτό μας επιτρέπει να αξιοποιήσουμε αποτελεσματικά τους πόρους του συστήματος και να αποφύγουμε τον κίνδυνο των συγκρούσεων (race conditions) που μπορεί να προκύψουν από την παράλληλη εκτέλεση πολλαπλών νημάτων.

Για να χρησιμοποιήσουμε το asyncio, πρέπει να ορίσουμε τις ασύγχρονες εργασίες μας ως coroutines και να τις εκτελέσουμε μέσω του event loop. Ο event loop είναι υπεύθυνος για την εκτέλεση των coroutines και την διαχείριση των αποτελεσμάτων τους.

Με τη χρήση του asyncio, μπορούμε να αναπτύξουμε αποδοτικές και αξιόπιστες ασύγχρονες εφαρμογές, εκμεταλλευόμενοι την ισχύ των coroutines και του event loop.
```python
import asyncio
import httpx

async def use_code(client):
resp = await client.post(f'http://victim.com', cookies={"session": "asdasdasd"}, data={"code": "123123123"})
return resp.text

async def main():
async with httpx.AsyncClient() as client:
tasks = []
for _ in range(20): #20 times
tasks.append(asyncio.ensure_future(use_code(client)))

# Get responses
results = await asyncio.gather(*tasks, return_exceptions=True)

# Print results
for r in results:
print(r)

# Async2sync sleep
await asyncio.sleep(0.5)
print(results)

asyncio.run(main())
```
## **Μεθοδολογία RC**

### Υπέρβαση Όριου / TOCTOU

Αυτό είναι το πιο βασικό είδος race condition όπου υπάρχουν ευπάθειες που εμφανίζονται σε μέρη που περιορίζουν τον αριθμό των φορών που μπορείτε να εκτελέσετε μια ενέργεια. Όπως για παράδειγμα να χρησιμοποιήσετε τον ίδιο κωδικό έκπτωσης σε ένα ηλεκτρονικό κατάστημα πολλές φορές. Ένα πολύ εύκολο παράδειγμα μπορεί να βρεθεί σε [αυτήν την αναφορά](https://medium.com/@pravinponnusamy/race-condition-vulnerability-found-in-bug-bounty-program-573260454c43) ή σε [αυτό το bug](https://hackerone.com/reports/759247).

Υπάρχουν πολλές παραλλαγές αυτού του είδους επίθεσης, συμπεριλαμβανομένων:

* Εξαργύρωση ενός κουπονιού δώρου πολλές φορές
* Αξιολόγηση ενός προϊόντος πολλές φορές
* Ανάληψη ή μεταφορά μεγαλύτερου ποσού από το υπόλοιπο του λογαριασμού σας
* Επαναχρησιμοποίηση μιας μόνο λύσης CAPTCHA
* Παράκαμψη ενός όριου ρυθμού αντίδρασης αντι-βίας

### **Κρυφές υποκαταστάσεις**

Η εκμετάλλευση πολύπλοκων race conditions συχνά περιλαμβάνει την αξιοποίηση σύντομων ευκαιριών για αλληλεπίδραση με κρυφές ή μη προσδιορισμένες καταστάσεις της μηχανής. Εδώ είναι πώς να προσεγγίσετε αυτό:

1. **Αναγνωρίστε Πιθανές Κρυφές Υποκαταστάσεις**
- Ξεκινήστε εντοπίζοντας σημεία που τροποποιούν ή αλληλεπιδρούν με κρίσιμα δεδομένα, όπως προφίλ χρηστών ή διαδικασίες επαναφοράς κωδικού πρόσβασης. Επικεντρωθείτε σε:
- **Αποθήκευση**: Προτιμήστε σημεία που χειρίζονται δεδομένα μόνιμα στον διακομιστή αντί αυτών που χειρίζονται δεδομένα στην πλευρά του πελάτη.
- **Ενέργεια**: Αναζητήστε λειτουργίες που τροποποιούν υπάρχοντα δεδομένα, τα οποία είναι πιο πιθανό να δημιουργήσουν εκμεταλλεύσιμες συνθήκες σε σύγκριση με αυτές που προσθέτουν νέα δεδομένα.
- **Κλειδώματα**: Επιτυχημένες επιθέσεις συνήθως περιλαμβάνουν λειτουργίες που βασίζονται στον ίδιο αναγνωριστικό, π.χ. όνομα χρήστη ή διακριτικό επαναφοράς.

2. **Πραγματοποιήστε Αρχική Εξερεύνηση**
- Δοκιμάστε τα εντοπισμένα σημεία με επιθέσεις race condition, παρατηρώντας για οποιεσδήποτε αποκλίσεις από τα αναμενόμενα αποτελέσματα. Απροσδόκητες απαντήσεις ή αλλαγές στη συμπεριφορά της εφαρμογής μπορούν να υποδείξουν μια ευπάθεια.

3. **Αποδείξτε την Ευπάθεια**
- Περιορίστε την επίθεση στον ελάχιστο αριθμό αιτημάτων που απαιτούνται για να εκμεταλλευτείτε την ευπάθεια, συνήθως μόνο δύο. Αυτό το βήμα μπορεί να απαιτήσει πολλαπλές προσπάθειες ή αυτοματοποίηση λόγω της ακριβούς χρονολογίας που εμπλέκεται.

### Επιθέσεις με Ευαισθησία στον Χρόνο

Η ακρίβεια στη χρονολόγηση των αιτημάτων μπορεί να αποκαλύψει ευπάθειες, ειδικά όταν χρησιμοποιούνται προβλέψιμες μεθόδοι όπως οι χρονοσφραγίδες για τα αναγνωριστικά ασφαλείας. Για παράδειγμα, η δημιουργία διακριτικών επαναφοράς κωδικού βάσει των χρονοσφραγίδων μπορεί να επιτρέψει τη χρήση ίδιων διακριτικών για ταυτόχρονα αιτήματα.

**Για Εκμετάλλευση:**
- Χρησιμοποιήστε ακριβή χρονολόγηση, όπως μια επίθεση με ένα μόνο πακέτο, για να κάνετε ταυτόχρονα αιτήματα επαναφοράς κωδικού πρόσβασης. Τα ίδια διακριτικά υποδηλώνουν μια ευπάθεια.

**Παράδειγμα:**
- Ζητήστε δύο διακριτικά επαναφοράς κωδικού πρόσβασης ταυτόχρονα και συγκρίνετέ τα. Αν τα διακριτικά ταιριάζουν, υποδεικνύεται μια αδυναμία στη δημιουργία διακριτικών.

**Ελέγξτε αυτό το [PortSwigger Lab](https://portswigger.net/web-security/race-conditions/lab-race-conditions-exploiting-time-sensitive-vulnerabilities) για να το δοκιμάσετε.**


## Περιπτώσεις με Κρυφές Υποκαταστάσεις

### Πληρωμή & προσθήκη ενός αντικειμένου

Ελέγξτε αυτό το [**PortSwigger Lab**](https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-insufficient-workflow-validation) για να δείτε πώς να πραγματοποιήσετε πληρωμή σε ένα κατάστημα και να
```python
session['userid'] = user.userid
if user.mfa_enabled:
session['enforce_mfa'] = True
# generate and send MFA code to user
# redirect browser to MFA code entry form
```
### Αιώνια διατήρηση OAuth2

Υπάρχουν αρκετοί [**πάροχοι OAuth**](https://en.wikipedia.org/wiki/List\_of\_OAuth\_providers). Αυτές οι υπηρεσίες θα σας επιτρέψουν να δημιουργήσετε μια εφαρμογή και να ελέγξετε την ταυτότητα των χρηστών που έχει εγγράψει ο πάροχος. Για να το κάνετε αυτό, ο **πελάτης** θα χρειαστεί να **επιτρέψει στην εφαρμογή σας** να έχει πρόσβαση σε μερικά από τα δεδομένα του μέσα στον **πάροχο OAuth**.\
Έτσι, μέχρι εδώ απλά μια κοινή σύνδεση με google/linkedin/github... όπου σας ζητείται σε μια σελίδα: "_Η εφαρμογή \<InsertCoolName> θέλει πρόσβαση στα δεδομένα σας, θέλετε να το επιτρέψετε;_"

#### Αγωνία Κατάστασης στο `authorization_code`

Το **πρόβλημα** προκύπτει όταν το **αποδεχθείτε** και αυτόματα στέλνει ένα **`authorization_code`** στην κακόβουλη εφαρμογή. Στη συνέχεια, αυτή η **εφαρμογή καταχράται μια Αγωνία Κατάστασης στον πάροχο υπηρεσίας OAuth για να δημιουργήσει περισσότερα από ένα AT/RT** (_Authentication Token/Refresh Token_) από το **`authorization_code`** για τον λογαριασμό σας. Βασικά, θα καταχραστεί το γεγονός ότι έχετε αποδεχθεί την εφαρμογή για να έχει πρόσβαση στα δεδομένα σας για να **δημιουργήσει πολλούς λογαριασμούς**. Στη συνέχεια, αν **σταματήσετε να επιτρέπετε στην εφαρμογή να έχει πρόσβαση στα δεδομένα σας, ένα ζευγάρι AT/RT θα διαγραφεί, αλλά οι άλλοι θα παραμείνουν έγκυροι**.

#### Αγωνία Κατάστασης στο `Refresh Token`

Αφού έχετε **αποκτήσει ένα έγκυρο RT** μπορείτε να προσπαθήσετε να το **καταχραστείτε για να δημιουργήσετε πολλά AT/RT** και **ακόμα κι αν ο χρήστης ακυρώσει τις άδειες** για την κακόβουλη εφαρμογή να έχει πρόσβαση στα δεδομένα του, **πολλά RT θα παραμείνουν έγκυρα**.

## **Αγωνία Κατάστασης στα WebSockets**

Στο [**WS\_RaceCondition\_PoC**](https://github.com/redrays-io/WS\_RaceCondition\_PoC) μπορείτε να βρείτε ένα PoC σε Java για να στείλετε μηνύματα websocket **παράλληλα** για να καταχραστείτε **Αγωνίες Κατάστασης επίσης στα Web Sockets**.

## Αναφορές

* [https://hackerone.com/reports/759247](https://hackerone.com/reports/759247)
* [https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html](https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html)
* [https://hackerone.com/reports/55140](https://hackerone.com/reports/55140)
* [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
* [https://portswigger.net/web-security/race-conditions](https://portswigger.net/web-security/race-conditions)

<details>

<summary><strong>Μάθετε το χάκινγκ του AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι για να υποστηρίξετε το HackTricks:

* Αν θέλετε να δείτε την **εταιρεία σας να διαφημίζεται στο HackTricks** ή να **κατεβάσετε το HackTricks σε μορφή PDF** ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**The PEASS Family**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Εγγραφείτε στην** 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στην [**ομάδα telegram**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Μοιραστείτε τα χάκινγκ κόλπα σας υποβάλλοντας PRs** στα αποθετήρια του [**HackTricks**](https://github.com/carlospolop/hacktricks) και του [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) στο github.

</details>

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Χρησιμοποιήστε το [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) για να δημιουργήσετε και να **αυτοματοποιήσετε ροές εργασίας** με τα πιο προηγμένα εργαλεία της κοινότητας.\
Αποκτήστε πρόσβαση σήμερα:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}
