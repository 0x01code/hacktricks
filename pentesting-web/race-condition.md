# Condici√≥n de Carrera

<figure><img src="../.gitbook/assets/image (3) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Utiliza [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) para construir y **automatizar flujos de trabajo** con las herramientas comunitarias **m√°s avanzadas** del mundo.\
Obt√©n Acceso Hoy:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* ¬øTrabajas en una **empresa de ciberseguridad**? ¬øQuieres ver a tu **empresa anunciada en HackTricks**? o ¬øquieres acceder a la **√∫ltima versi√≥n de PEASS o descargar HackTricks en PDF**? Consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* Consigue el [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* **√önete al** [**üí¨**](https://emojipedia.org/speech-balloon/) [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠gueme** en **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Comparte tus trucos de hacking enviando PRs al** [**repositorio de hacktricks**](https://github.com/carlospolop/hacktricks) **y al** [**repositorio de hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## Explotando RC

El principal problema al abusar de RC es que necesitas que las solicitudes se procesen en paralelo con una diferencia de tiempo muy corta (usualmente >1ms). En la siguiente secci√≥n, se proponen diferentes soluciones para hacer esto posible.

<figure><img src="../.gitbook/assets/image (5) (1).png" alt=""><figcaption></figcaption></figure>

### Ataque de un solo paquete (HTTP/2) / Sincronizaci√≥n del √∫ltimo byte (HTTP/1.1)

HTTP2 permite enviar **2 solicitudes en una sola conexi√≥n TCP** (mientras que en HTTP/1.1 tienen que ser secuenciales).\
El uso de un solo paquete TCP **elimina completamente el efecto del jitter de red**, por lo que esto claramente tiene potencial para ataques de condici√≥n de carrera tambi√©n. Sin embargo, **dos solicitudes no son suficientes para un ataque de carrera fiable** debido al **jitter del lado del servidor** - variaciones en el tiempo de procesamiento de solicitudes de la aplicaci√≥n causadas por variables incontrolables como la contenci√≥n de CPU.

Pero, utilizando la t√©cnica de '**sincronizaci√≥n del √∫ltimo byte**' de HTTP/1.1 es posible pre-enviar la mayor parte de los datos reteniendo un fragmento peque√±o de cada solicitud y luego 'completar' **20-30 solicitudes con un solo paquete TCP**.

Para **pre-enviar la mayor parte de cada solicitud**:

* Si la solicitud no tiene cuerpo, env√≠a todos los encabezados, pero no establezcas la bandera END\_STREAM. Ret√©n un marco de datos vac√≠o con END\_STREAM establecido.
* Si la solicitud tiene un cuerpo, env√≠a los encabezados y todos los datos del cuerpo excepto el √∫ltimo byte. Ret√©n un marco de datos que contenga el √∫ltimo byte.

A continuaci√≥n, **prep√°rate para enviar los marcos finales**:

* Espera 100ms para asegurarte de que los marcos iniciales han sido enviados.
* Aseg√∫rate de que TCP\_NODELAY est√© desactivado - es crucial que el algoritmo de Nagle agrupe los marcos finales.
* Env√≠a un paquete ping para calentar la conexi√≥n local. Si no haces esto, la pila de red del SO colocar√° el primer marco final en un paquete separado.

Finalmente, env√≠a los marcos retenidos. Deber√≠as poder verificar que aterrizaron en un solo paquete usando Wireshark.

{% hint style="info" %}
Nota que **no funciona para archivos est√°ticos** en ciertos servidores, pero los archivos est√°ticos son irrelevantes para ataques de RC.
{% endhint %}

Utilizando esta t√©cnica, puedes hacer que 20-30 solicitudes lleguen al servidor simult√°neamente - independientemente del jitter de red:

<figure><img src="../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

**Adapt√°ndose a la arquitectura del objetivo**

Es importante notar que muchas aplicaciones est√°n detr√°s de un servidor frontal, y estos pueden decidir reenviar algunas solicitudes a trav√©s de conexiones existentes al back-end, y crear nuevas conexiones para otras.

Como resultado, es importante no atribuir tiempos de solicitud inconsistentes al comportamiento de la aplicaci√≥n, como mecanismos de bloqueo que solo permiten que un solo hilo acceda a un recurso a la vez. Adem√°s, el enrutamiento de solicitudes del front-end a menudo se hace en base a una conexi√≥n por conexi√≥n, por lo que puedes ser capaz de suavizar el tiempo de las solicitudes realizando un calentamiento de conexi√≥n del lado del servidor - **enviando algunas solicitudes inconsecuentes por tu conexi√≥n antes de realizar el ataque** (esto es solo enviar varias solicitudes antes de comenzar el ataque real).

#### Mecanismos de bloqueo basados en sesi√≥n <a href="#session-based-locking-mechanisms" id="session-based-locking-mechanisms"></a>

Algunos frameworks intentan prevenir la corrupci√≥n accidental de datos utilizando alguna forma de **bloqueo de solicitudes**. Por ejemplo, el m√≥dulo de **manejador de sesiones nativo de PHP** solo procesa **una solicitud por sesi√≥n a la vez**.

Es extremadamente importante detectar este tipo de comportamiento ya que de lo contrario puede ocultar vulnerabilidades trivialmente explotables. Si notas que todas tus solicitudes se est√°n procesando secuencialmente, intenta enviar cada una de ellas utilizando un token de sesi√≥n diferente.

#### **Abusando de l√≠mites de tasa o recursos**

Si el calentamiento de la conexi√≥n no hace ninguna diferencia, hay varias soluciones a este problema.

Usando Turbo Intruder, puedes introducir un corto retraso del lado del cliente. Sin embargo, como esto implica dividir tus solicitudes de ataque reales en m√∫ltiples paquetes TCP, no podr√°s utilizar la t√©cnica de ataque de un solo paquete. Como resultado, en objetivos con alto jitter, el ataque es poco probable que funcione de manera fiable independientemente del retraso que establezcas.

<figure><img src="../.gitbook/assets/image (2) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

En cambio, puedes ser capaz de resolver este problema abusando de una caracter√≠stica de seguridad com√∫n.

Los servidores web a menudo **retrasan el procesamiento de solicitudes si se env√≠an demasiadas demasiado r√°pido**. Al enviar un gran n√∫mero de solicitudes ficticias para desencadenar intencionalmente el l√≠mite de tasa o recursos, puedes ser capaz de causar un retraso adecuado del lado del servidor. Esto hace que el ataque de un solo paquete sea viable incluso cuando se requiere una ejecuci√≥n retrasada.

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

{% hint style="warning" %}
Para m√°s informaci√≥n sobre esta t√©cnica consulta el informe original en [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
{% endhint %}

#### Ejemplos de Ataque

* **Tubo Intruder - Ataque de un solo paquete HTTP2 (1 endpoint)**: Puedes enviar la solicitud a **Turbo intruder** (`Extensions` -> `Turbo Intruder` -> `Send to Turbo Intruder`), puedes cambiar en la solicitud el valor que quieres forzar bruscamente para **`%s`** como en `csrf=Bn9VQB8OyefIs3ShR2fPESR0FzzulI1d&username=carlos&password=%s` y luego seleccionar el **`examples/race-single-packer-attack.py`** del men√∫ desplegable:

<figure><img src="../.gitbook/assets/image (4) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Si vas a **enviar diferentes valores**, podr√≠as modificar el c√≥digo con este que usa una lista de palabras del portapapeles:
```python
passwords = wordlists.clipboard
for password in passwords:
engine.queue(target.req, password, gate='race1')
```
{% hint style="warning" %}
Si la web no soporta HTTP2 (solo HTTP1.1) usa `Engine.THREADED` o `Engine.BURP` en lugar de `Engine.BURP2`.
{% endhint %}

* **Tubo Intruder - Ataque de paquete √∫nico HTTP2 (Varios endpoints)**: En caso de que necesites enviar una solicitud a 1 endpoint y luego varias a otros endpoints para activar el RCE, puedes modificar el script `race-single-packet-attack.py` con algo como:
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=1,
engine=Engine.BURP2
)

# Hardcode the second request for the RC
confirmationReq = '''POST /confirm?token[]= HTTP/2
Host: 0a9c00370490e77e837419c4005900d0.web-security-academy.net
Cookie: phpsessionid=MpDEOYRvaNT1OAm0OtAsmLZ91iDfISLU
Content-Length: 0

'''

# For each attempt (20 in total) send 50 confirmation requests.
for attempt in range(20):
currentAttempt = str(attempt)
username = 'aUser' + currentAttempt

# queue a single registration request
engine.queue(target.req, username, gate=currentAttempt)

# queue 50 confirmation requests - note that this will probably sent in two separate packets
for i in range(50):
engine.queue(confirmationReq, gate=currentAttempt)

# send all the queued requests for this attempt
engine.openGate(currentAttempt)
```
* Tambi√©n est√° disponible en **Repeater** a trav√©s de la nueva opci√≥n '**Enviar grupo en paralelo**' en Burp Suite.
* Para **limit-overrun** podr√≠as simplemente a√±adir **la misma solicitud 50 veces** en el grupo.
* Para **connection warming**, podr√≠as **a√±adir** al **principio** del **grupo** algunas **solicitudes** a alguna parte no est√°tica del servidor web.
* Para **retrasar** el proceso **entre** el procesamiento de **una solicitud y otra** en pasos de 2 subestados, podr√≠as **a√±adir solicitudes extra entre** ambas solicitudes.
* Para un RC de **multi-endpoint** podr√≠as empezar enviando la **solicitud** que **va al estado oculto** y luego **50 solicitudes** justo despu√©s que **explotan el estado oculto**.

<figure><img src="../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

### Raw BF

Antes de la investigaci√≥n previa, estos eran algunos payloads utilizados que simplemente intentaban enviar los paquetes lo m√°s r√°pido posible para causar un RC.

* **Repeater:** Revisa los ejemplos de la secci√≥n anterior.
* **Intruder**: Env√≠a la **solicitud** a **Intruder**, establece el **n√∫mero de hilos** a **30** dentro del **men√∫ de Opciones y,** selecciona como payload **Null payloads** y genera **30.**
* **Turbo Intruder**
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
pipeline=False
)
a = ['Session=<session_id_1>','Session=<session_id_2>','Session=<session_id_3>']
for i in range(len(a)):
engine.queue(target.req,a[i], gate='race1')
# open TCP connections and send partial requests
engine.start(timeout=10)
engine.openGate('race1')
engine.complete(timeout=60)

def handleResponse(req, interesting):
table.add(req)
```
* **Python - asyncio**
```python
import asyncio
import httpx

async def use_code(client):
resp = await client.post(f'http://victim.com', cookies={"session": "asdasdasd"}, data={"code": "123123123"})
return resp.text

async def main():
async with httpx.AsyncClient() as client:
tasks = []
for _ in range(20): #20 times
tasks.append(asyncio.ensure_future(use_code(client)))

# Get responses
results = await asyncio.gather(*tasks, return_exceptions=True)

# Print results
for r in results:
print(r)

# Async2sync sleep
await asyncio.sleep(0.5)
print(results)

asyncio.run(main())
```
## **Metodolog√≠a RC**

### Exceso de l√≠mite / TOCTOU

Este es el tipo m√°s b√°sico de condici√≥n de carrera donde las **vulnerabilidades** que **aparecen** en lugares que **limitan el n√∫mero de veces que puedes realizar una acci√≥n**. Como usar el mismo c√≥digo de descuento varias veces en una tienda web. Un ejemplo muy f√°cil se puede encontrar en [**este informe**](https://medium.com/@pravinponnusamy/race-condition-vulnerability-found-in-bug-bounty-program-573260454c43) o en [**este bug**](https://hackerone.com/reports/759247)**.**

Hay muchas variaciones de este tipo de ataque, incluyendo:

* Canjear una tarjeta de regalo varias veces
* Valorar un producto varias veces
* Retirar o transferir efectivo en exceso del saldo de tu cuenta
* Reutilizar una √∫nica soluci√≥n CAPTCHA
* Evitar un l√≠mite de tasa anti-fuerza bruta

### **Subestados ocultos**

Otros RC m√°s complicados explotar√°n **subestados en el estado de la m√°quina** que podr√≠an permitir a un atacante **abusar** de estados a los que **nunca se supon√≠a que tuviera acceso**, pero hay una **peque√±a ventana** para que el atacante acceda a √©l.

1. **Predecir subestados ocultos e interesantes potenciales**

El primer paso es identificar todos los puntos finales que escriben en √©l o leen datos de √©l y luego usan esos datos para algo importante. Por ejemplo, los usuarios pueden almacenarse en una tabla de base de datos que es modificada por el registro, ediciones de perfil, inicio de restablecimiento de contrase√±a y finalizaci√≥n de restablecimiento de contrase√±a.

Podemos usar tres preguntas clave para descartar puntos finales que probablemente no causen colisiones. Para cada objeto y los puntos finales asociados, preg√∫ntate:

* **¬øC√≥mo se almacena el estado?**

Los datos almacenados en una estructura de datos persistente del lado del servidor son ideales para la explotaci√≥n. Algunos puntos finales almacenan su estado completamente del lado del cliente, como los restablecimientos de contrase√±a que funcionan enviando un JWT por correo electr√≥nico; estos se pueden omitir con seguridad.

Las aplicaciones a menudo almacenan alg√∫n estado en la sesi√≥n del usuario. Estos a menudo est√°n algo protegidos contra subestados - m√°s sobre eso m√°s adelante.

* **¬øEstamos editando o a√±adiendo?**

Las operaciones que editan datos existentes (como cambiar la direcci√≥n de correo electr√≥nico principal de una cuenta) tienen un amplio potencial de colisi√≥n, mientras que las acciones que simplemente se a√±aden a los datos existentes (como agregar una direcci√≥n de correo electr√≥nico adicional) probablemente no sean vulnerables a nada m√°s que ataques de exceso de l√≠mite.

* **¬øEn qu√© est√° basada la operaci√≥n?**

La mayor√≠a de los puntos finales operan sobre un registro espec√≠fico, que se busca utilizando una 'clave', como un nombre de usuario, token de restablecimiento de contrase√±a o nombre de archivo. Para un ataque exitoso, necesitamos dos operaciones que usen la misma clave. Por ejemplo, imagina dos implementaciones plausibles de restablecimiento de contrase√±a:

<figure><img src="../.gitbook/assets/image (2) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

2. **Buscar pistas**

En este punto es hora de **lanzar algunos ataques RC** sobre los puntos finales potencialmente interesantes para tratar de encontrar resultados inesperados en comparaci√≥n con los regulares. **Cualquier desviaci√≥n de la respuesta esperada**, como un cambio en una o m√°s respuestas, o un efecto secundario como diferentes contenidos de correo electr√≥nico o un cambio visible en tu sesi√≥n, podr√≠a ser una pista que indica que algo est√° mal.

3. **Probar el concepto**

El paso final es **probar el concepto y convertirlo en un ataque viable**.

Cuando env√≠as un lote de solicitudes, puedes encontrar que un par de solicitudes tempranas desencadenan un estado final vulnerable, pero las solicitudes posteriores lo sobrescriben/invalidan y el estado final es inexplotable. En este escenario, querr√°s eliminar todas las solicitudes innecesarias: dos deber√≠an ser suficientes para explotar la mayor√≠a de las vulnerabilidades. Sin embargo, reducir a dos solicitudes har√° que el ataque sea m√°s sensible al tiempo, por lo que es posible que necesites repetir el ataque varias veces o automatizarlo.

### Ataques Sensibles al Tiempo

A veces es posible que no encuentres condiciones de carrera, pero las **t√©cnicas para entregar solicitudes con un tiempo preciso** a√∫n pueden revelar la presencia de otras vulnerabilidades.

Un ejemplo es cuando se utilizan **marcas de tiempo de alta resoluci√≥n en lugar de cadenas aleatorias seguras criptogr√°ficamente** para generar tokens de seguridad.

Considera un **token de restablecimiento de contrase√±a que solo se aleatoriza usando una marca de tiempo**. En este caso, podr√≠a ser posible **desencadenar dos restablecimientos de contrase√±a para dos usuarios diferentes**, que ambos usen el **mismo token**. Todo lo que necesitas hacer es cronometrar las solicitudes para que generen la misma marca de tiempo.

{% hint style="warning" %}
Para confirmar, por ejemplo, la situaci√≥n anterior, podr√≠as simplemente pedir **2 tokens de restablecimiento de contrase√±a al mismo tiempo** (usando ataque de paquete √∫nico) y verificar si son **iguales**.
{% endhint %}

Revisa el [**ejemplo en este laboratorio**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-exploiting-time-sensitive-vulnerabilities).

## Estudios de caso de subestados ocultos

### Pagar y a√±adir un art√≠culo

[**Revisa este laboratorio**](https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-insufficient-workflow-validation) para ver c√≥mo **pagar** en una tienda y **a√±adir un art√≠culo extra** que **no necesitar√°s pagar**.

### Confirmar otros correos electr√≥nicos

La idea es **verificar una direcci√≥n de correo electr√≥nico y cambiarla por otra diferente al mismo tiempo** para averiguar si la plataforma verifica la nueva cambiada.

### Cambiar correo electr√≥nico a 2 direcciones de correo electr√≥nico basado en Cookie

Seg√∫n [**este informe**](https://portswigger.net/research/smashing-the-state-machine) Gitlab era vulnerable a una toma de control de esta manera porque podr√≠a **enviar** el **token de verificaci√≥n de correo electr√≥nico de un correo a otro**.

Tambi√©n puedes revisar [**este laboratorio**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-single-endpoint) para aprender sobre esto.

### Estados ocultos de la base de datos / Evitar la confirmaci√≥n

Si se utilizan **2 escrituras diferentes** para **a√±adir informaci√≥n** dentro de una **base de datos**, hay una peque√±a porci√≥n de tiempo donde **solo se ha escrito el primer dato** dentro de la base de datos. Por ejemplo, al crear un usuario, el **nombre de usuario** y la **contrase√±a** podr√≠an ser **escritos** y **luego el token** para confirmar la cuenta reci√©n creada se escribe. Esto significa que por un peque√±o tiempo el **token para confirmar una cuenta es nulo**.

Por lo tanto, **registrar una cuenta y enviar varias solicitudes con un token vac√≠o** (`token=` o `token[]=` o cualquier otra variaci√≥n) para confirmar la cuenta de inmediato podr√≠a permitir **confirmar una cuenta** donde no controlas el correo electr√≥nico.

Revisa [**este laboratorio**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-partial-construction) para ver un ejemplo.

### Evitar 2FA

El siguiente pseudo-c√≥digo demuestra c√≥mo un sitio web podr√≠a ser vulnerable a una variaci√≥n de ataque de carrera de esta manera:
```python
session['userid'] = user.userid
if user.mfa_enabled:
session['enforce_mfa'] = True
# generate and send MFA code to user
# redirect browser to MFA code entry form
```
Como puedes ver, esto es de hecho una **secuencia de varios pasos dentro del lapso de una sola solicitud**. Lo m√°s importante es que pasa por un subestado en el que el **usuario temporalmente tiene una sesi√≥n v√°lida iniciada**, **pero la MFA a√∫n no se est√° aplicando**. Un atacante podr√≠a potencialmente explotar esto enviando una solicitud de inicio de sesi√≥n junto con una solicitud a un punto final sensible y autenticado.

### Persistencia eterna de OAuth2

Hay varios [**proveedores de OAuth**](https://en.wikipedia.org/wiki/List_of_OAuth_providers). Estos servicios te permitir√°n crear una aplicaci√≥n y autenticar usuarios que el proveedor tiene registrados. Para hacerlo, el **cliente** necesitar√° **permitir que tu aplicaci√≥n** acceda a algunos de sus datos dentro del **proveedor de OAuth**.\
Hasta aqu√≠, solo un inicio de sesi√≥n com√∫n con google/linkedin/github... donde te aparece una p√°gina que dice: "_La aplicaci√≥n \<InsertCoolName> quiere acceder a tu informaci√≥n, ¬øquieres permitirlo?_"

#### Condici√≥n de carrera en `authorization_code`

El **problema** aparece cuando lo **aceptas** y autom√°ticamente se env√≠a un **`authorization_code`** a la aplicaci√≥n maliciosa. Luego, esta **aplicaci√≥n abusa de una Condici√≥n de Carrera en el proveedor de servicios de OAuth para generar m√°s de un AT/RT** (_Token de Autenticaci√≥n/Token de Actualizaci√≥n_) a partir del **`authorization_code`** de tu cuenta. B√°sicamente, abusar√° del hecho de que has aceptado que la aplicaci√≥n acceda a tus datos para **crear varias cuentas**. Entonces, si **dejas de permitir que la aplicaci√≥n acceda a tus datos, un par de AT/RT se eliminar√°, pero los otros seguir√°n siendo v√°lidos**.

#### Condici√≥n de carrera en `Refresh Token`

Una vez que hayas **obtenido un RT v√°lido**, podr√≠as intentar **abusar de √©l para generar varios AT/RT** y **aunque el usuario cancele los permisos** para que la aplicaci√≥n maliciosa acceda a sus datos, **varios RT seguir√°n siendo v√°lidos.**

## **RC en WebSockets**

En [**WS_RaceCondition_PoC**](https://github.com/redrays-io/WS_RaceCondition_PoC) puedes encontrar un PoC en Java para enviar mensajes de websocket en **paralelo** para abusar de **Condici√≥n de Carrera tambi√©n en Web Sockets**.

## Referencias

* [https://hackerone.com/reports/759247](https://hackerone.com/reports/759247)
* [https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html](https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html)
* [https://hackerone.com/reports/55140](https://hackerone.com/reports/55140)
* [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
* [https://portswigger.net/web-security/race-conditions](https://portswigger.net/web-security/race-conditions)

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* ¬øTrabajas en una **empresa de ciberseguridad**? ¬øQuieres ver a tu **empresa anunciada en HackTricks**? o ¬øquieres tener acceso a la **√∫ltima versi√≥n de PEASS o descargar HackTricks en PDF**? Consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n de [**NFTs exclusivos**](https://opensea.io/collection/the-peass-family)
* Consigue el [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* **√önete al** [**üí¨**](https://emojipedia.org/speech-balloon/) [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠gueme** en **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Comparte tus trucos de hacking enviando PRs al** [**repositorio de hacktricks**](https://github.com/carlospolop/hacktricks) **y al** [**repositorio de hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

<figure><img src="../.gitbook/assets/image (3) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Usa [**Trickest**](https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks) para construir y **automatizar flujos de trabajo** f√°cilmente con las herramientas comunitarias **m√°s avanzadas**.\
Obt√©n Acceso Hoy:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}
