# 竞争条件

![](<../.gitbook/assets/image (9) (1) (2).png>)

\
使用[**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks)轻松构建和自动化由全球**最先进**的社区工具提供支持的工作流程。\
立即获取访问权限：

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* 你在**网络安全公司**工作吗？你想在HackTricks中看到你的**公司广告**吗？或者你想获得**PEASS的最新版本或下载PDF格式的HackTricks**吗？请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 发现我们的独家[**NFTs**](https://opensea.io/collection/the-peass-family)收藏品[**The PEASS Family**](https://opensea.io/collection/the-peass-family)
* 获取[**官方PEASS和HackTricks衣物**](https://peass.creator-spring.com)
* **加入**[**💬**](https://emojipedia.org/speech-balloon/) [**Discord群组**](https://discord.gg/hRep4RUj7f)或[**电报群组**](https://t.me/peass)或**关注**我在**Twitter**上的[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**。**
* **通过向**[**hacktricks repo**](https://github.com/carlospolop/hacktricks) **和**[**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **提交PR来分享你的黑客技巧。**

</details>

## 利用竞争条件

滥用竞争条件的主要问题是需要请求在非常短的时间差内并行处理（通常>1ms）。在下面的部分中，提出了不同的解决方案，以实现这一点。

<figure><img src="../.gitbook/assets/image.png" alt=""><figcaption></figcaption></figure>

### 单数据包攻击

HTTP2允许在**单个TCP连接**中发送**2个请求**（而在HTTP/1.1中，它们必须是顺序的）。\
使用单个TCP数据包完全**消除了网络抖动的影响**，因此这对于竞争条件攻击也具有潜力。然而，**两个请求对于可靠的竞争攻击来说是不够的**，这要归功于**服务器端抖动** - 应用程序请求处理时间的变化，由于CPU争用等不可控变量引起。

但是，使用HTTP/1.1的“**最后一个字节同步**”技术，可以预先发送大部分数据，并保留每个请求的一个小片段，然后使用单个TCP数据包“完成”**20-30个请求**。

要**预先发送每个请求的大部分**：

- 如果请求没有正文，请发送所有标头，但不设置END\_STREAM标志。保留一个带有设置了END\_STREAM的空数据帧。
- 如果请求有正文，请发送标头和除最后一个字节之外的所有正文数据。保留一个包含最后一个字节的数据帧。

接下来，**准备发送最后的帧**：

- 等待100ms，以确保初始帧已发送。
- 确保禁用TCP\_NODELAY - Nagle算法批处理最后的帧至关重要。
- 发送一个ping数据包以预热本地连接。如果不这样做，操作系统的网络堆栈将把第一个最后帧放在一个单独的数据包中。

最后，发送保留的帧。您应该能够使用Wireshark验证它们是否落在一个单独的数据包中。

{% hint style="info" %}
请注意，这**对于某些服务器上的静态文件不起作用**，但静态文件对于竞争条件攻击是无关紧要的。
{% endhint %}

使用这种技术，您可以使20-30个请求同时到达服务器 - 无论网络抖动如何：

<figure><img src="../.gitbook/assets/image (1).png" alt=""><figcaption></figcaption></figure>

**适应目标架构**

值得注意的是，许多应用程序位于前端服务器后面，这些服务器可能决定将某些请求转发到后端的现有连接，并为其他请求创建新的连接。

因此，重要的是不要将不一致的请求时间归因于应用程序行为，例如仅允许单个线程访问资源的锁定机制。此外，前端请求路由通常是基于每个连接的，因此您可以通过在执行攻击之前在服务器端进行连接预热 - **在连接上发送几个无关紧要的请求**，从而平滑请求时间。

请注意，**PHP默认情况下锁定sessionid**，因此您需要在批处理中为每个请求使用**单独的会话**，否则它们将按顺序处理。

{% hint style="warning" %}
有关此技术的更多信息，请查看[https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)中的原始报告。
{% endhint %}

#### 示例

您可以在[https://github.com/PortSwigger/turbo-intruder/blob/master/resources/examples/race-single-packet-attack.py](https://github.com/PortSwigger/turbo-intruder/blob/master/resources/examples/race-single-packet-attack.py)中查看如何在turbo intruder中使用此简单示例。

在Burp Suite的Repeater中，也可以通过新的“**并行发送组**”选项使用此功能。
### 原始的BF

在之前的研究中，以下是一些使用的有效载荷，它们只是尽可能快地发送数据包以引发RC。

* **Turbo Intruder**
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
pipeline=False
)
a = ['Session=<session_id_1>','Session=<session_id_2>','Session=<session_id_3>']
for i in range(len(a)):
engine.queue(target.req,a[i], gate='race1')
# open TCP connections and send partial requests
engine.start(timeout=10)
engine.openGate('race1')
engine.complete(timeout=60)

def handleResponse(req, interesting):
table.add(req)
```
* **Python - asyncio**

Python的asyncio模块是一种用于编写异步代码的库。它提供了一种方便的方式来处理并发任务，特别是在网络编程中。asyncio使用协程（coroutines）和事件循环（event loop）的概念来实现异步操作。

协程是一种轻量级的线程，可以在不同的任务之间切换执行。通过使用async和await关键字，可以定义协程函数。协程函数可以在遇到IO操作时暂停执行，并在IO操作完成后恢复执行。

事件循环是一个无限循环，用于处理协程任务的调度和执行。它负责调度协程函数的执行顺序，并在需要时暂停和恢复协程的执行。

使用asyncio编写异步代码的好处是可以提高程序的性能和响应能力。通过并发执行多个任务，可以减少等待时间，并充分利用系统资源。

下面是一个使用asyncio的简单示例：

```python
import asyncio

async def hello():
    print("Hello")
    await asyncio.sleep(1)
    print("World")

async def main():
    await asyncio.gather(hello(), hello(), hello())

asyncio.run(main())
```

在上面的示例中，我们定义了一个hello协程函数，它会打印"Hello"，然后暂停1秒钟，最后打印"World"。在main函数中，我们使用asyncio.gather函数同时执行三个hello协程。

通过运行上述代码，我们可以看到"Hello"和"World"交替打印出来，说明协程函数是并发执行的。

asyncio模块提供了丰富的功能和工具，用于处理异步编程中的各种情况。它是编写高效异步代码的强大工具，值得深入学习和探索。
```python
import asyncio
import httpx

async def use_code(client):
resp = await client.post(f'http://victim.com', cookies={"session": "asdasdasd"}, data={"code": "123123123"})
return resp.text

async def main():
async with httpx.AsyncClient() as client:
tasks = []
for _ in range(20): #20 times
tasks.append(asyncio.ensure_future(use_code(client)))

# Get responses
results = await asyncio.gather(*tasks, return_exceptions=True)

# Print results
for r in results:
print(r)

# Async2sync sleep
await asyncio.sleep(0.5)
print(results)

asyncio.run(main())
```
* **入侵者**: 将**请求**发送给**入侵者**，在**选项菜单**中设置**线程数**为**30**，选择**空负载**作为有效载荷并生成**30个**。

## **RC方法论**



## **RC影响**

### 越限

这是最基本的一种竞争条件，其中**漏洞**出现在**限制执行某个操作次数的位置**。比如在网店中多次使用相同的折扣码。一个非常简单的例子可以在[**这份报告**](https://medium.com/@pravinponnusamy/race-condition-vulnerability-found-in-bug-bounty-program-573260454c43)或者[**这个漏洞**](https://hackerone.com/reports/759247)**中找到**。

### **隐藏的子状态**

其他更复杂的竞争条件将利用机器状态中的**子状态**，这可能允许攻击者滥用他本不应该访问的状态，但攻击者有一个**很小的窗口**可以访问它。

1. **预测潜在的隐藏和有趣的子状态**

第一步是识别所有的端点，这些端点要么写入数据，要么从中读取数据，然后将这些数据用于某些重要的操作。例如，用户可能存储在一个数据库表中，该表通过注册、配置文件编辑、密码重置初始化和密码重置完成进行修改。

我们可以使用三个关键问题来排除不太可能引起冲突的端点。对于每个对象和相关的端点，问：

**1) 状态是如何存储的？**

存储在持久的服务器端数据结构中的数据非常适合利用。一些端点完全在客户端存储其状态，例如通过电子邮件发送JWT的密码重置 - 这些可以安全地跳过。

应用程序通常会在用户会话中存储一些状态。这些状态通常在某种程度上受到子状态的保护 - 关于这一点稍后会有更多的介绍。

**2) 我们是在编辑还是在追加？**

对现有数据进行编辑的操作（例如更改帐户的主电子邮件地址）具有充足的冲突潜力，而仅仅追加到现有数据的操作（例如添加额外的电子邮件地址）不太可能受到除了越限攻击之外的任何漏洞。

**3) 操作的键是什么？**

大多数端点都是在特定记录上操作的，该记录是使用“键”查找的，例如用户名、密码重置令牌或文件名。为了成功攻击，我们需要两个使用相同键的操作。例如，想象一下两个合理的密码重置实现：

<figure><img src="../.gitbook/assets/image (2).png" alt=""><figcaption></figcaption></figure>

2. **寻找线索**

此时是时候对潜在的有趣端点发起一些RC攻击，以寻找与常规响应不同的意外结果。任何与预期响应的偏差，例如一个或多个响应的变化，或者第二阶段效应，如电子邮件内容的不同或会话中的可见变化，都可能是指示出现问题的线索。

3. **验证概念**

最后一步是**验证概念并将其转化为可行的攻击**。

当您发送一批请求时，您可能会发现早期的请求对一个易受攻击的最终状态进行了触发，但后来的请求覆盖/使其无效，最终状态无法被利用。在这种情况下，您将希望消除所有不必要的请求 - 两个请求应足以利用大多数漏洞。然而，减少到两个请求将使攻击更加依赖于时间，因此您可能需要多次重试攻击或自动化攻击。

## 隐藏的子状态案例研究

### 支付并添加商品

[**查看此实验室**](https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-insufficient-workflow-validation)，了解如何在商店中**支付**并**添加额外的**商品，而无需为其支付。

### 确认其他电子邮件

这个想法是**验证一个电子邮件地址并同时更改它**，以找出平台是否验证了新的电子邮件地址。

### 将电子邮件更改为2个电子邮件地址

根据[**这篇文章**](https://portswigger.net/research/smashing-the-state-machine)的说法，Gitlab容易受到这种攻击，因为它可能会将一个电子邮件的**电子邮件验证令牌发送到另一个电子邮件**。

### OAuth2永久持久性

有几个[**OAuth提供商**](https://en.wikipedia.org/wiki/List\_of\_OAuth\_providers)。这些服务将允许您创建一个应用程序并对提供商已注册的用户进行身份验证。为了做到这一点，**客户端**将需要**允许您的应用程序**访问其在**OAuth提供商**内部的一些数据。\
因此，到目前为止，只是一个常见的使用Google/Linkdin/Github等登录的过程，您会看到一个页面上写着：“_应用程序\<InsertCoolName>想要访问您的信息，您是否允许？_”

#### `authorization_code`中的竞争条件

问题出现在您**接受**并自动发送一个**`authorization_code`**给恶意应用程序时。然后，该应用程序滥用OAuth服务提供商中的竞争条件，从**`authorization_code`**为您的帐户生成多个AT/RT（_身份验证令牌/刷新令牌_）。基本上，它将滥用您已经接受应用程序访问您的数据的事实，以**创建多个帐户**。然后，如果您**停止允许应用程序访问您的数据，一对AT/RT将被删除，但其他AT/RT仍然有效**。

#### `Refresh Token`中的竞争条件

一旦您获得了一个有效的RT，您可以尝试滥用它生成多个AT/RT，即使用户取消了允许恶意应用程序访问其数据的权限，**多个RT仍然有效**。

## 参考资料

* [https://hackerone.com/reports/759247](https://hackerone.com/reports/759247)
* [https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html](https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html)
* [https://hackerone.com/reports/55140](https://hackerone.com/reports/55140)
* [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* 您在**网络安全公司**工作吗？您想在HackTricks中看到您的**公司广告**吗？或者您想获得最新版本的PEASS或下载PDF格式的HackTricks吗？请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 发现我们的独家NFT收藏品[**The PEASS Family**](https://opensea.io/collection/the-peass-family)
* 获取[**官方PEASS和HackTricks周边产品**](https://peass.creator-spring.com)
* **加入** [**💬**](https://emojipedia.org/speech-balloon/) [**Discord 群组**](https://discord.gg/hRep4RUj7f) 或 [**Telegram 群组**](https://t.me/peass)，或在 **Twitter** 上 **关注** 我 [**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**。**
* **通过向** [**hacktricks 仓库**](https://github.com/carlospolop/hacktricks) **和** [**hacktricks-cloud 仓库**](https://github.com/carlospolop/hacktricks-cloud) **提交 PR 来分享你的黑客技巧。**

</details>

![](<../.gitbook/assets/image (9) (1) (2).png>)

\
使用 [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) 可以轻松构建和 **自动化工作流程**，使用全球最先进的社区工具。\
立即获取访问权限：

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}
