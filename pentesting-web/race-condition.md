# Condition de course

![](<../.gitbook/assets/image (9) (1) (2).png>)

\
Utilisez [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) pour créer et automatiser facilement des flux de travail alimentés par les outils communautaires les plus avancés au monde.\
Accédez dès aujourd'hui :

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* Vous travaillez dans une **entreprise de cybersécurité** ? Vous souhaitez voir votre **entreprise annoncée dans HackTricks** ? ou souhaitez-vous avoir accès à la **dernière version de PEASS ou télécharger HackTricks en PDF** ? Consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* Découvrez [**The PEASS Family**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFT**](https://opensea.io/collection/the-peass-family)
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* **Rejoignez le** [**💬**](https://emojipedia.org/speech-balloon/) [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** [**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR au** [**repo hacktricks**](https://github.com/carlospolop/hacktricks) **et au** [**repo hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## Exploitation de la condition de course

Le principal problème de l'exploitation des conditions de course est que vous avez besoin que les requêtes soient traitées en parallèle avec une très courte différence de temps (généralement >1ms). Dans la section suivante, différentes solutions sont proposées pour rendre cela possible.

<figure><img src="../.gitbook/assets/image.png" alt=""><figcaption></figcaption></figure>

### Attaque à un seul paquet

HTTP2 permet d'envoyer **2 requêtes dans une seule connexion TCP** (alors que dans HTTP/1.1, elles doivent être séquentielles).\
L'utilisation d'un seul paquet TCP élimine complètement l'effet du jitter du réseau, il y a donc clairement un potentiel pour les attaques de condition de course. Cependant, **deux requêtes ne suffisent pas pour une attaque de course fiable** grâce au **jitter côté serveur** - variations du temps de traitement des requêtes de l'application causées par des variables incontrôlables telles que la contention du CPU.

Mais, en utilisant la technique '**last-byte sync**' d'HTTP/1.1, il est possible d'envoyer préalablement la majeure partie des données en retenant un petit fragment de chaque requête, puis de 'compléter' **20 à 30 requêtes avec un seul paquet TCP**.

Pour **envoyer préalablement la majeure partie de chaque requête** :

- Si la requête n'a pas de corps, envoyez tous les en-têtes, mais ne définissez pas le drapeau END\_STREAM. Retenez un cadre de données vide avec le drapeau END\_STREAM défini.
- Si la requête a un corps, envoyez les en-têtes et toutes les données du corps sauf le dernier octet. Retenez un cadre de données contenant le dernier octet.

Ensuite, **préparez-vous à envoyer les trames finales** :

- Attendez 100 ms pour vous assurer que les trames initiales ont été envoyées.
- Assurez-vous que TCP\_NODELAY est désactivé - il est crucial que l'algorithme de Nagle regroupe les trames finales.
- Envoyez un paquet ping pour réchauffer la connexion locale. Si vous ne le faites pas, la pile réseau du système d'exploitation placera la première trame finale dans un paquet séparé.

Enfin, envoyez les trames retenues. Vous devriez pouvoir vérifier qu'elles sont arrivées dans un seul paquet en utilisant Wireshark.

{% hint style="info" %}
Notez que cela **ne fonctionne pas pour les fichiers statiques** sur certains serveurs, mais les fichiers statiques ne sont pas pertinents pour les attaques de condition de course. Mais les fichiers statiques sont sans importance pour les attaques de RC.
{% endhint %}

En utilisant cette technique, vous pouvez faire en sorte que 20 à 30 requêtes arrivent simultanément sur le serveur - indépendamment du jitter du réseau :

<figure><img src="../.gitbook/assets/image (1).png" alt=""><figcaption></figcaption></figure>

**Adaptation à l'architecture cible**

Il est important de noter que de nombreuses applications se trouvent derrière un serveur frontal, et ceux-ci peuvent décider de transférer certaines requêtes sur des connexions existantes vers l'arrière-plan, et de créer de nouvelles connexions pour d'autres.

Par conséquent, il est important de ne pas attribuer des délais de requête incohérents au comportement de l'application, tel que des mécanismes de verrouillage qui n'autorisent qu'un seul thread à accéder à une ressource à la fois. De plus, le routage des requêtes côté frontal est souvent effectué sur une base de connexion, vous pouvez donc lisser le délai des requêtes en effectuant un réchauffement de connexion côté serveur - **envoyer quelques requêtes insignifiantes sur votre connexion avant de lancer l'attaque**.

Notez que **PHP verrouille sur l'identifiant de session par défaut**, vous devez donc utiliser une **session distincte pour chaque requête** de votre lot, sinon elles seront traitées séquentiellement.

{% hint style="warning" %}
Pour plus d'informations sur cette technique, consultez le rapport original sur [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
{% endhint %}

#### Exemples

Vous pouvez consulter un exemple simple sur la façon d'utiliser cela dans Turbo Intruder sur [https://github.com/PortSwigger/turbo-intruder/blob/master/resources/examples/race-single-packet-attack.py](https://github.com/PortSwigger/turbo-intruder/blob/master/resources/examples/race-single-packet-attack.py).

Il est également disponible dans **Repeater** via la nouvelle option '**Envoyer le groupe en parallèle**' dans Burp Suite.
### BF brut

Avant les recherches précédentes, voici quelques charges utiles utilisées qui tentaient simplement d'envoyer les paquets aussi rapidement que possible pour provoquer une RC.

* **Turbo Intruder**
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
pipeline=False
)
a = ['Session=<session_id_1>','Session=<session_id_2>','Session=<session_id_3>']
for i in range(len(a)):
engine.queue(target.req,a[i], gate='race1')
# open TCP connections and send partial requests
engine.start(timeout=10)
engine.openGate('race1')
engine.complete(timeout=60)

def handleResponse(req, interesting):
table.add(req)
```
* **Python - asyncio**

La bibliothèque `asyncio` de Python est utilisée pour écrire du code asynchrone de manière concurrente. Elle permet d'exécuter des tâches en parallèle, ce qui est particulièrement utile pour les opérations d'entrée/sortie (I/O) intensives, telles que les appels réseau.

L'asynchronisme est basé sur le concept de coroutines, qui sont des fonctions spéciales pouvant être suspendues et reprises ultérieurement. Cela permet d'éviter les blocages et d'optimiser l'utilisation des ressources.

`asyncio` fournit également des primitives pour gérer les événements, les boucles d'événements et les tâches. Les événements sont des objets qui se produisent lorsqu'une opération asynchrone est terminée, tandis que les boucles d'événements sont responsables de l'exécution des coroutines et de la gestion des événements.

Pour utiliser `asyncio`, vous devez définir des coroutines en utilisant le mot-clé `async` et les exécuter dans une boucle d'événements à l'aide de la fonction `run_until_complete`. Vous pouvez également utiliser des mots-clés tels que `await` pour suspendre l'exécution d'une coroutine jusqu'à ce qu'une opération asynchrone soit terminée.

Voici un exemple simple d'utilisation de `asyncio` pour effectuer une requête HTTP asynchrone :

```python
import asyncio
import aiohttp

async def fetch(url):
    async with aiohttp.ClientSession() as session:
        async with session.get(url) as response:
            return await response.text()

async def main():
    url = "https://example.com"
    response = await fetch(url)
    print(response)

loop = asyncio.get_event_loop()
loop.run_until_complete(main())
```

Dans cet exemple, la fonction `fetch` est une coroutine qui utilise la bibliothèque `aiohttp` pour effectuer une requête HTTP asynchrone. La fonction `main` est également une coroutine qui appelle `fetch` et attend la réponse.

En exécutant ce code, vous pouvez effectuer une requête HTTP asynchrone et afficher la réponse. Cela permet d'économiser du temps en évitant les attentes inutiles lors de l'exécution de tâches I/O intensives.

`asyncio` est un outil puissant pour écrire du code asynchrone en Python, ce qui peut être très utile dans le domaine du piratage éthique pour effectuer des opérations de manière efficace et rapide.
```python
import asyncio
import httpx

async def use_code(client):
resp = await client.post(f'http://victim.com', cookies={"session": "asdasdasd"}, data={"code": "123123123"})
return resp.text

async def main():
async with httpx.AsyncClient() as client:
tasks = []
for _ in range(20): #20 times
tasks.append(asyncio.ensure_future(use_code(client)))

# Get responses
results = await asyncio.gather(*tasks, return_exceptions=True)

# Print results
for r in results:
print(r)

# Async2sync sleep
await asyncio.sleep(0.5)
print(results)

asyncio.run(main())
```
* **Intrus**: Envoyez la **requête** à **Intruder**, définissez le **nombre de threads** sur **30** dans le menu **Options**, sélectionnez les **charges utiles nulles** et générez-en **30**.

## **Méthodologie RC**

## **Impacts de RC**

### Dépassement de limite

Il s'agit du type le plus basique de race condition où des **vulnérabilités** apparaissent dans des endroits qui **limitent le nombre de fois où vous pouvez effectuer une action**. Par exemple, utiliser plusieurs fois le même code de réduction dans une boutique en ligne. Un exemple très simple peut être trouvé dans [**ce rapport**](https://medium.com/@pravinponnusamy/race-condition-vulnerability-found-in-bug-bounty-program-573260454c43) ou dans [**ce bogue**](https://hackerone.com/reports/759247)**.**

### **Sous-états cachés**

Les RC les plus complexes exploiteront des **sous-états dans l'état de la machine** qui pourraient permettre à un attaquant d'**abuser des états auxquels il n'était jamais censé avoir accès**, mais il existe une **petite fenêtre** pour que l'attaquant y accède.

1. **Prédire les sous-états cachés et intéressants potentiels**

La première étape consiste à identifier tous les points d'extrémité qui écrivent ou lisent des données à partir de celui-ci, puis utilisent ces données pour quelque chose d'important. Par exemple, les utilisateurs peuvent être stockés dans une table de base de données modifiée par l'enregistrement, les modifications de profil, l'initiation de la réinitialisation du mot de passe et l'achèvement de la réinitialisation du mot de passe.

Nous pouvons utiliser trois questions clés pour exclure les points d'extrémité qui sont peu susceptibles de provoquer des collisions. Pour chaque objet et les points d'extrémité associés, demandez-vous :

**1) Comment l'état est-il stocké ?**

Les données stockées dans une structure de données côté serveur persistante sont idéales pour l'exploitation. Certains points d'extrémité stockent leur état entièrement côté client, comme les réinitialisations de mot de passe qui fonctionnent en envoyant un JWT par e-mail - ceux-ci peuvent être ignorés en toute sécurité.

Les applications stockent souvent certains états dans la session utilisateur. Ils sont souvent quelque peu protégés contre les sous-états - nous en parlerons plus tard.

**2) Est-ce que nous modifions ou ajoutons ?**

Les opérations qui modifient des données existantes (comme le changement de l'adresse e-mail principale d'un compte) ont un potentiel de collision important, tandis que les actions qui ajoutent simplement des données existantes (comme l'ajout d'une adresse e-mail supplémentaire) sont peu susceptibles d'être vulnérables à autre chose qu'à des attaques de dépassement de limite.

**3) Sur quoi l'opération est-elle basée ?**

La plupart des points d'extrémité fonctionnent sur un enregistrement spécifique, qui est recherché à l'aide d'une "clé", telle qu'un nom d'utilisateur, un jeton de réinitialisation de mot de passe ou un nom de fichier. Pour une attaque réussie, nous avons besoin de deux opérations qui utilisent la même clé. Par exemple, imaginez deux implémentations plausibles de réinitialisation de mot de passe :

<figure><img src="../.gitbook/assets/image (2).png" alt=""><figcaption></figcaption></figure>

2. **Recherche d'indices**

À ce stade, il est temps de **lancer des attaques RC** sur les points d'extrémité potentiellement intéressants pour essayer de trouver des résultats inattendus par rapport aux résultats habituels. **Toute déviation de la réponse attendue**, telle qu'un changement dans une ou plusieurs réponses, ou un effet de second ordre comme des contenus d'e-mail différents ou un changement visible dans votre session, pourrait être un indice indiquant un problème.

3. **Prouver le concept**

La dernière étape consiste à **prouver le concept et à le transformer en une attaque viable**.

Lorsque vous envoyez un lot de requêtes, vous pouvez constater qu'une paire de requêtes initiales déclenche un état final vulnérable, mais que les requêtes ultérieures l'écrasent/invalident et que l'état final n'est pas exploitable. Dans ce scénario, vous voudrez éliminer toutes les requêtes inutiles - deux devraient suffire pour exploiter la plupart des vulnérabilités. Cependant, passer à deux requêtes rendra l'attaque plus sensible au timing, vous devrez donc peut-être réessayer l'attaque plusieurs fois ou l'automatiser.

## Études de cas sur les sous-états cachés

### Payer et ajouter un article

[**Consultez ce laboratoire**](https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-insufficient-workflow-validation) pour voir comment **payer** dans un magasin et **ajouter un article supplémentaire** pour lequel vous n'aurez pas besoin de payer.

### Confirmer d'autres e-mails

L'idée est de **vérifier une adresse e-mail et de la changer en même temps** pour savoir si la plateforme vérifie la nouvelle adresse modifiée.

### Changer l'e-mail en 2 adresses e-mail

Selon [**cet article**](https://portswigger.net/research/smashing-the-state-machine), Gitlab était vulnérable à une prise de contrôle de cette manière car il pourrait **envoyer le jeton de vérification d'e-mail d'une adresse e-mail à l'autre adresse e-mail**.

### Persistance éternelle d'OAuth2

Il existe plusieurs [**fournisseurs OAuth**](https://en.wikipedia.org/wiki/List\_of\_OAuth\_providers). Ces services vous permettront de créer une application et d'authentifier les utilisateurs enregistrés par le fournisseur. Pour ce faire, le **client** devra **autoriser votre application** à accéder à certaines de leurs données à l'intérieur du **fournisseur OAuth**.\
Jusqu'à présent, il s'agit simplement d'une connexion classique avec Google/LinkedIn/GitHub... où vous êtes invité avec une page disant : "_L'application \<InsertCoolName> souhaite accéder à vos informations, voulez-vous l'autoriser ?_"

#### Race Condition dans `authorization_code`

Le **problème** survient lorsque vous **l'acceptez** et envoie automatiquement un **`authorization_code`** à l'application malveillante. Ensuite, cette **application exploite une race condition dans le fournisseur de services OAuth pour générer plus d'un AT/RT** (_Authentication Token/Refresh Token_) à partir de l'**`authorization_code`** pour votre compte. Fondamentalement, elle exploitera le fait que vous avez accepté l'application pour accéder à vos données afin de **créer plusieurs comptes**. Ensuite, si vous **arrêtez d'autoriser l'application à accéder à vos données, une paire d'AT/RT sera supprimée, mais les autres resteront valides**.

#### Race Condition dans `Refresh Token`

Une fois que vous avez **obtenu un RT valide**, vous pouvez essayer de **l'exploiter pour générer plusieurs AT/RT** et même si l'utilisateur annule les autorisations pour l'application malveillante d'accéder à ses données, **plusieurs RT resteront valides**.

## Références

* [https://hackerone.com/reports/759247](https://hackerone.com/reports/759247)
* [https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html](https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html)
* [https://hackerone.com/reports/55140](https://hackerone.com/reports/55140)
* [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* Travaillez-vous dans une **entreprise de cybersécurité** ? Voulez-vous voir votre **entreprise annoncée dans HackTricks** ? ou voulez-vous avoir accès à la **dernière version de PEASS ou télécharger HackTricks en PDF** ? Consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* Découvrez [**La famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFT**](https://opensea.io/collection/the-peass-family)
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* **Rejoignez le** [**💬**](https://emojipedia.org/speech-balloon/) [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** [**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Partagez vos astuces de piratage en soumettant des PRs au** [**dépôt hacktricks**](https://github.com/carlospolop/hacktricks) **et au** [**dépôt hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

![](<../.gitbook/assets/image (9) (1) (2).png>)

\
Utilisez [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) pour créer et **automatiser facilement des flux de travail** alimentés par les outils communautaires les plus avancés au monde.\
Obtenez un accès dès aujourd'hui :

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}
