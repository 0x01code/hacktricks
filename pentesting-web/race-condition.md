# Race Condition

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Utilizza [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) per creare e automatizzare facilmente flussi di lavoro supportati dagli strumenti della community pi√π avanzati al mondo.\
Ottieni l'accesso oggi stesso:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>Impara l'hacking di AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata in HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PACCHETTI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**The PEASS Family**](https://opensea.io/collection/the-peass-family), la nostra collezione di esclusive [**NFT**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR a** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

{% hint style="warning" %}
Per ottenere una comprensione approfondita di questa tecnica, consulta il rapporto originale su [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
{% endhint %}

## Miglioramento degli attacchi di Race Condition

La principale difficolt√† nel sfruttare le race condition √® assicurarsi che pi√π richieste vengano gestite contemporaneamente, con **poca differenza nei tempi di elaborazione, idealmente inferiore a 1 ms**.

Qui puoi trovare alcune tecniche per la sincronizzazione delle richieste:

#### Attacco con un singolo pacchetto HTTP/2 vs Sincronizzazione dell'ultimo byte HTTP/1.1

- **HTTP/2**: Supporta l'invio di due richieste su una singola connessione TCP, riducendo l'impatto della variazione di rete. Tuttavia, a causa delle variazioni lato server, due richieste potrebbero non essere sufficienti per uno sfruttamento coerente della race condition.
- **'Last-Byte Sync' HTTP/1.1**: Consente l'invio anticipato della maggior parte delle parti di 20-30 richieste, trattenendo un piccolo frammento che viene quindi inviato insieme, raggiungendo l'arrivo simultaneo al server.

La **preparazione per Last-Byte Sync** prevede:
1. Invio di intestazioni e dati del corpo tranne l'ultimo byte senza terminare lo stream.
2. Pausa di 100 ms dopo l'invio iniziale.
3. Disabilitazione di TCP_NODELAY per utilizzare l'algoritmo di Nagle per l'invio finale dei frame.
4. Pinging per riscaldare la connessione.

L'invio successivo dei frame trattenuti dovrebbe risultare nel loro arrivo in un singolo pacchetto, verificabile tramite Wireshark. Questo metodo non si applica ai file statici, che di solito non sono coinvolti negli attacchi RC.

### Adattamento all'architettura del server

Comprendere l'architettura del target √® cruciale. I server front-end potrebbero instradare le richieste in modo diverso, influenzando i tempi. Il riscaldamento anticipato della connessione lato server, attraverso richieste insignificanti, potrebbe normalizzare i tempi delle richieste.

#### Gestione del blocco basato sulla sessione

Framework come il gestore di sessioni di PHP serializzano le richieste per sessione, potenzialmente oscurando le vulnerabilit√†. Utilizzare token di sessione diversi per ogni richiesta pu√≤ aggirare questo problema.

#### Superare i limiti di velocit√† o risorse

Se il riscaldamento della connessione non √® efficace, provocare intenzionalmente ritardi nei limiti di velocit√† o risorse dei server web attraverso una serie di richieste fittizie potrebbe agevolare l'attacco con un singolo pacchetto, inducendo un ritardo lato server favorevole alle race condition.


## Esempi di attacco

* **Tubo Intruder - Attacco con un singolo pacchetto HTTP2 (1 endpoint)**: Puoi inviare la richiesta a **Turbo intruder** (`Estensioni` -> `Turbo Intruder` -> `Invia a Turbo Intruder`), puoi modificare nella richiesta il valore che desideri forzare per **`%s`** come in `csrf=Bn9VQB8OyefIs3ShR2fPESR0FzzulI1d&username=carlos&password=%s` e quindi selezionare **`examples/race-single-packer-attack.py`** dal menu a discesa:

<figure><img src="../.gitbook/assets/image (4) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Se stai per **inviare valori diversi**, puoi modificare il codice con questo che utilizza una wordlist dagli appunti:
```python
passwords = wordlists.clipboard
for password in passwords:
engine.queue(target.req, password, gate='race1')
```
{% hint style="warning" %}
Se il sito web non supporta HTTP2 (solo HTTP1.1), utilizzare `Engine.THREADED` o `Engine.BURP` invece di `Engine.BURP2`.
{% endhint %}

* **Tubo Intruder - Attacco a pacchetto singolo HTTP2 (diversi endpoint)**: Nel caso in cui sia necessario inviare una richiesta a 1 endpoint e quindi pi√π richieste ad altri endpoint per innescare l'RCE, √® possibile modificare lo script `race-single-packet-attack.py` come segue:
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=1,
engine=Engine.BURP2
)

# Hardcode the second request for the RC
confirmationReq = '''POST /confirm?token[]= HTTP/2
Host: 0a9c00370490e77e837419c4005900d0.web-security-academy.net
Cookie: phpsessionid=MpDEOYRvaNT1OAm0OtAsmLZ91iDfISLU
Content-Length: 0

'''

# For each attempt (20 in total) send 50 confirmation requests.
for attempt in range(20):
currentAttempt = str(attempt)
username = 'aUser' + currentAttempt

# queue a single registration request
engine.queue(target.req, username, gate=currentAttempt)

# queue 50 confirmation requests - note that this will probably sent in two separate packets
for i in range(50):
engine.queue(confirmationReq, gate=currentAttempt)

# send all the queued requests for this attempt
engine.openGate(currentAttempt)
```
* √à anche disponibile in **Repeater** tramite la nuova opzione '**Invia gruppo in parallelo**' in Burp Suite.
* Per **limit-overrun** potresti semplicemente aggiungere la **stessa richiesta 50 volte** nel gruppo.
* Per **riscaldare la connessione**, potresti **aggiungere** all'**inizio** del **gruppo** alcune **richieste** a una parte non statica del server web.
* Per **ritardare** il processo **tra** l'elaborazione **di una richiesta e l'altra** in due passaggi di sottostati, potresti **aggiungere richieste extra tra** entrambe le richieste.
* Per un RC **multi-endpoint** potresti iniziare inviando la **richiesta** che **va allo stato nascosto** e poi **50 richieste** subito dopo di essa che **sfruttano lo stato nascosto**.

<figure><img src="../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

### Raw BF

Prima della ricerca precedente, questi erano alcuni payload utilizzati che cercavano semplicemente di inviare i pacchetti il pi√π velocemente possibile per causare una RC.

* **Repeater:** Controlla gli esempi della sezione precedente.
* **Intruder**: Invia la **richiesta** a **Intruder**, imposta il **numero di thread** su **30** nel menu **Opzioni** e seleziona come payload **Null payloads** e genera **30**.
* **Turbo Intruder**
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
pipeline=False
)
a = ['Session=<session_id_1>','Session=<session_id_2>','Session=<session_id_3>']
for i in range(len(a)):
engine.queue(target.req,a[i], gate='race1')
# open TCP connections and send partial requests
engine.start(timeout=10)
engine.openGate('race1')
engine.complete(timeout=60)

def handleResponse(req, interesting):
table.add(req)
```
* **Python - asyncio**

Python's `asyncio` module is a library that provides support for writing asynchronous code using coroutines, event loops, and tasks. It allows you to write concurrent code that is more efficient and responsive.

The `asyncio` module is built on top of the `async` and `await` keywords introduced in Python 3.5. It provides a way to write asynchronous code in a more structured and readable manner.

With `asyncio`, you can define coroutines using the `async` keyword and await the results of other coroutines using the `await` keyword. This allows you to write code that can perform multiple tasks concurrently without blocking the execution.

To use `asyncio`, you need to create an event loop using the `asyncio.get_event_loop()` function. The event loop is responsible for scheduling and executing coroutines. You can then run coroutines using the `loop.run_until_complete()` function.

`asyncio` also provides various utilities for working with asynchronous code, such as `asyncio.sleep()` for introducing delays, `asyncio.wait()` for waiting for multiple coroutines to complete, and `asyncio.gather()` for running multiple coroutines concurrently.

Overall, `asyncio` is a powerful tool for writing asynchronous code in Python, allowing you to take advantage of the benefits of concurrency and improve the performance of your applications.
```python
import asyncio
import httpx

async def use_code(client):
resp = await client.post(f'http://victim.com', cookies={"session": "asdasdasd"}, data={"code": "123123123"})
return resp.text

async def main():
async with httpx.AsyncClient() as client:
tasks = []
for _ in range(20): #20 times
tasks.append(asyncio.ensure_future(use_code(client)))

# Get responses
results = await asyncio.gather(*tasks, return_exceptions=True)

# Print results
for r in results:
print(r)

# Async2sync sleep
await asyncio.sleep(0.5)
print(results)

asyncio.run(main())
```
## **Metodologia RC**

### Limit-overrun / TOCTOU

Questo √® il tipo pi√π basilare di race condition in cui si trovano vulnerabilit√† in luoghi che limitano il numero di volte in cui √® possibile eseguire un'azione. Come ad esempio utilizzare lo stesso codice sconto pi√π volte in un negozio online. Un esempio molto semplice pu√≤ essere trovato in [questo rapporto](https://medium.com/@pravinponnusamy/race-condition-vulnerability-found-in-bug-bounty-program-573260454c43) o in [questo bug](https://hackerone.com/reports/759247).

Ci sono molte varianti di questo tipo di attacco, tra cui:

* Utilizzare pi√π volte una carta regalo
* Valutare pi√π volte un prodotto
* Prelevare o trasferire denaro in eccesso rispetto al saldo del tuo conto
* Riutilizzare una singola soluzione CAPTCHA
* Superare un limite di velocit√† anti-brute-force

### **Hidden substates**

Sfruttare race condition complesse spesso implica approfittare di brevi opportunit√† per interagire con sub-stati nascosti o non intenzionali della macchina. Ecco come affrontare questo problema:

1. **Identificare i potenziali sub-stati nascosti**
- Inizia individuando i punti finali che modificano o interagiscono con dati critici, come i profili utente o i processi di reset della password. Concentrati su:
- **Archiviazione**: Preferisci i punti finali che manipolano dati persistenti lato server rispetto a quelli che gestiscono dati lato client.
- **Azione**: Cerca operazioni che modificano dati esistenti, che sono pi√π suscettibili di creare condizioni sfruttabili rispetto a quelle che aggiungono nuovi dati.
- **Chiave**: Gli attacchi riusciti di solito coinvolgono operazioni basate sullo stesso identificatore, ad esempio nome utente o token di reset.

2. **Conduci una sonda iniziale**
- Testa i punti finali identificati con attacchi di race condition, osservando eventuali deviazioni dai risultati attesi. Risposte inaspettate o cambiamenti nel comportamento dell'applicazione possono indicare una vulnerabilit√†.

3. **Dimostra la vulnerabilit√†**
- Riduci l'attacco al numero minimo di richieste necessarie per sfruttare la vulnerabilit√†, spesso solo due. Questo passaggio potrebbe richiedere pi√π tentativi o automazione a causa della precisione temporale coinvolta.

### Attacchi sensibili al tempo

La precisione nel temporizzare le richieste pu√≤ rivelare vulnerabilit√†, specialmente quando vengono utilizzati metodi prevedibili come i timestamp per i token di sicurezza. Ad esempio, generare token di reset della password basati sui timestamp potrebbe consentire token identici per richieste simultanee.

**Per sfruttare:**
- Utilizza una temporizzazione precisa, come un attacco a pacchetto singolo, per effettuare richieste di reset della password simultanee. I token identici indicano una vulnerabilit√†.

**Esempio:**
- Richiedi due token di reset della password contemporaneamente e confrontali. I token corrispondenti suggeriscono una falla nella generazione dei token.

**Verifica questo [Laboratorio PortSwigger](https://portswigger.net/web-security/race-conditions/lab-race-conditions-exploiting-time-sensitive-vulnerabilities) per provarlo.**


## Studi di caso sui sub-stati nascosti

### Pagare e aggiungere un articolo

Verifica questo [**Laboratorio PortSwigger**](https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-insufficient-workflow-validation) per vedere come **pagare** in un negozio e **aggiungere un articolo extra** che non sar√† necessario pagare.

### Confermare altre email

L'idea √® quella di **verificare un indirizzo email e cambiarlo contemporaneamente** per scoprire se la piattaforma verifica il nuovo indirizzo modificato.

### Cambiare email in 2 indirizzi email basati su cookie

Secondo [**questa ricerca**](https://portswigger.net/research/smashing-the-state-machine) Gitlab era vulnerabile a un takeover in questo modo perch√© potrebbe **inviare il token di verifica dell'email di un'email all'altra email**.

**Verifica questo [Laboratorio PortSwigger](https://portswigger.net/web-security/race-conditions/lab-race-conditions-single-endpoint) per provarlo.**

### Stati nascosti del database / Bypass di conferma

Se vengono utilizzate **2 scritture diverse** per **aggiungere informazioni** all'interno di un **database**, c'√® una piccola porzione di tempo in cui **solo il primo dato √® stato scritto** all'interno del database. Ad esempio, quando si crea un utente, il **nome utente** e la **password** potrebbero essere **scritti** e **successivamente il token** per confermare il nuovo account viene scritto. Ci√≤ significa che per un breve periodo di tempo il **token per confermare un account √® nullo**.

Pertanto, **registrare un account e inviare diverse richieste con un token vuoto** (`token=` o `token[]=` o qualsiasi altra variazione) per confermare immediatamente l'account potrebbe consentire di **confermare un account** in cui non si controlla l'email.

**Verifica questo [Laboratorio PortSwigger](https://portswigger.net/web-security/race-conditions/lab-race-conditions-partial-construction) per provarlo.**

### Bypass 2FA

Il seguente pseudocodice √® vulnerabile a una race condition perch√© in un periodo di tempo molto breve il **2FA non viene applicato** mentre viene creato il sessione:
```python
session['userid'] = user.userid
if user.mfa_enabled:
session['enforce_mfa'] = True
# generate and send MFA code to user
# redirect browser to MFA code entry form
```
### Persistenza eterna di OAuth2

Ci sono diversi [**fornitori di OAuth**](https://en.wikipedia.org/wiki/List\_of\_OAuth\_providers). Questi servizi ti permetteranno di creare un'applicazione e autenticare gli utenti registrati presso il fornitore. Per fare ci√≤, il **client** dovr√† **permettere all'applicazione** di accedere ad alcuni dei loro dati all'interno del **fornitore di OAuth**.\
Quindi, fino a qui √® solo un normale accesso con google/linkedin/github... dove ti viene mostrata una pagina che dice: "_L'applicazione \<InsertCoolName> vuole accedere alle tue informazioni, vuoi permetterlo?_"

#### Race Condition in `authorization_code`

Il **problema** si presenta quando **accetti** e invii automaticamente un **`authorization_code`** all'applicazione malevola. Quindi, questa **applicazione sfrutta una Race Condition nel servizio di OAuth per generare pi√π di un AT/RT** (_Authentication Token/Refresh Token_) dal **`authorization_code`** per il tuo account. Fondamentalmente, sfrutter√† il fatto che hai accettato l'applicazione per accedere ai tuoi dati per **creare diversi account**. Quindi, se **smetti di permettere all'applicazione di accedere ai tuoi dati, una coppia di AT/RT verr√† eliminata, ma le altre saranno ancora valide**.

#### Race Condition in `Refresh Token`

Una volta che hai **ottenuto un RT valido**, potresti provare a **sfruttarlo per generare diversi AT/RT** e **anche se l'utente cancella le autorizzazioni** per l'applicazione malevola di accedere ai suoi dati, **diversi RT saranno ancora validi**.

## **RC in WebSockets**

In [**WS\_RaceCondition\_PoC**](https://github.com/redrays-io/WS\_RaceCondition\_PoC) puoi trovare un PoC in Java per inviare messaggi websocket in **parallelo** per sfruttare **Race Conditions anche in Web Sockets**.

## Riferimenti

* [https://hackerone.com/reports/759247](https://hackerone.com/reports/759247)
* [https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html](https://pandaonair.com/2020/06/11/race-conditions-exploring-the-possibilities.html)
* [https://hackerone.com/reports/55140](https://hackerone.com/reports/55140)
* [https://portswigger.net/research/smashing-the-state-machine](https://portswigger.net/research/smashing-the-state-machine)
* [https://portswigger.net/web-security/race-conditions](https://portswigger.net/web-security/race-conditions)

<details>

<summary><strong>Impara l'hacking di AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata in HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PACCHETTI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**The PEASS Family**](https://opensea.io/collection/the-peass-family), la nostra collezione di esclusive [**NFT**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR a** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Usa [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) per creare e **automatizzare facilmente flussi di lavoro** basati sugli strumenti comunitari pi√π avanzati al mondo.\
Ottieni l'accesso oggi stesso:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}
