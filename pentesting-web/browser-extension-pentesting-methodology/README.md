# ブラウザ拡張機能の侵入テスト方法論

<details>

<summary><strong>htARTE（HackTricks AWS Red Team Expert）</strong>を使って、ゼロからヒーローまでAWSハッキングを学ぶ</summary>

HackTricksをサポートする他の方法:

* **HackTricksで企業を宣伝したい**または**HackTricksをPDFでダウンロードしたい**場合は、[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS＆HackTricksグッズ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクションを見つける
* **💬 [Discordグループ](https://discord.gg/hRep4RUj7f)**または[telegramグループ](https://t.me/peass)に**参加**するか、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)を**フォロー**する。
* **HackTricks**と**HackTricks Cloud**のgithubリポジトリにPRを提出して、あなたのハッキングテクニックを共有してください。

</details>

## 基本情報

ブラウザ拡張機能はJavaScriptで書かれ、ブラウザによってバックグラウンドで読み込まれます。それは自身の[DOM](https://www.w3schools.com/js/js\_htmldom.asp)を持っており、他のサイトのDOMとやり取りすることができます。これは他のサイトの機密性、整合性、可用性（CIA）を危険にさらす可能性があります。

## 主要コンポーネント

拡張機能のレイアウトは視覚化された際に最も見栄えがよく、3つのコンポーネントで構成されています。それぞれのコンポーネントを詳しく見てみましょう。

<figure><img src="../../.gitbook/assets/image (16) (1).png" alt=""><figcaption><p><a href="http://webblaze.cs.berkeley.edu/papers/Extensions.pdf">http://webblaze.cs.berkeley.edu/papers/Extensions.pdf</a></p></figcaption></figure>

### **コンテンツスクリプト**

各コンテンツスクリプトは**単一のWebページ**のDOMに直接アクセスでき、したがって**潜在的に悪意のある入力**にさらされます。ただし、コンテンツスクリプトには、拡張機能コアにメッセージを送信する権限以外はありません。

### **拡張機能コア**

拡張機能コアには、拡張機能のほとんどの権限/アクセスが含まれていますが、拡張機能コアは[XMLHttpRequest](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest)およびコンテンツスクリプトを介してWebコンテンツとのみやり取りできます。また、拡張機能コアはホストマシンに直接アクセスする権限を持っていません。

### **ネイティブバイナリ**

拡張機能には、ユーザーの完全な権限を持つホストマシンにアクセスできるネイティブバイナリが含まれています。ネイティブバイナリは、Flashや他のブラウザプラグインで使用される標準のNetscape Plugin Application Programming Interface（[NPAPI](https://en.wikipedia.org/wiki/NPAPI)）を介して拡張機能コアとやり取りします。

### 境界

{% hint style="danger" %}
ユーザーの完全な権限を取得するには、攻撃者はコンテンツスクリプトから拡張機能コアに、そして拡張機能コアからネイティブバイナリに悪意のある入力を渡すように拡張機能を説得する必要があります。
{% endhint %}

拡張機能の各コンポーネントは、**強力な保護境界**によって互いに分離されています。各コンポーネントは**別々のオペレーティングシステムプロセス**で実行されます。コンテンツスクリプトと拡張機能コアは、ほとんどのオペレーティングシステムサービスには利用できない**サンドボックスプロセス**で実行されます。

さらに、コンテンツスクリプトは**別々のJavaScriptヒープ**で実行され、関連するWebページから分離されます。コンテンツスクリプトとWebページは**同じ基礎となるDOMにアクセス**できますが、2つは**JavaScriptポインタを交換せず**、JavaScript機能の漏洩を防ぎます。

## **`manifest.json`**

Chrome拡張機能は、[.crxファイル拡張子](https://www.lifewire.com/crx-file-2620391)を持つZIPフォルダーです。拡張機能のコアは、フォルダーのルートにある**`manifest.json`**ファイルで、レイアウト、権限、およびその他の構成オプションを指定します。

例：
```json
{
"manifest_version": 2,
"name": "My extension",
"version": "1.0",
"permissions": [
"storage"
],
"content_scripts": [
{
"js": [
"script.js"
],
"matches": [
"https://example.com/*",
"https://www.example.com/*"
],
"exclude_matches": ["*://*/*business*"],
}
],
"background": {
"scripts": [
"background.js"
]
},
"options_ui": {
"page": "options.html"
}
}
```
### `content_scripts`

コンテンツスクリプトは、ユーザーが一致するページに移動するたびに**ロードされます**。この場合、**`https://example.com/*`**と一致するページおよび**`*://*/*/business*`**と一致しないページです。これらはページ自体のスクリプトのように**実行され、ページの[Document Object Model (DOM)](https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model)**に任意アクセスできます。
```json
"content_scripts": [
{
"js": [
"script.js"
],
"matches": [
"https://example.com/*",
"https://www.example.com/*"
],
"exclude_matches": ["*://*/*business*"],
}
],
```
以下は、**`include_globs`** と **`exclude_globs`** を使用してさらにURLを含めたり除外したりする方法です。

これは、ページに説明ボタンを追加するコンテンツスクリプトの例です。[ストレージAPI](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/storage)を使用して、拡張機能のストレージから `message` の値を取得します。
```js
chrome.storage.local.get("message", result =>
{
let div = document.createElement("div");
div.innerHTML = result.message + " <button>Explain</button>";
div.querySelector("button").addEventListener("click", () =>
{
chrome.runtime.sendMessage("explain");
});
document.body.appendChild(div);
});
```
<figure><img src="../../.gitbook/assets/image (23).png" alt=""><figcaption></figcaption></figure>

このボタンがクリックされると、コンテンツスクリプトによって拡張機能ページにメッセージが送信されます。これは、`storage`が例外の中にあるため、コンテンツスクリプトがAPIに直接アクセスできない制限によるものです。これらの例外を超える機能が必要な場合、コンテンツスクリプトが通信できる拡張機能ページにメッセージが送信されます。

{% hint style="warning" %}
ブラウザによって、コンテンツスクリプトの機能はわずかに異なる場合があります。Chromiumベースのブラウザでは、機能のリストは[Chrome Developers documentation](https://developer.chrome.com/docs/extensions/mv3/content\_scripts/#capabilities)で利用可能であり、Firefoxでは[MDN](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/Content\_scripts#webextension\_apis)が主要な情報源となります。\
また、コンテンツスクリプトはバックグラウンドスクリプトと通信する能力を持ち、アクションを実行し、応答を返すことができます。
{% endhint %}

Chromeでコンテンツスクリプトを表示およびデバッグするには、Chromeデベロッパーツールメニューにアクセスし、Options > More tools > Developer toolsを選択するか、Ctrl + Shift + Iを押します。

デベロッパーツールが表示されたら、**Sourceタブ**をクリックし、その後**Content Scriptsタブ**をクリックします。これにより、さまざまな拡張機能から実行中のコンテンツスクリプトを観察し、実行フローを追跡するためのブレークポイントを設定できます。

### 注入されたコンテンツスクリプト

{% hint style="success" %}
**コンテンツスクリプトは必須ではない**ことに注意してください。**動的にスクリプトを注入**したり、**`tabs.executeScript`**を使用してウェブページに**プログラム的に注入**することも可能です。これにより、より**細かい制御**が可能になります。
{% endhint %}

コンテンツスクリプトをプログラム的に注入するには、スクリプトを注入するページに対して[ホスト権限](https://developer.chrome.com/docs/extensions/reference/permissions)が拡張機能に必要です。これらの権限は、拡張機能のマニフェスト内でそれらを**要求**するか、[**activeTab**](https://developer.chrome.com/docs/extensions/reference/manifest/activeTab)を介して一時的にセキュリティを確保することができます。

#### activeTabベースの拡張機能の例

{% code title="manifest.json" %}
```json
{
"name": "My extension",
...
"permissions": [
"activeTab",
"scripting"
],
"background": {
"service_worker": "background.js"
},
"action": {
"default_title": "Action Button"
}
}
```
{% endcode %}

* **クリック時にJSファイルをインジェクトする:**
```javascript
// content-script.js
document.body.style.backgroundColor = "orange";

//service-worker.js - Inject the JS file
chrome.action.onClicked.addListener((tab) => {
chrome.scripting.executeScript({
target: { tabId: tab.id },
files: ["content-script.js"]
});
});
```
* **クリック時に関数を注入する**:
```javascript
//service-worker.js - Inject a function
function injectedFunction() {
document.body.style.backgroundColor = "orange";
}

chrome.action.onClicked.addListener((tab) => {
chrome.scripting.executeScript({
target : {tabId : tab.id},
func : injectedFunction,
});
});
```
#### スクリプト権限の例
```javascript
// service-workser.js
chrome.scripting.registerContentScripts([{
id : "test",
matches : [ "https://*.example.com/*" ],
excludeMatches : [ "*://*/*business*" ],
js : [ "contentScript.js" ],
}]);

// Another example
chrome.tabs.executeScript(tabId, { file: "content_script.js" });
```
### Content Scripts `run_at`

`run_at`フィールドは、**JavaScriptファイルがWebページに注入されるタイミング**を制御します。推奨されるデフォルト値は`"document_idle"`です。

可能な値は次のとおりです：

- **`document_idle`**：可能な限り
- **`document_start`**：`css`からのファイルの後、ただし他のDOMが構築される前や他のスクリプトが実行される前に
- **`document_end`**：DOMが完全になった直後、ただし画像やフレームなどのサブリソースが読み込まれる前

#### `manifest.json`を介して
```json
{
"name": "My extension",
...
"content_scripts": [
{
"matches": ["https://*.example.com/*"],
"run_at": "document_idle",
"js": ["contentScript.js"]
}
],
...
}

```
**`service-worker.js`**を介して
```javascript
chrome.scripting.registerContentScripts([{
id : "test",
matches : [ "https://*.example.com/*" ],
runAt : "document_idle",
js : [ "contentScript.js" ],
}]);
```
### `バックグラウンド`

コンテンツスクリプトによって送信されるメッセージは、**バックグラウンドページ**によって受信されます。このページは、拡張機能のコンポーネントを調整する中心的な役割を果たします。特筆すべきは、バックグラウンドページが拡張機能の寿命全体にわたって持続し、直接的なユーザーとのやり取りなしに静かに動作します。独自のDocument Object Model（DOM）を持ち、複雑な相互作用や状態管理を可能にします。

**主なポイント**:

* **バックグラウンドページの役割:** 拡張機能の中心部として機能し、拡張機能のさまざまな部分との通信と調整を確実にします。
* **持続性:** ユーザーには見えないが、拡張機能の機能性には不可欠な、常に存在するエンティティです。
* **自動生成:** 明示的に定義されていない場合、ブラウザは自動的にバックグラウンドページを作成します。この自動生成されたページには、拡張機能のマニフェストで指定されたすべてのバックグラウンドスクリプトが含まれ、拡張機能のバックグラウンドタスクのシームレスな動作を保証します。

{% hint style="success" %}
ブラウザがバックグラウンドページを自動生成することで（明示的に宣言されていない場合）、必要なすべてのバックグラウンドスクリプトが統合され、操作されることで、拡張機能のセットアッププロセスが合理化されます。
{% endhint %}

例: バックグラウンドスクリプト:
```js
chrome.runtime.onMessage.addListener((request, sender, sendResponse) =>
{
if (request == "explain")
{
chrome.tabs.create({ url: "https://example.net/explanation" });
}
})
```
It uses [runtime.onMessage API](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/runtime/onMessage) to listen to messages. When an `"explain"` message is received, it uses [tabs API](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/tabs) to open a page in a new tab.

To debug the background script you could go to the **extension details and inspect the service worker,** this will open the developer tools with the background script:

<figure><img src="https://github.com/carlospolop/hacktricks/blob/master/pentesting-web/browser-extension-pentesting-methodology/broken-reference" alt=""><figcaption></figcaption></figure>

### Options pages and other

Browser extensions can contain various kinds of pages:

* **Action pages** are displayed in a **drop-down when the extension ico**n is clicked.
* Pages that the extension will **load in a new tab**.
* **Option Pages**: This page displays on top of the extension when clicked. In the previous manifest In my case I was able to access this page in `chrome://extensions/?options=fadlhnelkbeojnebcbkacjilhnbjfjca` or clicking:

<figure><img src="../../.gitbook/assets/image (24).png" alt="" width="375"><figcaption></figcaption></figure>

Note that these pages aren't persistent like background pages as they load dynamically content on necessity. Despite this, they share certain capabilities with the background page:

* **Communication with Content Scripts:** Similar to the background page, these pages can receive messages from content scripts, facilitating interaction within the extension.
* **Access to Extension-Specific APIs:** These pages enjoy comprehensive access to extension-specific APIs, subject to the permissions defined for the extension.

### `permissions` & `host_permissions`

**`permissions`** and **`host_permissions`** are entries from the `manifest.json` that will indicate **which permissions** the browser extensions has (storage, location...) and in **which web pages**.

As browser extensions can be so **privileged**, a malicious one or one being compromised could allow the attacker **different means to steal sensitive information and spy on the user**.

Check how these settings work and how they could get abused in:

{% content-ref url="browext-permissions-and-host_permissions.md" %}
[browext-permissions-and-host\_permissions.md](browext-permissions-and-host\_permissions.md)
{% endcontent-ref %}

### `content_security_policy`

A **content security policy** can be declared also inside the `manifest.json`. If there is one defined, it could be **vulnerable**.

The default setting for browser extension pages is rather restrictive:
```bash
script-src 'self'; object-src 'self';
```
以下はCSPと潜在的なバイパスに関する詳細情報です：

{% content-ref url="../content-security-policy-csp-bypass/" %}
[content-security-policy-csp-bypass](../content-security-policy-csp-bypass/)
{% endcontent-ref %}

### `web_accessible_resources`

ウェブページがブラウザ拡張機能のページ（例：`.html`ページ）にアクセスするためには、`manifest.json`の**`web_accessible_resources`**フィールドにこのページを記述する必要があります。\
例：
```javascript
{
...
"web_accessible_resources": [
{
"resources": [ "images/*.png" ],
"matches": [ "https://example.com/*" ]
},
{
"resources": [ "fonts/*.woff" ],
"matches": [ "https://example.com/*" ]
}
],
...
}
```
これらのページは次のようなURLでアクセスできます：
```
chrome-extension://<extension-id>/message.html
```
公開拡張機能では、**extension-id がアクセス可能**です：

<figure><img src="../../.gitbook/assets/image (1194).png" alt="" width="375"><figcaption></figcaption></figure>

ただし、`manifest.json` パラメータ **`use_dynamic_url`** が使用されている場合、この **id は動的になる**可能性があります。

{% hint style="success" %}
ここでページが言及されていても、**Content Security Policy** によって **ClickJacking に対して保護**されている可能性があるため、ClickJacking 攻撃が可能かどうかを確認する前にそれをチェックする必要があります（frame-ancestors セクション）。
{% endhint %}

これらのページにアクセスできるようにすることで、これらのページは **潜在的に脆弱な ClickJacking** を引き起こす可能性があります：

{% content-ref url="browext-clickjacking.md" %}
[browext-clickjacking.md](browext-clickjacking.md)
{% endcontent-ref %}

{% hint style="success" %}
これらのページがランダムな URL ではなく拡張機能によってのみ読み込まれるようにすると、ClickJacking 攻撃を防ぐことができます。
{% endhint %}

{% hint style="danger" %}
**`web_accessible_resources`** からのページや拡張機能の他のページも **バックグラウンドスクリプトに接触**することができます。したがって、これらのページのうちの1つが **XSS に脆弱**である場合、より大きな脆弱性が開かれる可能性があります。

さらに、**`web_accessible_resources`** で指定されたページは iframes 内でのみ開くことができますが、新しいタブからは拡張機能内の任意のページにアクセスすることができます。したがって、同じパラメータを悪用した XSS が見つかった場合、そのページが **`web_accessible_resources`** に構成されていなくても悪用される可能性があります。
{% endhint %}

### `externally_connectable`

[**ドキュメント**](https://developer.chrome.com/docs/extensions/reference/manifest/externally-connectable) によると、`"externally_connectable"` マニフェスト プロパティは、[runtime.connect](https://developer.chrome.com/docs/extensions/reference/runtime#method-connect) および [runtime.sendMessage](https://developer.chrome.com/docs/extensions/reference/runtime#method-sendMessage) を介して拡張機能に接続できる **どの拡張機能や Web ページが接続できるか** を宣言します。

- 拡張機能のマニフェストで **`externally_connectable`** キーが宣言されていないか、**`"ids": ["*"]`** として宣言されている場合、**すべての拡張機能が接続できますが、Web ページは接続できません**。
- 特定の ID が指定されている場合、たとえば `"ids": ["aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"]` のように、**それらのアプリケーションのみ** 接続できます。
- 一致が指定されている場合、それらの Web アプリが接続できます：
```json
"matches": [
"https://*.google.com/*",
"*://*.chromium.org/*",
```
* もし空として指定されている場合: **`"externally_connectable": {}`**、どのアプリやウェブも接続できません。

ここで示されている**拡張機能やURLが少ないほど**、**攻撃面が小さく**なります。

{% hint style="danger" %}
もし**`externally_connectable`**で示されたウェブページが**XSSに対して脆弱**である場合、攻撃者は**バックグラウンドスクリプトに直接メッセージを送信**することができ、Content ScriptとそのCSPを完全にバイパスできます。

したがって、これは**非常に強力なバイパス**です。

さらに、クライアントが不正な拡張機能をインストールした場合、脆弱な拡張機能との通信が許可されていなくても、許可されたウェブページに**XSSデータを注入**したり、**`WebRequest`**や**`DeclarativeNetRequest`** APIを悪用して対象ドメインのリクエストを操作し、ページのリクエストを**JavaScriptファイル**に変更する可能性があります（対象ページのCSPがこれらの攻撃を防ぐ可能性があります）。このアイデアは[**この解説から来ています**](https://www.darkrelay.com/post/opera-zero-day-rce-vulnerability)。
{% endhint %}

## 通信の要約

### 拡張機能 <--> Webアプリ

コンテンツスクリプトとウェブページ間で通信するためには通常、メッセージの投稿が使用されます。したがって、Webアプリケーションでは通常、**`window.postMessage`** 関数への呼び出しや、コンテンツスクリプト内のリスナーである **`window.addEventListener`** のようなものが見つかります。ただし、拡張機能は**ウェブアプリケーションに Post Message を送信する**こともできます（したがって、ウェブはそれを期待する必要があります）、または単にウェブに新しいスクリプトを読み込ませることもできます。

### 拡張機能内部

通常、**`chrome.runtime.sendMessage`** 関数が拡張機能内でメッセージを送信するために使用され（通常は`background`スクリプトで処理されます）、それを受信して処理するためには、**`chrome.runtime.onMessage.addListener`** を呼び出すリスナーが宣言されます。

また、**`chrome.runtime.connect()`** を使用して単一のメッセージを送信する代わりに永続的な接続を持つことも可能で、次の例のようにそれを使用して**メッセージを送信**および**受信**することができます：

<details>

<summary><code>chrome.runtime.connect()</code> の例</summary>
```javascript
var port = chrome.runtime.connect();

// Listen for messages from the web page
window.addEventListener("message", (event) => {
// Only accept messages from the same window
if (event.source !== window) {
return;
}

// Check if the message type is "FROM_PAGE"
if (event.data.type && (event.data.type === "FROM_PAGE")) {
console.log("Content script received: " + event.data.text);
// Forward the message to the background script
port.postMessage({ type: 'FROM_PAGE', text: event.data.text });
}
}, false);

// Listen for messages from the background script
port.onMessage.addListener(function(msg) {
console.log("Content script received message from background script:", msg);
// Handle the response message from the background script
});
```
</details>

バックグラウンドスクリプトから特定のタブにあるコンテンツスクリプトにメッセージを送信することも可能で、**`chrome.tabs.sendMessage`**を呼び出すことで、メッセージを送信するために**タブのID**を指定する必要があります。

### 拡張機能への`externally_connectable`から

`externally_connectable`構成で許可された**Webアプリケーションと外部ブラウザ拡張機能**は、次のようにしてリクエストを送信できます：
```javascript
chrome.runtime.sendMessage(extensionId, ...
```
## Web **↔︎** Content Script Communication

**コンテンツスクリプト**が動作し、ホストページが存在する環境はお互いに**分離**されており、**隔離**が確保されています。この隔離状態にもかかわらず、両者はページの**Document Object Model (DOM)** という共有リソースとやり取りする能力を持っています。ホストページが**コンテンツスクリプト**と通信したり、コンテンツスクリプトを介して間接的に拡張機能と通信するためには、両者がアクセス可能な**DOM**を通信チャネルとして利用する必要があります。

### ポストメッセージ

{% code title="content-script.js" %}
```javascript
// This is like "chrome.runtime.sendMessage" but to maintain the connection
var port = chrome.runtime.connect();

window.addEventListener("message", (event) => {
// We only accept messages from ourselves
if (event.source !== window) {
return;
}

if (event.data.type && (event.data.type === "FROM_PAGE")) {
console.log("Content script received: " + event.data.text);
// Forward the message to the background script
port.postMessage(event.data.text);
}
}, false);
```
{% endcode %}

{% code title="example.js" %}
```javascript
document.getElementById("theButton").addEventListener("click", () => {
window.postMessage(
{type : "FROM_PAGE", text : "Hello from the webpage!"}, "*");
}, false);
```
{% endcode %}

セキュアなPost Message通信は、受信したメッセージの信頼性をチェックする必要があります。これは以下のように行うことができます:

* **`event.isTrusted`**: この値は、イベントがユーザーのアクションによってトリガーされた場合にのみTrueです。
* コンテンツスクリプトは、ユーザーが特定のアクションを実行した場合にのみメッセージを期待するかもしれません。
* **オリジンドメイン**: メッセージを期待するのは特定のドメインのみかもしれません。
* 正規表現を使用する場合は非常に注意してください。
* **ソース**: `received_message.source !== window` は、Content Scriptがリスニングしている**同じウィンドウからのメッセージ**かどうかをチェックするために使用できます。

前述のチェックは、実行されていても脆弱性がある可能性があるため、次のページで**潜在的なPost Messageバイパス**をチェックしてください:

{% content-ref url="../postmessage-vulnerabilities/" %}
[postmessage-vulnerabilities](../postmessage-vulnerabilities/)
{% endcontent-ref %}

### Iframe

もう1つの通信方法は**Iframe URL**を介したものです。例は以下で見つけることができます:

{% content-ref url="browext-xss-example.md" %}
[browext-xss-example.md](browext-xss-example.md)
{% endcontent-ref %}

### DOM

これは厳密には通信方法ではありませんが、**webとコンテンツスクリプトはweb DOMにアクセスできます**。したがって、**コンテンツスクリプト**がそれから情報を読み取っている場合、**web DOMを信頼している**場合、webはこのデータを**変更**できる可能性があります（webは信頼されていないか、XSSの脆弱性があるため）そして**Content Scriptを危険にさらす**可能性があります。

また、**ブラウザ拡張機能を危険にさらすDOMベースのXSSの例**を以下で見つけることができます:

{% content-ref url="browext-xss-example.md" %}
[browext-xss-example.md](browext-xss-example.md)
{% endcontent-ref %}

## Content Script **↔︎** Background Script Communication

Content Scriptは、[**runtime.sendMessage()**](https://developer.chrome.com/docs/extensions/reference/runtime#method-sendMessage) **または** [**tabs.sendMessage()**](https://developer.chrome.com/docs/extensions/reference/tabs#method-sendMessage) 関数を使用して**ワンタイムのJSONシリアライズ可能な**メッセージを送信できます。

**応答**を処理するには、返された**Promise**を使用します。ただし、後方互換性のために、最後の引数として**コールバック**を渡すこともできます。

**コンテンツスクリプト**からリクエストを送信する方法は次のようになります:
```javascript
(async () => {
const response = await chrome.runtime.sendMessage({greeting: "hello"});
// do something with response here, not outside the function
console.log(response);
})();
```
**拡張機能**からリクエストを送信します（通常は**バックグラウンドスクリプト**）。選択したタブのコンテンツスクリプトにメッセージを送信する方法の例：
```javascript
// From https://stackoverflow.com/questions/36153999/how-to-send-a-message-between-chrome-extension-popup-and-content-script
(async () => {
const [tab] = await chrome.tabs.query({active: true, lastFocusedWindow: true});
const response = await chrome.tabs.sendMessage(tab.id, {greeting: "hello"});
// do something with response here, not outside the function
console.log(response);
})();
```
**受信側**では、メッセージを処理するために[**runtime.onMessage**](https://developer.chrome.com/docs/extensions/reference/runtime#event-onMessage) **イベントリスナー**を設定する必要があります。これはコンテンツスクリプトや拡張機能ページから見た場合に同じように見えます。
```javascript
// From https://stackoverflow.com/questions/70406787/javascript-send-message-from-content-js-to-background-js
chrome.runtime.onMessage.addListener(
function(request, sender, sendResponse) {
console.log(sender.tab ?
"from a content script:" + sender.tab.url :
"from the extension");
if (request.greeting === "hello")
sendResponse({farewell: "goodbye"});
}
);
```
例で強調されたように、**`sendResponse()`** は同期的に実行されました。`sendResponse()` を非同期に実行するために `onMessage` イベントハンドラを変更するには、`return true;` を組み込むことが重要です。

重要な考慮事項として、複数のページが `onMessage` イベントを受信するシナリオでは、特定のイベントに対して最初に `sendResponse()` を実行するページだけが効果的に応答を提供できます。同じイベントへの後続の応答は考慮されません。

新しい拡張機能を作成する際には、コールバックではなくプロミスを使用することが好ましいです。コールバックの使用に関しては、`sendResponse()` 関数は、同期的なコンテキスト内で直接実行されるか、イベントハンドラが非同期操作を示すために `true` を返す場合にのみ有効と見なされます。ハンドラのいずれも `true` を返さない場合や、`sendResponse()` 関数がメモリから削除された場合（ガベージコレクトされた場合）、`sendMessage()` 関数に関連付けられたコールバックがデフォルトでトリガーされます。

## メモリ/コード/クリップボード内の機密情報

ブラウザ拡張機能が**メモリ内に機密情報を保存**している場合、これらの情報は（特にWindowsマシンで）**ダンプ**され、この情報を**検索**することができます。

したがって、ブラウザ拡張機能のメモリは**安全ではない**と見なされ、資格情報やニーモニックフレーズなどの**機密情報は保存されてはいけません**。

もちろん、コードに機密情報を入れないでください。それは**公開**されます。

ブラウザからメモリをダンプするには、プロセスメモリをダンプするか、ブラウザ拡張機能の設定に移動して**`Inspect pop-up`**をクリックし、**`Memory`**セクションで**`Take a snaphost`**をクリックし、スナップショット内で機密情報を検索するために**`CTRL+F`**を使用できます。

さらに、ニーモニックキーまたはパスワードなどの非常に機密性の高い情報は、クリップボードにコピーされることを許可すべきではありません（または少なくとも数秒後にクリップボードから削除する必要があります）、なぜならばその後、クリップボードを監視するプロセスがそれらを取得できるからです。

## ブラウザでの拡張機能の読み込み

1. ブラウザ拡張機能を**ダウンロード**して解凍します
2. **`chrome://extensions/`** に移動し、`Developer Mode`を**有効**にします
3. **`Load unpacked`** ボタンをクリックします

**Firefox**では、**`about:debugging#/runtime/this-firefox`** に移動し、**`Load Temporary Add-on`** ボタンをクリックします。

## ストアからソースコードを取得する

Chrome拡張機能のソースコードはさまざまな方法で取得できます。以下に各オプションの詳細な説明と手順を示します。

### コマンドラインを使用してZIP形式で拡張機能をダウンロード

Chrome拡張機能のソースコードは、コマンドラインを使用してZIPファイルとしてダウンロードすることができます。これには、`curl`を使用して特定のURLからZIPファイルを取得し、ZIPファイルの内容をディレクトリに展開する必要があります。以下は手順です：

1. `"extension_id"` を実際の拡張機能のIDに置き換えます。
2. 次のコマンドを実行します：
```bash
extension_id=your_extension_id   # Replace with the actual extension ID
curl -L -o "$extension_id.zip" "https://clients2.google.com/service/update2/crx?response=redirect&os=mac&arch=x86-64&nacl_arch=x86-64&prod=chromecrx&prodchannel=stable&prodversion=44.0.2403.130&x=id%3D$extension_id%26uc"
unzip -d "$extension_id-source" "$extension_id.zip"
```
### CRX Viewer ウェブサイトを使用する

[https://robwu.nl/crxviewer/](https://robwu.nl/crxviewer/)

### CRX Viewer 拡張機能を使用する

もう1つの便利な方法は、オープンソースプロジェクトである Chrome 拡張機能ソースビューアを使用することです。[Chrome Web ストア](https://chrome.google.com/webstore/detail/chrome-extension-source-v/jifpbeccnghkjeaalbbjmodiffmgedin?hl=en) からインストールできます。ビューアのソースコードは、[GitHub リポジトリ](https://github.com/Rob--W/crxviewer)で入手できます。

### ローカルにインストールされた拡張機能のソースを表示する

ローカルにインストールされた Chrome 拡張機能も検査できます。以下の手順に従います：

1. `chrome://version/` にアクセスして、"Profile Path" フィールドを見つけて Chrome のローカルプロファイルディレクトリにアクセスします。
2. プロファイルディレクトリ内の `Extensions/` サブフォルダに移動します。
3. このフォルダには、通常、読みやすい形式でソースコードが含まれているすべてのインストールされた拡張機能が含まれています。

拡張機能を識別するために、それらの ID を名前にマッピングできます：

* `about:extensions` ページで「開発者モード」を有効にして、各拡張機能の ID を表示します。
* 各拡張機能のフォルダ内にある `manifest.json` ファイルには、拡張機能を識別するのに役立つ読みやすい `name` フィールドが含まれています。

### ファイルアーカイバまたはアンパッカーを使用する

Chrome Web ストアに移動して、拡張機能をダウンロードします。ファイルの拡張子は `.crx` になります。ファイルの拡張子を `.crx` から `.zip` に変更します。任意のファイルアーカイバ（WinRAR、7-Zip など）を使用して、ZIP ファイルの内容を抽出します。

### Chrome で開発者モードを使用する

Chrome を開いて `chrome://extensions/` に移動します。右上の「開発者モード」を有効にします。"アンパックされた拡張機能を読み込む" をクリックします。拡張機能のディレクトリに移動します。これによりソースコードはダウンロードされませんが、すでにダウンロードされたり開発された拡張機能のコードを表示および変更するのに便利です。

## セキュリティ監査チェックリスト

ブラウザ拡張機能は **攻撃面が限られています** が、一部には **脆弱性** や **潜在的な強化改善** が含まれている場合があります。以下は最も一般的なものです：

* [ ] **要求される `permissions` をできるだけ制限する**
* [ ] **`host_permissions` をできるだけ制限する**
* **`content_security_policy` を強化する**
* [ ] **`externally_connectable` をできるだけ制限する**。必要がない場合はデフォルトで残さず、`{}` を指定します。
* [ ] ここで **XSS または乗っ取りに脆弱な URL** が言及されている場合、攻撃者は **バックグラウンドスクリプトに直接メッセージを送信** できます。非常に強力なバイパスです。
* [ ] **`web_accessible_resources` をできるだけ制限する**。可能であれば空にしても構いません。
* [ ] もし **`web_accessible_resources` がない場合**、[**ClickJacking**](browext-clickjacking.md) をチェックします
* [ ] 拡張機能からウェブページへの **通信** が発生する場合、通信中に引き起こされる [**XSS の脆弱性**](browext-xss-example.md) をチェックします。
* [ ] Post Messages が使用されている場合、[**Post Message の脆弱性**](../postmessage-vulnerabilities/) をチェックします。
* [ ] **Content Script が DOM 詳細にアクセス** する場合、それらがウェブによって **変更** されると XSS を導入していないか確認します。
* [ ] この通信が **Content Script -> Background script 通信** にも関与している場合、特に注意してください。
* [ ] ブラウザ拡張機能の中に **機密情報を保存** すべきではありません
* [ ] ブラウザ拡張機能の中に **機密情報を保存** すべきではありません

## ツール

### [**Tarnish**](https://thehackerblog.com/tarnish/)

* 提供された Chrome Web ストアのリンクから任意の Chrome 拡張機能を取得します。
* [**manifest.json**](https://developer.chrome.com/extensions/manifest) **ビューア**：拡張機能のマニフェストの JSON フォーマットバージョンを簡単に表示します。
* **フィンガープリント解析**：[web\_accessible\_resources](https://developer.chrome.com/extensions/manifest/web\_accessible\_resources) の検出および Chrome 拡張機能のフィンガープリント JavaScript の自動生成。
* **潜在的な Clickjacking 解析**：[web\_accessible\_resources](https://developer.chrome.com/extensions/manifest/web\_accessible\_resources) ディレクティブが設定された拡張機能 HTML ページの検出。これらはページの目的に応じて Clickjacking の脆弱性があります。
* **許可警告ビューア**：ユーザーが拡張機能をインストールしようとすると表示されるすべての Chrome 許可プロンプト警告のリストを表示します。
* **危険な機能**：攻撃者によって悪用される可能性のある危険な機能の場所を表示します（たとえば、innerHTML、chrome.tabs.executeScript などの機能）。
* **エントリーポイント**：拡張機能がユーザー/外部入力を受け入れる場所を表示します。これは拡張機能の表面積を理解し、悪意のあるデータを拡張機能に送信する潜在的なポイントを探すのに役立ちます。
* 危険な機能とエントリーポイントのスキャナーには、次のものが生成されたアラートに含まれます：
* アラートを引き起こした関連するコードスニペットと行。
* 問題の説明。
* アラートを引き起こしたファイル全体を表示するための「ファイルを表示」ボタン。
* アラートされたファイルのパス。
* アラートされたファイルの完全な Chrome 拡張機能 URI。
* JavaScript ファイル内に脆弱な行がある場合、それが含まれているすべてのページのパスと、これらのページのタイプ、[web\_accessible\_resource](https://developer.chrome.com/extensions/manifest/web\_accessible\_resources) のステータス。
* **Content Security Policy (CSP) アナライザーおよびバイパスチェッカー**：拡張機能の CSP の弱点を指摘し、ホワイトリストに登録された CDN などによる CSP のバイパス方法を明らかにします。
* **既知の脆弱なライブラリ**：[Retire.js](https://retirejs.github.io/retire.js/) を使用して既知の脆弱な JavaScript ライブラリの使用をチェックします。
* 拡張機能とフォーマットされたバージョンをダウンロードします。
* オリジナルの拡張機能をダウンロードします。
* 拡張機能の整形されたバージョンをダウンロードします（自動整形された HTML および JavaScript）。
* スキャン結果の自動キャッシュ化。拡張機能のスキャンを実行すると、最初の実行にはかなりの時間がかかりますが、2回目以降は、拡張機能が更新されていない限り、結果がキャッシュされているためほぼ即座に実行されます。
* レポートの URL をリンクできるようにし、Tarnish によって生成された拡張機能レポートを他の人に簡単にリンクできるようにします。

### [Neto](https://github.com/elevenpaths/neto)

Project Neto は、Firefox や Chrome などのよく知られたブラウザ用のプラグインや拡張機能の隠れた機能を分析し解明するために設計された Python 3 パッケージです。このパッケージは、パッケージ化されたファイルを解凍して、`manifest.json`、ローカライゼーションフォルダ、JavaScript、および HTML ソースファイルからこれらの機能を抽出するプロセスを自動化します。

## 参考文献

* この方法論の支援に感謝します [**@naivenom**](https://twitter.com/naivenom)
* [https://www.cobalt.io/blog/introduction-to-chrome-browser-extension-security-testing](https://www.cobalt.io/blog/introduction-to-chrome-browser-extension-security-testing)
* [https://palant.info/2022/08/10/anatomy-of-a-basic-extension/](https://palant.info/2022/08/10/anatomy-of-a-basic-extension/)
* [https://palant.info/2022/08/24/attack-surface-of-extension-pages/](https://palant.info/2022/08/24/attack-surface-of-extension-pages/)
* [https://palant.info/2022/08/31/when-extension-pages-are-web-accessible/](https://palant.info/2022/08/31/when-extension-pages-are-web-accessible/)
* [https://help.passbolt.com/assets/files/PBL-02-report.pdf](https://help.passbolt.com/assets/files/PBL-02-report.pdf)
* [https://developer.chrome.com/docs/extensions/develop/concepts/content-scripts](https://developer.chrome.com/docs/extensions/develop/concepts/content-scripts)
* [https://developer.chrome.com/docs/extensions/mv2/background-pages](https://developer.chrome.com/docs/extensions/mv2/background-pages)
* [https://thehackerblog.com/kicking-the-rims-a-guide-for-securely-writing-and-auditing-chrome-extensions/](https://thehackerblog.com/kicking-the-rims-a-guide-for-securely-writing-and-auditing-chrome-extensions/)
* [https://gist.github.com/LongJohnCoder/9ddf5735df3a4f2e9559665fb864eac0](https://gist.github.com/LongJohnCoder/9ddf5735df3a4f2e9559665fb864eac0)

<details>

<summary><strong>htARTE（HackTricks AWS Red Team Expert）</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>でゼロからヒーローまでの AWS ハッキングを学ぶ</strong></a><strong>！</strong></summary>

HackTricks をサポートする他の方法:
* もし**HackTricksで会社を宣伝したい**か**HackTricksをPDFでダウンロードしたい**場合は、[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS & HackTricksグッズ**](https://peass.creator-spring.com)を入手してください
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)コレクションをご覧ください
* **💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)に参加するか、[**telegramグループ**](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**をフォロー**してください。
* **あなたのハッキングテクニックを共有するために、PRを** [**HackTricks**](https://github.com/carlospolop/hacktricks) **と** [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **のGitHubリポジトリに提出してください。**
