# M√©thodologie de Pentesting d'Extensions de Navigateur

<details>

<summary><strong>Apprenez le hacking AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Autres moyens de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop)!
* Obtenez le [**merchandising officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**La Famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection d'[**NFTs**](https://opensea.io/collection/the-peass-family) exclusifs
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez-moi** sur **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Partagez vos astuces de hacking en soumettant des PR aux d√©p√¥ts github** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## Informations de Base

Les extensions de navigateur sont √©crites en JavaScript et charg√©es par le navigateur en arri√®re-plan. Elles ont leur propre [DOM](https://www.w3schools.com/js/js_htmldom.asp) mais peuvent interagir avec le DOM d'autres sites. Cela signifie qu'elles peuvent compromettre la confidentialit√©, l'int√©grit√© et la disponibilit√© (CIA) d'autres sites.

## Composants Principaux

La structure d'une extension est mieux visualis√©e et se compose de trois composants. Examinons chaque composant en d√©tail.

<figure><img src="../../.gitbook/assets/image (4).png" alt=""><figcaption><p><a href="http://webblaze.cs.berkeley.edu/papers/Extensions.pdf">http://webblaze.cs.berkeley.edu/papers/Extensions.pdf</a></p></figcaption></figure>

### **Scripts de Contenu**

Chaque script de contenu a un acc√®s direct au DOM d'une **page web unique** et est donc expos√© √† des entr√©es **potentiellement malveillantes**. Cependant, le script de contenu ne contient aucune permission autre que la capacit√© d'envoyer des messages au noyau de l'extension.

### **Noyau de l'Extension**

Le noyau de l'extension contient la plupart des privil√®ges/acc√®s de l'extension, mais le noyau de l'extension ne peut interagir avec le contenu web que via [XMLHttpRequest](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest) et les scripts de contenu. De plus, le noyau de l'extension n'a pas d'acc√®s direct √† la machine h√¥te.

### **Binaire Natif**

L'extension permet un binaire natif qui peut **acc√©der √† la machine h√¥te avec les pleins privil√®ges de l'utilisateur.** Le binaire natif interagit avec le noyau de l'extension via l'interface de programmation d'applications de plugin Netscape standard ([NPAPI](https://en.wikipedia.org/wiki/NPAPI)) utilis√©e par Flash et d'autres plug-ins de navigateur.

### Limites

{% hint style="danger" %}
Pour obtenir les pleins privil√®ges de l'utilisateur, un attaquant doit convaincre l'extension de transmettre une entr√©e malveillante du script de contenu au noyau de l'extension et du noyau de l'extension au binaire natif.
{% endhint %}

Chaque composant de l'extension est s√©par√© des autres par des **limites de protection solides**. Chaque composant s'ex√©cute dans un **processus syst√®me d'exploitation s√©par√©**. Les scripts de contenu et les noyaux d'extension s'ex√©cutent dans des **processus sandbox** inaccessibles √† la plupart des services du syst√®me d'exploitation.

De plus, les scripts de contenu sont s√©par√©s de leurs pages web associ√©es en **s'ex√©cutant dans un tas JavaScript s√©par√©**. Le script de contenu et la page web ont **acc√®s au m√™me DOM sous-jacent**, mais les deux **n'√©changent jamais de pointeurs JavaScript**, emp√™chant la fuite de fonctionnalit√©s JavaScript.

## **`manifest.json`**

Une extension Chrome n'est qu'un dossier ZIP avec une extension de fichier [.crx](https://www.lifewire.com/crx-file-2620391). Le c≈ìur de l'extension est le fichier **`manifest.json`** √† la racine du dossier, qui sp√©cifie la disposition, les permissions et d'autres options de configuration.

Exemple :
```json
{
"manifest_version": 2,
"name": "My extension",
"version": "1.0",
"permissions": [
"storage"
],
"content_scripts": [
{
"js": [
"script.js"
],
"matches": [
"https://example.com/*",
"https://www.example.com/*"
],
"exclude_matches": ["*://*/*business*"],
}
],
"background": {
"scripts": [
"background.js"
]
},
"options_ui": {
"page": "options.html"
}
}
```
### `content_scripts`

Les scripts de contenu sont **charg√©s** chaque fois que l'utilisateur **navigue vers une page correspondante**, dans notre cas toute page correspondant √† l'expression **`https://example.com/*`** et ne correspondant pas √† la regex **`*://*/*/business*`**. Ils s'ex√©cutent **comme les propres scripts de la page** et ont un acc√®s arbitraire au [Document Object Model (DOM)](https://developer.mozilla.org/en-US/docs/Web/API/Document\_Object\_Model) de la page.
```json
"content_scripts": [
{
"js": [
"script.js"
],
"matches": [
"https://example.com/*",
"https://www.example.com/*"
],
"exclude_matches": ["*://*/*business*"],
}
],
```
Afin d'inclure ou d'exclure davantage d'URLs, il est √©galement possible d'utiliser **`include_globs`** et **`exclude_globs`**.

Voici un exemple de script de contenu qui ajoutera un bouton d'explication √† la page lorsque [l'API de stockage](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/storage) pour r√©cup√©rer la valeur `message` du stockage de l'extension.
```js
chrome.storage.local.get("message", result =>
{
let div = document.createElement("div");
div.innerHTML = result.message + " <button>Explain</button>";
div.querySelector("button").addEventListener("click", () =>
{
chrome.runtime.sendMessage("explain");
});
document.body.appendChild(div);
});
```
```json
{
  "name": "Exemple d'extension bas√©e sur activeTab",
  "version": "1.0",
  "description": "Injecte des scripts de contenu dans l'onglet actif",
  "permissions": ["activeTab"],
  "background": {
    "scripts": ["background.js"],
    "persistent": false
  },
  "browser_action": {
    "default_popup": "popup.html"
  },
  "manifest_version": 2
}
```
{% endcode %}

Lorsque ce bouton est cliqu√©, le script de contenu **utilise** [**runtime.sendMessage() API**](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/runtime/sendMessage) **pour envoyer un message aux pages de l'extension**. Cela est d√ª au fait qu'un script de contenu n'a acc√®s directement qu'√† un nombre limit√© d'APIs telles que `storage`. Tout le reste doit √™tre effectu√© par les pages de l'extension auxquelles les scripts de contenu peuvent envoyer des messages.

{% hint style="warning" %}
Les **capacit√©s des scripts de contenu** diff√®rent l√©g√®rement selon le navigateur. Pour les navigateurs bas√©s sur Chromium, vous pouvez trouver la liste dans la [documentation des d√©veloppeurs Chrome](https://developer.chrome.com/docs/extensions/mv3/content_scripts/#capabilities), pour Firefox [MDN](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/Content_scripts#webextension_apis) est la source ultime.\
Rappelez-vous que le script de contenu peut √©galement **communiquer avec les scripts d'arri√®re-plan** afin qu'ils effectuent des actions et renvoient la r√©ponse.
{% endhint %}

Pour voir et d√©boguer les scripts de contenu dans Chrome, vous pouvez ouvrir le menu des outils de d√©veloppement Chrome depuis Options > Plus d'outils > Outils de d√©veloppement OU (Appuyez sur - Ctrl + Shift + I).

Avec les outils de d√©veloppement affich√©s, cliquez sur l'onglet **Source**, puis sur l'onglet **Scripts de contenu**. Ici, vous pouvez voir les scripts de contenu en cours d'ex√©cution des diff√©rentes extensions et placer des points d'arr√™t pour surveiller le flux d'ex√©cution.

### Scripts de contenu inject√©s

{% hint style="success" %}
Notez que les **Scripts de contenu ne sont pas obligatoires** car il est √©galement possible d'**injecter** des scripts **dynamiquement** et de les **injecter de mani√®re programmatique** dans les pages web via **`tabs.executeScript`**. Cela offre en r√©alit√© des **contr√¥les plus granulaires**.
{% endhint %}

Pour injecter un script de contenu de mani√®re programmatique, votre extension a besoin de [permissions d'h√¥te](https://developer.chrome.com/docs/extensions/reference/permissions) pour la page dans laquelle elle essaie d'injecter des scripts. Les permissions d'h√¥te peuvent √™tre accord√©es soit en les **demandant** dans le manifeste de votre extension, soit temporairement via [**activeTab**](https://developer.chrome.com/docs/extensions/reference/manifest/activeTab)**.**

#### Exemple d'extension bas√©e sur activeTab

{% code title="manifest.json" %}
```json
{
"name": "My extension",
...
"permissions": [
"activeTab",
"scripting"
],
"background": {
"service_worker": "background.js"
},
"action": {
"default_title": "Action Button"
}
}
```
* **Injecter un fichier JS au clic :**
```javascript
// content-script.js
document.body.style.backgroundColor = "orange";

//service-worker.js - Inject the JS file
chrome.action.onClicked.addListener((tab) => {
chrome.scripting.executeScript({
target: { tabId: tab.id },
files: ["content-script.js"]
});
});
```
* **Injecter une fonction** au clic :
```javascript
//service-worker.js - Inject a function
function injectedFunction() {
document.body.style.backgroundColor = "orange";
}

chrome.action.onClicked.addListener((tab) => {
chrome.scripting.executeScript({
target : {tabId : tab.id},
func : injectedFunction,
});
});
```
#### Exemple avec des permissions de script
```javascript
// service-workser.js
chrome.scripting.registerContentScripts([{
id : "test",
matches : [ "https://*.nytimes.com/*" ],
excludeMatches : [ "*://*/*business*" ],
js : [ "contentScript.js" ],
}]);

// ANother example
chrome.tabs.executeScript(tabId, { file: "content_script.js" });
```
Afin d'inclure ou d'exclure plus d'URLs, il est √©galement possible d'utiliser **`include_globs`** et **`exclude_globs`**.

### Scripts de contenu `run_at`

Le champ `run_at` contr√¥le **quand les fichiers JavaScript sont inject√©s dans la page web**. La valeur pr√©f√©r√©e et par d√©faut est `"document_idle"`.

Les valeurs possibles sont :

* **`document_idle`** : Chaque fois que possible
* **`document_start`** : Apr√®s tous les fichiers de `css`, mais avant que tout autre DOM soit construit ou que tout autre script soit ex√©cut√©.
* **`document_end`** : Imm√©diatement apr√®s que le DOM est complet, mais avant que les sous-ressources comme les images et les cadres soient charg√©s.

#### Via `manifest.json`
```json
{
"name": "My extension",
...
"content_scripts": [
{
"matches": ["https://*.nytimes.com/*"],
"run_at": "document_idle",
"js": ["contentScript.js"]
}
],
...
}

```
Via **`service-worker.js`**
```javascript
chrome.scripting.registerContentScripts([{
id : "test",
matches : [ "https://*.nytimes.com/*" ],
runAt : "document_idle",
js : [ "contentScript.js" ],
}]);
```
### `arri√®re-plan`

Lorsque les scripts de contenu envoient un message, leur destination est la **page d'arri√®re-plan**. La page d'arri√®re-plan est une page sp√©ciale qui est **toujours pr√©sente** sauf indication contraire dans le manifeste de l'extension. Elle est invisible pour l'utilisateur, bien qu'elle soit une page normale avec son propre DOM et tout. Sa fonction est g√©n√©ralement de coordonner toutes les autres parties de l'extension.

{% hint style="success" %}
Si une page d'arri√®re-plan n'est pas d√©clar√©e explicitement, le navigateur va gentiment **en g√©n√©rer une** automatiquement et s'assurer que tous les **scripts d'arri√®re-plan d√©clar√©s sont charg√©s** dedans, comme dans l'exemple pr√©c√©dent de manifest.json.
{% endhint %}

Exemple de script d'arri√®re-plan :
```js
chrome.runtime.onMessage.addListener((request, sender, sendResponse) =>
{
if (request == "explain")
{
chrome.tabs.create({ url: "https://example.net/explanation" });
}
})
```
Il utilise l'[API runtime.onMessage](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/runtime/onMessage) pour √©couter les messages. Lorsqu'un message `"explain"` est re√ßu, il utilise l'[API tabs](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/tabs) pour ouvrir une page dans un nouvel onglet.

Pour d√©boguer le script d'arri√®re-plan, vous pouvez aller dans les **d√©tails de l'extension et inspecter le service worker,** cela ouvrira les outils de d√©veloppement avec le script d'arri√®re-plan :

<figure><img src="broken-reference" alt=""><figcaption></figcaption></figure>

### Pages d'options et autres

Les extensions de navigateur peuvent contenir divers types de pages :

* Les **pages d'action** sont affich√©es dans un **menu d√©roulant lorsque l'ic√¥ne de l'extension** est cliqu√©e.
* Des pages que l'extension va **charger dans un nouvel onglet**.
* **Pages d'Options** : Cette page s'affiche au-dessus de l'extension lorsqu'on clique dessus. Dans le manifeste pr√©c√©dent, dans mon cas, je pouvais acc√©der √† cette page dans `chrome://extensions/?options=fadlhnelkbeojnebcbkacjilhnbjfjca` ou en cliquant :

<figure><img src="../../.gitbook/assets/image (8).png" alt="" width="375"><figcaption></figcaption></figure>

Contrairement √† la page d'arri√®re-plan, ces pages ne sont pas persistantes mais se chargent lorsque n√©cessaire. Pourtant, elles peuvent toutes **recevoir des messages de scripts de contenu**. Et elles ont toutes **un acc√®s complet aux API sp√©cifiques √† l'extension**, dans la mesure o√π les permissions de l'extension le permettent.

Ensemble, les contextes pertinents pour les extensions de navigateur ressemblent √† ceci :

<figure><img src="../../.gitbook/assets/image (9).png" alt="" width="563"><figcaption></figcaption></figure>

### `permissions` & `host_permissions`

**`permissions`** et **`host_permissions`** sont des entr√©es du `manifest.json` qui indiqueront **quelles permissions** l'extension de navigateur a (stockage, localisation...) et sur **quelles pages web**.

Comme les extensions de navigateur peuvent √™tre si **privil√©gi√©es**, une extension malveillante ou compromise pourrait permettre √† l'attaquant **diff√©rents moyens de voler des informations sensibles et d'espionner l'utilisateur**.

V√©rifiez comment ces param√®tres fonctionnent et comment ils pourraient √™tre abus√©s dans :

{% content-ref url="browext-permissions-and-host_permissions.md" %}
[browext-permissions-and-host_permissions.md](browext-permissions-and-host_permissions.md)
{% endcontent-ref %}

### `content_security_policy`

Une **politique de s√©curit√© de contenu** peut √©galement √™tre d√©clar√©e dans le `manifest.json`. Si une est d√©finie, elle pourrait √™tre **vuln√©rable**.

Le param√®tre par d√©faut pour les pages d'extension de navigateur est plut√¥t restrictif :
```bash
script-src 'self'; object-src 'self';
```
Pour plus d'informations sur CSP et les contournements potentiels, consultez :

{% content-ref url="../content-security-policy-csp-bypass/" %}
[content-security-policy-csp-bypass](../content-security-policy-csp-bypass/)
{% endcontent-ref %}

### `web_accessible_resources`

Pour qu'une page web puisse acc√©der √† une page d'une Extension de Navigateur, une page `.html` par exemple, cette page doit √™tre mentionn√©e dans le champ **`web_accessible_resources`** du `manifest.json`.\
Par exemple :
```javascript
{
...
"web_accessible_resources": [
{
"resources": [ "images/*.png" ],
"matches": [ "https://example.com/*" ]
},
{
"resources": [ "fonts/*.woff" ],
"matches": [ "https://example.com/*" ]
}
],
...
}
```
Ces pages sont accessibles via des URL comme :
```
chrome-extension://<extension-id>/message.html
```
Dans les extensions publiques, **l'extension-id est accessible** :

<figure><img src="../../.gitbook/assets/image (722).png" alt="" width="375"><figcaption></figcaption></figure>

Cependant, si le param√®tre `manifest.json` **`use_dynamic_url`** est utilis√©, cet **id peut √™tre dynamique**.

Le fait d'√™tre autoris√© √† acc√©der √† ces pages rend ces pages **potentiellement vuln√©rables au ClickJacking** :

{% content-ref url="browext-clickjacking.md" %}
[browext-clickjacking.md](browext-clickjacking.md)
{% endcontent-ref %}

{% hint style="success" %}
Permettre √† ces pages d'√™tre charg√©es uniquement par l'extension et non par des URL al√©atoires pourrait pr√©venir les attaques de ClickJacking.
{% endhint %}

### `externally_connectable`

Selon la [**documentation**](https://developer.chrome.com/docs/extensions/reference/manifest/externally-connectable), la propri√©t√© du manifeste `"externally_connectable"` d√©clare **quelles extensions et pages web peuvent se connecter** √† votre extension via [runtime.connect](https://developer.chrome.com/docs/extensions/reference/runtime#method-connect) et [runtime.sendMessage](https://developer.chrome.com/docs/extensions/reference/runtime#method-sendMessage).

* Si la cl√© **`externally_connectable`** n'est **pas** d√©clar√©e dans le manifeste de votre extension ou si elle est d√©clar√©e comme **`"ids": ["*"]`**, **toutes les extensions peuvent se connecter, mais aucune page web ne peut se connecter**.
* Si **des IDs sp√©cifiques sont sp√©cifi√©s**, comme dans `"ids": ["aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"]`, **seules ces applications** peuvent se connecter.
* Si des **correspondances** sont sp√©cifi√©es, ces applications web pourront se connecter :
```json
"matches": [
"https://*.google.com/*",
"*://*.chromium.org/*",
```
* Si c'est sp√©cifi√© comme vide : **`"externally_connectable": {}`**, aucune application ou page web ne pourra se connecter.

**Moins d'extensions et d'URLs** indiqu√©es ici, **plus petite sera la surface d'attaque**.

{% hint style="danger" %}
Si une page web **vuln√©rable aux XSS ou √† la prise de contr√¥le** est indiqu√©e dans **`externally_connectable`**, un attaquant pourra **envoyer des messages directement au script d'arri√®re-plan**, contournant compl√®tement le Content Script et sa CSP.

Par cons√©quent, c'est un **contournement tr√®s puissant**.
{% endhint %}

## Communication Web **‚ÜîÔ∏é** Content Script

Bien que les environnements d'ex√©cution des **content scripts et des pages** qui les h√©bergent soient **isol√©s** l'un de l'autre, ils **partagent l'acc√®s au DOM de la page**. Si la page souhaite communiquer avec le content script, ou avec l'extension via le content script, elle doit le faire √† travers le **DOM partag√©**.

### Post Messages

{% code title="content-script.js" %}
```javascript
var port = chrome.runtime.connect();

window.addEventListener("message", (event) => {
// We only accept messages from ourselves
if (event.source !== window) {
return;
}

if (event.data.type && (event.data.type === "FROM_PAGE")) {
console.log("Content script received: " + event.data.text);
port.postMessage(event.data.text);
}
}, false);
```
```
{% endcode %}

{% code title="example.js" %}
```
```javascript
document.getElementById("theButton").addEventListener("click", () => {
window.postMessage(
{type : "FROM_PAGE", text : "Hello from the webpage!"}, "*");
}, false);
```
```markdown
{% endcode %}

Une communication Post Message s√©curis√©e devrait v√©rifier l'authenticit√© du message re√ßu, cela peut √™tre fait en v√©rifiant :

* **`event.isTrusted`** : Cela est vrai uniquement si l'√©v√©nement a √©t√© d√©clench√© par une action de l'utilisateur
* Le script de contenu pourrait attendre un message uniquement si l'utilisateur effectue une action
* **domaine d'origine** : Il peut √™tre v√©rifi√© contre une liste blanche de domaines.
* Si une regex est utilis√©e, soyez tr√®s prudent
* **Source** : `received_message.source !== window` peut √™tre utilis√© pour v√©rifier si le message provient **de la m√™me fen√™tre** o√π le Script de Contenu √©coute.

Les v√©rifications pr√©c√©dentes, m√™me si effectu√©es, pourraient √™tre vuln√©rables, donc v√©rifiez dans la page suivante **les contournements potentiels de Post Message** :

{% content-ref url="../postmessage-vulnerabilities/" %}
[postmessage-vulnerabilities](../postmessage-vulnerabilities/)
{% endcontent-ref %}

### Iframe

Une autre mani√®re possible de communication pourrait √™tre √† travers **les URLs d'Iframe**, vous pouvez trouver un exemple dans :

{% content-ref url="browext-xss-example.md" %}
[browext-xss-example.md](browext-xss-example.md)
{% endcontent-ref %}

### DOM

Ce n'est pas "exactement" une mani√®re de communiquer, mais **le web et le script de contenu auront acc√®s au DOM web**. Donc, si le **script de contenu** lit des informations √† partir de celui-ci, **faisant confiance au DOM web**, le web pourrait **modifier ces donn√©es** (parce que le web ne devrait pas √™tre consid√©r√© comme s√ªr, ou parce que le web est vuln√©rable aux XSS) et **compromettre le Script de Contenu**.

Vous pouvez √©galement trouver un exemple de **XSS bas√© sur le DOM pour compromettre une extension de navigateur** dans :

{% content-ref url="browext-xss-example.md" %}
[browext-xss-example.md](browext-xss-example.md)
{% endcontent-ref %}

## Informations Sensibles en M√©moire/Code

Si une Extension de Navigateur stocke **des informations sensibles dans sa m√©moire**, celles-ci pourraient √™tre **extraites** (surtout sur les machines Windows) et **recherch√©es** pour ces informations.

Par cons√©quent, la m√©moire de l'Extension de Navigateur **ne devrait pas √™tre consid√©r√©e comme s√©curis√©e** et **les informations sensibles** telles que les identifiants ou les phrases mn√©moniques **ne devraient pas √™tre stock√©es**.

Bien s√ªr, **ne mettez pas d'informations sensibles dans le code**, car elles seront **publiques**.

## Communication Script de Contenu **‚ÜîÔ∏é** Script d'Arri√®re-plan

Un Script de Contenu peut utiliser les fonctions [**runtime.sendMessage()**](https://developer.chrome.com/docs/extensions/reference/runtime#method-sendMessage) **ou** [**tabs.sendMessage()**](https://developer.chrome.com/docs/extensions/reference/tabs#method-sendMessage) pour envoyer un message **s√©rialisable en JSON √† usage unique**.

Pour g√©rer la **r√©ponse**, utilisez la **Promise** retourn√©e. Cependant, pour la compatibilit√© ascendante, vous pouvez toujours passer un **callback** comme dernier argument.

L'envoi d'une requ√™te √† partir d'un **script de contenu** ressemble √† ceci :
```
```javascript
(async () => {
const response = await chrome.runtime.sendMessage({greeting: "hello"});
// do something with response here, not outside the function
console.log(response);
})();
```
L'envoi d'une requ√™te depuis l'**extension** (g√©n√©ralement un **script d'arri√®re-plan**) vers un script de contenu est similaire, sauf que vous devez sp√©cifier √† quel onglet l'envoyer. Cet exemple montre comment envoyer un message au script de contenu dans l'onglet s√©lectionn√©.
```javascript
(async () => {
const [tab] = await chrome.tabs.query({active: true, lastFocusedWindow: true});
const response = await chrome.tabs.sendMessage(tab.id, {greeting: "hello"});
// do something with response here, not outside the function
console.log(response);
})();
```
√Ä **l'extr√©mit√© r√©ceptrice**, vous devez configurer un [**runtime.onMessage**](https://developer.chrome.com/docs/extensions/reference/runtime#event-onMessage) **√©couteur d'√©v√©nement** pour g√©rer le message. Cela se pr√©sente de la m√™me mani√®re depuis un script de contenu ou une page d'extension.
```javascript
chrome.runtime.onMessage.addListener(
function(request, sender, sendResponse) {
console.log(sender.tab ?
"from a content script:" + sender.tab.url :
"from the extension");
if (request.greeting === "hello")
sendResponse({farewell: "goodbye"});
}
);
```
Dans l'exemple ci-dessus, **`sendResponse()`** a √©t√© appel√© de mani√®re synchrone. Si vous souhaitez utiliser `sendResponse()` de mani√®re **asynchrone**, ajoutez `return true;` au gestionnaire d'√©v√©nement `onMessage`.

> Si plusieurs pages √©coutent les √©v√©nements `onMessage`, **seule la premi√®re √† appeler `sendResponse()`** pour un √©v√©nement particulier r√©ussira √† envoyer la r√©ponse. Toutes les autres r√©ponses √† cet √©v√©nement seront ignor√©es.

Pour les nouvelles extensions, vous devriez pr√©f√©rer les promesses aux rappels. Si vous utilisez des rappels, le rappel `sendResponse()` n'est valide que s'il est utilis√© de mani√®re synchrone, ou si le gestionnaire d'√©v√©nement retourne `true` pour indiquer qu'il r√©pondra de mani√®re asynchrone. Le rappel de la fonction `sendMessage()` sera invoqu√© automatiquement si aucun gestionnaire ne retourne true ou si le rappel `sendResponse()` est collect√© par le garbage collector.

## Charger une Extension dans le Navigateur

1. **T√©l√©chargez** l'Extension pour Navigateur et d√©compressez-la
2. Allez dans **`chrome://extensions/`** et **activez** le `Mode D√©veloppeur`
3. Cliquez sur le bouton **`Charger l'extension non empaquet√©e`**

Dans **Firefox**, vous allez dans **`about:debugging#/runtime/this-firefox`** et cliquez sur le bouton **`Charger un module temporaire`**.

## Obtenir le code source depuis le magasin

Depuis [**ici**](https://gist.github.com/paulirish/78d6c1406c901be02c2d):

### Option 1 : T√©l√©chargement de l'extension en ligne de commande sous forme de zip et extraction

{% code overflow="wrap" %}
```bash
extension_id=jifpbeccnghkjeaalbbjmodiffmgedin   # change this ID
curl -L -o "$extension_id.zip" "https://clients2.google.com/service/update2/crx?response=redirect&os=mac&arch=x86-64&nacl_arch=x86-64&prod=chromecrx&prodchannel=stable&prodversion=44.0.2403.130&x=id%3D$extension_id%26uc"
unzip -d "$extension_id-source" "$extension_id.zip"
```
```markdown
{% endcode %}

Merci √† crxviewer pour l'[URL de t√©l√©chargement magique](https://github.com/Rob--W/crxviewer/blob/6113c25e3569e1ec59365ad9a177aa97e2bcda61/src/cws_pattern.js#L27-L74).

### Option 2 : Utiliser le site web CRX Viewer

[https://robwu.nl/crxviewer/](https://robwu.nl/crxviewer/)

### Option 3 : Utiliser l'extension CRX Viewer

L'[extension Chrome pour visualiser le code source](https://chrome.google.com/webstore/detail/chrome-extension-source-v/jifpbeccnghkjeaalbbjmodiffmgedin?hl=en) est open source ([repo github](https://github.com/Rob--W/crxviewer)) et rend cela tr√®s facile.

### Option 3 : Voir le code source d'une extension install√©e localement

1. Trouvez le r√©pertoire de profil local de Chrome. Ouvrez `chrome://version/` et trouvez le champ "Chemin du profil:". Ouvrez ce dossier.
2. Ouvrez le sous-dossier `Extensions/`
3. Toutes vos extensions sont ici, avec g√©n√©ralement une source lisible.

#### Correspondance entre les IDs des extensions install√©es localement et les noms

* Sur `about:extensions`, activez le Mode D√©veloppeur et vous verrez les IDs sous chaque entr√©e
* Dans les dossiers `Extensions/`, le fichier manifest.json a un champ `name` lisible

## Liste de v√©rification pour l'audit de s√©curit√©

Bien que les extensions de navigateur aient une **surface d'attaque limit√©e**, certaines peuvent contenir des **vuln√©rabilit√©s** ou des **am√©liorations de durcissement potentielles**. Voici les plus courantes :

* [ ] **Limiter** autant que possible les **`permissions`** demand√©es
* [ ] **Limiter** autant que possible les **`host_permissions`**
* [ ] Utiliser une **`content_security_policy`** **robuste**
* [ ] **Limiter** autant que possible les **`externally_connectable`**, si aucun n'est n√©cessaire et possible, ne pas le laisser par d√©faut, sp√©cifier **`{}`**
* [ ] Si une **URL vuln√©rable aux XSS ou √† la prise de contr√¥le** est mentionn√©e ici, un attaquant pourra **envoyer des messages aux scripts en arri√®re-plan directement**. Contournement tr√®s puissant.
* [ ] **Limiter** autant que possible les **`web_accessible_resources`**, m√™me vide si possible.
* [ ] Si **`web_accessible_resources`** n'est pas nul, v√©rifier la pr√©sence de [**ClickJacking**](browext-clickjacking.md)
* [ ] Si une **communication** a lieu de l'**extension** vers la **page web**, [**v√©rifier les vuln√©rabilit√©s XSS**](browext-xss-example.md) **caus√©es dans la communication**.
* [ ] Si les Post Messages sont utilis√©s, v√©rifier les [**vuln√©rabilit√©s des Post Messages**](../postmessage-vulnerabilities/)**.**
* [ ] Si le **Content Script acc√®de aux d√©tails du DOM**, v√©rifier qu'ils **n'introduisent pas de XSS** s'ils sont **modifi√©s** par le web
* [ ] Mettre un accent particulier si cette communication est √©galement impliqu√©e dans la **communication Content Script -> Script en arri√®re-plan**
* [ ] **Les informations sensibles ne doivent pas √™tre stock√©es** dans le code de l'extension de navigateur
* [ ] **Les informations sensibles ne doivent pas √™tre stock√©es** dans la m√©moire de l'extension de navigateur

## Outils

### [**Tarnish**](https://thehackerblog.com/tarnish/)

* T√©l√©charge n'importe quelle extension Chrome √† partir d'un lien fourni du webstore Chrome.
* **Visualiseur de [**manifest.json**](https://developer.chrome.com/extensions/manifest)** : affiche simplement une version JSON mise en forme du manifeste de l'extension.
* **Analyse d'empreinte digitale** : D√©tection des [web_accessible_resources](https://developer.chrome.com/extensions/manifest/web_accessible_resources) et g√©n√©ration automatique de JavaScript pour l'empreinte digitale des extensions Chrome.
* **Analyse de Clickjacking Potentiel** : D√©tection des pages HTML d'extension avec la directive [web_accessible_resources](https://developer.chrome.com/extensions/manifest/web_accessible_resources) d√©finie. Celles-ci sont potentiellement vuln√©rables au clickjacking en fonction de l'objectif des pages.
* **Visualiseur d'avertissements de permissions** : qui montre une liste de tous les avertissements de demande de permission de Chrome qui seront affich√©s lorsqu'un utilisateur tente d'installer l'extension.
* **Fonctions Dangereuses** : montre l'emplacement des fonctions dangereuses qui pourraient potentiellement √™tre exploit√©es par un attaquant (par exemple, des fonctions telles que innerHTML, chrome.tabs.executeScript).
* **Points d'Entr√©e** : montre o√π l'extension prend des entr√©es utilisateur/externes. Cela est utile pour comprendre la surface d'attaque d'une extension et chercher des points potentiels pour envoyer des donn√©es malicieusement con√ßues √† l'extension.
* Les scanners de Fonctions Dangereuses et de Points d'Entr√©e ont les √©l√©ments suivants pour leurs alertes g√©n√©r√©es :
* Extrait de code pertinent et ligne qui a caus√© l'alerte.
* Description du probl√®me.
* Un bouton "Voir le fichier" pour visualiser le fichier source complet contenant le code.
* Le chemin du fichier alert√©.
* L'URI complet de l'extension Chrome du fichier alert√©.
* Le type de fichier, tel qu'un script de Page d'Arri√®re-plan, Script de Contenu, Action de Navigateur, etc.
* Si la ligne vuln√©rable se trouve dans un fichier JavaScript, les chemins de toutes les pages o√π il est inclus ainsi que le type de ces pages, et le statut de [web_accessible_resource](https://developer.chrome.com/extensions/manifest/web_accessible_resources).
* **Analyseur de Politique de S√©curit√© de Contenu (CSP) et v√©rificateur de contournement** : Cela mettra en √©vidence les faiblesses dans le CSP de votre extension et √©clairera √©galement les moyens potentiels de contourner votre CSP en raison de CDNs autoris√©s, etc.
* **Biblioth√®ques Vuln√©rables Connues** : Utilise [Retire.js](https://retirejs.github.io/retire.js/) pour v√©rifier toute utilisation de biblioth√®ques JavaScript connues pour √™tre vuln√©rables.
* T√©l√©charger l'extension et les versions format√©es.
* T√©l√©charger l'extension originale.
* T√©l√©charger une version embelli de l'extension (HTML et JavaScript automatiquement mis en forme).
* Mise en cache automatique des r√©sultats d'analyse, l'ex√©cution d'une analyse d'extension prendra un bon moment la premi√®re fois que vous l'ex√©cutez. Cependant, la deuxi√®me fois, en supposant que l'extension n'ait pas √©t√© mise √† jour, sera presque instantan√©e gr√¢ce √† la mise en cache des r√©sultats.
* URL de rapport pouvant √™tre li√©es, permettant de lier facilement quelqu'un d'autre √† un rapport d'extension g√©n√©r√© par tarnish.

### [Neto](https://github.com/elevenpaths/neto)

Le projet Neto est un package Python 3 con√ßu pour analyser et r√©v√©ler les fonctionnalit√©s cach√©es des plugins et extensions de navigateur pour des navigateurs bien connus tels que Firefox et Chrome. Il automatise le processus de d√©compression des fichiers empaquet√©s pour extraire ces fonctionnalit√©s de ressources pertinentes dans une extension comme `manifest.json`, les dossiers de localisation ou les fichiers sources Javascript et HTML.

## R√©f√©rences

* **Merci √†** [**@naivenom**](https://twitter.com/naivenom) **pour l'aide avec cette m√©thodologie**
* [https://www.cobalt.io/blog/introduction-to-chrome-browser-extension-security-testing](https://www.cobalt.io/blog/introduction-to-chrome-browser-extension-security-testing)
* [https://palant.info/2022/08/10/anatomy-of-a-basic-extension/](https://palant.info/2022/08/10/anatomy-of-a-basic-extension/)
* [https://palant.info/2022/08/24/attack-surface-of-extension-pages/](https://palant.info/2022/08/24/attack-surface-of-extension-pages/)
* [https://palant.info/2022/08/31/when-extension-pages-are-web-accessible/](https://palant.info/2022/08/31/when-extension-pages-are-web-accessible/)
* [https://help.passbolt.com/assets/files/PBL-02-report.pdf](https://help.passbolt.com/assets/files/PBL-02-report.pdf)
* [https://developer.chrome.com/docs/extensions/develop/concepts/content-scripts](https://developer.chrome.com/docs/extensions/develop/concepts/content-scripts)
* [https://developer.chrome.com/docs/extensions/mv2/background-pages](https://developer.chrome.com/docs/extensions/mv2/background-pages)
* [https://thehackerblog.com/kicking-the-rims-a-guide-for-securely-writing-and-auditing-chrome-extensions/](https://thehackerblog.com/kicking-the-rims-a-guide-for-securely-writing-and-auditing-chrome-extensions/)

<details>

<summary><strong>Apprenez le hacking AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Autres moyens de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop)!
* Obtenez le [**merchandising officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**La Famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection d'[**NFTs**](https://opensea.io/collection/the-peass-family) exclusifs
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Partagez vos astuces de hacking en soumettant des PR aux repos github** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
```
