# ブラウザ拡張機能のペンテスト方法論

<details>

<summary><strong>htARTE（HackTricks AWS Red Team Expert）</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>でゼロからヒーローまでAWSハッキングを学ぶ</strong></a><strong>！</strong></summary>

HackTricks をサポートする他の方法:

* **HackTricks で企業を宣伝**したい場合や **HackTricks をPDFでダウンロード**したい場合は [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop) をチェック！
* [**公式PEASS＆HackTricksグッズ**](https://peass.creator-spring.com)を入手
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な [**NFTs**](https://opensea.io/collection/the-peass-family) のコレクションを見つける
* **💬 [Discordグループ](https://discord.gg/hRep4RUj7f)** に参加するか、[telegramグループ](https://t.me/peass) に参加するか、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live) をフォローする
* **HackTricks** と **HackTricks Cloud** の github リポジトリに PR を提出して **あなたのハッキングテクニックを共有**する

</details>

## 基本情報

ブラウザ拡張機能はJavaScriptで書かれ、ブラウザによってバックグラウンドで読み込まれます。それは自身の[DOM](https://www.w3schools.com/js/js\_htmldom.asp)を持っていますが、他のサイトのDOMとやり取りすることができます。これは他のサイトの機密性、整合性、可用性（CIA）を危険にさらす可能性があります。

## 主要コンポーネント

拡張機能のレイアウトは視覚化された際に最も見栄えが良く、3つのコンポーネントで構成されています。それぞれのコンポーネントを詳しく見てみましょう。

<figure><img src="../../.gitbook/assets/image (16) (1).png" alt=""><figcaption><p><a href="http://webblaze.cs.berkeley.edu/papers/Extensions.pdf">http://webblaze.cs.berkeley.edu/papers/Extensions.pdf</a></p></figcaption></figure>

### **コンテンツスクリプト**

各コンテンツスクリプトは**単一のWebページのDOMに直接アクセス**でき、したがって**潜在的に悪意のある入力**にさらされます。ただし、コンテンツスクリプトには、拡張機能コアにメッセージを送信する権限以外はありません。

### **拡張機能コア**

拡張機能コアには、拡張機能のほとんどの権限/アクセスが含まれていますが、拡張機能コアは[XMLHttpRequest](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest)およびコンテンツスクリプトを介してのみWebコンテンツとやり取りできます。また、拡張機能コアはホストマシンに直接アクセスする権限を持っていません。

### **ネイティブバイナリ**

拡張機能には、ユーザーの完全な権限でホストマシンにアクセスできる**ネイティブバイナリ**が含まれています。ネイティブバイナリは、Flashや他のブラウザプラグインで使用される標準のNetscape Plugin Application Programming Interface（[NPAPI](https://en.wikipedia.org/wiki/NPAPI)）を介して拡張機能コアとやり取りします。

### 境界

{% hint style="danger" %}
ユーザーの完全な権限を取得するには、攻撃者はコンテンツスクリプトから拡張機能コアに、そして拡張機能コアからネイティブバイナリに悪意のある入力を渡すように拡張機能を説得する必要があります。
{% endhint %}

拡張機能の各コンポーネントは、**強力な保護境界**によって互いに分離されています。各コンポーネントは**別々のオペレーティングシステムプロセス**で実行されます。コンテンツスクリプトと拡張機能コアは、ほとんどのオペレーティングシステムサービスには利用できない**サンドボックスプロセス**で実行されます。

さらに、コンテンツスクリプトは**別々のJavaScriptヒープで実行**され、関連するWebページから分離されます。コンテンツスクリプトとWebページは**同じ基本的なDOMにアクセス**できますが、2つは**JavaScriptポインタを交換せず**、JavaScript機能の漏洩を防ぎます。

## **`manifest.json`**

Chrome拡張機能は、[.crxファイル拡張子](https://www.lifewire.com/crx-file-2620391)を持つZIPフォルダーです。拡張機能のコアは、フォルダーのルートにある**`manifest.json`**ファイルで、レイアウト、権限、その他の構成オプションを指定します。

例：
```json
{
"manifest_version": 2,
"name": "My extension",
"version": "1.0",
"permissions": [
"storage"
],
"content_scripts": [
{
"js": [
"script.js"
],
"matches": [
"https://example.com/*",
"https://www.example.com/*"
],
"exclude_matches": ["*://*/*business*"],
}
],
"background": {
"scripts": [
"background.js"
]
},
"options_ui": {
"page": "options.html"
}
}
```
### `content_scripts`

コンテンツスクリプトは、ユーザーが一致するページに移動するたびに**ロードされます**。この場合、**`https://example.com/*`**と一致するページおよび**`*://*/*/business*`**と一致しないページです。これらはページ自体のスクリプトのように実行され、ページの[Document Object Model (DOM)](https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model)に任意アクセスできます。
```json
"content_scripts": [
{
"js": [
"script.js"
],
"matches": [
"https://example.com/*",
"https://www.example.com/*"
],
"exclude_matches": ["*://*/*business*"],
}
],
```
以下は、**`include_globs`** と **`exclude_globs`** を使用してさらにURLを含めたり除外したりする方法です。

これは、ページに説明ボタンを追加するコンテンツスクリプトの例です。[ストレージAPI](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/storage)を使用して、拡張機能のストレージから `message` の値を取得します。
```js
chrome.storage.local.get("message", result =>
{
let div = document.createElement("div");
div.innerHTML = result.message + " <button>Explain</button>";
div.querySelector("button").addEventListener("click", () =>
{
chrome.runtime.sendMessage("explain");
});
document.body.appendChild(div);
});
```
<figure><img src="../../.gitbook/assets/image (23).png" alt=""><figcaption></figcaption></figure>

このボタンがクリックされると、コンテンツスクリプトによって拡張機能ページにメッセージが送信されます。これは、`storage`が例外の中にあるAPIに直接アクセスできないというコンテンツスクリプトの制限によるものです。これらの例外を超える機能については、コンテンツスクリプトが通信できる拡張機能ページにメッセージが送信されます。

{% hint style="warning" %}
ブラウザによっては、コンテンツスクリプトの機能がわずかに異なる場合があります。Chromiumベースのブラウザでは、[Chrome Developers documentation](https://developer.chrome.com/docs/extensions/mv3/content\_scripts/#capabilities)に機能リストがあり、Firefoxでは[MDN](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/Content\_scripts#webextension\_apis)が主要な情報源となります。\
また、コンテンツスクリプトはバックグラウンドスクリプトと通信する能力を持ち、アクションを実行し、応答を返すことができます。
{% endhint %}

Chromeでコンテンツスクリプトを表示およびデバッグするには、Chromeデベロッパーツールメニューにアクセスします。オプション > その他のツール > 開発者ツールを選択するか、Ctrl + Shift + Iを押します。

デベロッパーツールが表示されたら、**Sourceタブ**をクリックし、次に**Content Scriptsタブ**をクリックします。これにより、さまざまな拡張機能から実行中のコンテンツスクリプトを観察し、実行フローを追跡するためのブレークポイントを設定できます。

### 注入されたコンテンツスクリプト

{% hint style="success" %}
**コンテンツスクリプトは必須ではない**ことに注意してください。**動的にスクリプトを注入**したり、**`tabs.executeScript`**を使用してウェブページに**プログラム的に注入**することも可能です。これにより、より**細かい制御**が可能になります。
{% endhint %}

コンテンツスクリプトをプログラム的に注入するには、スクリプトを注入するページに対して[ホスト権限](https://developer.chrome.com/docs/extensions/reference/permissions)が必要です。これらの権限は、拡張機能のマニフェスト内でそれらを要求するか、[**activeTab**](https://developer.chrome.com/docs/extensions/reference/manifest/activeTab)を介して一時的にセキュリティを確保することができます。

#### activeTabベースの拡張機能の例

{% code title="manifest.json" %}
```json
{
"name": "My extension",
...
"permissions": [
"activeTab",
"scripting"
],
"background": {
"service_worker": "background.js"
},
"action": {
"default_title": "Action Button"
}
}
```
{% endcode %}

* **クリック時にJSファイルをインジェクトする:**
```javascript
// content-script.js
document.body.style.backgroundColor = "orange";

//service-worker.js - Inject the JS file
chrome.action.onClicked.addListener((tab) => {
chrome.scripting.executeScript({
target: { tabId: tab.id },
files: ["content-script.js"]
});
});
```
* **クリック時に関数を注入する**:
```javascript
//service-worker.js - Inject a function
function injectedFunction() {
document.body.style.backgroundColor = "orange";
}

chrome.action.onClicked.addListener((tab) => {
chrome.scripting.executeScript({
target : {tabId : tab.id},
func : injectedFunction,
});
});
```
#### スクリプト権限の例
```javascript
// service-workser.js
chrome.scripting.registerContentScripts([{
id : "test",
matches : [ "https://*.example.com/*" ],
excludeMatches : [ "*://*/*business*" ],
js : [ "contentScript.js" ],
}]);

// Another example
chrome.tabs.executeScript(tabId, { file: "content_script.js" });
```
### Content Scripts `run_at`

`run_at`フィールドは、**JavaScriptファイルがWebページに注入されるタイミング**を制御します。推奨されるデフォルト値は`"document_idle"`です。

可能な値は次のとおりです：

- **`document_idle`**：可能な限りすぐに
- **`document_start`**：`css`からのファイルの後、ただし他のDOMが構築される前や他のスクリプトが実行される前に
- **`document_end`**：DOMが完全になった直後、ただし画像やフレームなどのサブリソースが読み込まれる前

#### `manifest.json`を介して
```json
{
"name": "My extension",
...
"content_scripts": [
{
"matches": ["https://*.example.com/*"],
"run_at": "document_idle",
"js": ["contentScript.js"]
}
],
...
}

```
**`service-worker.js`**を介して
```javascript
chrome.scripting.registerContentScripts([{
id : "test",
matches : [ "https://*.example.com/*" ],
runAt : "document_idle",
js : [ "contentScript.js" ],
}]);
```
### `バックグラウンド`

コンテンツスクリプトによって送信されるメッセージは、**バックグラウンドページ**によって受信されます。このページは、拡張機能のコンポーネントを調整する中心的な役割を果たします。特筆すべきは、バックグラウンドページが拡張機能の寿命全体にわたって持続し、直接的なユーザーとのやり取りなしに静かに動作します。独自のDocument Object Model（DOM）を持ち、複雑な相互作用や状態管理を可能にします。

**主なポイント**:

* **バックグラウンドページの役割:** 拡張機能の中心部として機能し、拡張機能のさまざまな部分との通信と調整を確実にします。
* **持続性:** ユーザーには見えないが、拡張機能の機能性には不可欠な、常に存在するエンティティです。
* **自動生成:** 明示的に定義されていない場合、ブラウザは自動的にバックグラウンドページを作成します。この自動生成されたページには、拡張機能のマニフェストで指定されたすべてのバックグラウンドスクリプトが含まれ、拡張機能のバックグラウンドタスクのシームレスな動作を保証します。

{% hint style="success" %}
ブラウザが自動的にバックグラウンドページを生成することで（明示的に宣言されていない場合）、必要なすべてのバックグラウンドスクリプトが統合され、操作されることが保証され、拡張機能のセットアッププロセスが合理化されます。
{% endhint %}

例: バックグラウンドスクリプト:
```js
chrome.runtime.onMessage.addListener((request, sender, sendResponse) =>
{
if (request == "explain")
{
chrome.tabs.create({ url: "https://example.net/explanation" });
}
})
```
It uses [runtime.onMessage API](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/runtime/onMessage) to listen to messages. When an `"explain"` message is received, it uses [tabs API](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/tabs) to open a page in a new tab.

To debug the background script you could go to the **extension details and inspect the service worker,** this will open the developer tools with the background script:

<figure><img src="https://github.com/carlospolop/hacktricks/blob/master/pentesting-web/browser-extension-pentesting-methodology/broken-reference" alt=""><figcaption></figcaption></figure>

### Options pages and other

Browser extensions can contain various kinds of pages:

* **Action pages** are displayed in a **drop-down when the extension ico**n is clicked.
* Pages that the extension will **load in a new tab**.
* **Option Pages**: This page displays on top of the extension when clicked. In the previous manifest In my case I was able to access this page in `chrome://extensions/?options=fadlhnelkbeojnebcbkacjilhnbjfjca` or clicking:

<figure><img src="../../.gitbook/assets/image (24).png" alt="" width="375"><figcaption></figcaption></figure>

Note that these pages aren't persistent like background pages as they load dynamically content on necessity. Despite this, they share certain capabilities with the background page:

* **Communication with Content Scripts:** Similar to the background page, these pages can receive messages from content scripts, facilitating interaction within the extension.
* **Access to Extension-Specific APIs:** These pages enjoy comprehensive access to extension-specific APIs, subject to the permissions defined for the extension.

### `permissions` & `host_permissions`

**`permissions`** and **`host_permissions`** are entries from the `manifest.json` that will indicate **which permissions** the browser extensions has (storage, location...) and in **which web pages**.

As browser extensions can be so **privileged**, a malicious one or one being compromised could allow the attacker **different means to steal sensitive information and spy on the user**.

Check how these settings work and how thye could get abused in:

{% content-ref url="browext-permissions-and-host_permissions.md" %}
[browext-permissions-and-host\_permissions.md](browext-permissions-and-host\_permissions.md)
{% endcontent-ref %}

### `content_security_policy`

A **content security policy** can be declared also inside the `manifest.json`. If there is one defined, it could be **vulnerable**.

The default setting for browser extension pages is rather restrictive:
```bash
script-src 'self'; object-src 'self';
```
CSPと潜在的なバイパスに関する詳細は、以下をチェックしてください：

{% content-ref url="../content-security-policy-csp-bypass/" %}
[content-security-policy-csp-bypass](../content-security-policy-csp-bypass/)
{% endcontent-ref %}

### `web_accessible_resources`

ウェブページがブラウザ拡張機能のページ（例：`.html`ページ）にアクセスするためには、このページを`manifest.json`の**`web_accessible_resources`**フィールドに記述する必要があります。\
例：
```javascript
{
...
"web_accessible_resources": [
{
"resources": [ "images/*.png" ],
"matches": [ "https://example.com/*" ]
},
{
"resources": [ "fonts/*.woff" ],
"matches": [ "https://example.com/*" ]
}
],
...
}
```
これらのページは次のようなURLでアクセス可能です：
```
chrome-extension://<extension-id>/message.html
```
公開拡張機能では、**extension-id がアクセス可能**です：

<figure><img src="../../.gitbook/assets/image (1194).png" alt="" width="375"><figcaption></figcaption></figure>

ただし、`manifest.json` パラメータ **`use_dynamic_url`** が使用されている場合、この **id は動的になる**可能性があります。

これらのページにアクセスできるようにすると、これらのページは **潜在的に ClickJacking の脆弱性**を持つことになります：

{% content-ref url="browext-clickjacking.md" %}
[browext-clickjacking.md](browext-clickjacking.md)
{% endcontent-ref %}

{% hint style="success" %}
これらのページがランダムな URL ではなく拡張機能のみによって読み込まれるようにすると、ClickJacking 攻撃を防ぐことができます。
{% endhint %}

### `externally_connectable`

[**ドキュメント**](https://developer.chrome.com/docs/extensions/reference/manifest/externally-connectable)によると、`"externally_connectable"` マニフェスト プロパティは、[runtime.connect](https://developer.chrome.com/docs/extensions/reference/runtime#method-connect) および [runtime.sendMessage](https://developer.chrome.com/docs/extensions/reference/runtime#method-sendMessage) を介して拡張機能に接続できる **拡張機能や Web ページを宣言**します。

* 拡張機能のマニフェストに **`externally_connectable`** キーが宣言されていないか、**`"ids": ["*"]`** として宣言されている場合、**すべての拡張機能が接続できますが、Web ページは接続できません**。
* `"ids": ["aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"]` のように **特定の ID が指定**されている場合、**それらのアプリケーションのみ**が接続できます。
* 一致するものが指定されている場合、それらの Web アプリケーションが接続できます：
```json
"matches": [
"https://*.google.com/*",
"*://*.chromium.org/*",
```
* もし空に指定されている場合: **`"externally_connectable": {}`**、どのアプリやウェブも接続できません。

ここで示されている**拡張機能やURLが少ないほど**、**攻撃面が小さく**なります。

{% hint style="danger" %}
もし**XSSに対して脆弱なウェブページ**が**`externally_connectable`**で示されている場合、攻撃者は**バックグラウンドスクリプトに直接メッセージを送信**することができ、Content ScriptとそのCSPを完全にバイパスします。

したがって、これは**非常に強力なバイパス**です。

さらに、クライアントが不正な拡張機能をインストールした場合、脆弱な拡張機能との通信が許可されていなくても、許可されたウェブページに**XSSデータを注入**したり、**`WebRequest`**や**`DeclarativeNetRequest`** APIを悪用して、ターゲットドメインのリクエストを操作して**JavaScriptファイル**のリクエストを変更する可能性があります（ターゲットページのCSPがこれらの攻撃を防ぐ可能性があります）。このアイデアは[**この解説から来ています**](https://www.darkrelay.com/post/opera-zero-day-rce-vulnerability)。
{% endhint %}

##

## ウェブ **↔︎** Content Scriptの通信

**コンテンツスクリプト**が動作する環境とホストページが存在する環境はお互いに**分離**されており、**隔離**が保証されています。この隔離にもかかわらず、両者はページの**Document Object Model (DOM)**、共有リソースにアクセスする能力を持っています。ホストページが**コンテンツスクリプト**と通信したり、間接的にコンテンツスクリプトを介して拡張機能と通信するためには、両者がアクセス可能な**DOM**を通信チャネルとして利用する必要があります。

### ポストメッセージ

{% code title="content-script.js" %}
```javascript
var port = chrome.runtime.connect();

window.addEventListener("message", (event) => {
// We only accept messages from ourselves
if (event.source !== window) {
return;
}

if (event.data.type && (event.data.type === "FROM_PAGE")) {
console.log("Content script received: " + event.data.text);
port.postMessage(event.data.text);
}
}, false);
```
{% endcode %}

{% code title="example.js" %}
```javascript
document.getElementById("theButton").addEventListener("click", () => {
window.postMessage(
{type : "FROM_PAGE", text : "Hello from the webpage!"}, "*");
}, false);
```
{% endcode %}

セキュアなPost Message通信は、受信したメッセージの信頼性をチェックする必要があります。これは以下のように行うことができます:

- **`event.isTrusted`**: この値は、イベントがユーザーのアクションによってトリガーされた場合にのみTrueです。
- コンテンツスクリプトは、ユーザーが特定のアクションを実行した場合にのみメッセージを期待するかもしれません。
- **オリジンドメイン**: メッセージを期待するのは特定のドメインのみかもしれません。
- 正規表現が使用されている場合は非常に注意が必要です。
- **ソース**: `received_message.source !== window` は、Content Scriptがリスニングしているウィンドウと**同じウィンドウからのメッセージ**かどうかをチェックするために使用できます。

前述のチェックは、実行されていても脆弱性がある可能性があるため、次のページで**潜在的なPost Messageバイパス**をチェックしてください:

{% content-ref url="../postmessage-vulnerabilities/" %}
[postmessage-vulnerabilities](../postmessage-vulnerabilities/)
{% endcontent-ref %}

### Iframe

別の通信方法として、**Iframe URL**を介して通信する方法があります。例は以下で見つけることができます:

{% content-ref url="browext-xss-example.md" %}
[browext-xss-example.md](browext-xss-example.md)
{% endcontent-ref %}

### DOM

これは「正確には」通信方法ではありませんが、**webとコンテンツスクリプトはweb DOMにアクセスできます**。したがって、**コンテンツスクリプト**がそれから情報を読み取っている場合、**web DOMを信頼**していると、webはこのデータを**変更**できる可能性があります（webは信頼されていないか、XSSの脆弱性があるため）。そして、**コンテンツスクリプトを危険にさらす**可能性があります。

**ブラウザ拡張機能を危険にさらすDOMベースのXSSの例**も以下で見つけることができます:

{% content-ref url="browext-xss-example.md" %}
[browext-xss-example.md](browext-xss-example.md)
{% endcontent-ref %}

## メモリ/コード内の機密情報

ブラウザ拡張機能が**機密情報をそのメモリ内に保存**している場合、これは（特にWindowsマシンでは）**ダンプ**され、この情報を検索できます。

したがって、ブラウザ拡張機能のメモリは**安全ではない**と見なすべきであり、資格情報やニーモニックフレーズなどの**機密情報は保存されてはいけません**。

もちろん、**コード内に機密情報を入れない**でください。なぜならそれは**公開**されるからです。

ブラウザからメモリをダンプするには、**プロセスメモリをダンプ**するか、ブラウザ拡張機能の**設定**に移動して**`Inspect pop-up`**をクリックし、**`Memory`**セクションで**`Take a snaphost`**をクリックし、スナップショット内で機密情報を検索するために**`CTRL+F`**を使用できます。

## コンテンツスクリプト **↔︎** バックグラウンドスクリプト間の通信

コンテンツスクリプトは、[**runtime.sendMessage()**](https://developer.chrome.com/docs/extensions/reference/runtime#method-sendMessage) **または** [**tabs.sendMessage()**](https://developer.chrome.com/docs/extensions/reference/tabs#method-sendMessage) 関数を使用して**一度だけのJSONシリアライズ可能な**メッセージを送信できます。

**応答**を処理するには、返された**Promise**を使用します。ただし、後方互換性のために、最後の引数として**コールバック**を渡すこともできます。

**コンテンツスクリプト**からリクエストを送信する方法は次のようになります:
```javascript
(async () => {
const response = await chrome.runtime.sendMessage({greeting: "hello"});
// do something with response here, not outside the function
console.log(response);
})();
```
**拡張機能**（通常は**バックグラウンドスクリプト**）からリクエストを送信します。コンテンツスクリプトは、指定したタブに送信する必要があります。選択したタブのコンテンツスクリプトにメッセージを送信する方法の例：
```javascript
// From https://stackoverflow.com/questions/36153999/how-to-send-a-message-between-chrome-extension-popup-and-content-script
(async () => {
const [tab] = await chrome.tabs.query({active: true, lastFocusedWindow: true});
const response = await chrome.tabs.sendMessage(tab.id, {greeting: "hello"});
// do something with response here, not outside the function
console.log(response);
})();
```
**受信側**では、メッセージを処理するために[**runtime.onMessage**](https://developer.chrome.com/docs/extensions/reference/runtime#event-onMessage) **イベントリスナー**を設定する必要があります。これはコンテンツスクリプトや拡張機能ページから見た場合に同じように見えます。
```javascript
// From https://stackoverflow.com/questions/70406787/javascript-send-message-from-content-js-to-background-js
chrome.runtime.onMessage.addListener(
function(request, sender, sendResponse) {
console.log(sender.tab ?
"from a content script:" + sender.tab.url :
"from the extension");
if (request.greeting === "hello")
sendResponse({farewell: "goodbye"});
}
);
```
例で強調されているように、**`sendResponse()`** は同期的に実行されました。`sendResponse()` を非同期に実行するために `onMessage` イベントハンドラを変更するには、`return true;` を組み込むことが重要です。

複数のページが `onMessage` イベントを受信するシナリオでは、特定のイベントに対して最初に `sendResponse()` を実行するページだけが効果的に応答を返すことができます。同じイベントへの後続の応答は考慮されません。

新しい拡張機能を作成する際は、コールバックではなくプロミスを使用することが好ましいです。コールバックの使用に関しては、`sendResponse()` 関数は、同期的なコンテキスト内で直接実行される場合、またはイベントハンドラが非同期操作を示すために `true` を返す場合にのみ有効と見なされます。ハンドラのいずれも `true` を返さない場合や、`sendResponse()` 関数がメモリから削除された場合（ガベージコレクションされた場合）、`sendMessage()` 関数に関連付けられたコールバックがデフォルトでトリガーされます。

## ブラウザでの拡張機能の読み込み

1. ブラウザ拡張機能を**ダウンロード**して解凍します
2. **`chrome://extensions/`** に移動し、`Developer Mode` を**有効**にします
3. **`Load unpacked`** ボタンをクリックします

**Firefox** の場合は、**`about:debugging#/runtime/this-firefox`** に移動し、**`Load Temporary Add-on`** ボタンをクリックします。

## ストアからソースコードを取得する

Chrome 拡張機能のソースコードはさまざまな方法で取得できます。以下に、各オプションの詳細な説明と手順が示されています。

### コマンドラインを使用して ZIP 形式で拡張機能をダウンロード

Chrome 拡張機能のソースコードは、コマンドラインを使用して ZIP ファイルとしてダウンロードすることができます。これには、`curl` を使用して特定の URL から ZIP ファイルを取得し、その後 ZIP ファイルの内容をディレクトリに展開する必要があります。以下に手順を示します:

1. `"extension_id"` を実際の拡張機能の ID に置き換えます。
2. 次のコマンドを実行します:
```bash
extension_id=your_extension_id   # Replace with the actual extension ID
curl -L -o "$extension_id.zip" "https://clients2.google.com/service/update2/crx?response=redirect&os=mac&arch=x86-64&nacl_arch=x86-64&prod=chromecrx&prodchannel=stable&prodversion=44.0.2403.130&x=id%3D$extension_id%26uc"
unzip -d "$extension_id-source" "$extension_id.zip"
```
### CRX Viewerウェブサイトを使用する

[https://robwu.nl/crxviewer/](https://robwu.nl/crxviewer/)

### CRX Viewer拡張機能を使用する

もう1つの便利な方法は、オープンソースプロジェクトであるChrome Extension Source Viewerを使用することです。[Chrome Web Store](https://chrome.google.com/webstore/detail/chrome-extension-source-v/jifpbeccnghkjeaalbbjmodiffmgedin?hl=en)からインストールできます。ビューアのソースコードは、[GitHubリポジトリ](https://github.com/Rob--W/crxviewer)で入手できます。

### ローカルにインストールされた拡張機能のソースを表示する

ローカルにインストールされたChrome拡張機能も検査できます。以下の方法で行います：

1. `chrome://version/`にアクセスして、「Profile Path」フィールドを見つけることで、Chromeのローカルプロファイルディレクトリにアクセスします。
2. プロファイルディレクトリ内の`Extensions/`サブフォルダに移動します。
3. このフォルダには、通常、読みやすい形式でソースコードが含まれているすべてのインストールされた拡張機能が含まれています。

拡張機能を識別するために、それらのIDを名前にマッピングできます：

* `about:extensions`ページで開発者モードを有効にして、各拡張機能のIDを表示します。
* 各拡張機能のフォルダ内にある`manifest.json`ファイルには、拡張機能を識別するのに役立つ読みやすい`name`フィールドが含まれています。

### ファイルアーカイバまたはアンパッカーを使用する

Chrome Web Storeに移動して、拡張機能をダウンロードします。ファイルの拡張子は`.crx`になります。ファイルの拡張子を`.crx`から`.zip`に変更します。任意のファイルアーカイバ（WinRAR、7-Zipなど）を使用して、ZIPファイルの内容を抽出します。

### Chromeで開発者モードを使用する

Chromeを開いて`chrome://extensions/`に移動します。右上の「開発者モード」を有効にします。"アンパックされた拡張機能を読み込む"をクリックします。拡張機能のディレクトリに移動します。これによりソースコードはダウンロードされませんが、すでにダウンロードされたまたは開発された拡張機能のコードを表示および変更するのに便利です。

## セキュリティ監査チェックリスト

ブラウザ拡張機能は**攻撃面が限られています**が、一部には**脆弱性**や**潜在的な強化改善**が含まれている場合があります。以下は最も一般的なものです：

* [ ] **要求される`permissions`**を可能な限り**制限**する
* [ ] **`host_permissions`**を可能な限り**制限**する
* **`content_security_policy`**を**強力に**使用する
* 必要がない場合や可能な場合は、**`externally_connectable`**を可能な限り**制限**し、デフォルトで残さないように**`{}`**を指定する
* ここでXSSや乗っ取りに**脆弱なURL**が言及されている場合、攻撃者は**バックグラウンドスクリプトに直接メッセージを送信**できます。非常に強力なバイパスです。
* **`web_accessible_resources`**を可能な限り**制限**する。可能な場合は空にしても構いません。
* **`web_accessible_resources`**がnoneでない場合は、[**ClickJacking**](browext-clickjacking.md)をチェックします
* 拡張機能からウェブページへの**通信**が発生する場合は、通信中に発生する[XSSのチェック](browext-xss-example.md)を行います。
* Post Messagesが使用されている場合は、[**Post Messageの脆弱性**](../postmessage-vulnerabilities/)をチェックします。
* **Content ScriptがDOMの詳細にアクセス**する場合は、それらがWebによって**変更**されるとXSSを導入していないか確認します
* この通信が**Content Script -> Background script通信**にも関与している場合は特に注意してください
* ブラウザ拡張機能の中に**機密情報を保存**すべきではありません
* ブラウザ拡張機能の中に**機密情報を保存**すべきではありません

## ツール

### [**Tarnish**](https://thehackerblog.com/tarnish/)

* 提供されたChrome Webstoreリンクから任意のChrome拡張機能を取得します。
* [**manifest.json**](https://developer.chrome.com/extensions/manifest) **ビューア**：拡張機能のマニフェストのJSON整形バージョンを簡単に表示します。
* **フィンガープリント解析**：[web\_accessible\_resources](https://developer.chrome.com/extensions/manifest/web\_accessible\_resources)の検出およびChrome拡張機能のフィンガープリントJavaScriptの自動生成。
* **潜在的なClickjacking解析**：[web\_accessible\_resources](https://developer.chrome.com/extensions/manifest/web\_accessible\_resources)ディレクティブが設定された拡張機能HTMLページの検出。これらはページの目的に応じてClickjackingの脆弱性があります。
* **許可警告ビューア**：ユーザーが拡張機能をインストールしようとすると表示されるすべてのChrome許可プロンプト警告のリストを表示します。
* **危険な機能**：攻撃者によって悪用される可能性のある危険な機能の場所を表示します（例：innerHTML、chrome.tabs.executeScriptなどの機能）。
* **エントリーポイント**：拡張機能がユーザー/外部入力を受け入れる場所を表示します。これは拡張機能の表面積を理解し、悪意のあるデータを拡張機能に送信する潜在的なポイントを探すのに役立ちます。
* 危険な機能とエントリーポイントのスキャナーには、次のものが生成されたアラートに含まれます：
* アラートを引き起こした関連するコードスニペットと行。
* 問題の説明。
* アラートを引き起こしたファイルの完全なソースファイルを表示するための「ファイルを表示」ボタン。
* アラートされたファイルのパス。
* アラートされたファイルの完全なChrome拡張機能URI。
* JavaScriptファイルに脆弱な行が含まれている場合、それが含まれているすべてのページのパスと、これらのページのタイプ、[web\_accessible\_resource](https://developer.chrome.com/extensions/manifest/web\_accessible\_resources)ステータス。
* **Content Security Policy (CSP)アナライザーおよびバイパスチェッカー**：拡張機能のCSPの弱点を指摘し、ホワイトリストに登録されたCDNなどによるCSPのバイパス方法を明らかにします。
* **既知の脆弱なライブラリ**：[Retire.js](https://retirejs.github.io/retire.js/)を使用して既知の脆弱なJavaScriptライブラリの使用をチェックします。
* 拡張機能と整形されたバージョンをダウンロードします。
* オリジナルの拡張機能をダウンロードします。
* 拡張機能の整形されたバージョン（自動整形されたHTMLおよびJavaScript）をダウンロードします。
* スキャン結果の自動キャッシュ化。拡張機能のスキャンを実行すると、最初の実行にはかなりの時間がかかります。ただし、2回目以降は、拡張機能が更新されていない限り、結果がキャッシュされているため、ほぼ即座に実行されます。
* レポートURLへのリンク可能。Tarnishによって生成された拡張機能レポートへのリンクを簡単に他の人にリンクできます。

### [Neto](https://github.com/elevenpaths/neto)

Project Netoは、FirefoxやChromeなどのよく知られたブラウザ用のプラグインや拡張機能の隠れた機能を分析および解明するために考案されたPython 3パッケージです。このパッケージは、パッケージ化されたファイルを解凍して、`manifest.json`、ローカライゼーションフォルダ、JavaScriptおよびHTMLソースファイルからこれらの機能を抽出するプロセスを自動化します。

## 参考文献

* この方法論の支援に感謝します[**@naivenom**](https://twitter.com/naivenom)
* [https://www.cobalt.io/blog/introduction-to-chrome-browser-extension-security-testing](https://www.cobalt.io/blog/introduction-to-chrome-browser-extension-security-testing)
* [https://palant.info/2022/08/10/anatomy-of-a-basic-extension/](https://palant.info/2022/08/10/anatomy-of-a-basic-extension/)
* [https://palant.info/2022/08/24/attack-surface-of-extension-pages/](https://palant.info/2022/08/24/attack-surface-of-extension-pages/)
* [https://palant.info/2022/08/31/when-extension-pages-are-web-accessible/](https://palant.info/2022/08/31/when-extension-pages-are-web-accessible/)
* [https://help.passbolt.com/assets/files/PBL-02-report.pdf](https://help.passbolt.com/assets/files/PBL-02-report.pdf)
* [https://developer.chrome.com/docs/extensions/develop/concepts/content-scripts](https://developer.chrome.com/docs/extensions/develop/concepts/content-scripts)
* [https://developer.chrome.com/docs/extensions/mv2/background-pages](https://developer.chrome.com/docs/extensions/mv2/background-pages)
* [https://thehackerblog.com/kicking-the-rims-a-guide-for-securely-writing-and-auditing-chrome-extensions/](https://thehackerblog.com/kicking-the-rims-a-guide-for-securely-writing-and-auditing-chrome-extensions/)
* [https://gist.github.com/LongJohnCoder/9ddf5735df3a4f2e9559665fb864eac0](https://gist.github.com/LongJohnCoder/9ddf5735df3a4f2e9559665fb864eac0)

<details>

<summary><strong>htARTE（HackTricks AWS Red Team Expert）でAWSハッキングをゼロからヒーローまで学ぶ</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE（HackTricks AWS Red Team Expert）</strong></a><strong>をご覧ください！</strong></summary>

HackTricksをサポートする他の方法:
* もし**HackTricksで会社を宣伝したい**か**HackTricksをPDFでダウンロードしたい**場合は、[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS＆HackTricksグッズ**](https://peass.creator-spring.com)を入手してください
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクションをご覧ください
* **💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)に参加するか、[**telegramグループ**](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**をフォローしてください。**
* **ハッキングテクニックを共有するには、[**HackTricks**](https://github.com/carlospolop/hacktricks)と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のGitHubリポジトリにPRを提出してください。
