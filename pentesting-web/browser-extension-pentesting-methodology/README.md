# Metodologia di Pentesting delle Estensioni del Browser

<details>

<summary><strong>Impara l'hacking di AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata su HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PIANI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**La Famiglia PEASS**](https://opensea.io/collection/the-peass-family), la nostra collezione di [**NFT esclusivi**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR a** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos di github.

</details>

## Informazioni di Base

Le estensioni del browser sono scritte in JavaScript e caricate dal browser in background. Hanno il loro [DOM](https://www.w3schools.com/js/js\_htmldom.asp) ma possono interagire con i DOM di altri siti. Ci√≤ significa che potrebbero compromettere la confidenzialit√†, l'integrit√† e la disponibilit√† di altri siti (CIA).

## Componenti Principali

I layout delle estensioni appaiono migliori quando visualizzati e sono composti da tre componenti. Esaminiamo ogni componente in dettaglio.

<figure><img src="../../.gitbook/assets/image (13).png" alt=""><figcaption><p><a href="http://webblaze.cs.berkeley.edu/papers/Extensions.pdf">http://webblaze.cs.berkeley.edu/papers/Extensions.pdf</a></p></figcaption></figure>

### **Script di Contenuto**

Ogni script di contenuto ha accesso diretto al DOM di una **singola pagina web** ed √® quindi esposto a **input potenzialmente dannosi**. Tuttavia, lo script di contenuto non ha autorizzazioni diverse dalla capacit√† di inviare messaggi al core dell'estensione.

### **Core dell'Estensione**

Il core dell'estensione contiene la maggior parte dei privilegi/accessi dell'estensione, ma il core dell'estensione pu√≤ interagire solo con il contenuto web tramite [XMLHttpRequest](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest) e script di contenuto. Inoltre, il core dell'estensione non ha accesso diretto alla macchina host.

### **Binario Nativo**

L'estensione consente un binario nativo che pu√≤ **accedere alla macchina host con i pieni privilegi dell'utente**. Il binario nativo interagisce con il core dell'estensione attraverso l'interfaccia di programmazione delle applicazioni del plugin Netscape standard ([NPAPI](https://en.wikipedia.org/wiki/NPAPI)) utilizzata da Flash e altri plugin del browser.

### Limiti

{% hint style="danger" %}
Per ottenere i pieni privilegi dell'utente, un attaccante deve convincere l'estensione a passare input dannosi dallo script di contenuto al core dell'estensione e dal core dell'estensione al binario nativo.
{% endhint %}

Ogni componente dell'estensione √® separato gli uni dagli altri da **forti confini protettivi**. Ogni componente viene eseguito in un **processo separato del sistema operativo**. Gli script di contenuto e i core delle estensioni vengono eseguiti in **processi sandbox** non disponibili alla maggior parte dei servizi del sistema operativo.

Inoltre, gli script di contenuto sono separati dalle rispettive pagine web da **esecuzioni in un heap JavaScript separato**. Lo script di contenuto e la pagina web hanno **accesso allo stesso DOM sottostante**, ma i due **non scambiano mai puntatori JavaScript**, impedendo la fuoriuscita di funzionalit√† JavaScript.

## **`manifest.json`**

Un'estensione Chrome √® semplicemente una cartella ZIP con estensione file [.crx](https://www.lifewire.com/crx-file-2620391). Il core dell'estensione √® il file **`manifest.json`** nella radice della cartella, che specifica layout, autorizzazioni e altre opzioni di configurazione.

Esempio:
```json
{
"manifest_version": 2,
"name": "My extension",
"version": "1.0",
"permissions": [
"storage"
],
"content_scripts": [
{
"js": [
"script.js"
],
"matches": [
"https://example.com/*",
"https://www.example.com/*"
],
"exclude_matches": ["*://*/*business*"],
}
],
"background": {
"scripts": [
"background.js"
]
},
"options_ui": {
"page": "options.html"
}
}
```
### `content_scripts`

I content scripts vengono **caricati** ogni volta che l'utente **naviga su una pagina corrispondente**, nel nostro caso su qualsiasi pagina corrispondente all'espressione **`https://example.com/*`** e non corrispondente al regex **`*://*/*/business*`**. Eseguono **come gli script della pagina stessa** e hanno accesso arbitrario al [Document Object Model (DOM)](https://developer.mozilla.org/en-US/docs/Web/API/Document\_Object\_Model).
```json
"content_scripts": [
{
"js": [
"script.js"
],
"matches": [
"https://example.com/*",
"https://www.example.com/*"
],
"exclude_matches": ["*://*/*business*"],
}
],
```
Per includere o escludere ulteriori URL √® anche possibile utilizzare **`include_globs`** e **`exclude_globs`**.

Questo √® un esempio di script di contenuto che aggiunger√† un pulsante di spiegazione alla pagina quando [l'API di storage](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/storage) per recuperare il valore `message` dallo storage dell'estensione.
```js
chrome.storage.local.get("message", result =>
{
let div = document.createElement("div");
div.innerHTML = result.message + " <button>Explain</button>";
div.querySelector("button").addEventListener("click", () =>
{
chrome.runtime.sendMessage("explain");
});
document.body.appendChild(div);
});
```
<figure><img src="../../.gitbook/assets/image (20).png" alt=""><figcaption></figcaption></figure>

Un messaggio viene inviato alle pagine dell'estensione dallo script di contenuto quando viene cliccato questo pulsante, attraverso l'utilizzo dell'[**API runtime.sendMessage()**](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/runtime/sendMessage). Ci√≤ √® dovuto alla limitazione dello script di contenuto nell'accesso diretto alle API, con `storage` tra le poche eccezioni. Per funzionalit√† al di l√† di queste eccezioni, vengono inviati messaggi alle pagine dell'estensione con cui gli script di contenuto possono comunicare.

{% hint style="warning" %}
A seconda del browser, le capacit√† dello script di contenuto possono variare leggermente. Per i browser basati su Chromium, l'elenco delle capacit√† √® disponibile nella [documentazione per sviluppatori di Chrome](https://developer.chrome.com/docs/extensions/mv3/content_scripts/#capabilities), e per Firefox, il [MDN](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/Content_scripts#webextension_apis) funge da fonte primaria.\
√à inoltre importante notare che gli script di contenuto hanno la capacit√† di comunicare con gli script di background, consentendo loro di eseguire azioni e trasmettere risposte.
{% endhint %}

Per visualizzare e eseguire il debug degli script di contenuto in Chrome, √® possibile accedere al menu degli strumenti per sviluppatori di Chrome da Opzioni > Altri strumenti > Strumenti per sviluppatori O premendo Ctrl + Shift + I.

Una volta visualizzati gli strumenti per sviluppatori, √® necessario fare clic sulla scheda **Sorgente**, seguita dalla scheda **Script di contenuto**. Ci√≤ consente di osservare gli script di contenuto in esecuzione da varie estensioni e impostare i punti di interruzione per tracciare il flusso di esecuzione.

### Script di contenuto iniettati

{% hint style="success" %}
Si noti che **gli script di contenuto non sono obbligatori** poich√© √® anche possibile **iniettare dinamicamente** script e **iniettarli programmaticamente** nelle pagine web tramite **`tabs.executeScript`**. Questo fornisce effettivamente un controllo pi√π **granulare**.
{% endhint %}

Per l'iniezione programmatica di uno script di contenuto, √® necessario che l'estensione abbia i [permessi dell'host](https://developer.chrome.com/docs/extensions/reference/permissions) per la pagina in cui gli script devono essere iniettati. Questi permessi possono essere garantiti sia richiedendoli nel manifesto dell'estensione che su base temporanea tramite [**activeTab**](https://developer.chrome.com/docs/extensions/reference/manifest/activeTab).

#### Esempio di estensione basata su activeTab

{% code title="manifest.json" %}
```json
{
"name": "My extension",
...
"permissions": [
"activeTab",
"scripting"
],
"background": {
"service_worker": "background.js"
},
"action": {
"default_title": "Action Button"
}
}
```
{% endcode %}

* **Iniettare un file JS al clic:**
```javascript
// content-script.js
document.body.style.backgroundColor = "orange";

//service-worker.js - Inject the JS file
chrome.action.onClicked.addListener((tab) => {
chrome.scripting.executeScript({
target: { tabId: tab.id },
files: ["content-script.js"]
});
});
```
* **Iniettare una funzione** al click:
```javascript
//service-worker.js - Inject a function
function injectedFunction() {
document.body.style.backgroundColor = "orange";
}

chrome.action.onClicked.addListener((tab) => {
chrome.scripting.executeScript({
target : {tabId : tab.id},
func : injectedFunction,
});
});
```
#### Esempio con autorizzazioni di scripting
```javascript
// service-workser.js
chrome.scripting.registerContentScripts([{
id : "test",
matches : [ "https://*.example.com/*" ],
excludeMatches : [ "*://*/*business*" ],
js : [ "contentScript.js" ],
}]);

// Another example
chrome.tabs.executeScript(tabId, { file: "content_script.js" });
```
Per includere o escludere ulteriori URL √® anche possibile utilizzare **`include_globs`** e **`exclude_globs`**.

### Esecuzione degli script `run_at`

Il campo `run_at` controlla **quando i file JavaScript vengono iniettati nella pagina web**. Il valore preferito e predefinito √® `"document_idle"`.

I valori possibili sono:

* **`document_idle`**: Quando possibile
* **`document_start`**: Dopo eventuali file da `css`, ma prima che venga costruito qualsiasi altro DOM o venga eseguito qualsiasi altro script.
* **`document_end`**: Immediatamente dopo il completamento del DOM, ma prima che vengano caricati sottorisorse come immagini e frame.

#### Attraverso `manifest.json`
```json
{
"name": "My extension",
...
"content_scripts": [
{
"matches": ["https://*.example.com/*"],
"run_at": "document_idle",
"js": ["contentScript.js"]
}
],
...
}

```
Attraverso **`service-worker.js`**
```javascript
chrome.scripting.registerContentScripts([{
id : "test",
matches : [ "https://*.example.com/*" ],
runAt : "document_idle",
js : [ "contentScript.js" ],
}]);
```
### `sfondo`

I messaggi inviati dagli script di contenuto sono ricevuti dalla **pagina di sfondo**, che svolge un ruolo centrale nel coordinare i componenti dell'estensione. In particolare, la pagina di sfondo persiste per tutta la durata dell'estensione, operando discretamente senza interazione diretta dell'utente. Possiede il proprio Document Object Model (DOM), consentendo interazioni complesse e gestione dello stato.

**Punti Chiave**:

* **Ruolo della Pagina di Sfondo:** Agisce come centro nervoso dell'estensione, garantendo comunicazione e coordinamento tra le varie parti dell'estensione.
* **Persistenza:** √à un'entit√† sempre presente, invisibile per l'utente ma fondamentale per la funzionalit√† dell'estensione.
* **Generazione Automatica:** Se non esplicitamente definita, il browser creer√† automaticamente una pagina di sfondo. Questa pagina generata automaticamente includer√† tutti gli script di sfondo specificati nel manifesto dell'estensione, garantendo il corretto funzionamento dei compiti di sfondo dell'estensione.

{% hint style="success" %}
La comodit√† fornita dal browser nella generazione automatica di una pagina di sfondo (quando non dichiarata esplicitamente) garantisce che tutti gli script di sfondo necessari siano integrati e operativi, semplificando il processo di configurazione dell'estensione.
{% endhint %}

Esempio di script di sfondo:
```js
chrome.runtime.onMessage.addListener((request, sender, sendResponse) =>
{
if (request == "explain")
{
chrome.tabs.create({ url: "https://example.net/explanation" });
}
})
```
Utilizza l'API [runtime.onMessage](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/runtime/onMessage) per ascoltare i messaggi. Quando viene ricevuto un messaggio `"explain"`, utilizza l'API [tabs](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/tabs) per aprire una pagina in una nuova scheda.

Per eseguire il debug dello script di background, √® possibile andare ai **dettagli dell'estensione e ispezionare il service worker**, ci√≤ aprir√† gli strumenti per sviluppatori con lo script di background:

<figure><img src="https://github.com/carlospolop/hacktricks/blob/master/pentesting-web/browser-extension-pentesting-methodology/broken-reference" alt=""><figcaption></figcaption></figure>

### Pagine delle opzioni e altre

Le estensioni del browser possono contenere vari tipi di pagine:

* Le **pagine di azione** vengono visualizzate in un **menu a discesa quando si fa clic sull'icona dell'estensione**.
* Pagine che l'estensione **caricher√† in una nuova scheda**.
* **Pagine delle opzioni**: Questa pagina viene visualizzata sopra l'estensione quando si fa clic. Nel manifesto precedente nel mio caso sono riuscito ad accedere a questa pagina in `chrome://extensions/?options=fadlhnelkbeojnebcbkacjilhnbjfjca` o facendo clic su:

<figure><img src="../../.gitbook/assets/image (21).png" alt="" width="375"><figcaption></figcaption></figure>

Si noti che queste pagine non sono persistenti come le pagine di background poich√© caricano dinamicamente il contenuto solo quando necessario. Nonostante ci√≤, condividono alcune capacit√† con la pagina di background:

* **Comunicazione con gli script di contenuto:** Similmente alla pagina di background, queste pagine possono ricevere messaggi dagli script di contenuto, facilitando l'interazione all'interno dell'estensione.
* **Accesso alle API specifiche dell'estensione:** Queste pagine godono di un ampio accesso alle API specifiche dell'estensione, soggette alle autorizzazioni definite per l'estensione.

### `permissions` e `host_permissions`

**`permissions`** e **`host_permissions`** sono voci presenti nel `manifest.json` che indicheranno **quali autorizzazioni** ha l'estensione del browser (archiviazione, posizione...) e in **quali pagine web**.

Poich√© le estensioni del browser possono essere cos√¨ **privilegiate**, una malintenzionata o compromessa potrebbe consentire all'attaccante **diversi mezzi per rubare informazioni sensibili e spiare l'utente**.

Verifica come funzionano queste impostazioni e come potrebbero essere abusate in:

{% content-ref url="browext-permissions-and-host_permissions.md" %}
[browext-permissions-and-host\_permissions.md](browext-permissions-and-host\_permissions.md)
{% endcontent-ref %}

### `content_security_policy`

Una **policy di sicurezza dei contenuti** pu√≤ essere dichiarata anche all'interno del `manifest.json`. Se ne √® definita una, potrebbe essere **vulnerabile**.

L'impostazione predefinita per le pagine delle estensioni del browser √® piuttosto restrittiva:
```bash
script-src 'self'; object-src 'self';
```
Per ulteriori informazioni su CSP e potenziali bypass, controlla:

{% content-ref url="../content-security-policy-csp-bypass/" %}
[content-security-policy-csp-bypass](../content-security-policy-csp-bypass/)
{% endcontent-ref %}

### `web_accessible_resources`

affinch√© una pagina web possa accedere a una pagina di un'estensione del browser, ad esempio una pagina `.html`, questa pagina deve essere menzionata nel campo **`web_accessible_resources`** del `manifest.json`.\
Per esempio:
```javascript
{
...
"web_accessible_resources": [
{
"resources": [ "images/*.png" ],
"matches": [ "https://example.com/*" ]
},
{
"resources": [ "fonts/*.woff" ],
"matches": [ "https://example.com/*" ]
}
],
...
}
```
Queste pagine sono accessibili tramite URL come:
```
chrome-extension://<extension-id>/message.html
```
Nei **estensioni pubbliche l'ID dell'estensione √® accessibile**:

<figure><img src="../../.gitbook/assets/image (1191).png" alt="" width="375"><figcaption></figcaption></figure>

Tuttavia, se il parametro `manifest.json` **`use_dynamic_url`** √® utilizzato, questo **ID pu√≤ essere dinamico**.

Essere autorizzati ad accedere a queste pagine rende queste pagine **potenzialmente vulnerabili al ClickJacking**:

{% content-ref url="browext-clickjacking.md" %}
[browext-clickjacking.md](browext-clickjacking.md)
{% endcontent-ref %}

{% hint style="success" %}
Consentire il caricamento di queste pagine solo dall'estensione e non da URL casuali potrebbe prevenire gli attacchi di ClickJacking.
{% endhint %}

### `externally_connectable`

Come da [**documentazione**](https://developer.chrome.com/docs/extensions/reference/manifest/externally-connectable), La propriet√† del manifesto `"externally_connectable"` dichiara **quali estensioni e pagine web possono connettersi** alla tua estensione tramite [runtime.connect](https://developer.chrome.com/docs/extensions/reference/runtime#method-connect) e [runtime.sendMessage](https://developer.chrome.com/docs/extensions/reference/runtime#method-sendMessage).

* Se la chiave **`externally_connectable`** non √® dichiarata nel manifesto della tua estensione o √® dichiarata come **`"ids": ["*"]`**, **tutte le estensioni possono connettersi, ma nessuna pagina web pu√≤ connettersi**.
* Se vengono specificati **ID specifici**, come in `"ids": ["aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"]`, **solo quelle applicazioni** possono connettersi.
* Se vengono specificati **corrispondenze**, quelle app web saranno in grado di connettersi:
```json
"matches": [
"https://*.google.com/*",
"*://*.chromium.org/*",
```
* Se √® specificato come vuoto: **`"externally_connectable": {}`**, nessuna app o sito web potr√† connettersi.

Pi√π estensioni e URL sono indicati qui, pi√π piccola sar√† la superficie di attacco.

{% hint style="danger" %}
Se una pagina web vulnerabile a XSS o takeover √® indicata in **`externally_connectable`**, un attaccante sar√† in grado di inviare messaggi direttamente allo script di background, bypassando completamente lo script di contenuto e la sua CSP.

Pertanto, si tratta di un bypass molto potente.

Inoltre, se il cliente installa un'estensione fraudolenta, anche se non √® consentito comunicare con l'estensione vulnerabile, potrebbe iniettare dati XSS in una pagina web consentita o abusare delle API **`WebRequest`** o **`DeclarativeNetRequest`** per manipolare le richieste su un dominio mirato alterando la richiesta di una pagina per un file JavaScript. (Si noti che la CSP sulla pagina mirata potrebbe prevenire questi attacchi). Quest'idea proviene [**da questo articolo**](https://www.darkrelay.com/post/opera-zero-day-rce-vulnerability).
{% endhint %}

##

## Comunicazione Web **‚ÜîÔ∏é** Script di Contenuto

Gli ambienti in cui operano gli **script di contenuto** e dove esistono le pagine host sono **separati** l'uno dall'altro, garantendo **isolamento**. Nonostante questo isolamento, entrambi hanno la capacit√† di interagire con il **Modello ad Oggetti del Documento (DOM)** della pagina, una risorsa condivisa. Per consentire alla pagina host di comunicare con lo **script di contenuto**, o indirettamente con l'estensione attraverso lo script di contenuto, √® necessario utilizzare il **DOM** accessibile da entrambe le parti come canale di comunicazione.

### Messaggi Post

{% code title="content-script.js" %}
```javascript
var port = chrome.runtime.connect();

window.addEventListener("message", (event) => {
// We only accept messages from ourselves
if (event.source !== window) {
return;
}

if (event.data.type && (event.data.type === "FROM_PAGE")) {
console.log("Content script received: " + event.data.text);
port.postMessage(event.data.text);
}
}, false);
```
{% endcode %}

{% code title="esempio.js" %}
```javascript
document.getElementById("theButton").addEventListener("click", () => {
window.postMessage(
{type : "FROM_PAGE", text : "Hello from the webpage!"}, "*");
}, false);
```
{% endcode %}

Una comunicazione sicura tramite Post Message dovrebbe verificare l'autenticit√† del messaggio ricevuto, questo pu√≤ essere fatto controllando:

- **`event.isTrusted`**: Questo √® True solo se l'evento √® stato attivato da un'azione dell'utente
- Lo script di contenuto potrebbe aspettarsi un messaggio solo se l'utente esegue qualche azione
- **Dominio di origine**: potrebbe aspettarsi un messaggio solo da una lista di domini approvati.
- Se viene utilizzata un'espressione regolare, fare molta attenzione
- **Sorgente**: `received_message.source !== window` pu√≤ essere utilizzato per verificare se il messaggio proveniva **dalla stessa finestra** in cui lo script di contenuto sta ascoltando.

I controlli precedenti, anche se eseguiti, potrebbero essere vulnerabili, quindi controlla nella seguente pagina **potenziali bypass di Post Message**:

{% content-ref url="../postmessage-vulnerabilities/" %}
[postmessage-vulnerabilities](../postmessage-vulnerabilities/)
{% endcontent-ref %}

### Iframe

Un altro possibile modo di comunicazione potrebbe essere attraverso **URL Iframe**, puoi trovare un esempio in:

{% content-ref url="browext-xss-example.md" %}
[browext-xss-example.md](browext-xss-example.md)
{% endcontent-ref %}

### DOM

Questo non √® "esattamente" un modo di comunicazione, ma il **web e lo script di contenuto avranno accesso al DOM web**. Quindi, se lo **script di contenuto** sta leggendo alcune informazioni da esso, **fidandosi del DOM web**, il web potrebbe **modificare questi dati** (perch√© il web non dovrebbe essere fidato, o perch√© il web √® vulnerabile a XSS) e **compromettere lo script di contenuto**.

Puoi trovare anche un esempio di **XSS basato sul DOM per compromettere un'estensione del browser** in:

{% content-ref url="browext-xss-example.md" %}
[browext-xss-example.md](browext-xss-example.md)
{% endcontent-ref %}

## Informazioni Sensibili in Memoria/Codice

Se un'estensione del browser memorizza **informazioni sensibili all'interno della sua memoria**, queste potrebbero essere **estratte** (specialmente su macchine Windows) e **ricercate** per queste informazioni.

Pertanto, la memoria dell'estensione del browser **non dovrebbe essere considerata sicura** e le **informazioni sensibili** come credenziali o frasi mnemoniche **non dovrebbero essere memorizzate**.

Naturalmente, **non inserire informazioni sensibili nel codice**, poich√© saranno **pubbliche**.

Per estrarre la memoria dal browser potresti **estrarre la memoria del processo** o andare nelle **impostazioni** dell'estensione del browser cliccando su **`Ispeziona popup`** -> Nella sezione **`Memoria`** -> **`Fai uno snapshot`** e **`CTRL+F`** per cercare all'interno dello snapshot informazioni sensibili.

## Comunicazione Script di Contenuto **‚ÜîÔ∏é** Script di Background

Uno script di contenuto pu√≤ utilizzare le funzioni [**runtime.sendMessage()**](https://developer.chrome.com/docs/extensions/reference/runtime#method-sendMessage) **o** [**tabs.sendMessage()**](https://developer.chrome.com/docs/extensions/reference/tabs#method-sendMessage) per inviare un messaggio **una tantum serializzabile in JSON**.

Per gestire la **risposta**, utilizza la **Promise** restituita. Tuttavia, per la compatibilit√† all'indietro, √® ancora possibile passare un **callback** come ultimo argomento.

L'invio di una richiesta da uno **script di contenuto** appare cos√¨:
```javascript
(async () => {
const response = await chrome.runtime.sendMessage({greeting: "hello"});
// do something with response here, not outside the function
console.log(response);
})();
```
Inviare una richiesta dall'**estensione** (di solito uno **script di background**) Uno script di contenuto pu√≤ utilizzare le funzioni, tranne che √® necessario specificare a quale scheda inviarlo. Esempio di come inviare un messaggio allo script di contenuto nella scheda selezionata:
```javascript
// From https://stackoverflow.com/questions/36153999/how-to-send-a-message-between-chrome-extension-popup-and-content-script
(async () => {
const [tab] = await chrome.tabs.query({active: true, lastFocusedWindow: true});
const response = await chrome.tabs.sendMessage(tab.id, {greeting: "hello"});
// do something with response here, not outside the function
console.log(response);
})();
```
Sul **lato ricevente**, √® necessario impostare un [**runtime.onMessage**](https://developer.chrome.com/docs/extensions/reference/runtime#event-onMessage) **ascoltatore di eventi** per gestire il messaggio. Questo appare allo stesso modo da uno script di contenuto o da una pagina di estensione.
```javascript
// From https://stackoverflow.com/questions/70406787/javascript-send-message-from-content-js-to-background-js
chrome.runtime.onMessage.addListener(
function(request, sender, sendResponse) {
console.log(sender.tab ?
"from a content script:" + sender.tab.url :
"from the extension");
if (request.greeting === "hello")
sendResponse({farewell: "goodbye"});
}
);
```
Nell'esempio evidenziato, **`sendResponse()`** √® stato eseguito in modo sincrono. Per modificare il gestore degli eventi `onMessage` per l'esecuzione asincrona di `sendResponse()`, √® imperativo incorporare `return true;`.

Una considerazione importante √® che nei casi in cui pi√π pagine sono impostate per ricevere eventi `onMessage`, **la prima pagina a eseguire `sendResponse()`** per un evento specifico sar√† l'unica in grado di consegnare efficacemente la risposta. Eventuali risposte successive allo stesso evento non verranno prese in considerazione.

Nella creazione di nuove estensioni, la preferenza dovrebbe essere verso le promesse anzich√© i callback. Riguardo all'uso dei callback, la funzione `sendResponse()` √® considerata valida solo se viene eseguita direttamente all'interno del contesto sincrono, o se il gestore degli eventi indica un'operazione asincrona restituendo `true`. Se nessuno dei gestori restituisce `true` o se la funzione `sendResponse()` viene rimossa dalla memoria (garbage-collected), il callback associato alla funzione `sendMessage()` verr√† attivato per impostazione predefinita.

## Caricamento di un'estensione nel browser

1. **Scarica** l'Estensione per il Browser & scompattala
2. Vai su **`chrome://extensions/`** e **abilita** la `Modalit√† Sviluppatore`
3. Clicca sul pulsante **`Carica non elaborato`**

In **Firefox** vai su **`about:debugging#/runtime/this-firefox`** e clicca sul pulsante **`Carica componente aggiuntivo temporaneo`**.

## Ottenere il codice sorgente dallo store

Il codice sorgente di un'estensione Chrome pu√≤ essere ottenuto attraverso vari metodi. Di seguito sono fornite spiegazioni dettagliate e istruzioni per ciascuna opzione.

### Scarica l'Estensione come ZIP tramite la riga di comando

Il codice sorgente di un'estensione Chrome pu√≤ essere scaricato come file ZIP utilizzando la riga di comando. Questo comporta l'uso di `curl` per recuperare il file ZIP da un URL specifico e quindi estrarre i contenuti del file ZIP in una directory. Ecco i passaggi:

1. Sostituisci `"extension_id"` con l'effettivo ID dell'estensione.
2. Esegui i seguenti comandi:
```bash
extension_id=your_extension_id   # Replace with the actual extension ID
curl -L -o "$extension_id.zip" "https://clients2.google.com/service/update2/crx?response=redirect&os=mac&arch=x86-64&nacl_arch=x86-64&prod=chromecrx&prodchannel=stable&prodversion=44.0.2403.130&x=id%3D$extension_id%26uc"
unzip -d "$extension_id-source" "$extension_id.zip"
```
### Utilizzare il sito web CRX Viewer

[https://robwu.nl/crxviewer/](https://robwu.nl/crxviewer/)

### Utilizzare l'estensione CRX Viewer

Un altro metodo conveniente √® utilizzare il Chrome Extension Source Viewer, che √® un progetto open-source. Pu√≤ essere installato dal [Chrome Web Store](https://chrome.google.com/webstore/detail/chrome-extension-source-v/jifpbeccnghkjeaalbbjmodiffmgedin?hl=en). Il codice sorgente del visualizzatore √® disponibile nel suo [repository GitHub](https://github.com/Rob--W/crxviewer).

### Visualizzare il codice sorgente dell'estensione installata localmente

Anche le estensioni Chrome installate localmente possono essere ispezionate. Ecco come:

1. Accedi alla directory del profilo locale di Chrome visitando `chrome://version/` e individuando il campo "Percorso del profilo".
2. Naviga alla sottocartella `Extensions/` all'interno della directory del profilo.
3. Questa cartella contiene tutte le estensioni installate, tipicamente con il loro codice sorgente in un formato leggibile.

Per identificare le estensioni, puoi mappare i loro ID ai nomi:

* Abilita la Modalit√† Sviluppatore nella pagina `about:extensions` per vedere gli ID di ciascuna estensione.
* All'interno della cartella di ciascuna estensione, il file `manifest.json` contiene un campo `name` leggibile, che ti aiuta a identificare l'estensione.

### Utilizzare un Archiviatore o Decompressore di File

Vai al Chrome Web Store e scarica l'estensione. Il file avr√† estensione `.crx`. Cambia l'estensione del file da `.crx` a `.zip`. Utilizza un qualsiasi archiviatore di file (come WinRAR, 7-Zip, ecc.) per estrarre i contenuti del file ZIP.

### Utilizzare la Modalit√† Sviluppatore in Chrome

Apri Chrome e vai a `chrome://extensions/`. Abilita "Modalit√† Sviluppatore" in alto a destra. Clicca su "Carica estensione non pacchettizzata...". Naviga alla directory della tua estensione. Questo non scarica il codice sorgente, ma √® utile per visualizzare e modificare il codice di un'estensione gi√† scaricata o sviluppata.

## Checklist di Audit della Sicurezza

Anche se le Estensioni del Browser hanno una **superficie di attacco limitata**, alcune di esse potrebbero contenere **vulnerabilit√†** o **miglioramenti potenziali della sicurezza**. Ecco le pi√π comuni:

* [ ] **Limitare** il pi√π possibile le **`permissions`** richieste
* [ ] **Limitare** il pi√π possibile le **`host_permissions`**
* Utilizzare una **`content_security_policy`** **forte**
* [ ] **Limitare** il pi√π possibile il **`externally_connectable`**, se non √® necessario e possibile, non lasciarlo per impostazione predefinita, specificare **`{}`**
* Se un **URL vulnerabile a XSS o a takeover** √® menzionato qui, un attaccante sar√† in grado di **inviare messaggi direttamente agli script di background**. Molto potente bypass.
* [ ] **Limitare** il pi√π possibile le **`web_accessible_resources`**, anche vuoto se possibile.
* Se **`web_accessible_resources`** non √® nullo, controllare il [**ClickJacking**](browext-clickjacking.md)
* Se avviene una qualsiasi **comunicazione** dall'**estensione** alla **pagina web**, [**controllare XSS**](browext-xss-example.md) **vulnerabilit√†** causate nella comunicazione.
* Se vengono utilizzati i Post Messages, controllare le [**vulnerabilit√† di Post Message**](../postmessage-vulnerabilities/)**.**
* Se lo **Script di Contenuto accede ai dettagli del DOM**, controllare che non stiano introducendo un XSS se vengono **modificati** dalla pagina web
* Fare un'enfasi particolare se questa comunicazione √® coinvolta anche nella **comunicazione Script di Contenuto -> Script di Background**
* Le **informazioni sensibili non dovrebbero essere memorizzate** all'interno del codice dell'Estensione del Browser
* Le **informazioni sensibili non dovrebbero essere memorizzate** all'interno della memoria dell'Estensione del Browser

## Strumenti

### [**Tarnish**](https://thehackerblog.com/tarnish/)

* Estrae qualsiasi estensione Chrome da un link fornito dal Chrome webstore.
* Visualizzatore di [**manifest.json**](https://developer.chrome.com/extensions/manifest): visualizza semplicemente una versione JSON formattata del manifesto dell'estensione.
* Analisi dell'**Impronta Digitale**: Rilevamento delle [web\_accessible\_resources](https://developer.chrome.com/extensions/manifest/web\_accessible\_resources) e generazione automatica di JavaScript per l'impronta digitale dell'estensione Chrome.
* Analisi del **Potenziale Clickjacking**: Rilevamento delle pagine HTML dell'estensione con la direttiva [web\_accessible\_resources](https://developer.chrome.com/extensions/manifest/web\_accessible\_resources) impostata. Queste sono potenzialmente vulnerabili al clickjacking a seconda dello scopo delle pagine.
* Visualizzatore di Avvertimenti di **Permessi**: mostra un elenco di tutti gli avvisi di permessi di Chrome che verranno visualizzati quando un utente cercher√† di installare l'estensione.
* **Funzioni Pericolose**: mostra la posizione delle funzioni pericolose che potrebbero essere sfruttate da un attaccante (ad esempio funzioni come innerHTML, chrome.tabs.executeScript).
* **Punti di Ingresso**: mostra dove l'estensione accetta input dell'utente/esterno. Questo √® utile per comprendere l'area di superficie di un'estensione e cercare potenziali punti per inviare dati malevoli all'estensione.
* Sia gli scanner di Funzioni Pericolose che di Punti di Ingresso hanno quanto segue per i loro avvisi generati:
* Frammento di codice rilevante e linea che ha causato l'avviso.
* Descrizione del problema.
* Un pulsante "Visualizza File" per visualizzare il file sorgente completo contenente il codice.
* Il percorso del file segnalato.
* L'URI completo dell'estensione Chrome del file segnalato.
* Il tipo di file, come uno script di Pagina di Background, Script di Contenuto, Azione del Browser, ecc.
* Se la linea vulnerabile √® in un file JavaScript, i percorsi di tutte le pagine in cui √® inclusa nonch√© lo stato di [web\_accessible\_resource](https://developer.chrome.com/extensions/manifest/web\_accessible\_resources) di queste pagine.
* **Analizzatore e Verificatore di Bypass della Politica di Sicurezza del Contenuto (CSP)**: Questo evidenzier√† le debolezze nella CSP della tua estensione e illuminer√† eventuali modi per aggirare la tua CSP a causa di CDN in whitelist, ecc.
* **Librerie Vulnerabili Conosciute**: Utilizza [Retire.js](https://retirejs.github.io/retire.js/) per controllare l'uso di librerie JavaScript conosciute come vulnerabili.
* Scarica l'estensione e le versioni formattate.
* Scarica l'estensione originale.
* Scarica una versione formattata dell'estensione (HTML e JavaScript autoformattati).
* Cache automatica dei risultati della scansione, eseguire una scansione dell'estensione richieder√† molto tempo la prima volta che la esegui. Tuttavia, la seconda volta, assumendo che l'estensione non sia stata aggiornata, sar√† quasi istantanea grazie ai risultati in cache.
* URL di Report collegabili, per collegare facilmente qualcun altro a un report sull'estensione generato da tarnish.

### [Neto](https://github.com/elevenpaths/neto)

Il Progetto Neto √® un pacchetto Python 3 concepito per analizzare e svelare funzionalit√† nascoste di plugin e estensioni del browser per browser ben noti come Firefox e Chrome. Automatizza il processo di decomprimere i file confezionati per estrarre queste funzionalit√† da risorse rilevanti in un'estensione come `manifest.json`, cartelle di localizzazione o file sorgente Javascript e HTML.

## Riferimenti

* **Grazie a** [**@naivenom**](https://twitter.com/naivenom) **per l'aiuto con questa metodologia**
* [https://www.cobalt.io/blog/introduction-to-chrome-browser-extension-security-testing](https://www.cobalt.io/blog/introduction-to-chrome-browser-extension-security-testing)
* [https://palant.info/2022/08/10/anatomy-of-a-basic-extension/](https://palant.info/2022/08/10/anatomy-of-a-basic-extension/)
* [https://palant.info/2022/08/24/attack-surface-of-extension-pages/](https://palant.info/2022/08/24/attack-surface-of-extension-pages/)
* [https://palant.info/2022/08/31/when-extension-pages-are-web-accessible/](https://palant.info/2022/08/31/when-extension-pages-are-web-accessible/)
* [https://help.passbolt.com/assets/files/PBL-02-report.pdf](https://help.passbolt.com/assets/files/PBL-02-report.pdf)
* [https://developer.chrome.com/docs/extensions/develop/concepts/content-scripts](https://developer.chrome.com/docs/extensions/develop/concepts/content-scripts)
* [https://developer.chrome.com/docs/extensions/mv2/background-pages](https://developer.chrome.com/docs/extensions/mv2/background-pages)
* [https://thehackerblog.com/kicking-the-rims-a-guide-for-securely-writing-and-auditing-chrome-extensions/](https://thehackerblog.com/kicking-the-rims-a-guide-for-securely-writing-and-auditing-chrome-extensions/)
* [https://gist.github.com/LongJohnCoder/9ddf5735df3a4f2e9559665fb864eac0](https://gist.github.com/LongJohnCoder/9ddf5735df3a4f2e9559665fb864eac0)

<details>

<summary><strong>Impara l'hacking di AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:
* Se vuoi vedere la tua **azienda pubblicizzata su HackTricks** o **scaricare HackTricks in PDF** controlla i [**PACCHETTI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**La Famiglia PEASS**](https://opensea.io/collection/the-peass-family), la nostra collezione di esclusive [**NFT**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR ai** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repository di Github.

</details>
