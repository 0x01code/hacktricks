# Metodología de Pentesting de Extensiones de Navegador

<details>

<summary><strong>Aprende hacking en AWS de cero a héroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si quieres ver a tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF**, consulta los [**PLANES DE SUSCRIPCIÓN**](https://github.com/sponsors/carlospolop)!
* Consigue el [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colección de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* **Únete al** 💬 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **sígueme** en **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de github de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## Información Básica

Las extensiones de navegador están escritas en JavaScript y son cargadas por el navegador en segundo plano. Tienen su [DOM](https://www.w3schools.com/js/js_htmldom.asp) pero pueden interactuar con los DOMs de otros sitios. Esto significa que pueden comprometer la confidencialidad, integridad y disponibilidad (CIA) de otros sitios.

## Componentes Principales

La estructura de una extensión se visualiza mejor y consta de tres componentes. Veamos cada componente en detalle.

<figure><img src="../../.gitbook/assets/image (4).png" alt=""><figcaption><p><a href="http://webblaze.cs.berkeley.edu/papers/Extensions.pdf">http://webblaze.cs.berkeley.edu/papers/Extensions.pdf</a></p></figcaption></figure>

### **Scripts de Contenido**

Cada script de contenido tiene acceso directo al DOM de una **página web individual** y, por lo tanto, está expuesto a **entradas potencialmente maliciosas**. Sin embargo, el script de contenido no contiene permisos aparte de la capacidad de enviar mensajes al núcleo de la extensión.

### **Núcleo de la Extensión**

El núcleo de la extensión contiene la mayoría de los privilegios/accesos de la extensión, pero solo puede interactuar con el contenido web a través de [XMLHttpRequest](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest) y scripts de contenido. Además, el núcleo de la extensión no tiene acceso directo a la máquina anfitriona.

### **Binario Nativo**

La extensión permite un binario nativo que puede **acceder a la máquina anfitriona con todos los privilegios del usuario.** El binario nativo interactúa con el núcleo de la extensión a través de la interfaz de programación de aplicaciones de plugins de Netscape estándar ([NPAPI](https://en.wikipedia.org/wiki/NPAPI)) utilizada por Flash y otros complementos del navegador.

### Límites

{% hint style="danger" %}
Para obtener los privilegios completos del usuario, un atacante debe convencer a la extensión de pasar una entrada maliciosa del script de contenido al núcleo de la extensión y del núcleo de la extensión al binario nativo.
{% endhint %}

Cada componente de la extensión está separado de los demás por **fuertes límites protectores**. Cada componente se ejecuta en un **proceso del sistema operativo separado**. Los scripts de contenido y los núcleos de las extensiones se ejecutan en **procesos de sandbox** no disponibles para la mayoría de los servicios del sistema operativo.

Además, los scripts de contenido están separados de sus páginas web asociadas al **ejecutarse en un montón de JavaScript separado**. El script de contenido y la página web tienen **acceso al mismo DOM subyacente**, pero los dos **nunca intercambian punteros de JavaScript**, evitando la fuga de funcionalidad de JavaScript.

## **`manifest.json`**

Una extensión de Chrome es simplemente una carpeta ZIP con una extensión de archivo [.crx](https://www.lifewire.com/crx-file-2620391). El núcleo de la extensión es el archivo **`manifest.json`** en la raíz de la carpeta, que especifica la estructura, permisos y otras opciones de configuración.

Ejemplo:
```json
{
"manifest_version": 2,
"name": "My extension",
"version": "1.0",
"permissions": [
"storage"
],
"content_scripts": [
{
"js": [
"script.js"
],
"matches": [
"https://example.com/*",
"https://www.example.com/*"
],
"exclude_matches": ["*://*/*business*"],
}
],
"background": {
"scripts": [
"background.js"
]
},
"options_ui": {
"page": "options.html"
}
}
```
### `content_scripts`

Los scripts de contenido se **cargan** cada vez que el usuario **navega a una página que coincide**, en nuestro caso cualquier página que coincida con la expresión **`https://example.com/*`** y que no coincida con la regex **`*://*/*/business*`**. Se ejecutan **como los propios scripts de la página** y tienen acceso arbitrario al [Modelo de Objeto de Documento (DOM)](https://developer.mozilla.org/en-US/docs/Web/API/Document\_Object\_Model) de la página.
```json
"content_scripts": [
{
"js": [
"script.js"
],
"matches": [
"https://example.com/*",
"https://www.example.com/*"
],
"exclude_matches": ["*://*/*business*"],
}
],
```
Para incluir o excluir más URLs también es posible utilizar **`include_globs`** y **`exclude_globs`**.

Este es un ejemplo de un script de contenido que añadirá un botón de explicación a la página cuando [la API de almacenamiento](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/storage) para recuperar el valor de `message` del almacenamiento de la extensión.
```js
chrome.storage.local.get("message", result =>
{
let div = document.createElement("div");
div.innerHTML = result.message + " <button>Explain</button>";
div.querySelector("button").addEventListener("click", () =>
{
chrome.runtime.sendMessage("explain");
});
document.body.appendChild(div);
});
```
```json
{
  "name": "Ejemplo de extensión basada en activeTab",
  "version": "1.0",
  "description": "Inyecta un script de contenido en la página actual",
  "permissions": ["activeTab"],
  "background": {
    "scripts": ["background.js"],
    "persistent": false
  },
  "browser_action": {
    "default_popup": "popup.html"
  },
  "manifest_version": 2
}
```
{% endcode %}

Cuando se hace clic en este botón, el **script de contenido utiliza** [**runtime.sendMessage() API**](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/runtime/sendMessage) **para enviar un mensaje a las páginas de la extensión**. Esto se debe a que un script de contenido solo tiene acceso directo a un puñado de APIs como `storage`. Todo lo demás debe ser realizado por las páginas de la extensión a las que los scripts de contenido pueden enviar mensajes.

{% hint style="warning" %}
Las **capacidades del script de contenido** varían ligeramente dependiendo del navegador. Para navegadores basados en Chromium puedes encontrar la lista en la [documentación de Chrome Developers](https://developer.chrome.com/docs/extensions/mv3/content_scripts/#capabilities), para Firefox [MDN](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/Content_scripts#webextension_apis) es la fuente definitiva.\
Recuerda que el Script de Contenido también puede **comunicarse con los scripts de fondo** para que realicen acciones y envíen la respuesta.
{% endhint %}

Para ver y depurar scripts de contenido en Chrome, puedes abrir el menú de herramientas para desarrolladores de Chrome desde Opciones > Más herramientas > Herramientas para desarrolladores O (Presiona - Ctrl + Shift + I).

Con las herramientas para desarrolladores mostradas, haz clic en la **pestaña Fuente**, luego haz clic en la **pestaña Scripts de Contenido**. Aquí puedes ver los scripts de contenido en ejecución de las diversas extensiones y establecer puntos de interrupción para monitorear el flujo de ejecución.

<figure><img src="../../.gitbook/assets/image (1) (1).png" alt=""><figcaption></figcaption></figure>

### Scripts de contenido inyectados

{% hint style="success" %}
Ten en cuenta que **los Scripts de Contenido no son obligatorios**, ya que también es posible **inyectar** scripts **dinámicamente** y **programáticamente** en páginas web a través de **`tabs.executeScript`**. Esto en realidad proporciona controles más **granulares**.
{% endhint %}

Para inyectar un script de contenido programáticamente, tu extensión necesita [permisos de host](https://developer.chrome.com/docs/extensions/reference/permissions) para la página en la que está intentando inyectar scripts. Los permisos de host pueden otorgarse **solicitándolos** como parte del manifiesto de tu extensión o temporalmente a través de [**activeTab**](https://developer.chrome.com/docs/extensions/reference/manifest/activeTab)**.**

#### Ejemplo de extensión basada en activeTab

{% code title="manifest.json" %}
```json
{
"name": "My extension",
...
"permissions": [
"activeTab",
"scripting"
],
"background": {
"service_worker": "background.js"
},
"action": {
"default_title": "Action Button"
}
}
```
* **Inyectar un archivo JS al hacer clic:**
```javascript
// content-script.js
document.body.style.backgroundColor = "orange";

//service-worker.js - Inject the JS file
chrome.action.onClicked.addListener((tab) => {
chrome.scripting.executeScript({
target: { tabId: tab.id },
files: ["content-script.js"]
});
});
```
* **Inyectar una función** al hacer clic:
```javascript
//service-worker.js - Inject a function
function injectedFunction() {
document.body.style.backgroundColor = "orange";
}

chrome.action.onClicked.addListener((tab) => {
chrome.scripting.executeScript({
target : {tabId : tab.id},
func : injectedFunction,
});
});
```
#### Ejemplo con permisos de scripting
```javascript
// service-workser.js
chrome.scripting.registerContentScripts([{
id : "test",
matches : [ "https://*.nytimes.com/*" ],
excludeMatches : [ "*://*/*business*" ],
js : [ "contentScript.js" ],
}]);

// ANother example
chrome.tabs.executeScript(tabId, { file: "content_script.js" });
```
Para incluir o excluir más URLs también es posible utilizar **`include_globs`** y **`exclude_globs`**.

### Scripts de Contenido `run_at`

El campo `run_at` controla **cuándo se inyectan los archivos JavaScript en la página web**. El valor preferido y predeterminado es `"document_idle"`.

Los valores posibles son:

* **`document_idle`**: Siempre que sea posible
* **`document_start`**: Después de cualquier archivo de `css`, pero antes de que se construya cualquier otro DOM o se ejecute cualquier otro script.
* **`document_end`**: Inmediatamente después de que el DOM esté completo, pero antes de que se carguen subrecursos como imágenes y marcos.

#### A través de `manifest.json`
```json
{
"name": "My extension",
...
"content_scripts": [
{
"matches": ["https://*.nytimes.com/*"],
"run_at": "document_idle",
"js": ["contentScript.js"]
}
],
...
}

```
A través de **`service-worker.js`**
```javascript
chrome.scripting.registerContentScripts([{
id : "test",
matches : [ "https://*.nytimes.com/*" ],
runAt : "document_idle",
js : [ "contentScript.js" ],
}]);
```
### `fondo`

Cuando los scripts de contenido envían un mensaje, su destino es la **página de fondo**. La página de fondo es una página especial que está **siempre presente** a menos que se especifique lo contrario en el manifiesto de la extensión. Es invisible para el usuario, a pesar de ser una página regular con su propio DOM y todo. Su función es típicamente coordinar todas las demás partes de la extensión.

{% hint style="success" %}
Si una página de fondo no se declara explícitamente, el navegador generará una **automáticamente** de manera útil y se asegurará de que todos los **scripts de fondo declarados estén cargados** en ella, como en el ejemplo anterior de manifest.json.
{% endhint %}

Ejemplo de script de fondo:
```js
chrome.runtime.onMessage.addListener((request, sender, sendResponse) =>
{
if (request == "explain")
{
chrome.tabs.create({ url: "https://example.net/explanation" });
}
})
```
Utiliza la [API runtime.onMessage](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/runtime/onMessage) para escuchar mensajes. Cuando se recibe un mensaje de `"explain"`, utiliza la [API de tabs](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/tabs) para abrir una página en una nueva pestaña.

Para depurar el script de fondo, podrías ir a **los detalles de la extensión e inspeccionar el service worker,** esto abrirá las herramientas de desarrollador con el script de fondo:

<figure><img src="broken-reference" alt=""><figcaption></figcaption></figure>

### Páginas de opciones y otras

Las extensiones de navegador pueden contener varios tipos de páginas:

* **Páginas de acción** se muestran en un **desplegable cuando se hace clic en el icono de la extensión**.
* Páginas que la extensión **cargará en una nueva pestaña**.
* **Páginas de opciones**: Esta página se muestra encima de la extensión al hacer clic. En el manifiesto anterior, en mi caso, pude acceder a esta página en `chrome://extensions/?options=fadlhnelkbeojnebcbkacjilhnbjfjca` o haciendo clic:

<figure><img src="../../.gitbook/assets/image (8).png" alt="" width="375"><figcaption></figcaption></figure>

A diferencia de la página de fondo, estas páginas no son persistentes, sino que se cargan cuando se necesitan. Sin embargo, todas ellas pueden **recibir mensajes de los scripts de contenido**. Y todas tienen **acceso completo a las APIs específicas de la extensión**, en la medida en que lo permitan los permisos de la extensión.

En conjunto, los contextos relevantes para las extensiones de navegador se ven así:

<figure><img src="../../.gitbook/assets/image (9).png" alt="" width="563"><figcaption></figcaption></figure>

### `permissions` & `host_permissions`

**`permissions`** y **`host_permissions`** son entradas del `manifest.json` que indicarán **qué permisos** tiene la extensión de navegador (almacenamiento, ubicación...) y en **qué páginas web**.

Como las extensiones de navegador pueden ser tan **privilegiadas**, una maliciosa o una que haya sido comprometida podría permitir al atacante **diferentes medios para robar información sensible y espiar al usuario**.

Revisa cómo funcionan estos ajustes y cómo podrían ser abusados en:

{% content-ref url="browext-permissions-and-host_permissions.md" %}
[browext-permissions-and-host\_permissions.md](browext-permissions-and-host\_permissions.md)
{% endcontent-ref %}

### `content_security_policy`

Una **política de seguridad de contenido** también puede ser declarada dentro del `manifest.json`. Si hay una definida, podría ser **vulnerable**.

La configuración predeterminada para las páginas de extensiones de navegador es bastante restrictiva:
```bash
script-src 'self'; object-src 'self';
```
Para obtener más información sobre CSP y posibles bypasses, consulta:

{% content-ref url="../content-security-policy-csp-bypass/" %}
[content-security-policy-csp-bypass](../content-security-policy-csp-bypass/)
{% endcontent-ref %}

### `web_accessible_resources`

para que una página web acceda a una página de una Extensión de Navegador, una página `.html` por ejemplo, esta página debe estar mencionada en el campo **`web_accessible_resources`** del `manifest.json`.\
Por ejemplo:
```javascript
{
...
"web_accessible_resources": [
{
"resources": [ "images/*.png" ],
"matches": [ "https://example.com/*" ]
},
{
"resources": [ "fonts/*.woff" ],
"matches": [ "https://example.com/*" ]
}
],
...
}
```
Estas páginas son accesibles en URL como:
```
chrome-extension://<extension-id>/message.html
```
En las extensiones públicas el **extension-id es accesible**:

<figure><img src="../../.gitbook/assets/image (722).png" alt="" width="375"><figcaption></figcaption></figure>

Sin embargo, si se utiliza el parámetro `manifest.json` **`use_dynamic_url`**, este **id puede ser dinámico**.

El poder acceder a estas páginas las hace **potencialmente vulnerables a ClickJacking**:

{% content-ref url="browext-clickjacking.md" %}
[browext-clickjacking.md](browext-clickjacking.md)
{% endcontent-ref %}

{% hint style="success" %}
Permitir que estas páginas solo se carguen por la extensión y no por URLs aleatorias podría prevenir ataques de ClickJacking.
{% endhint %}

### `externally_connectable`

Según los [**documentos**](https://developer.chrome.com/docs/extensions/reference/manifest/externally-connectable), la propiedad del manifiesto `"externally_connectable"` declara **qué extensiones y páginas web pueden conectarse** a tu extensión a través de [runtime.connect](https://developer.chrome.com/docs/extensions/reference/runtime#method-connect) y [runtime.sendMessage](https://developer.chrome.com/docs/extensions/reference/runtime#method-sendMessage).

* Si la clave **`externally_connectable`** **no** está declarada en el manifiesto de tu extensión o está declarada como **`"ids": ["*"]`**, **todas las extensiones pueden conectarse, pero ninguna página web puede hacerlo**.
* Si se especifican **IDs específicos**, como en `"ids": ["aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"]`, **solo esas aplicaciones** pueden conectarse.
* Si se especifican **coincidencias**, esas aplicaciones web podrán conectarse:
```json
"matches": [
"https://*.google.com/*",
"*://*.chromium.org/*",
```
* Si se especifica como vacío: **`"externally_connectable": {}`**, ninguna app o web podrá conectarse.

Cuantas **menos extensiones y URLs** se indiquen aquí, **menor será la superficie de ataque**.

{% hint style="danger" %}
Si una página web **vulnerable a XSS o takeover** se indica en **`externally_connectable`**, un atacante podrá **enviar mensajes directamente al script de fondo**, evitando completamente el Content Script y su CSP.

Por lo tanto, esto es un **bypass muy poderoso**.
{% endhint %}

## Comunicación Web **↔︎** Content Script

Aunque los entornos de ejecución de **los content scripts y las páginas** que los alojan están **aislados** entre sí, **comparten acceso al DOM de la página**. Si la página desea comunicarse con el content script, o con la extensión a través del content script, debe hacerlo a través del **DOM compartido**.

### Post Messages

{% code title="content-script.js" %}
```javascript
var port = chrome.runtime.connect();

window.addEventListener("message", (event) => {
// We only accept messages from ourselves
if (event.source !== window) {
return;
}

if (event.data.type && (event.data.type === "FROM_PAGE")) {
console.log("Content script received: " + event.data.text);
port.postMessage(event.data.text);
}
}, false);
```
{% endcode %}

{% code title="example.js" %}
```javascript
document.getElementById("theButton").addEventListener("click", () => {
window.postMessage(
{type : "FROM_PAGE", text : "Hello from the webpage!"}, "*");
}, false);
```
```markdown
Una comunicación segura de Post Message debe verificar la autenticidad del mensaje recibido, esto se puede hacer comprobando:

* **`event.isTrusted`**: Esto es verdadero solo si el evento fue desencadenado por una acción del usuario
* El script de contenido podría estar esperando un mensaje solo si el usuario realiza alguna acción
* **dominio de origen**: Se puede verificar contra una lista de permitidos de dominios.
* Si se usa una expresión regular, tenga mucho cuidado
* **Fuente**: `received_message.source !== window` se puede usar para verificar si el mensaje fue **de la misma ventana** donde el Script de Contenido está escuchando.

Las comprobaciones anteriores, incluso si se realizan, podrían ser vulnerables, así que revise en la siguiente página **posibles bypasses de Post Message**:

{% content-ref url="../postmessage-vulnerabilities/" %}
[postmessage-vulnerabilities](../postmessage-vulnerabilities/)
{% endcontent-ref %}

### Iframe

Otra posible forma de comunicación podría ser a través de **URLs de Iframe**, puede encontrar un ejemplo en:

{% content-ref url="browext-xss-example.md" %}
[browext-xss-example.md](browext-xss-example.md)
{% endcontent-ref %}

### DOM

Esto no es "exactamente" una forma de comunicación, pero **la web y el script de contenido tendrán acceso al DOM web**. Por lo tanto, si el **script de contenido** está leyendo alguna información de él, **confiando en el DOM web**, la web podría **modificar estos datos** (porque la web no debería ser confiable, o porque la web es vulnerable a XSS) y **comprometer el Script de Contenido**.

También puede encontrar un ejemplo de un **XSS basado en DOM para comprometer una extensión de navegador** en:

{% content-ref url="browext-xss-example.md" %}
[browext-xss-example.md](browext-xss-example.md)
{% endcontent-ref %}

## Información Sensible en Memoria/Código

Si una Extensión de Navegador almacena **información sensible dentro de su memoria**, esta podría ser **volcada** (especialmente en máquinas Windows) y **buscada** para obtener esta información.

Por lo tanto, la memoria de la Extensión de Navegador **no debe considerarse segura** y **no se debe almacenar información sensible**, como credenciales o frases mnemotécnicas.

Por supuesto, **no coloque información sensible en el código**, ya que será **pública**.

## Comunicación Script de Contenido **↔︎** Script de Fondo

Un Script de Contenido puede usar las funciones [**runtime.sendMessage()**](https://developer.chrome.com/docs/extensions/reference/runtime#method-sendMessage) **o** [**tabs.sendMessage()**](https://developer.chrome.com/docs/extensions/reference/tabs#method-sendMessage) para enviar un mensaje **serializable en JSON de un solo uso**.

Para manejar la **respuesta**, use la **Promise** devuelta. Aunque, por compatibilidad hacia atrás, todavía puede pasar un **callback** como último argumento.

Enviar una solicitud desde un **script de contenido** se ve así:
```
```javascript
(async () => {
const response = await chrome.runtime.sendMessage({greeting: "hello"});
// do something with response here, not outside the function
console.log(response);
})();
```
Enviando una solicitud desde la **extensión** (usualmente un **script de fondo**) a un script de contenido es similar, excepto que necesitas especificar a qué pestaña enviarla. Este ejemplo demuestra cómo enviar un mensaje al script de contenido en la pestaña seleccionada.
```javascript
(async () => {
const [tab] = await chrome.tabs.query({active: true, lastFocusedWindow: true});
const response = await chrome.tabs.sendMessage(tab.id, {greeting: "hello"});
// do something with response here, not outside the function
console.log(response);
})();
```
En el **extremo receptor**, necesitas configurar un [**runtime.onMessage**](https://developer.chrome.com/docs/extensions/reference/runtime#event-onMessage) **event listener** para manejar el mensaje. Esto se ve igual desde un script de contenido o una página de extensión.
```javascript
chrome.runtime.onMessage.addListener(
function(request, sender, sendResponse) {
console.log(sender.tab ?
"from a content script:" + sender.tab.url :
"from the extension");
if (request.greeting === "hello")
sendResponse({farewell: "goodbye"});
}
);
```
En el ejemplo anterior, **`sendResponse()`** fue llamado de manera sincrónica. Si quieres usar `sendResponse()` de manera **asincrónica**, añade `return true;` al manejador de eventos `onMessage`.

> Si múltiples páginas están escuchando eventos `onMessage`, **solo la primera en llamar a `sendResponse()`** para un evento particular tendrá éxito al enviar la respuesta. Todas las demás respuestas a ese evento serán ignoradas.

Para extensiones nuevas deberías preferir promesas sobre callbacks. Si estás usando callbacks, el callback `sendResponse()` solo es válido si se usa de manera sincrónica, o si el manejador de eventos retorna `true` para indicar que responderá de manera asincrónica. El callback de la función `sendMessage()` será invocado automáticamente si ningún manejador retorna true o si el callback `sendResponse()` es recolectado por el garbage collector.

## Cargando una Extensión en el Navegador

1. **Descarga** la Extensión del Navegador y descomprímela
2. Ve a **`chrome://extensions/`** y **activa** el `Modo de Desarrollador`
3. Haz clic en el botón **`Cargar descomprimido`**

En **Firefox** ve a **`about:debugging#/runtime/this-firefox`** y haz clic en el botón **`Cargar Complemento Temporal`**.

## Obteniendo el código fuente desde la tienda

Desde [**aquí**](https://gist.github.com/paulirish/78d6c1406c901be02c2d):

### Opción 1: Descarga de la extensión en línea de comandos como zip y extrae

{% code overflow="wrap" %}
```bash
extension_id=jifpbeccnghkjeaalbbjmodiffmgedin   # change this ID
curl -L -o "$extension_id.zip" "https://clients2.google.com/service/update2/crx?response=redirect&os=mac&arch=x86-64&nacl_arch=x86-64&prod=chromecrx&prodchannel=stable&prodversion=44.0.2403.130&x=id%3D$extension_id%26uc"
unzip -d "$extension_id-source" "$extension_id.zip"
```
{% endcode %}

Gracias a crxviewer por la [URL mágica de descarga](https://github.com/Rob--W/crxviewer/blob/6113c25e3569e1ec59365ad9a177aa97e2bcda61/src/cws\_pattern.js#L27-L74).

### Opción 2: Usa el sitio web CRX Viewer

[https://robwu.nl/crxviewer/](https://robwu.nl/crxviewer/)

### Opción 3: Usa la extensión CRX Viewer

La [Chrome extension source viewer](https://chrome.google.com/webstore/detail/chrome-extension-source-v/jifpbeccnghkjeaalbbjmodiffmgedin?hl=en) es de código abierto ([repositorio en github](https://github.com/Rob--W/crxviewer)) y facilita mucho este proceso.

### Opción 3: Ver el código fuente de una extensión instalada localmente

1. Encuentra tu directorio de perfil local de Chrome. Abre `chrome://version/` y busca el campo "Ruta del perfil:". Abre esa carpeta.
2. Abre la subcarpeta `Extensions/`
3. Aquí están todas tus extensiones, con código fuente típicamente legible.

#### Mapeo entre las IDs de extensiones instaladas localmente y sus nombres

* En `about:extensions`, activa el Modo de Desarrollador y verás las IDs bajo cada entrada
* Dentro de las carpetas `Extensions/`, el archivo manifest.json tiene un campo `name` legible

## Lista de Verificación de Auditoría de Seguridad

Aunque las Extensiones de Navegador tienen una **superficie de ataque limitada**, algunas pueden contener **vulnerabilidades** o **posibles mejoras de endurecimiento**. Las más comunes son:

* [ ] **Limitar** tanto como sea posible los **`permissions`** solicitados
* [ ] **Limitar** tanto como sea posible los **`host_permissions`**
* [ ] Usar una **fuerte** **`content_security_policy`**
* [ ] **Limitar** tanto como sea posible el **`externally_connectable`**, si no se necesita y es posible, no dejarlo por defecto, especificar **`{}`**
* [ ] Si se menciona aquí una **URL vulnerable a XSS o a toma de control**, un atacante podrá **enviar mensajes a los scripts de fondo directamente**. Un bypass muy poderoso.
* [ ] **Limitar** tanto como sea posible los **`web_accessible_resources`**, incluso vacío si es posible.
* [ ] Si **`web_accessible_resources`** no es ninguno, verificar [**ClickJacking**](browext-clickjacking.md)
* [ ] Si ocurre alguna **comunicación** desde la **extensión** a la **página web**, [**verificar vulnerabilidades de XSS**](browext-xss-example.md) causadas en la comunicación.
* [ ] Si se usan Post Messages, verificar [**vulnerabilidades de Post Message**](../postmessage-vulnerabilities/)**.**
* [ ] Si el **Content Script accede a detalles del DOM**, verificar que no estén **introduciendo un XSS** si se **modifican** por la web
* [ ] Hacer un énfasis especial si esta comunicación también está involucrada en la **comunicación Content Script -> Script de fondo**
* [ ] **No se debe almacenar información sensible** dentro del código de la Extensión de Navegador
* [ ] **No se debe almacenar información sensible** dentro de la memoria de la Extensión de Navegador

## Herramientas

### [**Tarnish**](https://thehackerblog.com/tarnish/)

* Extrae cualquier extensión de Chrome de un enlace proporcionado de la tienda web de Chrome.
* **Visualizador de [**manifest.json**](https://developer.chrome.com/extensions/manifest)**: simplemente muestra una versión en JSON bonito del manifiesto de la extensión.
* **Análisis de Huellas Digitales**: Detección de [web\_accessible\_resources](https://developer.chrome.com/extensions/manifest/web\_accessible\_resources) y generación automática de JavaScript para la toma de huellas digitales de extensiones de Chrome.
* **Análisis Potencial de Clickjacking**: Detección de páginas HTML de extensión con la directiva [web\_accessible\_resources](https://developer.chrome.com/extensions/manifest/web\_accessible\_resources) establecida. Estas son potencialmente vulnerables a clickjacking dependiendo del propósito de las páginas.
* **Visualizador de Advertencias de Permisos**: que muestra una lista de todas las advertencias de solicitud de permisos de Chrome que se mostrarán al usuario al intentar instalar la extensión.
* **Funciones Peligrosas**: muestra la ubicación de funciones peligrosas que podrían ser explotadas por un atacante (por ejemplo, funciones como innerHTML, chrome.tabs.executeScript).
* **Puntos de Entrada**: muestra dónde la extensión recibe entrada de usuario/externa. Esto es útil para entender la superficie de ataque de una extensión y buscar puntos potenciales para enviar datos maliciosamente elaborados a la extensión.
* Tanto el escáner de Funciones Peligrosas como el de Puntos de Entrada tienen lo siguiente para sus alertas generadas:
* Fragmento de código relevante y línea que causó la alerta.
* Descripción del problema.
* Un botón "Ver Archivo" para ver el archivo fuente completo que contiene el código.
* La ruta del archivo alertado.
* La URI completa de la extensión de Chrome del archivo alertado.
* El tipo de archivo que es, como un script de Página de Fondo, Script de Contenido, Acción del Navegador, etc.
* Si la línea vulnerable está en un archivo JavaScript, las rutas de todas las páginas donde está incluido, así como el tipo de estas páginas y el estado de [web\_accessible\_resource](https://developer.chrome.com/extensions/manifest/web\_accessible\_resources).
* **Analizador de Política de Seguridad de Contenido (CSP) y verificador de bypass**: Esto señalará debilidades en la CSP de tu extensión y también iluminará cualquier forma potencial de eludir tu CSP debido a CDNs en la lista blanca, etc.
* **Bibliotecas Vulnerables Conocidas**: Esto utiliza [Retire.js](https://retirejs.github.io/retire.js/) para verificar cualquier uso de bibliotecas de JavaScript conocidas por ser vulnerables.
* Descargar extensiones y versiones formateadas.
* Descargar la extensión original.
* Descargar una versión embellecida de la extensión (HTML y JavaScript automáticamente bonitos).
* Caché automático de resultados de análisis, realizar un análisis de extensión tomará un buen tiempo la primera vez que se ejecute. Sin embargo, la segunda vez, asumiendo que la extensión no ha sido actualizada, será casi instantáneo debido a que los resultados están en caché.
* URLs de Reportes Enlazables, enlaza fácilmente a alguien más a un informe de extensión generado por tarnish.

### [Neto](https://github.com/elevenpaths/neto)

El proyecto Neto es un paquete de Python 3 concebido para analizar y desentrañar características ocultas de plugins y extensiones de navegador para navegadores bien conocidos como Firefox y Chrome. Automatiza el proceso de descomprimir los archivos empaquetados para extraer estas características de recursos relevantes en una extensión como `manifest.json`, carpetas de localización o archivos fuente de Javascript y HTML.

## Referencias

* **Gracias a** [**@naivenom**](https://twitter.com/naivenom) **por la ayuda con esta metodología**
* [https://www.cobalt.io/blog/introduction-to-chrome-browser-extension-security-testing](https://www.cobalt.io/blog/introduction-to-chrome-browser-extension-security-testing)
* [https://palant.info/2022/08/10/anatomy-of-a-basic-extension/](https://palant.info/2022/08/10/anatomy-of-a-basic-extension/)
* [https://palant.info/2022/08/24/attack-surface-of-extension-pages/](https://palant.info/2022/08/24/attack-surface-of-extension-pages/)
* [https://palant.info/2022/08/31/when-extension-pages-are-web-accessible/](https://palant.info/2022/08/31/when-extension-pages-are-web-accessible/)
* [https://help.passbolt.com/assets/files/PBL-02-report.pdf](https://help.passbolt.com/assets/files/PBL-02-report.pdf)
* [https://developer.chrome.com/docs/extensions/develop/concepts/content-scripts](https://developer.chrome.com/docs/extensions/develop/concepts/content-scripts)
* [https://developer.chrome.com/docs/extensions/mv2/background-pages](https://developer.chrome.com/docs/extensions/mv2/background-pages)
* [https://thehackerblog.com/kicking-the-rims-a-guide-for-securely-writing-and-auditing-chrome-extensions/](https://thehackerblog.com/kicking-the-rims-a-guide-for-securely-writing-and-auditing-chrome-extensions/)

<details>

<summary><strong>Aprende hacking en AWS de cero a héroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si quieres ver a tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** revisa los [**PLANES DE SUSCRIPCIÓN**](https://github.com/sponsors/carlospolop)!
* Consigue el [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colección de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* **Únete al** 💬 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **sígueme** en **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) en github.

</details>
