# Browser-Erweiterungs-Pentesting-Methodik

<details>

<summary><strong>Lernen Sie AWS-Hacking von Null auf Held mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen m√∂chten** oder **HackTricks als PDF herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merch**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories einreichen.

</details>

## Grundlegende Informationen

Browser-Erweiterungen werden in JavaScript geschrieben und vom Browser im Hintergrund geladen. Sie haben ihr [DOM](https://www.w3schools.com/js/js\_htmldom.asp), k√∂nnen jedoch mit DOMs anderer Websites interagieren. Dies bedeutet, dass sie die Vertraulichkeit, Integrit√§t und Verf√ºgbarkeit (CIA) anderer Websites beeintr√§chtigen k√∂nnen.

## Hauptkomponenten

Erweiterungslayouts sehen am besten aus, wenn sie visualisiert werden und bestehen aus drei Komponenten. Schauen wir uns jede Komponente genauer an.

<figure><img src="../../.gitbook/assets/image (16) (1).png" alt=""><figcaption><p><a href="http://webblaze.cs.berkeley.edu/papers/Extensions.pdf">http://webblaze.cs.berkeley.edu/papers/Extensions.pdf</a></p></figcaption></figure>

### **Inhaltsskripte**

Jedes Inhaltsskript hat direkten Zugriff auf das DOM einer **einzigen Webseite** und ist somit potenziell **b√∂sartigen Eingaben** ausgesetzt. Das Inhaltsskript enth√§lt jedoch keine Berechtigungen au√üer der F√§higkeit, Nachrichten an den Erweiterungskern zu senden.

### **Erweiterungskern**

Der Erweiterungskern enth√§lt die meisten Erweiterungsprivilegien/-zugriffe, kann jedoch nur √ºber [XMLHttpRequest](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest) und Inhaltsskripte mit Webinhalten interagieren. Au√üerdem hat der Erweiterungskern keinen direkten Zugriff auf den Hostrechner.

### **Native Bin√§rdatei**

Die Erweiterung erm√∂glicht eine native Bin√§rdatei, die **mit den vollen Benutzerrechten auf den Hostrechner zugreifen kann**. Die native Bin√§rdatei interagiert mit dem Erweiterungskern √ºber die Standard-Netscape-Plugin-Anwendungsprogrammierschnittstelle ([NPAPI](https://en.wikipedia.org/wiki/NPAPI)), die von Flash und anderen Browser-Plug-Ins verwendet wird.

### Grenzen

{% hint style="danger" %}
Um die vollen Benutzerrechte zu erlangen, muss ein Angreifer die Erweiterung √ºberzeugen, b√∂sartige Eingaben vom Inhaltsskript an den Erweiterungskern und vom Erweiterungskern an die native Bin√§rdatei weiterzuleiten.
{% endhint %}

Jede Komponente der Erweiterung ist durch **starke Schutzgrenzen voneinander getrennt**. Jede Komponente l√§uft in einem **eigenen Betriebssystemprozess**. Inhaltsskripte und Erweiterungskerne laufen in **Sandbox-Prozessen**, die f√ºr die meisten Betriebssystemdienste nicht verf√ºgbar sind.

Dar√ºber hinaus sind Inhaltsskripte von ihren zugeh√∂rigen Webseiten durch **Ausf√ºhrung in einem separaten JavaScript-Heap** getrennt. Das Inhaltsskript und die Webseite haben **Zugriff auf dasselbe zugrunde liegende DOM**, aber die beiden **tauschen niemals JavaScript-Pointer aus**, was das Auslaufen von JavaScript-Funktionalit√§t verhindert.

## **`manifest.json`**

Eine Chrome-Erweiterung ist nur ein ZIP-Ordner mit einer [.crx-Dateierweiterung](https://www.lifewire.com/crx-file-2620391). Der Kern der Erweiterung ist die **`manifest.json`**-Datei im Stammverzeichnis des Ordners, die Layout, Berechtigungen und andere Konfigurationsoptionen angibt.

Beispiel:
```json
{
"manifest_version": 2,
"name": "My extension",
"version": "1.0",
"permissions": [
"storage"
],
"content_scripts": [
{
"js": [
"script.js"
],
"matches": [
"https://example.com/*",
"https://www.example.com/*"
],
"exclude_matches": ["*://*/*business*"],
}
],
"background": {
"scripts": [
"background.js"
]
},
"options_ui": {
"page": "options.html"
}
}
```
### `content_scripts`

Content-Skripte werden **geladen**, wenn der Benutzer zu einer √ºbereinstimmenden Seite **navigiert**, in unserem Fall zu einer Seite, die dem Ausdruck **`https://example.com/*`** entspricht und nicht dem **`*://*/*/business*`**-Regex entspricht. Sie werden **wie die eigenen Skripte der Seite** ausgef√ºhrt und haben beliebigen Zugriff auf das [Document Object Model (DOM)](https://developer.mozilla.org/en-US/docs/Web/API/Document\_Object\_Model).
```json
"content_scripts": [
{
"js": [
"script.js"
],
"matches": [
"https://example.com/*",
"https://www.example.com/*"
],
"exclude_matches": ["*://*/*business*"],
}
],
```
Um weitere URLs einzuschlie√üen oder auszuschlie√üen, ist es auch m√∂glich, **`include_globs`** und **`exclude_globs`** zu verwenden.

Dies ist ein Beispielinhaltsskript, das eine Erkl√§rungsschaltfl√§che zur Seite hinzuf√ºgt, wenn [die Speicher-API](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/storage) verwendet wird, um den Wert `message` aus dem Speicher der Erweiterung abzurufen.
```js
chrome.storage.local.get("message", result =>
{
let div = document.createElement("div");
div.innerHTML = result.message + " <button>Explain</button>";
div.querySelector("button").addEventListener("click", () =>
{
chrome.runtime.sendMessage("explain");
});
document.body.appendChild(div);
});
```
<figure><img src="../../.gitbook/assets/image (23).png" alt=""><figcaption></figcaption></figure>

Eine Nachricht wird an die Erweiterungsseiten gesendet, wenn auf diese Schaltfl√§che geklickt wird, durch die Verwendung der [**runtime.sendMessage() API**](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/runtime/sendMessage). Dies liegt an der Beschr√§nkung des Inhaltskripts beim direkten Zugriff auf APIs, wobei `storage` zu den wenigen Ausnahmen geh√∂rt. F√ºr Funktionalit√§ten √ºber diese Ausnahmen hinaus werden Nachrichten an Erweiterungsseiten gesendet, mit denen Inhaltskripte kommunizieren k√∂nnen.

{% hint style="warning" %}
Je nach Browser k√∂nnen sich die F√§higkeiten des Inhaltskripts geringf√ºgig unterscheiden. F√ºr auf Chromium basierende Browser ist die Liste der F√§higkeiten in der [Chrome-Entwicklerdokumentation](https://developer.chrome.com/docs/extensions/mv3/content_scripts/#capabilities) verf√ºgbar, und f√ºr Firefox dient die [MDN](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/Content_scripts#webextension_apis) als prim√§re Quelle.\
Es ist auch erw√§hnenswert, dass Inhaltskripte die M√∂glichkeit haben, mit Hintergrundskripten zu kommunizieren, was es ihnen erm√∂glicht, Aktionen auszuf√ºhren und Antworten zur√ºckzugeben.
{% endhint %}

Um Inhaltskripte in Chrome anzuzeigen und zu debuggen, kann das Chrome-Entwicklertools-Men√º √ºber Optionen > Weitere Tools > Entwicklertools aufgerufen werden oder durch Dr√ºcken von Strg + Umschalt + I.

Nachdem die Entwicklertools angezeigt werden, sollte auf den **Quellcode-Tab** geklickt werden, gefolgt vom **Inhaltskripte-Tab**. Dies erm√∂glicht die Beobachtung der ausgef√ºhrten Inhaltskripte aus verschiedenen Erweiterungen und das Setzen von Haltepunkten, um den Ausf√ºhrungsfluss zu verfolgen.

### Eingef√ºgte Inhaltskripte

{% hint style="success" %}
Beachten Sie, dass **Inhaltskripte nicht zwingend erforderlich** sind, da es auch m√∂glich ist, Skripte **dynamisch einzuf√ºgen** und sie **programmgesteuert** in Webseiten √ºber **`tabs.executeScript`** einzuf√ºgen. Dies bietet tats√§chlich mehr **feingranulare Kontrollen**.
{% endhint %}

F√ºr die programmgesteuerte Einschleusung eines Inhaltskripts muss die Erweiterung [Hostberechtigungen](https://developer.chrome.com/docs/extensions/reference/permissions) f√ºr die Seite haben, in die die Skripte eingef√ºgt werden sollen. Diese Berechtigungen k√∂nnen entweder durch **Anforderung** im Manifest der Erweiterung oder vor√ºbergehend durch [**activeTab**](https://developer.chrome.com/docs/extensions/reference/manifest/activeTab) gesichert werden.

#### Beispiel f√ºr eine activeTab-basierte Erweiterung

{% code title="manifest.json" %}
```json
{
"name": "My extension",
...
"permissions": [
"activeTab",
"scripting"
],
"background": {
"service_worker": "background.js"
},
"action": {
"default_title": "Action Button"
}
}
```
{% endcode %}

* **Injizieren einer JS-Datei beim Klicken:**
```javascript
// content-script.js
document.body.style.backgroundColor = "orange";

//service-worker.js - Inject the JS file
chrome.action.onClicked.addListener((tab) => {
chrome.scripting.executeScript({
target: { tabId: tab.id },
files: ["content-script.js"]
});
});
```
* **F√ºgen Sie eine Funktion** beim Klicken hinzu:
```javascript
//service-worker.js - Inject a function
function injectedFunction() {
document.body.style.backgroundColor = "orange";
}

chrome.action.onClicked.addListener((tab) => {
chrome.scripting.executeScript({
target : {tabId : tab.id},
func : injectedFunction,
});
});
```
#### Beispiel mit Skriptberechtigungen
```javascript
// service-workser.js
chrome.scripting.registerContentScripts([{
id : "test",
matches : [ "https://*.example.com/*" ],
excludeMatches : [ "*://*/*business*" ],
js : [ "contentScript.js" ],
}]);

// Another example
chrome.tabs.executeScript(tabId, { file: "content_script.js" });
```
Um mehr URLs einzuschlie√üen oder auszuschlie√üen, ist es auch m√∂glich, **`include_globs`** und **`exclude_globs`** zu verwenden.

### Inhalts Skripte `run_at`

Das Feld `run_at` steuert **wann JavaScript-Dateien in die Webseite eingef√ºgt werden**. Der bevorzugte und Standardwert ist `"document_idle"`.

Die m√∂glichen Werte sind:

* **`document_idle`**: Immer wenn m√∂glich
* **`document_start`**: Nach allen Dateien von `css`, aber vor dem Aufbau eines anderen DOM oder der Ausf√ºhrung eines anderen Skripts.
* **`document_end`**: Unmittelbar nachdem der DOM vollst√§ndig ist, aber bevor Subressourcen wie Bilder und Frames geladen wurden.

#### √úber `manifest.json`
```json
{
"name": "My extension",
...
"content_scripts": [
{
"matches": ["https://*.example.com/*"],
"run_at": "document_idle",
"js": ["contentScript.js"]
}
],
...
}

```
√úber **`service-worker.js`**
```javascript
chrome.scripting.registerContentScripts([{
id : "test",
matches : [ "https://*.example.com/*" ],
runAt : "document_idle",
js : [ "contentScript.js" ],
}]);
```
### `Hintergrund`

Nachrichten, die von Inhaltsskripten gesendet werden, werden von der **Hintergrundseite** empfangen, die eine zentrale Rolle bei der Koordination der Komponenten der Erweiterung spielt. Insbesondere bleibt die Hintergrundseite w√§hrend der gesamten Lebensdauer der Erweiterung bestehen, arbeitet diskret ohne direkte Benutzerinteraktion und verf√ºgt √ºber ihr eigenes Document Object Model (DOM), das komplexe Interaktionen und Zustandsverwaltung erm√∂glicht.

**Schl√ºsselpunkte**:

- **Rolle der Hintergrundseite:** Dient als Nervenzentrum f√ºr die Erweiterung und gew√§hrleistet die Kommunikation und Koordination zwischen verschiedenen Teilen der Erweiterung.
- **Persistenz:** Es handelt sich um eine st√§ndig vorhandene Entit√§t, die f√ºr den Benutzer unsichtbar ist, aber f√ºr die Funktionalit√§t der Erweiterung unerl√§sslich ist.
- **Automatische Generierung:** Wenn nicht explizit definiert, wird vom Browser automatisch eine Hintergrundseite erstellt. Diese automatisch generierte Seite enth√§lt alle im Manifest der Erweiterung angegebenen Hintergrundskripte und gew√§hrleistet den nahtlosen Betrieb der Hintergrundaufgaben der Erweiterung.

{% hint style="success" %}
Die Bequemlichkeit, die der Browser durch die automatische Generierung einer Hintergrundseite bietet (wenn nicht explizit deklariert), stellt sicher, dass alle erforderlichen Hintergrundskripte integriert und betriebsbereit sind, was den Einrichtungsprozess der Erweiterung optimiert.
{% endhint %}

Beispielhintergrundskript:
```js
chrome.runtime.onMessage.addListener((request, sender, sendResponse) =>
{
if (request == "explain")
{
chrome.tabs.create({ url: "https://example.net/explanation" });
}
})
```
Es verwendet die [runtime.onMessage API](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/runtime/onMessage), um Nachrichten anzuh√∂ren. Wenn eine `"erkl√§ren"` Nachricht empfangen wird, verwendet es die [Tabs API](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/tabs), um eine Seite in einem neuen Tab zu √∂ffnen.

Um das Hintergrundskript zu debuggen, k√∂nnen Sie zu den **Erweiterungsdetails gehen und den Service-Worker inspizieren**, dies √∂ffnet die Entwicklertools mit dem Hintergrundskript:

<figure><img src="https://github.com/carlospolop/hacktricks/blob/master/pentesting-web/browser-extension-pentesting-methodology/broken-reference" alt=""><figcaption></figcaption></figure>

### Optionsseiten und andere

Browser-Erweiterungen k√∂nnen verschiedene Arten von Seiten enthalten:

* **Aktionsseiten** werden in einem **Dropdown-Men√º angezeigt, wenn auf das Erweiterungssymbol geklickt wird**.
* Seiten, die die Erweiterung in einem **neuen Tab laden wird**.
* **Optionsseiten**: Diese Seite wird oben auf der Erweiterung angezeigt, wenn darauf geklickt wird. Im vorherigen Manifest konnte ich auf diese Seite zugreifen unter `chrome://extensions/?options=fadlhnelkbeojnebcbkacjilhnbjfjca` oder durch Klicken auf:

<figure><img src="../../.gitbook/assets/image (24).png" alt="" width="375"><figcaption></figcaption></figure>

Beachten Sie, dass diese Seiten im Gegensatz zu Hintergrundseiten nicht persistent sind, da sie bei Bedarf dynamisch Inhalte laden. Trotzdem teilen sie bestimmte F√§higkeiten mit der Hintergrundseite:

* **Kommunikation mit Inhaltskripten:** √Ñhnlich wie die Hintergrundseite k√∂nnen diese Seiten Nachrichten von Inhaltskripten empfangen, um die Interaktion innerhalb der Erweiterung zu erleichtern.
* **Zugriff auf erweiterungsspezifische APIs:** Diese Seiten haben umfassenden Zugriff auf erweiterungsspezifische APIs, abh√§ngig von den f√ºr die Erweiterung definierten Berechtigungen.

### `permissions` & `host_permissions`

**`permissions`** und **`host_permissions`** sind Eintr√§ge aus der `manifest.json`, die anzeigen, **welche Berechtigungen** die Browser-Erweiterungen haben (Speicher, Standort...) und auf **welchen Webseiten**.

Da Browser-Erweiterungen so **privilegiert** sein k√∂nnen, k√∂nnte eine b√∂sartige oder kompromittierte Erweiterung einem Angreifer **verschiedene M√∂glichkeiten bieten, sensible Informationen zu stehlen und den Benutzer auszuspionieren**.

√úberpr√ºfen Sie, wie diese Einstellungen funktionieren und wie sie missbraucht werden k√∂nnten in:

{% content-ref url="browext-permissions-and-host_permissions.md" %}
[browext-permissions-and-host\_permissions.md](browext-permissions-and-host\_permissions.md)
{% endcontent-ref %}

### `content_security_policy`

Eine **Content-Security-Policy** kann ebenfalls in der `manifest.json` deklariert werden. Wenn eine definiert ist, k√∂nnte sie **anf√§llig** sein.

Die Standardkonfiguration f√ºr Browser-Erweiterungsseiten ist eher restriktiv:
```bash
script-src 'self'; object-src 'self';
```
F√ºr weitere Informationen zu CSP und m√∂glichen Umgehungen siehe:

{% content-ref url="../content-security-policy-csp-bypass/" %}
[content-security-policy-csp-bypass](../content-security-policy-csp-bypass/)
{% endcontent-ref %}

### `web_accessible_resources`

Damit eine Webseite auf eine Seite einer Browsererweiterung zugreifen kann, z. B. eine `.html`-Seite, muss diese Seite im Feld **`web_accessible_resources`** der `manifest.json` erw√§hnt werden.\
Zum Beispiel:
```javascript
{
...
"web_accessible_resources": [
{
"resources": [ "images/*.png" ],
"matches": [ "https://example.com/*" ]
},
{
"resources": [ "fonts/*.woff" ],
"matches": [ "https://example.com/*" ]
}
],
...
}
```
Diese Seiten sind unter URLs wie folgt erreichbar:
```
chrome-extension://<extension-id>/message.html
```
In √∂ffentlichen Erweiterungen ist die **Erweiterungs-ID zug√§nglich**:

<figure><img src="../../.gitbook/assets/image (1194).png" alt="" width="375"><figcaption></figcaption></figure>

Wenn jedoch der Parameter **`use_dynamic_url`** in der `manifest.json` verwendet wird, kann diese **ID dynamisch sein**.

{% hint style="success" %}
Beachten Sie, dass selbst wenn hier eine Seite erw√§hnt wird, sie m√∂glicherweise **gegen Clickjacking gesch√ºtzt** ist, dank der **Content Security Policy**. Daher m√ºssen Sie auch dies √ºberpr√ºfen (Abschnitt frame-ancestors), bevor Sie einen m√∂glichen Clickjacking-Angriff best√§tigen.
{% endhint %}

Das Zugreifen auf diese Seiten kann diese Seiten **potenziell anf√§llig f√ºr Clickjacking** machen:

{% content-ref url="browext-clickjacking.md" %}
[browext-clickjacking.md](browext-clickjacking.md)
{% endcontent-ref %}

{% hint style="success" %}
Indem Sie diese Seiten nur von der Erweiterung und nicht von zuf√§lligen URLs laden lassen, k√∂nnten Clickjacking-Angriffe verhindert werden.
{% endhint %}

{% hint style="danger" %}
Beachten Sie, dass die Seiten aus **`web_accessible_resources`** und andere Seiten der Erweiterung auch in der Lage sind, **Hintergrundskripte zu kontaktieren**. Wenn also eine dieser Seiten anf√§llig f√ºr **XSS** ist, k√∂nnte dies eine gr√∂√üere Sicherheitsl√ºcke √∂ffnen.

Au√üerdem k√∂nnen nur Seiten, die in **`web_accessible_resources`** angegeben sind, in iframes ge√∂ffnet werden, aber von einem neuen Tab aus ist es m√∂glich, auf jede Seite in der Erweiterung zuzugreifen, wenn die Erweiterungs-ID bekannt ist. Daher k√∂nnte, wenn ein XSS gefunden wird, das dieselben Parameter missbraucht, dies auch missbraucht werden, selbst wenn die Seite nicht in **`web_accessible_resources`** konfiguriert ist.
{% endhint %}

### `externally_connectable`

Gem√§√ü der [**Dokumentation**](https://developer.chrome.com/docs/extensions/reference/manifest/externally-connectable) gibt die Eigenschaft `"externally_connectable"` im Manifest an, **welche Erweiterungen und Webseiten** √ºber [runtime.connect](https://developer.chrome.com/docs/extensions/reference/runtime#method-connect) und [runtime.sendMessage](https://developer.chrome.com/docs/extensions/reference/runtime#method-sendMessage) mit Ihrer Erweiterung verbunden werden k√∂nnen.

* Wenn der Schl√ºssel **`externally_connectable`** nicht im Manifest Ihrer Erweiterung deklariert ist oder als **`"ids": ["*"]`** deklariert ist, k√∂nnen **alle Erweiterungen eine Verbindung herstellen, aber keine Webseiten**.
* Wenn **spezifische IDs angegeben sind**, wie in `"ids": ["aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"]`, k√∂nnen **nur diese Anwendungen** eine Verbindung herstellen.
* Wenn **√úbereinstimmungen** angegeben sind, k√∂nnen diese Web-Apps eine Verbindung herstellen:
```json
"matches": [
"https://*.google.com/*",
"*://*.chromium.org/*",
```
* Wenn es als leer angegeben ist: **`"externally_connectable": {}`**, wird keine App oder Website eine Verbindung herstellen k√∂nnen.

Je weniger Erweiterungen und URLs hier angegeben sind, desto kleiner wird die Angriffsfl√§che sein.

{% hint style="danger" %}
Wenn eine Webseite **anf√§llig f√ºr XSS oder √úbernahme** ist und in **`externally_connectable`** angegeben ist, kann ein Angreifer **Nachrichten direkt an das Hintergrundskript senden**, wodurch das Content-Skript und seine CSP vollst√§ndig umgangen werden.

Daher handelt es sich hierbei um einen **sehr leistungsstarken Bypass**.

Dar√ºber hinaus, wenn der Client eine sch√§dliche Erweiterung installiert, selbst wenn sie nicht berechtigt ist, mit der anf√§lligen Erweiterung zu kommunizieren, k√∂nnte sie **XSS-Daten in eine erlaubte Webseite einschleusen** oder die **`WebRequest`**- oder **`DeclarativeNetRequest`**-APIs missbrauchen, um Anfragen auf einer gezielten Domain zu manipulieren und eine Anfrage f√ºr eine **JavaScript-Datei** einer Seite zu √§ndern. (Beachten Sie, dass die CSP auf der gezielten Seite diese Angriffe verhindern k√∂nnte). Diese Idee stammt aus [**diesem Bericht**](https://www.darkrelay.com/post/opera-zero-day-rce-vulnerability).
{% endhint %}

## Kommunikationszusammenfassung

### Erweiterung <--> Webanwendung

Um zwischen dem Inhalts-Skript und der Webseite zu kommunizieren, werden normalerweise Nachrichten gepostet. Daher finden Sie in der Webanwendung in der Regel Aufrufe der Funktion **`window.postMessage`** und im Inhalts-Skript Listener wie **`window.addEventListener`**. Beachten Sie jedoch, dass die Erweiterung auch **mit der Webanwendung kommunizieren kann, indem sie eine Post-Nachricht sendet** (und daher sollte die Webseite dies erwarten) oder einfach die Webseite einen neuen Skript laden lassen kann.

### Innerhalb der Erweiterung

Normalerweise wird die Funktion **`chrome.runtime.sendMessage`** verwendet, um eine Nachricht innerhalb der Erweiterung zu senden (normalerweise vom `background`-Skript behandelt) und um sie zu empfangen und zu verarbeiten, wird ein Listener deklariert, der **`chrome.runtime.onMessage.addListener`** aufruft.

Es ist auch m√∂glich, **`chrome.runtime.connect()`** zu verwenden, um eine dauerhafte Verbindung anstelle des Sendens einzelner Nachrichten zu haben. Es ist m√∂glich, es zu verwenden, um **Nachrichten zu senden** und **zu empfangen** wie im folgenden Beispiel:

<details>

<summary><code>chrome.runtime.connect()</code> Beispiel</summary>
```javascript
var port = chrome.runtime.connect();

// Listen for messages from the web page
window.addEventListener("message", (event) => {
// Only accept messages from the same window
if (event.source !== window) {
return;
}

// Check if the message type is "FROM_PAGE"
if (event.data.type && (event.data.type === "FROM_PAGE")) {
console.log("Content script received: " + event.data.text);
// Forward the message to the background script
port.postMessage({ type: 'FROM_PAGE', text: event.data.text });
}
}, false);

// Listen for messages from the background script
port.onMessage.addListener(function(msg) {
console.log("Content script received message from background script:", msg);
// Handle the response message from the background script
});
```
</details>

Es ist auch m√∂glich, Nachrichten von einem Hintergrundskript an ein Inhaltskript in einem bestimmten Tab zu senden, indem **`chrome.tabs.sendMessage`** aufgerufen wird, wobei die **ID des Tabs** angegeben werden muss, an den die Nachricht gesendet werden soll.

### Von erlaubten `externally_connectable` zum Browser-Plugin

**Web-Apps und externe Browser-Erweiterungen, die in der Konfiguration `externally_connectable` zugelassen sind, k√∂nnen Anfragen senden mit:
```javascript
chrome.runtime.sendMessage(extensionId, ...
```
Wo es erforderlich ist, die **Erweiterungs-ID** zu erw√§hnen.

## Web **‚ÜîÔ∏é** Inhalts Skript Kommunikation

Die Umgebungen, in denen **Inhalts Skripte** arbeiten und in denen die Host-Seiten existieren, sind voneinander **getrennt**, um **Isolierung** zu gew√§hrleisten. Trotz dieser Isolierung haben beide die M√∂glichkeit, mit dem **Document Object Model (DOM)** der Seite zu interagieren, einem gemeinsamen Ressourcenbereich. Damit die Host-Seite mit dem **Inhalts Skript** kommunizieren kann, oder indirekt mit der Erweiterung √ºber das Inhalts Skript, ist es erforderlich, das **DOM** zu nutzen, auf das beide Parteien als Kommunikationskanal zugreifen k√∂nnen.

### Post Nachrichten

{% code title="inhaltsskript.js" %}
```javascript
// This is like "chrome.runtime.sendMessage" but to maintain the connection
var port = chrome.runtime.connect();

window.addEventListener("message", (event) => {
// We only accept messages from ourselves
if (event.source !== window) {
return;
}

if (event.data.type && (event.data.type === "FROM_PAGE")) {
console.log("Content script received: " + event.data.text);
// Forward the message to the background script
port.postMessage(event.data.text);
}
}, false);
```
{% endcode %}

{% code title="beispiel.js" %}
```javascript
document.getElementById("theButton").addEventListener("click", () => {
window.postMessage(
{type : "FROM_PAGE", text : "Hello from the webpage!"}, "*");
}, false);
```
{% endcode %}

Eine sichere Post-Nachrichten-Kommunikation sollte die Echtheit der empfangenen Nachricht √ºberpr√ºfen, dies kann durch folgende √úberpr√ºfungen erfolgen:

- **`event.isTrusted`**: Dies ist nur wahr, wenn das Ereignis durch eine Benutzeraktion ausgel√∂st wurde.
- Das Inhalts-Skript erwartet m√∂glicherweise eine Nachricht nur, wenn der Benutzer eine Aktion ausf√ºhrt.
- **Ursprungsdom√§ne**: Erwartet m√∂glicherweise eine Nachricht nur von einer Whitelist von Dom√§nen.
- Wenn ein Regex verwendet wird, seien Sie sehr vorsichtig.
- **Quelle**: `received_message.source !== window` kann verwendet werden, um zu √ºberpr√ºfen, ob die Nachricht **aus demselben Fenster** stammt, in dem das Inhalts-Skript zuh√∂rt.

Die zuvor durchgef√ºhrten √úberpr√ºfungen k√∂nnten selbst dann anf√§llig sein, √ºberpr√ºfen Sie daher auf der folgenden Seite **potenzielle Post-Nachrichten-Umgehungen**:

{% content-ref url="../postmessage-vulnerabilities/" %}
[postmessage-vulnerabilities](../postmessage-vulnerabilities/)
{% endcontent-ref %}

### Iframe

Eine weitere m√∂gliche Kommunikationsmethode k√∂nnte √ºber **Iframe-URLs** erfolgen, ein Beispiel finden Sie unter:

{% content-ref url="browext-xss-example.md" %}
[browext-xss-example.md](browext-xss-example.md)
{% endcontent-ref %}

### DOM

Dies ist nicht "genau" eine Kommunikationsmethode, aber das **Web und das Inhalts-Skript haben Zugriff auf das Web-DOM**. Wenn das **Inhalts-Skript** also einige Informationen daraus liest und dem Web-DOM vertraut, k√∂nnte das Web diese Daten **√§ndern** (weil dem Web nicht vertraut werden sollte oder weil das Web anf√§llig f√ºr XSS ist) und das **Inhalts-Skript gef√§hrden**.

Ein Beispiel f√ºr eine **DOM-basierte XSS zur Kompromittierung einer Browsererweiterung** finden Sie auch unter:

{% content-ref url="browext-xss-example.md" %}
[browext-xss-example.md](browext-xss-example.md)
{% endcontent-ref %}

## Inhalts-Skript **‚ÜîÔ∏é** Hintergrundskript-Kommunikation

Ein Inhalts-Skript kann die Funktionen [**runtime.sendMessage()**](https://developer.chrome.com/docs/extensions/reference/runtime#method-sendMessage) **oder** [**tabs.sendMessage()**](https://developer.chrome.com/docs/extensions/reference/tabs#method-sendMessage) verwenden, um eine **einmalige JSON-serialisierbare** Nachricht zu senden.

Um die **Antwort** zu verarbeiten, verwenden Sie das zur√ºckgegebene **Promise**. F√ºr die Abw√§rtskompatibilit√§t k√∂nnen Sie jedoch immer noch eine **R√ºckruffunktion** als letzten Argument √ºbergeben.

Das Senden einer Anfrage von einem **Inhalts-Skript** sieht wie folgt aus:
```javascript
(async () => {
const response = await chrome.runtime.sendMessage({greeting: "hello"});
// do something with response here, not outside the function
console.log(response);
})();
```
Senden einer Anfrage von der **Erweiterung** (normalerweise ein **Hintergrundskript**). Beispiel, wie man eine Nachricht an das Inhalts-Skript im ausgew√§hlten Tab sendet:
```javascript
// From https://stackoverflow.com/questions/36153999/how-to-send-a-message-between-chrome-extension-popup-and-content-script
(async () => {
const [tab] = await chrome.tabs.query({active: true, lastFocusedWindow: true});
const response = await chrome.tabs.sendMessage(tab.id, {greeting: "hello"});
// do something with response here, not outside the function
console.log(response);
})();
```
Auf der **Empf√§ngerseite** m√ºssen Sie einen [**runtime.onMessage**](https://developer.chrome.com/docs/extensions/reference/runtime#event-onMessage) **Ereignislistener** einrichten, um die Nachricht zu verarbeiten. Dies sieht sowohl in einem Inhalts-Script als auch auf einer Erweiterungsseite gleich aus.
```javascript
// From https://stackoverflow.com/questions/70406787/javascript-send-message-from-content-js-to-background-js
chrome.runtime.onMessage.addListener(
function(request, sender, sendResponse) {
console.log(sender.tab ?
"from a content script:" + sender.tab.url :
"from the extension");
if (request.greeting === "hello")
sendResponse({farewell: "goodbye"});
}
);
```
Im hervorgehobenen Beispiel wurde **`sendResponse()`** synchron ausgef√ºhrt. Um den `onMessage`-Ereignisbehandler f√ºr die asynchrone Ausf√ºhrung von `sendResponse()` zu √§ndern, ist es unerl√§sslich, `return true;` einzubeziehen.

Eine wichtige √úberlegung ist, dass in Szenarien, in denen mehrere Seiten darauf eingestellt sind, `onMessage`-Ereignisse zu empfangen, **die erste Seite, die `sendResponse()` f√ºr ein bestimmtes Ereignis ausf√ºhrt**, die einzige sein wird, die die Antwort effektiv liefern kann. Alle nachfolgenden Antworten auf dasselbe Ereignis werden nicht ber√ºcksichtigt.

Bei der Erstellung neuer Erweiterungen sollte der Vorzug Promises gegen√ºber Callbacks gelten. In Bezug auf die Verwendung von Callbacks wird die `sendResponse()`-Funktion nur dann als g√ºltig betrachtet, wenn sie direkt im synchronen Kontext ausgef√ºhrt wird oder wenn der Ereignisbehandler eine asynchrone Operation anzeigt, indem er `true` zur√ºckgibt. Sollten keine der Handler `true` zur√ºckgeben oder wenn die `sendResponse()`-Funktion aus dem Speicher entfernt (garbage-collected) wird, wird das mit der `sendMessage()`-Funktion verkn√ºpfte Callback standardm√§√üig ausgel√∂st.

## Sensible Informationen im Speicher/Code/Clipboard

Wenn eine Browsererweiterung **sensible Informationen im Speicher speichert**, k√∂nnen diese (insbesondere auf Windows-Maschinen) **ausgelesen** und nach diesen Informationen **gesucht** werden.

Daher sollte der Speicher der Browsererweiterung **nicht als sicher angesehen** werden und **sensible Informationen** wie Anmeldeinformationen oder mnemonische Phrasen **sollten nicht gespeichert werden**.

Nat√ºrlich sollten **keine sensiblen Informationen im Code** platziert werden, da sie **√∂ffentlich** zug√§nglich sind.

Um den Speicher des Browsers auszulesen, k√∂nnen Sie **den Prozessspeicher auslesen** oder in den **Einstellungen** der Browsererweiterung auf **`Inspect pop-up`** klicken -> Im Abschnitt **`Memory`** -> **`Take a snaphost`** und **`STRG+F`** zum Suchen innerhalb des Schnappschusses nach sensiblen Informationen verwenden.

Dar√ºber hinaus sollten hochsensible Informationen wie mnemonische Schl√ºssel oder Passw√∂rter **nicht im Zwischenspeicher kopiert werden** (oder zumindest innerhalb weniger Sekunden daraus entfernt werden), da Prozesse, die den Zwischenspeicher √ºberwachen, sie dann abrufen k√∂nnen.

## Laden einer Erweiterung im Browser

1. **Laden** Sie die Browsererweiterung herunter und entpacken Sie sie
2. Gehen Sie zu **`chrome://extensions/`** und **aktivieren** Sie den `Entwicklermodus`
3. Klicken Sie auf die Schaltfl√§che **`Unverpackte Erweiterung laden`**

In **Firefox** gehen Sie zu **`about:debugging#/runtime/this-firefox`** und klicken auf die Schaltfl√§che **`Tempor√§re Add-on laden`**.

## Abrufen des Quellcodes aus dem Store

Der Quellcode einer Chrome-Erweiterung kann auf verschiedene Arten erhalten werden. Im Folgenden finden Sie detaillierte Erkl√§rungen und Anweisungen f√ºr jede Option.

### Erweiterung als ZIP √ºber die Befehlszeile herunterladen

Der Quellcode einer Chrome-Erweiterung kann als ZIP-Datei √ºber die Befehlszeile heruntergeladen werden. Dies beinhaltet die Verwendung von `curl`, um die ZIP-Datei von einer bestimmten URL abzurufen und dann die Inhalte der ZIP-Datei in ein Verzeichnis zu extrahieren. Hier sind die Schritte:

1. Ersetzen Sie `"extension_id"` durch die tats√§chliche ID der Erweiterung.
2. F√ºhren Sie die folgenden Befehle aus:
```bash
extension_id=your_extension_id   # Replace with the actual extension ID
curl -L -o "$extension_id.zip" "https://clients2.google.com/service/update2/crx?response=redirect&os=mac&arch=x86-64&nacl_arch=x86-64&prod=chromecrx&prodchannel=stable&prodversion=44.0.2403.130&x=id%3D$extension_id%26uc"
unzip -d "$extension_id-source" "$extension_id.zip"
```
### Verwenden Sie die CRX Viewer-Website

[https://robwu.nl/crxviewer/](https://robwu.nl/crxviewer/)

### Verwenden Sie die CRX Viewer-Erweiterung

Eine weitere praktische Methode ist die Verwendung des Chrome Extension Source Viewer, der ein Open-Source-Projekt ist. Es kann aus dem [Chrome Web Store](https://chrome.google.com/webstore/detail/chrome-extension-source-v/jifpbeccnghkjeaalbbjmodiffmgedin?hl=en) installiert werden. Der Quellcode des Viewers ist in seinem [GitHub-Repository](https://github.com/Rob--W/crxviewer) verf√ºgbar.

### Quellcode einer lokal installierten Erweiterung anzeigen

Auch lokal installierte Chrome-Erweiterungen k√∂nnen inspiziert werden. So geht's:

1. Greifen Sie auf Ihr lokales Chrome-Profilverzeichnis zu, indem Sie `chrome://version/` besuchen und das Feld "Profilpfad" suchen.
2. Navigieren Sie zum Unterordner `Extensions/` innerhalb des Profilverzeichnisses.
3. Dieser Ordner enth√§lt alle installierten Erweiterungen, in der Regel mit ihrem Quellcode in einem lesbaren Format.

Um Erweiterungen zu identifizieren, k√∂nnen Sie ihre IDs den Namen zuordnen:

* Aktivieren Sie den Entwicklermodus auf der Seite `about:extensions`, um die IDs jeder Erweiterung zu sehen.
* Im Ordner jeder Erweiterung enth√§lt die Datei `manifest.json` ein lesbares `name`-Feld, das Ihnen hilft, die Erweiterung zu identifizieren.

### Verwenden Sie einen Dateiarchivierer oder -entpacker

Gehen Sie zum Chrome Web Store und laden Sie die Erweiterung herunter. Die Datei wird die Erweiterung `.crx` haben. √Ñndern Sie die Dateierweiterung von `.crx` in `.zip`. Verwenden Sie einen Dateiarchivierer (wie WinRAR, 7-Zip usw.), um den Inhalt der ZIP-Datei zu extrahieren.

### Verwenden Sie den Entwicklermodus in Chrome

√ñffnen Sie Chrome und gehen Sie zu `chrome://extensions/`. Aktivieren Sie oben rechts den "Entwicklermodus". Klicken Sie auf "Entpackte Erweiterung laden...". Navigieren Sie zum Verzeichnis Ihrer Erweiterung. Dies l√§dt nicht den Quellcode herunter, ist aber n√ºtzlich, um den Code einer bereits heruntergeladenen oder entwickelten Erweiterung anzuzeigen und zu √§ndern.

## Sicherheitspr√ºfungs-Checkliste

Auch wenn Browser-Erweiterungen eine **begrenzte Angriffsfl√§che** haben, k√∂nnen einige von ihnen **Schwachstellen** oder **potenzielle Verbesserungen der Absicherung** enthalten. Die folgenden sind die h√§ufigsten:

* [ ] **Beschr√§nken** Sie so weit wie m√∂glich die angeforderten **`Berechtigungen`**
* [ ] **Beschr√§nken** Sie so weit wie m√∂glich die **`host_permissions`**
* Verwenden Sie eine **starke** **`content_security_policy`**
* [ ] **Beschr√§nken** Sie so weit wie m√∂glich die **`externally_connectable`**, wenn keine ben√∂tigt wird und m√∂glich ist, lassen Sie sie nicht standardm√§√üig, geben Sie explizit **`{}`** an
* [ ] Wenn hier eine **URL anf√§llig f√ºr XSS oder √úbernahme** erw√§hnt wird, kann ein Angreifer **Nachrichten direkt an die Hintergrundskripte senden**. Sehr m√§chtiger Umgehungsweg.
* [ ] **Beschr√§nken** Sie so weit wie m√∂glich die **`web_accessible_resources`**, auch leer, wenn m√∂glich.
* [ ] Wenn **`web_accessible_resources`** nicht leer ist, √ºberpr√ºfen Sie auf [**Clickjacking**](browext-clickjacking.md)
* [ ] Wenn eine **Kommunikation** von der **Erweiterung** zur **Webseite** erfolgt, √ºberpr√ºfen Sie auf [**XSS**](browext-xss-example.md) **Schwachstellen**, die durch die Kommunikation verursacht werden.
* [ ] Wenn Post Messages verwendet werden, √ºberpr√ºfen Sie auf [**Post Message-Schwachstellen**](../postmessage-vulnerabilities/)**.**
* [ ] Wenn das **Content Script auf DOM-Details zugreift**, √ºberpr√ºfen Sie, dass sie kein XSS einf√ºhren, wenn sie vom Web ge√§ndert werden
* [ ] Legen Sie einen besonderen Schwerpunkt darauf, wenn diese Kommunikation auch an der **Kommunikation zwischen dem Content Script und dem Hintergrundskript** beteiligt ist
* [ ] **Empfindliche Informationen sollten nicht** im Code der Browser-Erweiterung **gespeichert werden**
* [ ] **Empfindliche Informationen sollten nicht** im Speicher der Browser-Erweiterung **gespeichert werden**

## Werkzeuge

### [**Tarnish**](https://thehackerblog.com/tarnish/)

* Holt jede Chrome-Erweiterung von einem bereitgestellten Chrome-Webstore-Link.
* [**manifest.json**](https://developer.chrome.com/extensions/manifest) **Viewer**: zeigt einfach eine JSON-formatierte Version des Manifests der Erweiterung an.
* **Fingerprint-Analyse**: Erkennung von [web\_accessible\_resources](https://developer.chrome.com/extensions/manifest/web\_accessible\_resources) und automatische Generierung von JavaScript zur Erstellung von Chrome-Erweiterungs-Fingerabdr√ºcken.
* **Potenzielle Clickjacking-Analyse**: Erkennung von Erweiterungs-HTML-Seiten mit der Direktive [web\_accessible\_resources](https://developer.chrome.com/extensions/manifest/web\_accessible\_resources). Diese sind je nach Zweck der Seiten potenziell anf√§llig f√ºr Clickjacking.
* **Berechtigungswarnungs-Viewer**: zeigt eine Liste aller Chrome-Berechtigungswarnungen an, die angezeigt werden, wenn ein Benutzer versucht, die Erweiterung zu installieren.
* **Gef√§hrliche Funktionen**: zeigt den Ort gef√§hrlicher Funktionen, die von einem Angreifer potenziell ausgenutzt werden k√∂nnten (z. B. Funktionen wie innerHTML, chrome.tabs.executeScript).
* **Einstiegspunkte**: zeigt, wo die Erweiterung Benutzer-/externe Eingaben entgegennimmt. Dies ist n√ºtzlich, um den Umfang einer Erweiterung zu verstehen und nach potenziellen Punkten zu suchen, an die b√∂sartig gestaltete Daten gesendet werden k√∂nnen.
* Sowohl die Scanner f√ºr Gef√§hrliche Funktionen als auch Einstiegspunkte haben folgendes f√ºr ihre generierten Warnungen:
* Relevanten Code-Schnipsel und Zeile, die die Warnung verursacht hat.
* Beschreibung des Problems.
* Eine Schaltfl√§che "Datei anzeigen", um die vollst√§ndige Quelldatei mit dem Code anzuzeigen.
* Der Pfad der alarmierten Datei.
* Die vollst√§ndige Chrome-Erweiterungs-URI der alarmierten Datei.
* Der Dateityp, z. B. ein Hintergrundseiten-Skript, ein Inhalts-Skript, eine Browseraktion usw.
* Wenn die anf√§llige Zeile in einer JavaScript-Datei ist, die Pfade aller Seiten, auf denen sie enthalten ist, sowie den Status dieser Seiten als [web\_accessible\_resource](https://developer.chrome.com/extensions/manifest/web\_accessible\_resources).
* **Content Security Policy (CSP)-Analyzer und Bypass-Checker**: Dies zeigt Schw√§chen in der CSP Ihrer Erweiterung auf und beleuchtet auch m√∂gliche Umgehungsm√∂glichkeiten Ihrer CSP aufgrund von whitelisteten CDNs usw.
* **Bekannte verwundbare Bibliotheken**: Verwendet [Retire.js](https://retirejs.github.io/retire.js), um auf die Verwendung von bekannten verwundbaren JavaScript-Bibliotheken zu pr√ºfen.
* Erweiterung und formatierte Versionen herunterladen.
* Die Originalerweiterung herunterladen.
* Eine versch√∂nerte Version der Erweiterung herunterladen (automatisch formatiertes HTML und JavaScript).
* Automatisches Zwischenspeichern von Scanergebnissen, das Ausf√ºhren eines Erweiterungsscans dauert beim ersten Mal eine gute Zeit. Beim zweiten Mal, vorausgesetzt die Erweiterung wurde nicht aktualisiert, erfolgt die Ausf√ºhrung fast sofort aufgrund der zwischengespeicherten Ergebnisse.
* Verlinkbare Berichts-URLs, um jemand anderen leicht zu einem von Tarnish generierten Erweiterungsbericht zu verlinken.

### [Neto](https://github.com/elevenpaths/neto)

Das Projekt Neto ist ein Python 3-Paket, das entwickelt wurde, um versteckte Funktionen von Browser-Plugins und -Erweiterungen f√ºr bekannte Browser wie Firefox und Chrome zu analysieren und aufzudecken. Es automatisiert den Prozess des Entpackens der gepackten Dateien, um diese Funktionen aus relevanten Ressourcen in einer Erweiterung wie `manifest.json`, Lokalisierungsordnern oder JavaScript- und HTML-Quelldateien zu extrahieren.

## Referenzen

* **Dank an** [**@naivenom**](https://twitter.com/naivenom) **f√ºr die Hilfe bei dieser Methodik**
* [https://www.cobalt.io/blog/introduction-to-chrome-browser-extension-security-testing](https://www.cobalt.io/blog/introduction-to-chrome-browser-extension-security-testing)
* [https://palant.info/2022/08/10/anatomy-of-a-basic-extension/](https://palant.info/2022/08/10/anatomy-of-a-basic-extension/)
* [https://palant.info/2022/08/24/attack-surface-of-extension-pages/](https://palant.info/2022/08/24/attack-surface-of-extension-pages/)
* [https://palant.info/2022/08/31/when-extension-pages-are-web-accessible/](https://palant.info/2022/08/31/when-extension-pages-are-web-accessible/)
* [https://help.passbolt.com/assets/files/PBL-02-report.pdf](https://help.passbolt.com/assets/files/PBL-02-report.pdf)
* [https://developer.chrome.com/docs/extensions/develop/concepts/content-scripts](https://developer.chrome.com/docs/extensions/develop/concepts/content-scripts)
* [https://developer.chrome.com/docs/extensions/mv2/background-pages](https://developer.chrome.com/docs/extensions/mv2/background-pages)
* [https://thehackerblog.com/kicking-the-rims-a-guide-for-securely-writing-and-auditing-chrome-extensions/](https://thehackerblog.com/kicking-the-rims-a-guide-for-securely-writing-and-auditing-chrome-extensions/)
* [https://gist.github.com/LongJohnCoder/9ddf5735df3a4f2e9559665fb864eac0](https://gist.github.com/LongJohnCoder/9ddf5735df3a4f2e9559665fb864eac0)

<details>

<summary><strong>Erlernen Sie AWS-Hacking von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:
* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen m√∂chten** oder **HackTricks im PDF-Format herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks Merch**](https://peass.creator-spring.com)
* Entdecken Sie [**Die PEASS-Familie**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) Github-Repositorys einreichen.

</details>
