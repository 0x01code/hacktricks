# Browser Extension Pentesting Methodology

<details>

<summary><strong>Erlernen Sie AWS-Hacking von Null auf Held mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen m√∂chten** oder **HackTricks im PDF-Format herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories einreichen.

</details>

## Grundlegende Informationen

Browser-Erweiterungen werden in JavaScript geschrieben und vom Browser im Hintergrund geladen. Sie haben ihr [DOM](https://www.w3schools.com/js/js\_htmldom.asp), k√∂nnen jedoch mit DOMs anderer Websites interagieren. Dies bedeutet, dass sie die Vertraulichkeit, Integrit√§t und Verf√ºgbarkeit (CIA) anderer Websites gef√§hrden k√∂nnen.

## Hauptkomponenten

Erweiterungslayouts sehen am besten aus, wenn sie visualisiert werden und bestehen aus drei Komponenten. Schauen wir uns jede Komponente genauer an.

<figure><img src="../../.gitbook/assets/image (4) (1).png" alt=""><figcaption><p><a href="http://webblaze.cs.berkeley.edu/papers/Extensions.pdf">http://webblaze.cs.berkeley.edu/papers/Extensions.pdf</a></p></figcaption></figure>

### **Inhaltsskripte**

Jedes Inhaltsskript hat direkten Zugriff auf das DOM einer **einzigen Webseite** und ist somit potenziell **b√∂sartigen Eingaben** ausgesetzt. Das Inhaltsskript enth√§lt jedoch keine Berechtigungen au√üer der M√∂glichkeit, Nachrichten an den Erweiterungskern zu senden.

### **Erweiterungskern**

Der Erweiterungskern enth√§lt die meisten Erweiterungsprivilegien/-zugriffe, kann jedoch nur √ºber [XMLHttpRequest](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest) und Inhaltsskripte mit Webinhalten interagieren. Au√üerdem hat der Erweiterungskern keinen direkten Zugriff auf den Hostrechner.

### **Native Bin√§rdatei**

Die Erweiterung erm√∂glicht eine native Bin√§rdatei, die mit den vollen Benutzerrechten auf den Hostrechner zugreifen kann. Die native Bin√§rdatei interagiert mit dem Erweiterungskern √ºber die Standard-Netscape-Plugin-Anwendungsprogrammierschnittstelle ([NPAPI](https://en.wikipedia.org/wiki/NPAPI)), die von Flash und anderen Browser-Plug-Ins verwendet wird.

### Grenzen

{% hint style="danger" %}
Um die vollen Benutzerrechte zu erlangen, muss ein Angreifer die Erweiterung √ºberzeugen, b√∂sartige Eingaben vom Inhaltsskript an den Erweiterungskern und vom Erweiterungskern an die native Bin√§rdatei weiterzuleiten.
{% endhint %}

Jede Komponente der Erweiterung ist durch **starke Schutzgrenzen** voneinander getrennt. Jede Komponente l√§uft in einem **eigenen Betriebssystemprozess**. Inhaltsskripte und Erweiterungskerne laufen in **Sandbox-Prozessen**, die f√ºr die meisten Betriebssystemdienste nicht verf√ºgbar sind.

Dar√ºber hinaus sind Inhaltsskripte von ihren zugeh√∂rigen Webseiten durch **Ausf√ºhrung in einem separaten JavaScript-Heap** getrennt. Das Inhaltsskript und die Webseite haben **Zugriff auf dasselbe zugrunde liegende DOM**, aber die beiden **tauschen niemals JavaScript-Pointer aus**, um das Auslaufen von JavaScript-Funktionalit√§t zu verhindern.

## **`manifest.json`**

Eine Chrome-Erweiterung ist nur ein ZIP-Ordner mit einer [.crx-Dateierweiterung](https://www.lifewire.com/crx-file-2620391). Der Kern der Erweiterung ist die **`manifest.json`**-Datei im Stammverzeichnis des Ordners, die Layout, Berechtigungen und andere Konfigurationsoptionen angibt.

Beispiel:

```json
{
"manifest_version": 2,
"name": "My extension",
"version": "1.0",
"permissions": [
"storage"
],
"content_scripts": [
{
"js": [
"script.js"
],
"matches": [
"https://example.com/*",
"https://www.example.com/*"
],
"exclude_matches": ["*://*/*business*"],
}
],
"background": {
"scripts": [
"background.js"
]
},
"options_ui": {
"page": "options.html"
}
}
```

### `content_scripts`

Content-Skripte werden **geladen**, wenn der Benutzer zu einer √ºbereinstimmenden Seite navigiert, in unserem Fall zu einer Seite, die dem Ausdruck **`https://example.com/*`** entspricht und nicht dem Regex **`*://*/*/business*`** entspricht. Sie werden **wie die eigenen Skripte der Seite** ausgef√ºhrt und haben beliebigen Zugriff auf das [Document Object Model (DOM)](https://developer.mozilla.org/en-US/docs/Web/API/Document\_Object\_Model).

```json
"content_scripts": [
{
"js": [
"script.js"
],
"matches": [
"https://example.com/*",
"https://www.example.com/*"
],
"exclude_matches": ["*://*/*business*"],
}
],
```

Um mehr URLs einzuschlie√üen oder auszuschlie√üen, ist es auch m√∂glich, **`include_globs`** und **`exclude_globs`** zu verwenden.

Dies ist ein Beispielinhaltsskript, das eine Erkl√§rungsschaltfl√§che zur Seite hinzuf√ºgt, wenn [die Speicher-API](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/storage) verwendet wird, um den Wert `message` aus dem Speicher der Erweiterung abzurufen.

```js
chrome.storage.local.get("message", result =>
{
let div = document.createElement("div");
div.innerHTML = result.message + " <button>Explain</button>";
div.querySelector("button").addEventListener("click", () =>
{
chrome.runtime.sendMessage("explain");
});
document.body.appendChild(div);
});
```

<figure><img src="../../.gitbook/assets/image (7).png" alt=""><figcaption></figcaption></figure>

Wenn auf diese Schaltfl√§che geklickt wird, wird eine Nachricht an die Erweiterungsseiten vom Inhalts-Script gesendet, indem die [**runtime.sendMessage() API**](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/runtime/sendMessage) genutzt wird. Dies liegt an der Begrenzung des Inhalts-Scripts im direkten Zugriff auf APIs, wobei `storage` zu den wenigen Ausnahmen geh√∂rt. F√ºr Funktionalit√§ten √ºber diese Ausnahmen hinaus werden Nachrichten an Erweiterungsseiten gesendet, mit denen Inhalts-Scripts kommunizieren k√∂nnen.

{% hint style="warning" %}
Je nach Browser k√∂nnen sich die F√§higkeiten des Inhalts-Scripts geringf√ºgig unterscheiden. F√ºr auf Chromium basierende Browser ist die Liste der F√§higkeiten in der [Chrome-Entwicklerdokumentation](https://developer.chrome.com/docs/extensions/mv3/content\_scripts/#capabilities) verf√ºgbar, und f√ºr Firefox dient die [MDN](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/Content\_scripts#webextension\_apis) als prim√§re Quelle.\
Es ist auch erw√§hnenswert, dass Inhalts-Scripts die M√∂glichkeit haben, mit Hintergrund-Scripts zu kommunizieren, was es ihnen erm√∂glicht, Aktionen auszuf√ºhren und Antworten zur√ºckzugeben.
{% endhint %}

Um Inhalts-Scripts in Chrome anzuzeigen und zu debuggen, kann das Chrome-Entwicklertools-Men√º √ºber Optionen > Weitere Tools > Entwicklertools aufgerufen werden ODER durch Dr√ºcken von Strg + Umschalt + I.

Nachdem die Entwicklertools angezeigt werden, sollte auf den **Quellcode-Tab** geklickt werden, gefolgt vom **Inhalts-Scripts-Tab**. Dies erm√∂glicht die Beobachtung der ausgef√ºhrten Inhalts-Scripts aus verschiedenen Erweiterungen und das Setzen von Haltepunkten, um den Ausf√ºhrungsfluss zu verfolgen.

### Eingef√ºgte Inhalts-Scripts

{% hint style="success" %}
Beachten Sie, dass **Inhalts-Scripts nicht zwingend erforderlich** sind, da es auch m√∂glich ist, Skripte **dynamisch einzuf√ºgen** und sie **programmgesteuert** in Webseiten √ºber **`tabs.executeScript`** einzuf√ºgen. Dies bietet tats√§chlich mehr **feingranulare Kontrollen**.
{% endhint %}

F√ºr die programmgesteuerte Einschleusung eines Inhalts-Scripts muss die Erweiterung [Host-Berechtigungen](https://developer.chrome.com/docs/extensions/reference/permissions) f√ºr die Seite haben, in die die Skripte eingef√ºgt werden sollen. Diese Berechtigungen k√∂nnen entweder durch **Anforderung** im Manifest der Erweiterung oder vor√ºbergehend durch [**activeTab**](https://developer.chrome.com/docs/extensions/reference/manifest/activeTab) gesichert werden.

#### Beispiel f√ºr eine activeTab-basierte Erweiterung

{% code title="manifest.json" %}
```json
{
"name": "My extension",
...
"permissions": [
"activeTab",
"scripting"
],
"background": {
"service_worker": "background.js"
},
"action": {
"default_title": "Action Button"
}
}
```
{% endcode %}

* **Injizieren einer JS-Datei beim Klicken:**

```javascript
// content-script.js
document.body.style.backgroundColor = "orange";

//service-worker.js - Inject the JS file
chrome.action.onClicked.addListener((tab) => {
chrome.scripting.executeScript({
target: { tabId: tab.id },
files: ["content-script.js"]
});
});
```

* **F√ºgen Sie eine Funktion** beim Klicken hinzu:

```javascript
//service-worker.js - Inject a function
function injectedFunction() {
document.body.style.backgroundColor = "orange";
}

chrome.action.onClicked.addListener((tab) => {
chrome.scripting.executeScript({
target : {tabId : tab.id},
func : injectedFunction,
});
});
```

#### Beispiel mit Skriptberechtigungen

```javascript
// service-workser.js
chrome.scripting.registerContentScripts([{
id : "test",
matches : [ "https://*.example.com/*" ],
excludeMatches : [ "*://*/*business*" ],
js : [ "contentScript.js" ],
}]);

// Another example
chrome.tabs.executeScript(tabId, { file: "content_script.js" });
```

Um mehr URLs einzuschlie√üen oder auszuschlie√üen, ist es auch m√∂glich, **`include_globs`** und **`exclude_globs`** zu verwenden.

### Inhalts Skripte `run_at`

Das Feld `run_at` steuert **wann JavaScript-Dateien in die Webseite eingef√ºgt werden**. Der bevorzugte und Standardwert ist `"document_idle"`.

Die m√∂glichen Werte sind:

* **`document_idle`**: Wenn m√∂glich
* **`document_start`**: Nach allen Dateien von `css`, aber bevor ein anderer DOM erstellt wird oder ein anderes Skript ausgef√ºhrt wird.
* **`document_end`**: Unmittelbar nachdem der DOM vollst√§ndig ist, aber bevor Subressourcen wie Bilder und Frames geladen wurden.

#### √úber `manifest.json`

```json
{
"name": "My extension",
...
"content_scripts": [
{
"matches": ["https://*.example.com/*"],
"run_at": "document_idle",
"js": ["contentScript.js"]
}
],
...
}

```

√úber **`service-worker.js`**

```javascript
chrome.scripting.registerContentScripts([{
id : "test",
matches : [ "https://*.example.com/*" ],
runAt : "document_idle",
js : [ "contentScript.js" ],
}]);
```

### `Hintergrund`

Nachrichten, die von Inhaltsskripten gesendet werden, werden von der **Hintergrundseite** empfangen, die eine zentrale Rolle bei der Koordination der Komponenten der Erweiterung spielt. Insbesondere bleibt die Hintergrundseite w√§hrend der gesamten Lebensdauer der Erweiterung bestehen und arbeitet diskret ohne direkte Benutzerinteraktion. Sie verf√ºgt √ºber ihr eigenes Document Object Model (DOM), das komplexe Interaktionen und Zustandsverwaltung erm√∂glicht.

**Hauptpunkte**:

* **Rolle der Hintergrundseite:** Dient als Nervenzentrum f√ºr die Erweiterung und gew√§hrleistet die Kommunikation und Koordination zwischen verschiedenen Teilen der Erweiterung.
* **Persistenz:** Es handelt sich um eine st√§ndig pr√§sente Entit√§t, die f√ºr den Benutzer unsichtbar ist, aber f√ºr die Funktionalit√§t der Erweiterung unerl√§sslich ist.
* **Automatische Generierung:** Wenn nicht explizit definiert, erstellt der Browser automatisch eine Hintergrundseite. Diese automatisch generierte Seite enth√§lt alle im Manifest der Erweiterung angegebenen Hintergrundskripte und gew√§hrleistet den nahtlosen Betrieb der Hintergrundaufgaben der Erweiterung.

{% hint style="success" %}
Die Bequemlichkeit, die der Browser durch die automatische Generierung einer Hintergrundseite bietet (wenn nicht explizit deklariert), stellt sicher, dass alle erforderlichen Hintergrundskripte integriert und betriebsbereit sind, was den Einrichtungsprozess der Erweiterung vereinfacht.
{% endhint %}

Beispielhintergrundskript:

```js
chrome.runtime.onMessage.addListener((request, sender, sendResponse) =>
{
if (request == "explain")
{
chrome.tabs.create({ url: "https://example.net/explanation" });
}
})
```

Es verwendet die [runtime.onMessage API](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/runtime/onMessage), um Nachrichten anzuh√∂ren. Wenn eine `"erkl√§ren"` Nachricht empfangen wird, verwendet es die [Tabs API](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/tabs), um eine Seite in einem neuen Tab zu √∂ffnen.

Um das Hintergrundskript zu debuggen, k√∂nnen Sie zu den **Erweiterungsdetails gehen und den Service-Worker inspizieren**, dies √∂ffnet die Entwicklertools mit dem Hintergrundskript:

<figure><img src="https://github.com/carlospolop/hacktricks/blob/de/pentesting-web/browser-extension-pentesting-methodology/broken-reference" alt=""><figcaption></figcaption></figure>

### Optionsseiten und andere

Browser-Erweiterungen k√∂nnen verschiedene Arten von Seiten enthalten:

* **Aktionsseiten** werden in einem **Dropdown-Men√º angezeigt, wenn auf das Erweiterungssymbol geklickt wird**.
* Seiten, die die Erweiterung in einem **neuen Tab laden wird**.
* **Optionsseiten**: Diese Seite wird oben auf der Erweiterung angezeigt, wenn darauf geklickt wird. Im vorherigen Manifest konnte ich auf diese Seite zugreifen unter `chrome://extensions/?options=fadlhnelkbeojnebcbkacjilhnbjfjca` oder durch Klicken auf:

<figure><img src="../../.gitbook/assets/image (8).png" alt="" width="375"><figcaption></figcaption></figure>

Beachten Sie, dass diese Seiten im Gegensatz zu Hintergrundseiten nicht persistent sind, da sie bei Bedarf dynamisch Inhalte laden. Trotzdem teilen sie bestimmte F√§higkeiten mit der Hintergrundseite:

* **Kommunikation mit Inhalts-Skripten:** √Ñhnlich wie die Hintergrundseite k√∂nnen diese Seiten Nachrichten von Inhalts-Skripten empfangen, um die Interaktion innerhalb der Erweiterung zu erleichtern.
* **Zugriff auf erweiterungsspezifische APIs:** Diese Seiten haben umfassenden Zugriff auf erweiterungsspezifische APIs, abh√§ngig von den f√ºr die Erweiterung definierten Berechtigungen.

### `permissions` & `host_permissions`

**`permissions`** und **`host_permissions`** sind Eintr√§ge aus der `manifest.json`, die anzeigen, **welche Berechtigungen** die Browser-Erweiterungen haben (Speicher, Standort...) und auf **welchen Webseiten**.

Da Browser-Erweiterungen so **privilegiert** sein k√∂nnen, k√∂nnte eine b√∂sartige oder kompromittierte Erweiterung einem Angreifer **verschiedene M√∂glichkeiten bieten, sensible Informationen zu stehlen und den Benutzer auszuspionieren**.

√úberpr√ºfen Sie, wie diese Einstellungen funktionieren und wie sie missbraucht werden k√∂nnten in:

{% content-ref url="browext-permissions-and-host_permissions.md" %}
[browext-permissions-and-host\_permissions.md](browext-permissions-and-host\_permissions.md)
{% endcontent-ref %}

### `content_security_policy`

Eine **Content-Security-Policy** kann ebenfalls in der `manifest.json` deklariert werden. Wenn eine definiert ist, k√∂nnte sie **anf√§llig** sein.

Die Standardkonfiguration f√ºr Browser-Erweiterungsseiten ist eher restriktiv:

```bash
script-src 'self'; object-src 'self';
```

F√ºr weitere Informationen zu CSP und m√∂glichen Umgehungen √ºberpr√ºfen Sie:

{% content-ref url="../content-security-policy-csp-bypass/" %}
[content-security-policy-csp-bypass](../content-security-policy-csp-bypass/)
{% endcontent-ref %}

### `web_accessible_resources`

Damit eine Webseite auf eine Seite einer Browsererweiterung zugreifen kann, z. B. eine `.html`-Seite, muss diese Seite im Feld **`web_accessible_resources`** der `manifest.json` erw√§hnt werden.\
Zum Beispiel:

```javascript
{
...
"web_accessible_resources": [
{
"resources": [ "images/*.png" ],
"matches": [ "https://example.com/*" ]
},
{
"resources": [ "fonts/*.woff" ],
"matches": [ "https://example.com/*" ]
}
],
...
}
```

Diese Seiten sind unter URLs wie folgt erreichbar:

```
chrome-extension://<extension-id>/message.html
```

In √∂ffentlichen Erweiterungen ist die **Erweiterungs-ID zug√§nglich**:

<figure><img src="../../.gitbook/assets/image (722).png" alt="" width="375"><figcaption></figcaption></figure>

Wenn jedoch der Parameter `manifest.json` **`use_dynamic_url`** verwendet wird, kann diese **ID dynamisch sein**.

Das Zugreifen auf diese Seiten macht sie anf√§llig f√ºr **potenzielles Clickjacking**:

{% content-ref url="browext-clickjacking.md" %}
[browext-clickjacking.md](browext-clickjacking.md)
{% endcontent-ref %}

{% hint style="success" %}
Indem man diese Seiten nur von der Erweiterung und nicht von zuf√§lligen URLs laden l√§sst, k√∂nnten Clickjacking-Angriffe verhindert werden.
{% endhint %}

### `externally_connectable`

Gem√§√ü der [**Dokumentation**](https://developer.chrome.com/docs/extensions/reference/manifest/externally-connectable) gibt die Eigenschaft `"externally_connectable"` im Manifest an, **welche Erweiterungen und Webseiten** √ºber [runtime.connect](https://developer.chrome.com/docs/extensions/reference/runtime#method-connect) und [runtime.sendMessage](https://developer.chrome.com/docs/extensions/reference/runtime#method-sendMessage) mit Ihrer Erweiterung verbunden werden k√∂nnen.

* Wenn der Schl√ºssel **`externally_connectable`** nicht im Manifest Ihrer Erweiterung deklariert ist oder als **`"ids": ["*"]`** deklariert ist, k√∂nnen **alle Erweiterungen eine Verbindung herstellen, aber keine Webseiten**.
* Wenn **spezifische IDs** angegeben sind, wie in `"ids": ["aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"]`, k√∂nnen **nur diese Anwendungen** eine Verbindung herstellen.
* Wenn **√úbereinstimmungen** angegeben sind, k√∂nnen diese Webanwendungen eine Verbindung herstellen:

```json
"matches": [
"https://*.google.com/*",
"*://*.chromium.org/*",
```

* Wenn es als leer angegeben ist: **`"externally_connectable": {}`**, wird keine App oder Website eine Verbindung herstellen k√∂nnen.

Je weniger Erweiterungen und URLs hier angegeben sind, desto kleiner wird die Angriffsfl√§che sein.

{% hint style="danger" %}
Wenn eine Website, die anf√§llig f√ºr XSS oder √úbernahmen ist, in **`externally_connectable`** angegeben ist, kann ein Angreifer Nachrichten direkt an das Hintergrundskript senden, wodurch das Content-Skript und seine CSP vollst√§ndig umgangen werden.

Daher handelt es sich hierbei um einen sehr leistungsstarken Bypass.

Dar√ºber hinaus k√∂nnte, wenn der Client eine sch√§dliche Erweiterung installiert, selbst wenn diese nicht berechtigt ist, mit der anf√§lligen Erweiterung zu kommunizieren, XSS-Daten auf einer erlaubten Webseite einschleusen oder **`WebRequest`**- oder **`DeclarativeNetRequest`**-APIs missbrauchen, um Anfragen auf einer gezielten Domain zu manipulieren und eine Anforderung f√ºr eine **JavaScript-Datei** auf einer Seite zu √§ndern. (Beachten Sie, dass CSP auf der gezielten Seite diese Angriffe verhindern k√∂nnte). Diese Idee stammt aus [**diesem Bericht**](https://www.darkrelay.com/post/opera-zero-day-rce-vulnerability).
{% endhint %}

##

## Web **‚ÜîÔ∏é** Content-Skript-Kommunikation

Die Umgebungen, in denen **Content-Skripte** arbeiten, und in denen die Host-Seiten existieren, sind voneinander **getrennt**, was eine **Isolierung** gew√§hrleistet. Trotz dieser Isolierung haben beide die M√∂glichkeit, mit dem **Document Object Model (DOM)** der Seite zu interagieren, einem gemeinsamen Ressourcenbereich. Damit die Host-Seite mit dem **Content-Skript** kommunizieren kann, oder indirekt mit der Erweiterung √ºber das Content-Skript, muss sie das **DOM** nutzen, das beiden Parteien als Kommunikationskanal zug√§nglich ist.

### Post-Nachrichten

{% code title="content-script.js" %}
```javascript
var port = chrome.runtime.connect();

window.addEventListener("message", (event) => {
// We only accept messages from ourselves
if (event.source !== window) {
return;
}

if (event.data.type && (event.data.type === "FROM_PAGE")) {
console.log("Content script received: " + event.data.text);
port.postMessage(event.data.text);
}
}, false);
```
{% endcode %}

{% code title="beispiel.js" %}
```javascript
document.getElementById("theButton").addEventListener("click", () => {
window.postMessage(
{type : "FROM_PAGE", text : "Hello from the webpage!"}, "*");
}, false);
```
{% endcode %}

Eine sichere Post Message-Kommunikation sollte die Echtheit der empfangenen Nachricht √ºberpr√ºfen, dies kann durch folgende √úberpr√ºfungen erfolgen:

* **`event.isTrusted`**: Dies ist nur wahr, wenn das Ereignis durch eine Benutzeraktion ausgel√∂st wurde.
* Das Inhalts-Skript erwartet m√∂glicherweise eine Nachricht nur, wenn der Benutzer eine Aktion ausf√ºhrt.
* **Ursprungsdom√§ne**: Erwartet m√∂glicherweise eine Nachricht nur von einer Whitelist von Dom√§nen.
* Wenn ein Regex verwendet wird, seien Sie sehr vorsichtig.
* **Quelle**: `received_message.source !== window` kann verwendet werden, um zu √ºberpr√ºfen, ob die Nachricht aus demselben Fenster stammt, in dem das Inhalts-Skript zuh√∂rt.

Die zuvor durchgef√ºhrten √úberpr√ºfungen k√∂nnten selbst dann anf√§llig sein, √ºberpr√ºfen Sie auf der folgenden Seite **potenzielle Post Message-Umgehungen**:

{% content-ref url="../postmessage-vulnerabilities/" %}
[postmessage-vulnerabilities](../postmessage-vulnerabilities/)
{% endcontent-ref %}

### Iframe

Eine weitere m√∂gliche Kommunikationsmethode k√∂nnte √ºber **Iframe-URLs** erfolgen, ein Beispiel finden Sie unter:

{% content-ref url="browext-xss-example.md" %}
[browext-xss-example.md](browext-xss-example.md)
{% endcontent-ref %}

### DOM

Dies ist nicht "genau" eine Kommunikationsmethode, aber das **Web und das Inhalts-Skript haben Zugriff auf das Web-DOM**. Wenn das **Inhalts-Skript** also Informationen daraus liest und dem Web-DOM vertraut, k√∂nnte das Web diese Daten **√§ndern** (weil dem Web nicht vertraut werden sollte oder weil das Web anf√§llig f√ºr XSS ist) und das **Inhalts-Skript gef√§hrden**.

Ein Beispiel f√ºr eine **DOM-basierte XSS zur Kompromittierung einer Browsererweiterung** finden Sie auch unter:

{% content-ref url="browext-xss-example.md" %}
[browext-xss-example.md](browext-xss-example.md)
{% endcontent-ref %}

## Sensible Informationen im Speicher/Code

Wenn eine Browsererweiterung **sensible Informationen im Speicher speichert**, k√∂nnten diese **ausgelesen** (insbesondere auf Windows-Maschinen) und nach diesen Informationen **gesucht** werden.

Daher sollte der Speicher der Browsererweiterung **nicht als sicher angesehen** werden und **sensible Informationen** wie Anmeldeinformationen oder mnemonische Phrasen **sollten nicht gespeichert werden**.

Nat√ºrlich sollten **keine sensiblen Informationen im Code** platziert werden, da sie **√∂ffentlich** zug√§nglich sind.

## Kommunikation zwischen Inhalts-Skript und Hintergrundskript

Ein Inhalts-Skript kann die Funktionen [**runtime.sendMessage()**](https://developer.chrome.com/docs/extensions/reference/runtime#method-sendMessage) **oder** [**tabs.sendMessage()**](https://developer.chrome.com/docs/extensions/reference/tabs#method-sendMessage) verwenden, um eine **einmalige JSON-serialisierbare** Nachricht zu senden.

Um die **Antwort** zu verarbeiten, verwenden Sie das zur√ºckgegebene **Promise**. F√ºr die Abw√§rtskompatibilit√§t k√∂nnen Sie jedoch immer noch eine **R√ºckruffunktion** als letzten Argument √ºbergeben.

Das Senden einer Anfrage von einem **Inhalts-Skript** sieht wie folgt aus:

```javascript
(async () => {
const response = await chrome.runtime.sendMessage({greeting: "hello"});
// do something with response here, not outside the function
console.log(response);
})();
```

Senden einer Anfrage von der **Erweiterung** (normalerweise ein **Hintergrundskript**) Ein Inhalts-Skript kann die Funktionen verwenden, au√üer dass Sie angeben m√ºssen, an welchen Tab sie gesendet werden soll. Beispiel daf√ºr, wie man eine Nachricht an das Inhalts-Skript im ausgew√§hlten Tab sendet:

```javascript
// From https://stackoverflow.com/questions/36153999/how-to-send-a-message-between-chrome-extension-popup-and-content-script
(async () => {
const [tab] = await chrome.tabs.query({active: true, lastFocusedWindow: true});
const response = await chrome.tabs.sendMessage(tab.id, {greeting: "hello"});
// do something with response here, not outside the function
console.log(response);
})();
```

Auf der **Empf√§ngerseite** m√ºssen Sie einen [**runtime.onMessage**](https://developer.chrome.com/docs/extensions/reference/runtime#event-onMessage) **Ereignislistener** einrichten, um die Nachricht zu verarbeiten. Dies sieht sowohl in einem Inhalts-Script als auch in einer Erweiterungsseite gleich aus.

```javascript
// From https://stackoverflow.com/questions/70406787/javascript-send-message-from-content-js-to-background-js
chrome.runtime.onMessage.addListener(
function(request, sender, sendResponse) {
console.log(sender.tab ?
"from a content script:" + sender.tab.url :
"from the extension");
if (request.greeting === "hello")
sendResponse({farewell: "goodbye"});
}
);
```

Im hervorgehobenen Beispiel wurde **`sendResponse()`** synchron ausgef√ºhrt. Um den `onMessage`-Ereignisbehandler f√ºr die asynchrone Ausf√ºhrung von `sendResponse()` zu √§ndern, ist es unerl√§sslich, `return true;` einzubeziehen.

Eine wichtige √úberlegung ist, dass in Szenarien, in denen mehrere Seiten auf `onMessage`-Ereignisse eingestellt sind, **die erste Seite, die `sendResponse()`** f√ºr ein bestimmtes Ereignis ausf√ºhrt, die einzige ist, die die Antwort effektiv liefern kann. Alle nachfolgenden Antworten auf dasselbe Ereignis werden nicht ber√ºcksichtigt.

Bei der Erstellung neuer Erweiterungen sollte der Vorzug Promises gegen√ºber Callbacks gelten. In Bezug auf die Verwendung von Callbacks wird die `sendResponse()`-Funktion nur dann als g√ºltig betrachtet, wenn sie direkt im synchronen Kontext ausgef√ºhrt wird oder wenn der Ereignisbehandler eine asynchrone Operation anzeigt, indem er `true` zur√ºckgibt. Sollten keine der Handler `true` zur√ºckgeben oder wenn die `sendResponse()`-Funktion aus dem Speicher entfernt wird (garbage-collected), wird das mit der `sendMessage()`-Funktion verkn√ºpfte Callback standardm√§√üig ausgel√∂st.

## Laden einer Erweiterung im Browser

1. **Browser-Erweiterung herunterladen** & entpacken
2. Gehe zu **`chrome://extensions/`** und **aktiviere** den `Entwicklermodus`
3. Klicke auf die Schaltfl√§che **`Unverpackte Erweiterung laden`**

In **Firefox** gehst du zu **`about:debugging#/runtime/this-firefox`** und klickst auf die Schaltfl√§che **`Tempor√§re Add-on laden`**.

## Abrufen des Quellcodes aus dem Store

Der Quellcode einer Chrome-Erweiterung kann auf verschiedene Arten erhalten werden. Im Folgenden sind detaillierte Erkl√§rungen und Anweisungen f√ºr jede Option aufgef√ºhrt.

### Erweiterung als ZIP √ºber die Befehlszeile herunterladen

Der Quellcode einer Chrome-Erweiterung kann als ZIP-Datei √ºber die Befehlszeile heruntergeladen werden. Dies beinhaltet die Verwendung von `curl`, um die ZIP-Datei von einer bestimmten URL abzurufen und dann den Inhalt der ZIP-Datei in ein Verzeichnis zu extrahieren. Hier sind die Schritte:

1. Ersetze `"extension_id"` durch die tats√§chliche ID der Erweiterung.
2. F√ºhre die folgenden Befehle aus:

```bash
extension_id=your_extension_id   # Replace with the actual extension ID
curl -L -o "$extension_id.zip" "https://clients2.google.com/service/update2/crx?response=redirect&os=mac&arch=x86-64&nacl_arch=x86-64&prod=chromecrx&prodchannel=stable&prodversion=44.0.2403.130&x=id%3D$extension_id%26uc"
unzip -d "$extension_id-source" "$extension_id.zip"
```

### Nutzen Sie die CRX Viewer-Website

[https://robwu.nl/crxviewer/](https://robwu.nl/crxviewer/)

### Verwenden Sie die CRX Viewer-Erweiterung

Eine weitere praktische Methode ist die Verwendung des Chrome Extension Source Viewer, der ein Open-Source-Projekt ist. Es kann aus dem [Chrome Web Store](https://chrome.google.com/webstore/detail/chrome-extension-source-v/jifpbeccnghkjeaalbbjmodiffmgedin?hl=en) installiert werden. Der Quellcode des Viewers ist in seinem [GitHub-Repository](https://github.com/Rob--W/crxviewer) verf√ºgbar.

### Quellcode einer lokal installierten Erweiterung anzeigen

Auch lokal installierte Chrome-Erweiterungen k√∂nnen inspiziert werden. So geht's:

1. Greifen Sie auf Ihr lokales Chrome-Profilverzeichnis zu, indem Sie `chrome://version/` aufrufen und das Feld "Profilpfad" suchen.
2. Navigieren Sie zum Unterordner `Extensions/` innerhalb des Profilverzeichnisses.
3. Dieser Ordner enth√§lt alle installierten Erweiterungen, in der Regel mit ihrem Quellcode in einem lesbaren Format.

Um Erweiterungen zu identifizieren, k√∂nnen Sie ihre IDs den Namen zuordnen:

* Aktivieren Sie den Entwicklermodus auf der Seite `about:extensions`, um die IDs jeder Erweiterung zu sehen.
* In jedem Erweiterungsordner enth√§lt die Datei `manifest.json` ein lesbares `name`-Feld, das Ihnen hilft, die Erweiterung zu identifizieren.

### Verwenden Sie einen Dateiarchivierer oder -entpacker

Gehen Sie zum Chrome Web Store und laden Sie die Erweiterung herunter. Die Datei wird die Erweiterung `.crx` haben. √Ñndern Sie die Dateierweiterung von `.crx` in `.zip`. Verwenden Sie einen Dateiarchivierer (wie WinRAR, 7-Zip usw.), um den Inhalt der ZIP-Datei zu extrahieren.

### Verwenden Sie den Entwicklermodus in Chrome

√ñffnen Sie Chrome und gehen Sie zu `chrome://extensions/`. Aktivieren Sie oben rechts den "Entwicklermodus". Klicken Sie auf "Entpackte Erweiterung laden...". Navigieren Sie zum Verzeichnis Ihrer Erweiterung. Dies l√§dt nicht den Quellcode herunter, ist aber n√ºtzlich, um den Code einer bereits heruntergeladenen oder entwickelten Erweiterung anzuzeigen und zu √§ndern.

## Sicherheitspr√ºfungs-Checkliste

Obwohl Browser-Erweiterungen eine **begrenzte Angriffsfl√§che** haben, k√∂nnen einige von ihnen **Schwachstellen** oder **potenzielle Verbesserungen der Absicherung** enthalten. Die folgenden sind die h√§ufigsten:

* [ ] **Beschr√§nken** Sie so weit wie m√∂glich die angeforderten **`Berechtigungen`**
* [ ] **Beschr√§nken** Sie so weit wie m√∂glich die **`host_permissions`**
* [ ] Verwenden Sie eine **starke** **`content_security_policy`**
* [ ] **Beschr√§nken** Sie so weit wie m√∂glich die **`externally_connectable`**, wenn keine ben√∂tigt wird und m√∂glich ist, lassen Sie sie nicht standardm√§√üig, geben Sie **`{}`** an
* [ ] Wenn eine **URL anf√§llig f√ºr XSS oder √úbernahme** ist, kann ein Angreifer **Nachrichten direkt an die Hintergrundskripte senden**. Sehr m√§chtiger Umgehungsweg.
* [ ] **Beschr√§nken** Sie so weit wie m√∂glich die **`web_accessible_resources`**, auch leer, wenn m√∂glich.
* [ ] Wenn **`web_accessible_resources`** nicht leer ist, √ºberpr√ºfen Sie auf [**Clickjacking**](browext-clickjacking.md)
* [ ] Wenn eine **Kommunikation** von der **Erweiterung** zur **Webseite** erfolgt, √ºberpr√ºfen Sie auf [**XSS**](browext-xss-example.md) **Schwachstellen**, die durch die Kommunikation verursacht werden.
* [ ] Wenn Post Messages verwendet werden, √ºberpr√ºfen Sie auf [**Post Message-Schwachstellen**](../postmessage-vulnerabilities/)**.**
* [ ] Wenn das **Content Script auf DOM-Details zugreift**, √ºberpr√ºfen Sie, dass sie kein XSS einf√ºhren, wenn sie vom Web ge√§ndert werden
* [ ] Legen Sie einen besonderen Schwerpunkt darauf, wenn diese Kommunikation auch an der **Kommunikation zwischen dem Content Script und dem Hintergrundskript** beteiligt ist
* [ ] **Empfindliche Informationen sollten nicht** im Code der Browser-Erweiterung **gespeichert werden**
* [ ] **Empfindliche Informationen sollten nicht** im Speicher der Browser-Erweiterung **gespeichert werden**

## Tools

### [**Tarnish**](https://thehackerblog.com/tarnish/)

* Holt jede Chrome-Erweiterung von einem bereitgestellten Chrome Webstore-Link.
* [**manifest.json**](https://developer.chrome.com/extensions/manifest) **Viewer**: zeigt einfach eine JSON-formatierte Version des Manifests der Erweiterung an.
* **Fingerprint-Analyse**: Erkennung von [web\_accessible\_resources](https://developer.chrome.com/extensions/manifest/web\_accessible\_resources) und automatische Generierung von Chrome-Erweiterungs-Fingerprinting-JavaScript.
* **Potenzielle Clickjacking-Analyse**: Erkennung von Erweiterungs-HTML-Seiten mit der Direktive [web\_accessible\_resources](https://developer.chrome.com/extensions/manifest/web\_accessible\_resources). Diese sind je nach Zweck der Seiten potenziell anf√§llig f√ºr Clickjacking.
* **Berechtigungswarnungs-Viewer**: zeigt eine Liste aller Chrome-Berechtigungswarnungen an, die angezeigt werden, wenn ein Benutzer versucht, die Erweiterung zu installieren.
* **Gef√§hrliche Funktionen**: zeigt den Ort gef√§hrlicher Funktionen, die potenziell von einem Angreifer ausgenutzt werden k√∂nnten (z. B. Funktionen wie innerHTML, chrome.tabs.executeScript).
* **Einstiegspunkte**: zeigt, wo die Erweiterung Benutzer-/externe Eingaben entgegennimmt. Dies ist n√ºtzlich, um die Oberfl√§che einer Erweiterung zu verstehen und nach potenziellen Punkten zu suchen, an die b√∂sartig gestaltete Daten gesendet werden k√∂nnen.
* Sowohl die Scanner f√ºr Gef√§hrliche Funktionen als auch Einstiegspunkte haben folgendes f√ºr ihre generierten Warnungen:
* Relevanten Code-Schnipsel und Zeile, die die Warnung verursacht hat.
* Beschreibung des Problems.
* Eine Schaltfl√§che "Datei anzeigen", um die vollst√§ndige Quelldatei mit dem Code anzuzeigen.
* Der Pfad der alarmierten Datei.
* Die vollst√§ndige Chrome-Erweiterungs-URI der alarmierten Datei.
* Der Dateityp, z. B. ein Hintergrundseiten-Skript, ein Inhalts-Skript, eine Browseraktion usw.
* Wenn die anf√§llige Zeile in einer JavaScript-Datei ist, die Pfade aller Seiten, auf denen sie enthalten ist, sowie den Typ dieser Seiten und den [web\_accessible\_resource](https://developer.chrome.com/extensions/manifest/web\_accessible\_resources)-Status.
* **Content Security Policy (CSP)-Analysator und Bypass-Pr√ºfer**: Dies zeigt Schw√§chen in der CSP Ihrer Erweiterung auf und beleuchtet auch m√∂gliche Umgehungsm√∂glichkeiten Ihrer CSP aufgrund von whitelisteten CDNs usw.
* **Bekannte verwundbare Bibliotheken**: Verwendet [Retire.js](https://retirejs.github.io/retire.js), um auf die Verwendung von bekannten verwundbaren JavaScript-Bibliotheken zu pr√ºfen.
* Erweiterung und formatierte Versionen herunterladen.
* Die originale Erweiterung herunterladen.
* Eine versch√∂nerte Version der Erweiterung herunterladen (automatisch formatiertes HTML und JavaScript).
* Automatisches Zwischenspeichern von Scanergebnissen, das Ausf√ºhren eines Erweiterungsscans dauert beim ersten Mal eine gute Zeit. Beim zweiten Mal, vorausgesetzt die Erweiterung wurde nicht aktualisiert, erfolgt die Ausf√ºhrung fast sofort aufgrund des zwischengespeicherten Ergebnisses.
* Verlinkbare Berichts-URLs, um jemand anderen einfach zu einem von Tarnish generierten Erweiterungsbericht zu verlinken.

### [Neto](https://github.com/elevenpaths/neto)

Das Projekt Neto ist ein Python 3-Paket, das entwickelt wurde, um versteckte Funktionen von Browser-Plugins und -Erweiterungen f√ºr bekannte Browser wie Firefox und Chrome zu analysieren und aufzudecken. Es automatisiert den Prozess des Entpackens der gepackten Dateien, um diese Funktionen aus relevanten Ressourcen in einer Erweiterung wie `manifest.json`, Lokalisierungsordnern oder JavaScript- und HTML-Quelldateien zu extrahieren.

## Referenzen

* **Dank an** [**@naivenom**](https://twitter.com/naivenom) **f√ºr die Hilfe bei dieser Methodik**
* [https://www.cobalt.io/blog/introduction-to-chrome-browser-extension-security-testing](https://www.cobalt.io/blog/introduction-to-chrome-browser-extension-security-testing)
* [https://palant.info/2022/08/10/anatomy-of-a-basic-extension/](https://palant.info/2022/08/10/anatomy-of-a-basic-extension/)
* [https://palant.info/2022/08/24/attack-surface-of-extension-pages/](https://palant.info/2022/08/24/attack-surface-of-extension-pages/)
* [https://palant.info/2022/08/31/when-extension-pages-are-web-accessible/](https://palant.info/2022/08/31/when-extension-pages-are-web-accessible/)
* [https://help.passbolt.com/assets/files/PBL-02-report.pdf](https://help.passbolt.com/assets/files/PBL-02-report.pdf)
* [https://developer.chrome.com/docs/extensions/develop/concepts/content-scripts](https://developer.chrome.com/docs/extensions/develop/concepts/content-scripts)
* [https://developer.chrome.com/docs/extensions/mv2/background-pages](https://developer.chrome.com/docs/extensions/mv2/background-pages)
* [https://thehackerblog.com/kicking-the-rims-a-guide-for-securely-writing-and-auditing-chrome-extensions/](https://thehackerblog.com/kicking-the-rims-a-guide-for-securely-writing-and-auditing-chrome-extensions/)
* [https://gist.github.com/LongJohnCoder/9ddf5735df3a4f2e9559665fb864eac0](https://gist.github.com/LongJohnCoder/9ddf5735df3a4f2e9559665fb864eac0)

<details>

<summary><strong>Erlernen Sie AWS-Hacking von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr Unternehmen in HackTricks beworben sehen m√∂chten oder HackTricks im PDF-Format herunterladen m√∂chten, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks Merch**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories einreichen.

</details>
