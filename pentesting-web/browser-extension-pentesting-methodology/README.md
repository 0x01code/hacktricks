# Tarayıcı Uzantısı Pentesting Metodolojisi

<details>

<summary><strong>AWS hacklemeyi sıfırdan kahraman seviyesine öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Kırmızı Takım Uzmanı)</strong></a><strong> ile!</strong></summary>

HackTricks'i desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamını görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**PEASS Ailesi'ni**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) katılın veya [**telegram grubuna**](https://t.me/peass) katılın veya bizi **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)'da **takip edin**.
* **Hacking püf noktalarınızı paylaşarak** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına PR gönderin.

</details>

## Temel Bilgiler

Tarayıcı uzantıları JavaScript ile yazılır ve tarayıcı tarafından arka planda yüklenir. Kendi [DOM](https://www.w3schools.com/js/js\_htmldom.asp)'una sahiptir ancak diğer sitelerin DOM'larıyla etkileşimde bulunabilir. Bu, diğer sitelerin gizliliğini, bütünlüğünü ve erişilebilirliğini (CIA) tehlikeye atabilir.

## Ana Bileşenler

Uzantı düzenleri en iyi görselleştirildiğinde üç bileşenden oluşur. Her bileşeni detaylı olarak inceleyelim.

<figure><img src="../../.gitbook/assets/image (13).png" alt=""><figcaption><p><a href="http://webblaze.cs.berkeley.edu/papers/Extensions.pdf">http://webblaze.cs.berkeley.edu/papers/Extensions.pdf</a></p></figcaption></figure>

### **İçerik Betikleri**

Her içerik betiğinin **tek bir web sayfasının** DOM'una doğrudan erişimi vardır ve bu nedenle **potansiyel olarak kötü niyetli girdilere** maruz kalır. Ancak, içerik betiği, uzantı çekirdeğine mesaj gönderme yeteneği dışında hiçbir izne sahip değildir.

### **Uzantı Çekirdeği**

Uzantı çekirdeği, uzantının çoğu ayrıcalık/erişime sahiptir, ancak uzantı çekirdeği yalnızca [XMLHttpRequest](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest) ve içerik betikleri aracılığıyla web içeriği ile etkileşimde bulunabilir. Ayrıca, uzantı çekirdeğinin ana makineye doğrudan erişimi yoktur.

### **Yerel İkili**

Uzantı, kullanıcının tam ayrıcalıklarıyla ana makineye **erişebilen bir yerel ikiliye** izin verir. Yerel ikili, Flash ve diğer tarayıcı eklentileri tarafından kullanılan standart Netscape Eklenti Uygulama Programlama Arayüzü ([NPAPI](https://en.wikipedia.org/wiki/NPAPI)) aracılığıyla uzantı çekirdeği ile etkileşime geçer.

### Sınırlar

{% hint style="danger" %}
Kullanıcının tam ayrıcalıklarını elde etmek için, bir saldırganın içerik betiğinden uzantı çekirdeğine ve uzantı çekirdeğinden yerel ikiliye kötü niyetli girdi geçirmesi gerekir.
{% endhint %}

Uzantının her bileşeni **güçlü koruyucu sınırlarla** birbirinden ayrılmıştır. Her bileşen ayrı bir işletim sistemi işlemi içinde çalışır. İçerik betikleri ve uzantı çekirdekleri, çoğu işletim sistemi hizmetine erişilemeyen **kum havuzu işlemlerinde** çalışır.

Ayrıca, içerik betikleri, **ayrı bir JavaScript yığınında çalışarak** ilişkili web sayfalarından ayrı tutulur. İçerik betiği ve web sayfası, **aynı temel DOM'a erişime sahiptir**, ancak ikisi **hiçbir zaman JavaScript işaretçilerini değiş tokuş etmez**, JavaScript işlevselliğinin sızmasını önler.

## **`manifest.json`**

Bir Chrome uzantısı, [.crx dosya uzantısına sahip bir ZIP klasörüdür](https://www.lifewire.com/crx-file-2620391). Uzantının çekirdeği, klasörün kökünde bulunan **`manifest.json`** dosyasıdır ve düzen, izinler ve diğer yapılandırma seçeneklerini belirtir.

Örnek:
```json
{
"manifest_version": 2,
"name": "My extension",
"version": "1.0",
"permissions": [
"storage"
],
"content_scripts": [
{
"js": [
"script.js"
],
"matches": [
"https://example.com/*",
"https://www.example.com/*"
],
"exclude_matches": ["*://*/*business*"],
}
],
"background": {
"scripts": [
"background.js"
]
},
"options_ui": {
"page": "options.html"
}
}
```
### `content_scripts`

İçerik betikleri, kullanıcı **eşleşen bir sayfaya gezindiğinde yüklenir**, bizim durumumuzda **`https://example.com/*`** ifadesine uyan herhangi bir sayfa ve **`*://*/*/business*`** regexine uymayanlar. Sayfanın kendi betikleri gibi **çalışır** ve sayfanın [Belge Nesne Modeli (DOM)](https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model)ne keyfi erişime sahiptir.
```json
"content_scripts": [
{
"js": [
"script.js"
],
"matches": [
"https://example.com/*",
"https://www.example.com/*"
],
"exclude_matches": ["*://*/*business*"],
}
],
```
URL'leri dahil etmek veya hariç tutmak için **`include_globs`** ve **`exclude_globs`** kullanmak da mümkündür.

Bu, depolama API'sini kullanarak uzantının depolamasından `message` değerini almak için bir açıklama düğmesi ekleyecek bir örnek içerik betiğidir.
```js
chrome.storage.local.get("message", result =>
{
let div = document.createElement("div");
div.innerHTML = result.message + " <button>Explain</button>";
div.querySelector("button").addEventListener("click", () =>
{
chrome.runtime.sendMessage("explain");
});
document.body.appendChild(div);
});
```
<figure><img src="../../.gitbook/assets/image (20).png" alt=""><figcaption></figcaption></figure>

Bu düğmeye tıklandığında içerik betiği tarafından uzantı sayfalarına bir mesaj gönderilir, [**runtime.sendMessage() API**](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/runtime/sendMessage) kullanılarak. Bu, içerik betiğinin API'lere doğrudan erişimindeki kısıtlamadan kaynaklanmaktadır, `storage` bunun istisnalarından biridir. Bu istisnaların ötesindeki işlevsellikler için, içerik betikleri ile iletişim kurabilen uzantı sayfalarına mesajlar gönderilir.

{% hint style="warning" %}
Tarayıcıya bağlı olarak, içerik betiğinin yetenekleri biraz değişebilir. Chromium tabanlı tarayıcılar için, yetenekler listesi [Chrome Geliştiriciler belgelerinde](https://developer.chrome.com/docs/extensions/mv3/content_scripts/#capabilities) mevcuttur ve Firefox için [MDN](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/Content_scripts#webextension_apis) birincil kaynak olarak hizmet verir.\
Ayrıca içerik betiklerinin arka plan betikleri ile iletişim kurma yeteneğine sahip oldukları ve eylemleri gerçekleştirmelerine ve yanıtları geri iletmelerine olanak tanıdığı da belirtilmelidir.
{% endhint %}

Chrome'da içerik betiklerini görüntülemek ve hata ayıklamak için, Chrome geliştirici araçları menüsüne Options > More tools > Developer tools yoluyla veya Ctrl + Shift + I tuşlarına basarak erişilebilir.

Geliştirici araçları görüntülendikten sonra, **Source** sekmesine tıklanmalı ve ardından **Content Scripts** sekmesine tıklanmalıdır. Bu, çeşitli uzantılardan çalışan içerik betiklerinin gözlemlenmesine ve yürütme akışını izlemek için kesme noktaları belirlemeye olanak tanır.

### Enjekte edilmiş içerik betikleri

{% hint style="success" %}
**İçerik Betiklerinin zorunlu olmadığını** unutmayın, aynı zamanda **dinamik olarak** betiklerin **enjekte edilmesi** ve bunların **programatik olarak enjekte edilmesi** de mümkündür **`tabs.executeScript`** aracılığıyla web sayfalarına. Bu aslında daha **detaylı kontroller** sağlar.
{% endhint %}

Bir içerik betiğinin programatik olarak enjekte edilmesi için, uzantının betiklerin enjekte edileceği sayfaya [ana bilgisayar izinlerine](https://developer.chrome.com/docs/extensions/reference/permissions) sahip olması gerekir. Bu izinler, uzantının manifest dosyası içinde talep edilerek veya geçici olarak [**activeTab**](https://developer.chrome.com/docs/extensions/reference/manifest/activeTab) aracılığıyla sağlanabilir.

#### Örnek activeTab tabanlı uzantı

{% code title="manifest.json" %}
```json
{
"name": "My extension",
...
"permissions": [
"activeTab",
"scripting"
],
"background": {
"service_worker": "background.js"
},
"action": {
"default_title": "Action Button"
}
}
```
{% endcode %}

* **Tıklama olayıyla bir JS dosyası enjekte etmek:**
```javascript
// content-script.js
document.body.style.backgroundColor = "orange";

//service-worker.js - Inject the JS file
chrome.action.onClicked.addListener((tab) => {
chrome.scripting.executeScript({
target: { tabId: tab.id },
files: ["content-script.js"]
});
});
```
* **Tıklama olayına bir fonksiyon enjekte etme**:
```javascript
//service-worker.js - Inject a function
function injectedFunction() {
document.body.style.backgroundColor = "orange";
}

chrome.action.onClicked.addListener((tab) => {
chrome.scripting.executeScript({
target : {tabId : tab.id},
func : injectedFunction,
});
});
```
#### Betik İzinleri ile Örnek
```javascript
// service-workser.js
chrome.scripting.registerContentScripts([{
id : "test",
matches : [ "https://*.example.com/*" ],
excludeMatches : [ "*://*/*business*" ],
js : [ "contentScript.js" ],
}]);

// Another example
chrome.tabs.executeScript(tabId, { file: "content_script.js" });
```
**`include_globs`** ve **`exclude_globs`** kullanarak daha fazla URL eklemek veya hariç tutmak mümkündür.

### İçerik Betikleri `run_at`

`run_at` alanı, **JavaScript dosyalarının web sayfasına ne zaman enjekte edileceğini kontrol eder**. Tercih edilen ve varsayılan değer `"document_idle"` değeridir.

Mümkün olan değerler şunlardır:

* **`document_idle`**: Mümkün olduğunda
* **`document_start`**: `css` dosyalarından sonra, ancak diğer DOM oluşturulmadan veya başka bir betik çalıştırılmadan önce.
* **`document_end`**: DOM tamamlandıktan hemen sonra, ancak resimler ve çerçeveler gibi alt kaynaklar yüklenmeden önce.

#### `manifest.json` üzerinden
```json
{
"name": "My extension",
...
"content_scripts": [
{
"matches": ["https://*.example.com/*"],
"run_at": "document_idle",
"js": ["contentScript.js"]
}
],
...
}

```
**`service-worker.js`** aracılığıyla
```javascript
chrome.scripting.registerContentScripts([{
id : "test",
matches : [ "https://*.example.com/*" ],
runAt : "document_idle",
js : [ "contentScript.js" ],
}]);
```
### `arkaplan`

İçerik komutları tarafından gönderilen mesajlar, uzantının bileşenlerini koordine etmede merkezi bir rol oynayan **arkaplan sayfası** tarafından alınır. Önemli bir şekilde, arkaplan sayfası uzantının ömrü boyunca varlığını sürdürür, doğrudan kullanıcı etkileşimi olmadan gizlice çalışır. Kendi Document Object Model (DOM) 'a sahiptir, karmaşık etkileşimlere ve durum yönetimine olanak tanır.

**Ana Noktalar**:

* **Arkaplan Sayfa Rolü:** Uzantı için iletişim ve koordinasyonu sağlayarak merkezi bir rol oynar.
* **Kalıcılık:** Kullanıcı için görünmez ancak uzantının işlevselliği için ayrılmaz bir parçadır.
* **Otomatik Oluşturma:** Açıkça tanımlanmamışsa, tarayıcı otomatik olarak bir arkaplan sayfası oluşturur. Bu otomatik oluşturulan sayfa, uzantının manifestosunda belirtilen tüm arkaplan betiklerini içerecek şekilde tasarlanmıştır, böylece uzantının arka plan görevlerinin sorunsuz çalışmasını sağlar.

{% hint style="success" %}
Tarayıcının otomatik olarak bir arkaplan sayfası oluşturması (açıkça belirtilmediğinde) sağladığı kolaylık, gerekli tüm arkaplan betiklerinin entegre edilmiş ve operasyonel olduğundan emin olur, böylece uzantının kurulum sürecini basitleştirir.
{% endhint %}

Örnek arkaplan betiği:
```js
chrome.runtime.onMessage.addListener((request, sender, sendResponse) =>
{
if (request == "explain")
{
chrome.tabs.create({ url: "https://example.net/explanation" });
}
})
```
Extension, mesajları dinlemek için [runtime.onMessage API](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/runtime/onMessage) kullanır. Bir `"explain"` mesajı alındığında, [tabs API](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/tabs) kullanarak yeni bir sekmede bir sayfa açar.

Arka plan betiğini hata ayıklamak için **uzantı ayrıntılarına gidip hizmet işçisini inceleyebilirsiniz,** bu arka plan betiği ile geliştirici araçları açacaktır:

<figure><img src="https://github.com/carlospolop/hacktricks/blob/master/pentesting-web/browser-extension-pentesting-methodology/broken-reference" alt=""><figcaption></figcaption></figure>

### Seçenek sayfaları ve diğerleri

Tarayıcı uzantıları çeşitli türde sayfalar içerebilir:

* **Eylem sayfaları**, uzantı simgesine tıklandığında bir **açılır menüde** gösterilir.
* Uzantının yeni bir sekmede **yükleyeceği sayfalar**.
* **Seçenek Sayfaları**: Bu sayfa, tıklanıldığında uzantının üstünde görüntülenir. Önceki manifestoda bu sayfaya `chrome://extensions/?options=fadlhnelkbeojnebcbkacjilhnbjfjca` adresinden veya tıklayarak erişebildim:

<figure><img src="../../.gitbook/assets/image (21).png" alt="" width="375"><figcaption></figcaption></figure>

Bu sayfalar arka plan sayfaları gibi kalıcı değildir, gerektiğinde içeriği dinamik olarak yüklerler. Bununla birlikte, bu sayfalar arka plan sayfasıyla belirli yetenekleri paylaşırlar:

* **İçerik Betikleriyle İletişim:** Arka plan sayfasına benzer şekilde, bu sayfalar içerik betiklerinden mesaj alabilir, uzantı içinde etkileşimi kolaylaştırır.
* **Uzantıya Özgü API'lere Erişim:** Bu sayfalar, uzantıya özgü API'lere kapsamlı erişime sahiptir, uzantı için tanımlanan izinlere tabidir.

### `permissions` ve `host_permissions`

**`permissions`** ve **`host_permissions`**, tarayıcı uzantısının sahip olduğu **izinleri** (depolama, konum...) ve **hangi web sayfalarında** olduğunu belirten `manifest.json` dosyasındaki girişlerdir.

Tarayıcı uzantıları çok **aşırı yetkilendirilebileceğinden**, kötü niyetli veya tehlikeye maruz kalan bir uzantı saldırganın **duyarlı bilgileri çalmak ve kullanıcıyı izlemek için farklı yöntemlere izin verebilir**.

Bu ayarların nasıl çalıştığını ve nasıl kötüye kullanılabileceğini kontrol edin:

{% content-ref url="browext-permissions-and-host_permissions.md" %}
[browext-permissions-and-host\_permissions.md](browext-permissions-and-host\_permissions.md)
{% endcontent-ref %}

### `content_security_policy`

Bir **içerik güvenlik politikası**, `manifest.json` dosyasının içinde de belirtilebilir. Tanımlanmışsa, **savunmasız olabilir**.

Tarayıcı uzantısı sayfaları için varsayılan ayar oldukça kısıtlayıcıdır:
```bash
script-src 'self'; object-src 'self';
```
CSP ve olası bypass'lar hakkında daha fazla bilgi için şu adrese bakın:

{% content-ref url="../content-security-policy-csp-bypass/" %}
[content-security-policy-csp-bypass](../content-security-policy-csp-bypass/)
{% endcontent-ref %}

### `web_accessible_resources`

Bir web sayfasının, örneğin bir `.html` sayfasının bir Tarayıcı Uzantısının bir sayfasına erişmesi için, bu sayfanın `manifest.json` dosyasındaki **`web_accessible_resources`** alanında belirtilmesi gerekir.\
Örneğin:
```javascript
{
...
"web_accessible_resources": [
{
"resources": [ "images/*.png" ],
"matches": [ "https://example.com/*" ]
},
{
"resources": [ "fonts/*.woff" ],
"matches": [ "https://example.com/*" ]
}
],
...
}
```
Bu sayfalara şu URL'lerden erişilebilir:
```
chrome-extension://<extension-id>/message.html
```
Genel uzantılarda **uzantı kimliği erişilebilir**:

<figure><img src="../../.gitbook/assets/image (1191).png" alt="" width="375"><figcaption></figcaption></figure>

Ancak, `manifest.json` parametresi **`use_dynamic_url`** kullanılıyorsa, bu **kimlik dinamik olabilir**.

Bu sayfalara erişime izin verilmesi, bu sayfaları **potansiyel olarak savunmasız ClickJacking** yapar:

{% content-ref url="browext-clickjacking.md" %}
[browext-clickjacking.md](browext-clickjacking.md)
{% endcontent-ref %}

{% hint style="success" %}
Bu sayfaların yalnızca uzantı tarafından yüklenmesine ve rastgele URL'ler tarafından yüklenmemesine izin vermek, ClickJacking saldırılarını önleyebilir.
{% endhint %}

### `externally_connectable`

[**Belgelere**](https://developer.chrome.com/docs/extensions/reference/manifest/externally-connectable) göre, `"externally_connectable"` manifest özelliği, [runtime.connect](https://developer.chrome.com/docs/extensions/reference/runtime#method-connect) ve [runtime.sendMessage](https://developer.chrome.com/docs/extensions/reference/runtime#method-sendMessage) aracılığıyla uzantınıza **hangi uzantıların ve web sayfalarının bağlanabileceğini** belirtir.

* Eğer **`externally_connectable`** anahtarı uzantınızın manifestinde belirtilmemişse veya **`"ids": ["*"]`** olarak belirtilmişse, **tüm uzantılar bağlanabilir, ancak hiçbir web sayfası bağlanamaz**.
* Eğer **belirli kimlikler belirtilmişse**, örneğin `"ids": ["aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"]`, **yalnızca bu uygulamalar** bağlanabilir.
* Eğer **eşleşmeler** belirtilmişse, bu web uygulamaları bağlanabilir:
```json
"matches": [
"https://*.google.com/*",
"*://*.chromium.org/*",
```
* Eğer boş olarak belirtilmişse: **`"externally_connectable": {}`**, hiçbir uygulama veya web bağlanamaz.

Burada belirtilen **daha az uzantı ve URL** olduğunda, **saldırı yüzeyi daha küçük** olacaktır.

{% hint style="danger" %}
Eğer **XSS'ye duyarlı veya ele geçirilebilir** bir web sayfası **`externally_connectable`** içinde belirtilmişse, bir saldırgan **mesajları doğrudan arka plan betiğine gönderebilecek**, İçerik Betiği'ni ve CSP'sini tamamen atlayabilecektir.

Bu nedenle, bu **çok güçlü bir atlatma**dır.

Dahası, istemci yanlış bir uzantı yüklerse, hatta savunmasız uzantıyla iletişim kurmasına izin verilmiyorsa, **izin verilen bir web sayfasına XSS verisi enjekte edebilir** veya hedeflenen bir alan adındaki istekleri manipüle etmek için **`WebRequest`** veya **`DeclarativeNetRequest`** API'larını kötüye kullanabilir ve bir sayfanın isteğini bir **JavaScript dosyası** için değiştirebilir. (Hedeflenen sayfadaki CSP bu saldırıları önleyebilir). Bu fikir [**bu yazıdan gelmektedir**](https://www.darkrelay.com/post/opera-zero-day-rce-vulnerability).
{% endhint %}

##

## Web **↔︎** İçerik Betiği İletişimi

**İçerik betiklerinin** çalıştığı ortamlar ve ana sayfaların bulunduğu ortamlar birbirinden **ayrılmış** olup, **izolasyonu** sağlar. Bu izolasyona rağmen, her ikisi de sayfanın **Belge Nesne Modeli (DOM)** ile etkileşimde bulunma yeteneğine sahiptir, ortak bir kaynak. Ana sayfanın **içerik betiği** ile iletişim kurabilmesi veya içerik betiği aracılığıyla dolaylı olarak uzantı ile iletişim kurabilmesi için, her iki tarafın da erişebildiği **DOM**'u iletişim kanalı olarak kullanması gerekmektedir.

### Mesaj Gönderme

{% code title="content-script.js" %}
```javascript
var port = chrome.runtime.connect();

window.addEventListener("message", (event) => {
// We only accept messages from ourselves
if (event.source !== window) {
return;
}

if (event.data.type && (event.data.type === "FROM_PAGE")) {
console.log("Content script received: " + event.data.text);
port.postMessage(event.data.text);
}
}, false);
```
{% endcode %}

{% code title="örnek.js" %}
```javascript
document.getElementById("theButton").addEventListener("click", () => {
window.postMessage(
{type : "FROM_PAGE", text : "Hello from the webpage!"}, "*");
}, false);
```
{% endcode %}

Güvenli bir Post Message iletişimi, alınan iletiyi doğrulamalıdır, bunu şu şekilde kontrol edebiliriz:

* **`event.isTrusted`**: Bu, yalnızca olayın bir kullanıcı eylemi tarafından tetiklendiğinde True olur
* İçerik betiği, kullanıcı belirli bir eylem gerçekleştirdiğinde yalnızca bir ileti bekleyebilir
* **köken alanı**: yalnızca belirli bir alan listesinden ileti bekleyebilir.
* Eğer bir regex kullanılıyorsa, çok dikkatli olunmalıdır
* **Kaynak**: `received_message.source !== window` iletişim Betiği'nin dinlediği pencereden **geldiğini kontrol etmek için kullanılabilir**.

Önceki kontroller, gerçekleştirilmiş olsa bile, savunmasız olabilir, bu nedenle aşağıdaki sayfada **potansiyel Post Message atlamalarını** kontrol edin:

{% content-ref url="../postmessage-vulnerabilities/" %}
[postmessage-vulnerabilities](../postmessage-vulnerabilities/)
{% endcontent-ref %}

### Iframe

Başka bir iletişim yolu olası bir şekilde **Iframe URL'leri** aracılığıyla olabilir, bir örnek bulabilirsiniz:

{% content-ref url="browext-xss-example.md" %}
[browext-xss-example.md](browext-xss-example.md)
{% endcontent-ref %}

### DOM

Bu "tam olarak" bir iletişim yolu değil, ancak **web ve içerik betiği web DOM'a erişebilir**. Dolayısıyla, eğer **içerik betiği** bazı bilgileri okuyorsa, **web DOM'a güveniyorsa**, web bu verileri **değiştirebilir** (çünkü web güvenilir olmamalıdır veya web XSS'ye karşı savunmasız olabilir) ve **İçerik Betiği'ni tehlikeye atabilir**.

Ayrıca, bir **tarayıcı uzantısını tehlikeye atmak için DOM tabanlı XSS örneği** bulabilirsiniz:

{% content-ref url="browext-xss-example.md" %}
[browext-xss-example.md](browext-xss-example.md)
{% endcontent-ref %}

## Bellek/Kod İçinde Hassas Bilgiler

Bir Tarayıcı Uzantısı, **hassas bilgileri belleğinde saklarsa**, bu bilgiler **dökülebilir** (özellikle Windows makinelerinde) ve bu bilgiler için **arama yapılabilir**.

Bu nedenle, Tarayıcı Uzantısının belleği **güvenli kabul edilmemeli** ve kimlik bilgileri veya mnemonik ifadeler gibi **hassas bilgilerin saklanmaması gerekir**.

Tabii ki, **hassas bilgileri kod içine koymayın**, çünkü bu bilgiler **genel** olacaktır.

## İçerik Betiği **↔︎** Arkaplan Betiği İletişimi

Bir İçerik Betiği, [**runtime.sendMessage()**](https://developer.chrome.com/docs/extensions/reference/runtime#method-sendMessage) **veya** [**tabs.sendMessage()**](https://developer.chrome.com/docs/extensions/reference/tabs#method-sendMessage) fonksiyonlarını kullanarak **bir kereye mahsus JSON-serileştirilebilir** bir ileti gönderebilir.

**Yanıtı** işlemek için dönen **Promise**'ı kullanın. Ancak, geriye dönük uyumluluk için hala bir **geri çağrı**yı son argüman olarak iletebilirsiniz.

Bir **içerik betiğinden** istek göndermek şu şekilde görünür:
```javascript
(async () => {
const response = await chrome.runtime.sendMessage({greeting: "hello"});
// do something with response here, not outside the function
console.log(response);
})();
```
**Uzantıdan** bir istek gönderme (genellikle bir **arka plan betiği**) Bir İçerik Betiği, fonksiyonları kullanabilir, ancak hangi sekmeye gönderileceğini belirtmeniz gerekir. Seçilen sekmedeki içerik betiğine mesaj göndermek için örnek:
```javascript
// From https://stackoverflow.com/questions/36153999/how-to-send-a-message-between-chrome-extension-popup-and-content-script
(async () => {
const [tab] = await chrome.tabs.query({active: true, lastFocusedWindow: true});
const response = await chrome.tabs.sendMessage(tab.id, {greeting: "hello"});
// do something with response here, not outside the function
console.log(response);
})();
```
**Alıcı tarafında**, mesajı işlemek için bir [**runtime.onMessage**](https://developer.chrome.com/docs/extensions/reference/runtime#event-onMessage) **olay dinleyicisi** kurmanız gerekmektedir. Bu, içerik betiği veya uzantı sayfasından aynı şekilde görünmektedir.
```javascript
// From https://stackoverflow.com/questions/70406787/javascript-send-message-from-content-js-to-background-js
chrome.runtime.onMessage.addListener(
function(request, sender, sendResponse) {
console.log(sender.tab ?
"from a content script:" + sender.tab.url :
"from the extension");
if (request.greeting === "hello")
sendResponse({farewell: "goodbye"});
}
);
```
Öne çıkarılan örnekte, **`sendResponse()`** senkron bir şekilde yürütüldü. `sendResponse()`'ın asenkron yürütülmesi için `onMessage` olay işleyicisini değiştirmek için `return true;` eklemek hayati önem taşır.

Önemli bir husus, birden fazla sayfanın `onMessage` olaylarını alacağı senaryolarda, belirli bir olay için **`sendResponse()`'ı yürüten ilk sayfanın** yanıtı etkili bir şekilde iletebilecek tek sayfa olacağıdır. Aynı olaya yönelik herhangi bir sonraki yanıt dikkate alınmayacaktır.

Yeni uzantılar oluşturulurken, tercih edilen yaklaşım geri aramalar yerine söz verilere yöneliktir. Geri aramaların kullanımıyla ilgili olarak, `sendResponse()` fonksiyonu yalnızca senkron bağlam içinde doğrudan yürütüldüğünde veya olay işleyicisi asenkron bir işlemi belirtiyorsa `true` döndürdüğünde geçerli kabul edilir. Hiçbir işleyicinin `true` dönmediği veya `sendResponse()` fonksiyonunun bellekten kaldırıldığı durumlarda (çöp toplama), `sendMessage()` fonksiyonuyla ilişkilendirilen geri arama varsayılan olarak tetiklenecektir.

## Bir Uzantıyı Tarayıcıda Yükleme

1. Tarayıcı Uzantısını **indirin** ve açın
2. **`chrome://extensions/`** adresine gidin ve `Geliştirici Modu`'nu **etkinleştirin**
3. **`Paketlenmemiş yükleyin`** düğmesine tıklayın

**Firefox**'da **`about:debugging#/runtime/this-firefox`** adresine gidin ve **`Geçici Eklenti Yükle`** düğmesine tıklayın.

## Mağazadan kaynak kodunu alma

Bir Chrome uzantısının kaynak kodu çeşitli yöntemlerle elde edilebilir. Aşağıda her seçenek için detaylı açıklamalar ve talimatlar bulunmaktadır.

### Komut Satırı Aracılığıyla ZIP Olarak Uzantı İndirme

Bir Chrome uzantısının kaynak kodu, komut satırını kullanarak ZIP dosyası olarak indirilebilir. Bu, belirli bir URL'den ZIP dosyasını almak için `curl`'ün kullanılmasını ve ardından ZIP dosyasının içeriğini bir dizine çıkarmayı içerir. İşte adımlar:

1. `"extension_id"` yerine gerçek uzantı kimliğini yazın.
2. Aşağıdaki komutları çalıştırın:
```bash
extension_id=your_extension_id   # Replace with the actual extension ID
curl -L -o "$extension_id.zip" "https://clients2.google.com/service/update2/crx?response=redirect&os=mac&arch=x86-64&nacl_arch=x86-64&prod=chromecrx&prodchannel=stable&prodversion=44.0.2403.130&x=id%3D$extension_id%26uc"
unzip -d "$extension_id-source" "$extension_id.zip"
```
### CRX Viewer websitesini kullanın

[https://robwu.nl/crxviewer/](https://robwu.nl/crxviewer/)

### CRX Viewer uzantısını kullanın

Başka bir pratik yöntem, açık kaynaklı bir proje olan Chrome Extension Source Viewer'ı kullanmaktır. Bu, [Chrome Web Mağazası'ndan](https://chrome.google.com/webstore/detail/chrome-extension-source-v/jifpbeccnghkjeaalbbjmodiffmgedin?hl=en) yüklenebilir. Görüntüleyicinin kaynak kodu [GitHub deposunda](https://github.com/Rob--W/crxviewer) bulunabilir.

### Yerel olarak yüklenen uzantının kaynağını görüntüleyin

Yerel olarak yüklenen Chrome uzantıları da incelenebilir. İşte yapmanız gerekenler:

1. "Profile Path" alanını bulmak için `chrome://version/` adresine giderek Chrome yerel profil dizinine erişin.
2. Profil dizini içindeki `Extensions/` alt klasörüne gidin.
3. Bu klasör, genellikle okunabilir bir formatta kaynak kodlarıyla birlikte tüm yüklenmiş uzantıları içerir.

Uzantıları tanımlamak için ID'lerini isimlerine eşleyebilirsiniz:

* Her uzantının ID'lerini görmek için `about:extensions` sayfasında Geliştirici Modunu etkinleştirin.
* Her uzantının klasörü içinde, `manifest.json` dosyası, uzantıyı tanımanıza yardımcı olan okunabilir bir `name` alanı içerir.

### Bir Dosya Arşivleyici veya Açıcı Kullanın

Chrome Web Mağazasına gidin ve uzantıyı indirin. Dosyanın uzantısı `.crx` olacaktır. Dosya uzantısını `.crx`'den `.zip`'e değiştirin. ZIP dosyasının içeriğini çıkarmak için WinRAR, 7-Zip vb. herhangi bir dosya arşivleyicisini kullanın.

### Chrome'da Geliştirici Modunu Kullanın

Chrome'u açın ve `chrome://extensions/` adresine gidin. Sağ üstte "Geliştirici modunu" etkinleştirin. "Paketlenmemiş uzantıyı yükle..." üzerine tıklayın. Uzantının dizinine gidin. Bu, kaynak kodunu indirmese de, zaten indirilmiş veya geliştirilmiş bir uzantının kodunu görüntülemek ve değiştirmek için kullanışlıdır.

## Güvenlik Denetim Listesi

Tarayıcı Uzantıları **sınırlı bir saldırı yüzeyine** sahip olmalarına rağmen, bazıları **zayıflıklar** veya **potansiyel sıkılaştırma iyileştirmeleri** içerebilir. En yaygın olanlar şunlardır:

* [ ] Mümkün olduğunca az **`izinler`** isteyin
* [ ] Mümkün olduğunca az **`host_permissions`** isteyin
* Güçlü bir **`content_security_policy`** kullanın
* Mümkün olduğunca az **`externally_connectable`** kullanın, gerekli değilse ve mümkünse varsayılan olarak bırakmayın, **`{}`** belirtin
* Burada XSS'ye veya ele geçirmeye açık olan bir URL belirtilmişse, bir saldırganın **mesajları doğrudan arka plan betiklerine göndermesine** izin verilecektir. Çok güçlü bir atlatma.
* Mümkün olduğunca az **`web_accessible_resources`** kullanın, mümkünse hatta boş bırakın.
* Eğer **`web_accessible_resources`** yoksa, [**ClickJacking**](browext-clickjacking.md) için kontrol edin
* Eğer **uzantıdan web sayfasına iletişim** varsa, iletişimde oluşan **XSS zafiyetlerini** kontrol edin.
* Post Mesajları kullanılıyorsa, [**Post Mesaj zafiyetlerini**](../postmessage-vulnerabilities/) kontrol edin.
* **İçerik Betiği DOM detaylarına erişiyorsa**, bunların web tarafından **değiştirilmesi durumunda XSS** oluşturup oluşturmadığını kontrol edin
* Bu iletişimin aynı zamanda **İçerik Betiği -> Arka plan betiği ile iletişiminde** yer alıyorsa özel bir vurgu yapın
* **Hassas bilgilerin** Tarayıcı Uzantısı **kodunun içinde saklanmaması** gerekir
* **Hassas bilgilerin** Tarayıcı Uzantısı **belleğinde saklanmaması** gerekir

## Araçlar

### [**Tarnish**](https://thehackerblog.com/tarnish/)

* Sağlanan bir Chrome web mağazası bağlantısından herhangi bir Chrome uzantısını çeker.
* [**manifest.json**](https://developer.chrome.com/extensions/manifest) **görüntüleyici**: uzantının manifest dosyasının JSON düzgünleştirilmiş bir sürümünü basitçe gösterir.
* **Parmak İzi Analizi**: [web\_accessible\_resources](https://developer.chrome.com/extensions/manifest/web\_accessible\_resources) tespiti ve Chrome uzantısı parmak izi oluşturma JavaScript'inin otomatik oluşturulması.
* **Potansiyel Clickjacking Analizi**: [web\_accessible\_resources](https://developer.chrome.com/extensions/manifest/web\_accessible\_resources) yönergesi ayarlanmış uzantı HTML sayfalarının tespiti. Bu sayfalar, sayfaların amacına bağlı olarak clickjacking'e karşı potansiyel olarak savunmasız olabilir.
* **İzin Uyarıları Görüntüleyici**: bir kullanıcının uzantıyı yüklemeye çalıştığında görüntülenecek tüm Chrome izin uyarılarının bir listesini gösterir.
* **Tehlikeli Fonksiyonlar**: bir saldırgan tarafından kötüye kullanılabilecek tehlikeli fonksiyonların konumunu gösterir (örneğin, innerHTML, chrome.tabs.executeScript gibi fonksiyonlar).
* **Giriş Noktaları**: uzantının kullanıcı/dış giriş aldığı yerleri gösterir. Bu, bir uzantının yüzey alanını anlamanızı ve uzantıya kötü niyetli şekilde oluşturulmuş verileri gönderebileceğiniz potansiyel noktaları aramanızı sağlar.
* Tehlikeli Fonksiyonlar ve Giriş Noktaları tarayıcıları için oluşturulan uyarılar şunları içerir:
* Uyarıya sebep olan ilgili kod parçası ve satır.
* Sorunun açıklaması.
* Kodu içeren tam kaynak dosyasını görüntülemek için "Dosyayı Görüntüle" düğmesi.
* Uyarı verilen dosyanın yolu.
* Uyarı verilen dosyanın tam Chrome uzantısı URI'si.
* JavaScript dosyasında zayıf satır varsa, bu satırın dahil olduğu tüm sayfaların yolları ve bu sayfaların türleri ve [web\_accessible\_resource](https://developer.chrome.com/extensions/manifest/web\_accessible\_resources) durumları.
* **İçerik Güvenlik Politikası (CSP) analizcisi ve atlatma kontrolcüsü**: Uzantınızın CSP'sindeki zayıflıkları belirleyecek ve CSP'nizi atlatmanın mümkün yollarını aydınlatacaktır (whitelisted CDNs vb. nedeniyle).
* **Bilinen Zayıf Kütüphaneler**: [Retire.js](https://retirejs.github.io/retire.js/) kullanarak bilinen zayıf JavaScript kütüphanelerinin kullanımını kontrol eder.
* Uzantıyı indirme ve biçimlendirilmiş sürümleri indirme.
* Orijinal uzantıyı indirme.
* Uzantının güzelleştirilmiş sürümünü indirme (otomatik olarak düzeltilmiş HTML ve JavaScript).
* Tarama sonuçlarının otomatik önbelleğe alınması, bir uzantı taraması yapmak ilk seferinde biraz zaman alabilir. Ancak, uzantı güncellenmediyse, ikinci sefer, sonuçların önbelleğe alınması nedeniyle neredeyse anlık olacaktır.
* Bağlantılabilir Rapor URL'leri, Tarnish tarafından oluşturulan bir uzantı raporunu başka birine kolayca bağlantı yapabilirsiniz.

### [Neto](https://github.com/elevenpaths/neto)

Proje Neto, Firefox ve Chrome gibi popüler tarayıcılar için tarayıcı eklentilerinin ve uzantılarının gizli özelliklerini analiz etmek ve açığa çıkarmak için tasarlanmış Python 3 paketidir. Bu paket, paketlenmiş dosyaları açmak için süreci otomatikleştirir ve bu özellikleri uzantıdaki ilgili kaynaklardan (örneğin `manifest.json`, yerelleştirme klasörleri veya JavaScript ve HTML kaynak dosyaları) çıkartır.

## Referanslar

* Bu metodolojiye yardımı için [**@naivenom**](https://twitter.com/naivenom)'a teşekkürler
* [https://www.cobalt.io/blog/introduction-to-chrome-browser-extension-security-testing](https://www.cobalt.io/blog/introduction-to-chrome-browser-extension-security-testing)
* [https://palant.info/2022/08/10/anatomy-of-a-basic-extension/](https://palant.info/2022/08/10/anatomy-of-a-basic-extension/)
* [https://palant.info/2022/08/24/attack-surface-of-extension-pages/](https://palant.info/2022/08/24/attack-surface-of-extension-pages/)
* [https://palant.info/2022/08/31/when-extension-pages-are-web-accessible/](https://palant.info/2022/08/31/when-extension-pages-are-web-accessible/)
* [https://help.passbolt.com/assets/files/PBL-02-report.pdf](https://help.passbolt.com/assets/files/PBL-02-report.pdf)
* [https://developer.chrome.com/docs/extensions/develop/concepts/content-scripts](https://developer.chrome.com/docs/extensions/develop/concepts/content-scripts)
* [https://developer.chrome.com/docs/extensions/mv2/background-pages](https://developer.chrome.com/docs/extensions/mv2/background-pages)
* [https://thehackerblog.com/kicking-the-rims-a-guide-for-securely-writing-and-auditing-chrome-extensions/](https://thehackerblog.com/kicking-the-rims-a-guide-for-securely-writing-and-auditing-chrome-extensions/)
* [https://gist.github.com/LongJohnCoder/9ddf5735df3a4f2e9559665fb864eac0](https://gist.github.com/LongJohnCoder/9ddf5735df3a4f2e9559665fb864eac0)

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong> ile sıfırdan kahramana AWS hacklemeyi öğrenin</summary>

HackTricks'i desteklemenin diğer yolları:
* Eğer **şirketinizin HackTricks'te reklamını görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**PEASS Ailesi'ni**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* **Katılın** 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) veya bizi **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.** takip edin
* **Hacking püf noktalarınızı paylaşın, PR'lar göndererek** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına.
