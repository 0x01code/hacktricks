# ブラウザ拡張機能のペネトレーションテスト方法論

<details>

<summary><strong>AWSハッキングをゼロからヒーローまで学ぶ</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>！</strong></summary>

HackTricksをサポートする他の方法:

* **HackTricksにあなたの会社を広告したい**、または**HackTricksをPDFでダウンロードしたい**場合は、[**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS & HackTricksグッズ**](https://peass.creator-spring.com)を入手する
* [**PEASSファミリー**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクションをチェックする
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)に**参加する**か、[**テレグラムグループ**](https://t.me/peass)に参加する、または**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)を**フォローする**。
* [**HackTricks**](https://github.com/carlospolop/hacktricks)と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のgithubリポジトリにPRを提出して、あなたのハッキングのコツを共有する。

</details>

## 基本情報

ブラウザ拡張機能はJavaScriptで書かれ、ブラウザによってバックグラウンドで読み込まれます。それは独自の[DOM](https://www.w3schools.com/js/js_htmldom.asp)を持っていますが、他のサイトのDOMと相互作用することができます。これは、他のサイトの機密性、完全性、および可用性（CIA）を損なう可能性があります。

## 主要コンポーネント

拡張機能のレイアウトは視覚化されたときに最もよく見え、3つのコンポーネントで構成されています。それぞれのコンポーネントを詳しく見ていきましょう。

<figure><img src="../../.gitbook/assets/image.png" alt=""><figcaption><p><a href="http://webblaze.cs.berkeley.edu/papers/Extensions.pdf">http://webblaze.cs.berkeley.edu/papers/Extensions.pdf</a></p></figcaption></figure>

### **コンテンツスクリプト**

各コンテンツスクリプトは、**単一のウェブページ**のDOMに直接アクセスでき、**潜在的に悪意のある入力**にさらされます。ただし、コンテンツスクリプトには、拡張機能のコアにメッセージを送信する機能以外の権限は含まれていません。

Chromeでコンテンツスクリプトを表示およびデバッグするには、オプション > その他のツール > 開発者ツールからChrome開発者ツールメニューを開くか（Ctrl + Shift + Iを押す）。

開発者ツールが表示されたら、**ソースタブ**をクリックし、次に**コンテンツスクリプト**タブをクリックします。ここでは、さまざまな拡張機能の実行中のコンテンツスクリプトを見ることができ、実行の流れを監視するためにブレークポイントを設定できます。私たちの場合は、Wappalyzerブラウザ拡張機能を通じて示しています。

<figure><img src="../../.gitbook/assets/image (1).png" alt=""><figcaption></figcaption></figure>

### **拡張機能コア**

拡張機能コアには、ほとんどの拡張機能の権限/アクセスが含まれていますが、拡張機能コアは[XMLHttpRequest](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest)とコンテンツスクリプトを介してのみウェブコンテンツと対話できます。また、拡張機能コアはホストマシンに直接アクセスすることはできません。

### **ネイティブバイナリ**

拡張機能は、ユーザーの完全な権限でホストマシンにアクセスできるネイティブバイナリを許可します。ネイティブバイナリは、Flashや他のブラウザプラグインに使用される標準のNetscape Plugin Application Programming Interface（[NPAPI](https://en.wikipedia.org/wiki/NPAPI)）を介して拡張機能コアと対話します。

### 境界

{% hint style="danger" %}
ユーザーの完全な権限を取得するためには、攻撃者は拡張機能に悪意のある入力をコンテンツスクリプトから拡張機能のコアに、そして拡張機能のコアからネイティブバイナリに渡すように説得する必要があります。
{% endhint %}

拡張機能の各コンポーネントは、**強力な保護境界**によって互いに分離されています。各コンポーネントは、**別々のオペレーティングシステムプロセス**で実行されます。コンテンツスクリプトと拡張機能コアは、ほとんどのオペレーティングシステムサービスにアクセスできない**サンドボックスプロセス**で実行されます。

さらに、コンテンツスクリプトは、**別のJavaScriptヒープで実行されることによって**、関連するウェブページから分離されます。コンテンツスクリプトとウェブページは、同じ基盤となるDOMに**アクセスできますが**、二つは**JavaScriptポインターを交換することはなく**、JavaScript機能のリークを防ぎます。

## **`manifest.json`**

Chrome拡張機能は、単なるZIPフォルダであり、[.crxファイル拡張子](https://www.lifewire.com/crx-file-2620391)を持っています。拡張機能のコアは、フォルダのルートにある**`manifest.json`**ファイルで、レイアウト、権限、その他の設定オプションを指定しています。

例：
```json
{
"manifest_version": 2,
"name": "My extension",
"version": "1.0",
"permissions": [
"storage"
],
"content_scripts": [
{
"js": [
"script.js"
],
"matches": [
"https://example.com/*",
"https://www.example.com/*"
],
"exclude_matches": ["*://*/*business*"],
}
],
"background": {
"scripts": [
"background.js"
]
},
"options_ui": {
"page": "options.html"
}
}
```
### `content_scripts`

コンテンツスクリプトは、ユーザーが**対応するページに移動する**と**ロードされます**。この場合、**`https://example.com/*`** の表現に一致し、**`*://*/*/business*`** の正規表現には一致しない任意のページです。これらは**ページ自身のスクリプトのように実行され**、ページの[Document Object Model (DOM)](https://developer.mozilla.org/en-US/docs/Web/API/Document\_Object\_Model)に任意にアクセスできます。
```json
"content_scripts": [
{
"js": [
"script.js"
],
"matches": [
"https://example.com/*",
"https://www.example.com/*"
],
"exclude_matches": ["*://*/*business*"],
}
],
```
以下のURLを含めたり除外したりするためには、**`include_globs`** と **`exclude_globs`** を使用することも可能です。

これは、[ストレージAPI](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/storage) を使用して拡張機能のストレージから `message` 値を取得する際に、ページに説明ボタンを追加するコンテンツスクリプトの例です。
```js
chrome.storage.local.get("message", result =>
{
let div = document.createElement("div");
div.innerHTML = result.message + " <button>Explain</button>";
div.querySelector("button").addEventListener("click", () =>
{
chrome.runtime.sendMessage("explain");
});
document.body.appendChild(div);
});
```
<figure><img src="../../.gitbook/assets/image (7).png" alt=""><figcaption></figcaption></figure>

このボタンをクリックすると、コンテンツスクリプトは[**runtime.sendMessage() API**](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/runtime/sendMessage)を**使用して拡張機能のページにメッセージを送信します**。これは、コンテンツスクリプトが`storage`などの限られたAPIにのみ直接アクセスできるためです。それ以外のことは、コンテンツスクリプトがメッセージを送信できる拡張機能のページで行う必要があります。

{% hint style="warning" %}
**コンテンツスクリプトの機能**はブラウザによって若干異なります。Chromiumベースのブラウザのリストは[Chrome Developers documentation](https://developer.chrome.com/docs/extensions/mv3/content\_scripts/#capabilities)で、Firefoxは[MDN](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/Content\_scripts#webextension\_apis)が最も信頼できる情報源です。\
コンテンツスクリプトが**バックグラウンドスクリプトと通信**もできることを覚えておいてください。そうすることで、バックグラウンドスクリプトがアクションを実行し、レスポンスを送り返すことができます。
{% endhint %}

### インジェクトされたコンテンツスクリプト

{% hint style="success" %}
**コンテンツスクリプトは必須ではありません**。**`tabs.executeScript`**を介してウェブページにスクリプトを**動的に**、**プログラム的にインジェクト**することも可能です。これにより、より**細かい制御**が可能になります。
{% endhint %}

コンテンツスクリプトをプログラム的にインジェクトするには、拡張機能がスクリプトをインジェクトしようとしているページの[ホスト権限](https://developer.chrome.com/docs/extensions/reference/permissions)が必要です。ホスト権限は、拡張機能のマニフェストの一部として**要求する**ことによって、または[**activeTab**](https://developer.chrome.com/docs/extensions/reference/manifest/activeTab)**を介して一時的に**付与することができます。

#### activeTabベースの拡張機能の例

{% code title="manifest.json" %}
```json
{
"name": "My extension",
...
"permissions": [
"activeTab",
"scripting"
],
"background": {
"service_worker": "background.js"
},
"action": {
"default_title": "Action Button"
}
}
```
{% endcode %}

* **クリック時にJSファイルを注入する:**
```javascript
// content-script.js
document.body.style.backgroundColor = "orange";

//service-worker.js - Inject the JS file
chrome.action.onClicked.addListener((tab) => {
chrome.scripting.executeScript({
target: { tabId: tab.id },
files: ["content-script.js"]
});
});
```
* **クリック時に関数をインジェクトする**:
```javascript
//service-worker.js - Inject a function
function injectedFunction() {
document.body.style.backgroundColor = "orange";
}

chrome.action.onClicked.addListener((tab) => {
chrome.scripting.executeScript({
target : {tabId : tab.id},
func : injectedFunction,
});
});
```
#### スクリプティング権限を使用した例
```javascript
// service-workser.js
chrome.scripting.registerContentScripts([{
id : "test",
matches : [ "https://*.nytimes.com/*" ],
excludeMatches : [ "*://*/*business*" ],
js : [ "contentScript.js" ],
}]);

// ANother example
chrome.tabs.executeScript(tabId, { file: "content_script.js" });
```
URLを含めたり除外したりするためには、**`include_globs`** と **`exclude_globs`** も使用可能です。

### コンテンツスクリプトの `run_at`

`run_at` フィールドは **JavaScriptファイルがウェブページに注入されるタイミング** を制御します。推奨されるデフォルト値は `"document_idle"` です。

可能な値は以下の通りです:

* **`document_idle`**: 可能な限り
* **`document_start`**: `css` からのファイルの後、他のDOMが構築される前や他のスクリプトが実行される前。
* **`document_end`**: DOMが完了した直後、しかし画像やフレームなどのサブリソースがロードされる前。

#### `manifest.json` を通じて
```json
{
"name": "My extension",
...
"content_scripts": [
{
"matches": ["https://*.nytimes.com/*"],
"run_at": "document_idle",
"js": ["contentScript.js"]
}
],
...
}

```
Via **`service-worker.js`**
```javascript
chrome.scripting.registerContentScripts([{
id : "test",
matches : [ "https://*.nytimes.com/*" ],
runAt : "document_idle",
js : [ "contentScript.js" ],
}]);
```
### `バックグラウンド`

コンテンツスクリプトがメッセージを送信するとき、その宛先は**バックグラウンドページ**です。バックグラウンドページは、拡張機能のマニフェストで指定されていない限り、**常に存在する**特別なページです。ユーザーには見えませんが、独自のDOMを持つ通常のページです。通常、拡張機能の他のすべての部分を調整する機能を果たします。

{% hint style="success" %}
バックグラウンドページが明示的に宣言されていない場合、ブラウザーは親切にも自動的に**生成し**、前のmanifest.jsonの例のように、**宣言されたバックグラウンドスクリプトがすべてロードされる**ようにします。
{% endhint %}

バックグラウンドスクリプトの例：
```js
chrome.runtime.onMessage.addListener((request, sender, sendResponse) =>
{
if (request == "explain")
{
chrome.tabs.create({ url: "https://example.net/explanation" });
}
})
```
以下は、メッセージをリッスンするために[runtime.onMessage API](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/runtime/onMessage)を使用します。`"explain"`メッセージを受信すると、[tabs API](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/tabs)を使用して新しいタブでページを開きます。

### オプションページなど

ブラウザ拡張機能にはさまざまな種類のページが含まれています：

* **アクションページ**は、拡張機能のアイコンがクリックされたときにドロップダウンで表示されます。
* 拡張機能が**新しいタブでロードするページ**。
* **オプションページ**：このページは、クリックしたときに拡張機能の上に表示されます。以前のマニフェストでは、`chrome://extensions/?options=fadlhnelkbeojnebcbkacjilhnbjfjca`でこのページにアクセスできたり、以下をクリックしてアクセスできました：

<figure><img src="../../.gitbook/assets/image (8).png" alt="" width="375"><figcaption></figcaption></figure>

バックグラウンドページとは異なり、これらのページは永続的ではなく、必要に応じてロードされます。しかし、すべてのページは**コンテンツスクリプトからメッセージを受信できます**。そして、拡張機能の許可が許す限り、**拡張機能固有のAPIに完全にアクセスできます**。

ブラウザ拡張機能に関連するコンテキストは、全体として次のようになります：

<figure><img src="../../.gitbook/assets/image (9).png" alt="" width="563"><figcaption></figcaption></figure>

### `permissions` & `host_permissions`

**`permissions`** と **`host_permissions`** は、`manifest.json`からのエントリで、ブラウザ拡張機能がどの**権限**を持っているか（ストレージ、位置情報など）、**どのウェブページ**で機能するかを示します。

ブラウザ拡張機能は非常に**特権的**であるため、悪意のあるものや侵害されたものは、攻撃者が**機密情報を盗んだり、ユーザーを監視したりするさまざまな手段**を可能にすることがあります。

これらの設定がどのように機能し、どのように悪用される可能性があるかを確認してください：

{% content-ref url="browext-permissions-and-host_permissions.md" %}
[browext-permissions-and-host\_permissions.md](browext-permissions-and-host\_permissions.md)
{% endcontent-ref %}

### `content_security_policy`

**コンテンツセキュリティポリシー**も`manifest.json`内で宣言することができます。定義されている場合、それは**脆弱性**を持つ可能性があります。

ブラウザ拡張機能ページのデフォルト設定はかなり制限的です：
```bash
script-src 'self'; object-src 'self';
```
CSPと潜在的なバイパスについての詳細は、以下を確認してください：

{% content-ref url="../content-security-policy-csp-bypass/" %}
[content-security-policy-csp-bypass](../content-security-policy-csp-bypass/)
{% endcontent-ref %}

### `web_accessible_resources`

ウェブページがブラウザ拡張機能のページにアクセスするためには、例えば`.html`ページであれば、このページは`manifest.json`の**`web_accessible_resources`**フィールドに記載されている必要があります。\
例えば：
```javascript
{
...
"web_accessible_resources": [
{
"resources": [ "images/*.png" ],
"matches": [ "https://example.com/*" ]
},
{
"resources": [ "fonts/*.woff" ],
"matches": [ "https://example.com/*" ]
}
],
...
}
```
これらのページは次のようなURLでアクセス可能です:
```
chrome-extension://<extension-id>/message.html
```
公開されている拡張機能では、**extension-id はアクセス可能です**：

<figure><img src="../../.gitbook/assets/image (722).png" alt="" width="375"><figcaption></figcaption></figure>

ただし、`manifest.json` パラメーターの **`use_dynamic_url`** を使用すると、この **id は動的になる可能性があります**。

これらのページにアクセスできることは、これらのページを **潜在的に脆弱なClickJackingにさらす可能性があります**：

{% content-ref url="browext-clickjacking.md" %}
[browext-clickjacking.md](browext-clickjacking.md)
{% endcontent-ref %}

{% hint style="success" %}
これらのページを拡張機能によってのみ読み込まれ、ランダムなURLによっては読み込まれないようにすることで、ClickJacking攻撃を防ぐことができるかもしれません。
{% endhint %}

### `externally_connectable`

[**ドキュメント**](https://developer.chrome.com/docs/extensions/reference/manifest/externally-connectable)によると、`"externally_connectable"` マニフェストプロパティは、どの拡張機能やウェブページが [runtime.connect](https://developer.chrome.com/docs/extensions/reference/runtime#method-connect) および [runtime.sendMessage](https://developer.chrome.com/docs/extensions/reference/runtime#method-sendMessage) を介して拡張機能に接続できるかを宣言します。

* もし **`externally_connectable`** キーが拡張機能のマニフェストに宣言されて**いない**場合、または **`"ids": ["*"]`** として宣言されている場合、**すべての拡張機能が接続できますが、ウェブページは接続できません**。
* **特定のIDが指定されている**場合、例えば `"ids": ["aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"]` のように、**それらのアプリケーションのみ**が接続できます。
* **matches** が指定されている場合、それらのウェブアプリが接続できるようになります：
```json
"matches": [
"https://*.google.com/*",
"*://*.chromium.org/*",
```
* 空と指定されている場合：**`"externally_connectable": {}`**、どのアプリやウェブも接続できません。

ここに示された**拡張機能とURLが少ないほど**、**攻撃面が小さくなります**。

{% hint style="danger" %}
**`externally_connectable`**に**XSSや乗っ取りに弱いウェブページ**が指定されている場合、攻撃者はContent ScriptとそのCSPを完全に迂回して、**バックグラウンドスクリプトに直接メッセージを送信**することができます。

したがって、これは**非常に強力なバイパス**です。
{% endhint %}

## Web **↔︎** Content Script コミュニケーション

**コンテンツスクリプトとそれをホストするページ**の実行環境は互いに**隔離**されていますが、ページのDOMへのアクセスは**共有**しています。ページがコンテンツスクリプト、またはコンテンツスクリプトを介して拡張機能と通信したい場合、**共有DOM**を通じて行う必要があります。

### ポストメッセージ

{% code title="content-script.js" %}
```javascript
var port = chrome.runtime.connect();

window.addEventListener("message", (event) => {
// We only accept messages from ourselves
if (event.source !== window) {
return;
}

if (event.data.type && (event.data.type === "FROM_PAGE")) {
console.log("Content script received: " + event.data.text);
port.postMessage(event.data.text);
}
}, false);
```
```
{% endcode %}

{% code title="example.js" %}
```
```javascript
document.getElementById("theButton").addEventListener("click", () => {
window.postMessage(
{type : "FROM_PAGE", text : "Hello from the webpage!"}, "*");
}, false);
```
{% endcode %}

安全なPost Message通信では、受信したメッセージの真正性を確認する必要があります。これは以下のチェックを行うことで実現できます：

* **`event.isTrusted`**: これはユーザーのアクションによってトリガーされた場合にのみTrueです
* コンテンツスクリプトは、ユーザーが何らかのアクションを実行した場合にのみメッセージを期待しているかもしれません
* **オリジンドメイン**: 許可されたドメインのリストと照合することができます。
* 正規表現を使用する場合は非常に注意してください
* **ソース**: `received_message.source !== window` はメッセージが**同じウィンドウから**送られたかどうかをチェックするために使用できます。

上記のチェックを行っても、脆弱性がある可能性があるので、以下のページで**潜在的なPost Messageバイパス**を確認してください：

{% content-ref url="../postmessage-vulnerabilities/" %}
[postmessage-vulnerabilities](../postmessage-vulnerabilities/)
{% endcontent-ref %}

### Iframe

通信の別の可能性としては、**IframeのURL**を介して行われることがあります。例は以下で見つけることができます：

{% content-ref url="browext-xss-example.md" %}
[browext-xss-example.md](browext-xss-example.md)
{% endcontent-ref %}

### DOM

これは「正確には」通信方法ではありませんが、**ウェブとコンテンツスクリプトはウェブDOMにアクセスできます**。したがって、**コンテンツスクリプト**がそれから情報を読み取っていて、**ウェブDOMを信頼している**場合、ウェブはその**データを変更**できます（ウェブが信頼されていないか、ウェブがXSSに脆弱であるため）し、**コンテンツスクリプトを危険にさらす**可能性があります。

**DOMベースのXSSがブラウザ拡張機能を危険にさらす**例も以下で見つけることができます：

{% content-ref url="browext-xss-example.md" %}
[browext-xss-example.md](browext-xss-example.md)
{% endcontent-ref %}

## メモリ/コード内の機密情報

ブラウザ拡張機能が**メモリ内に機密情報を保存している**場合、これは**ダンプ**され（特にWindowsマシンで）、この情報を**検索**される可能性があります。

したがって、ブラウザ拡張機能のメモリは**安全とは見なされず**、資格情報やニーモニックフレーズなどの**機密情報は保存されるべきではありません**。

もちろん、**コード内に機密情報を置かないでください**。それは**公開される**からです。

## コンテンツスクリプト **↔︎** バックグラウンドスクリプト通信

コンテンツスクリプトは、**一度限りのJSONシリアライズ可能な**メッセージを送信するために[**runtime.sendMessage()**](https://developer.chrome.com/docs/extensions/reference/runtime#method-sendMessage) **または** [**tabs.sendMessage()**](https://developer.chrome.com/docs/extensions/reference/tabs#method-sendMessage)関数を使用できます。

**レスポンス**を処理するには、返された**Promise**を使用します。ただし、後方互換性のために、最後の引数として**コールバック**を渡すこともできます。

**コンテンツスクリプト**からリクエストを送信するには、次のようになります：
```javascript
(async () => {
const response = await chrome.runtime.sendMessage({greeting: "hello"});
// do something with response here, not outside the function
console.log(response);
})();
```
**エクステンション**（通常は**バックグラウンドスクリプト**）からコンテンツスクリプトへのリクエストの送信は似ていますが、どのタブに送るかを指定する必要があります。この例は、選択されたタブのコンテンツスクリプトにメッセージを送信する方法を示しています。
```javascript
(async () => {
const [tab] = await chrome.tabs.query({active: true, lastFocusedWindow: true});
const response = await chrome.tabs.sendMessage(tab.id, {greeting: "hello"});
// do something with response here, not outside the function
console.log(response);
})();
```
**受信側**では、メッセージを処理するために[**runtime.onMessage**](https://developer.chrome.com/docs/extensions/reference/runtime#event-onMessage) **イベントリスナー**を設定する必要があります。これはコンテンツスクリプトまたは拡張機能ページから見ても同じように見えます。
```javascript
chrome.runtime.onMessage.addListener(
function(request, sender, sendResponse) {
console.log(sender.tab ?
"from a content script:" + sender.tab.url :
"from the extension");
if (request.greeting === "hello")
sendResponse({farewell: "goodbye"});
}
);
```
上記の例では、**`sendResponse()`** は同期的に呼び出されました。`sendResponse()` を **非同期的に** 使用したい場合は、`onMessage` イベントハンドラに `return true;` を追加します。

> 複数のページが `onMessage` イベントを待ち受けている場合、特定のイベントに対して **最初に `sendResponse()` を呼び出したものだけが** 応答を送信することに成功します。そのイベントに対する他のすべての応答は無視されます。

新しい拡張機能では、コールバックよりもプロミスを優先するべきです。コールバックを使用する場合、`sendResponse()` コールバックは同期的に使用されるか、またはイベントハンドラが非同期的に応答することを示すために `true` を返す場合にのみ有効です。`sendMessage()` 関数のコールバックは、ハンドラが true を返さない場合や `sendResponse()` コールバックがガベージコレクションされた場合に自動的に呼び出されます。

## ブラウザでの拡張機能の読み込み

1. ブラウザ拡張機能を **ダウンロード** して解凍
2. **`chrome://extensions/`** に移動し、`Developer Mode` を **有効化**
3. **`Load unpacked`** ボタンをクリック

**Firefox** では **`about:debugging#/runtime/this-firefox`** に移動し、**`Load Temporary Add-on`** ボタンをクリックします。

## ストアからのソースコードの取得

[**こちら**](https://gist.github.com/paulirish/78d6c1406c901be02c2d)から：

### オプション 1: コマンドラインで拡張機能をzipとしてダウンロードし、解凍

{% code overflow="wrap" %}
```bash
extension_id=jifpbeccnghkjeaalbbjmodiffmgedin   # change this ID
curl -L -o "$extension_id.zip" "https://clients2.google.com/service/update2/crx?response=redirect&os=mac&arch=x86-64&nacl_arch=x86-64&prod=chromecrx&prodchannel=stable&prodversion=44.0.2403.130&x=id%3D$extension_id%26uc"
unzip -d "$extension_id-source" "$extension_id.zip"
```
```
{% endcode %}

crxviewerに[magic download URL](https://github.com/Rob--W/crxviewer/blob/6113c25e3569e1ec59365ad9a177aa97e2bcda61/src/cws_pattern.js#L27-L74)の提供に感謝します。

### オプション 2: CRX Viewerウェブサイトを使用する

[https://robwu.nl/crxviewer/](https://robwu.nl/crxviewer/)

### オプション 3: CRX Viewer拡張機能を使用する

[Chrome extension source viewer](https://chrome.google.com/webstore/detail/chrome-extension-source-v/jifpbeccnghkjeaalbbjmodiffmgedin?hl=en)はオープンソースです（[githubリポジトリ](https://github.com/Rob--W/crxviewer)）と非常に簡単にこれを行います。

### オプション 3: ローカルにインストールされた拡張機能のソースを表示する

1. Chromeのローカルプロファイルディレクトリを見つけます。`chrome://version/`を開き、「Profile Path:`フィールドを探します。そのフォルダを開きます。
2. `Extensions/`サブフォルダを開きます。
3. すべての拡張機能がここにあり、通常はソースが読めます。

#### ローカルにインストールされた拡張機能IDと名前のマッピング

* `about:extensions`で開発者モードをオンにすると、各エントリの下にIDが表示されます。
* `Extensions/`フォルダ内では、manifest.jsonに読みやすい`name`フィールドがあります。

## セキュリティ監査チェックリスト

ブラウザ拡張機能は**攻撃面が限定されています**が、中には**脆弱性**や**潜在的な強化改善**を含むものもあります。以下は最も一般的なものです：

* [ ] 要求される**`permissions`**をできるだけ**制限**する
* [ ] **`host_permissions`**をできるだけ**制限**する
* [ ] **強力な** **`content_security_policy`**を使用する
* [ ] **`externally_connectable`**をできるだけ**制限**する。必要ない場合はデフォルトのままにせず、**`{}`**を指定する
* [ ] **XSSや乗っ取りに脆弱なURL**がここに記載されている場合、攻撃者は**バックグラウンドスクリプトに直接メッセージを送る**ことができます。非常に強力なバイパス。
* [ ] **`web_accessible_resources`**をできるだけ**制限**する。可能であれば空にする。
* [ ] **`web_accessible_resources`**がnoneでない場合は、[**ClickJacking**](browext-clickjacking.md)のチェックを行う
* [ ] 拡張機能から**ウェブページ**への**通信**が発生する場合は、通信によって引き起こされる[**XSS**](browext-xss-example.md)の**脆弱性**を**チェック**する。
* [ ] Post Messagesが使用されている場合は、[**Post Messageの脆弱性**](../postmessage-vulnerabilities/)をチェックする。
* [ ] **Content ScriptがDOMの詳細にアクセス**する場合、ウェブによって**変更**された場合にXSSを**導入していない**ことを確認する
* [ ] この通信が**Content Script -> Background script通信**にも関与している場合は特に注意する
* [ ] **機密情報はブラウザ拡張機能の**コード内に**保存されるべきではない**
* [ ] **機密情報はブラウザ拡張機能の**メモリ内に**保存されるべきではない**

## ツール

### [**Tarnish**](https://thehackerblog.com/tarnish/)

* 提供されたChromeウェブストアリンクから任意のChrome拡張機能を取得します。
* [**manifest.json**](https://developer.chrome.com/extensions/manifest) **ビューア**: 拡張機能のマニフェストのJSON整形バージョンを単純に表示します。
* **フィンガープリント分析**: [web_accessible_resources](https://developer.chrome.com/extensions/manifest/web_accessible_resources)の検出とChrome拡張機能のフィンガープリントJavaScriptの自動生成。
* **潜在的なClickjacking分析**: [web_accessible_resources](https://developer.chrome.com/extensions/manifest/web_accessible_resources)ディレクティブが設定された拡張機能のHTMLページの検出。これらはページの目的に応じてclickjackingに脆弱な可能性があります。
* **Permission Warning(s)ビューア**: ユーザーが拡張機能をインストールしようとした際に表示されるChromeの許可プロンプト警告のリストを表示します。
* **危険な関数**: 攻撃者によって潜在的に悪用される可能性のある危険な関数の場所を示します（例えば、innerHTML、chrome.tabs.executeScriptなどの関数）。
* **エントリポイント**: 拡張機能がユーザー/外部からの入力を受け取る場所を示します。これは、拡張機能の表面領域を理解し、拡張機能に悪意のあるデータを送信する潜在的なポイントを探すのに役立ちます。
* 危険な関数とエントリポイントのスキャナーは、生成されたアラートについて以下を持っています：
* アラートを引き起こした関連するコードスニペットと行。
* 問題の説明。
* コードが含まれる完全なソースファイルを表示する「View File」ボタン。
* アラートされたファイルのパス。
* アラートされたファイルの完全なChrome拡張機能URI。
* ファイルの種類、例えばBackground Pageスクリプト、Content Script、Browser Actionなど。
* 脆弱な行がJavaScriptファイルにある場合、それが含まれているすべてのページのパスとこれらのページのタイプ、および[web_accessible_resource](https://developer.chrome.com/extensions/manifest/web_accessible_resources)のステータス。
* **Content Security Policy (CSP)アナライザーとバイパスチェッカー**: これは、拡張機能のCSPの弱点を指摘し、ホワイトリストに登録されたCDNなどによるCSPの潜在的なバイパス方法を照らし出します。
* **既知の脆弱なライブラリ**: これは[Retire.js](https://retirejs.github.io/retire.js/)を使用して、既知の脆弱なJavaScriptライブラリの使用をチェックします。
* 拡張機能と整形されたバージョンをダウンロードします。
* オリジナルの拡張機能をダウンロードします。
* 拡張機能の美化バージョンをダウンロードします（自動整形されたHTMLとJavaScript）。
* スキャン結果の自動キャッシュ、拡張機能のスキャンを初めて実行するとかなりの時間がかかります。しかし、拡張機能が更新されていないと仮定すると、結果がキャッシュされているため、2回目はほぼ瞬時になります。
* リンク可能なレポートURL、tarnishによって生成された拡張機能レポートへ他の人を簡単にリンクできます。

### [Neto](https://github.com/elevenpaths/neto)

Netoプロジェクトは、FirefoxやChromeなどのよく知られたブラウザのブラウザプラグインや拡張機能の隠された機能を分析し、解明するために考案されたPython 3パッケージです。これは、`manifest.json`、ローカライゼーションフォルダ、またはJavascriptおよびHTMLソースファイルなど、拡張機能の関連リソースからこれらの機能を抽出するためにパッケージ化されたファイルを解凍するプロセスを自動化します。

## 参考文献

* この方法論に協力してくれた[**@naivenom**](https://twitter.com/naivenom)に**感謝します**
* [https://www.cobalt.io/blog/introduction-to-chrome-browser-extension-security-testing](https://www.cobalt.io/blog/introduction-to-chrome-browser-extension-security-testing)
* [https://palant.info/2022/08/10/anatomy-of-a-basic-extension/](https://palant.info/2022/08/10/anatomy-of-a-basic-extension/)
* [https://palant.info/2022/08/24/attack-surface-of-extension-pages/](https://palant.info/2022/08/24/attack-surface-of-extension-pages/)
* [https://palant.info/2022/08/31/when-extension-pages-are-web-accessible/](https://palant.info/2022/08/31/when-extension-pages-are-web-accessible/)
* [https://help.passbolt.com/assets/files/PBL-02-report.pdf](https://help.passbolt.com/assets/files/PBL-02-report.pdf)
* [https://developer.chrome.com/docs/extensions/develop/concepts/content-scripts](https://developer.chrome.com/docs/extensions/develop/concepts/content-scripts)
* [https://developer.chrome.com/docs/extensions/mv2/background-pages](https://developer.chrome.com/docs/extensions/mv2/background-pages)
* [https://thehackerblog.com/kicking-the-rims-a-guide-for-securely-writing-and-auditing-chrome-extensions/](https://thehackerblog.com/kicking-the-rims-a-guide-for-securely-writing-and-auditing-chrome-extensions/)

<details>

<summary><strong>AWSのハッキングをゼロからヒーローまで学ぶには</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>をご覧ください！</strong></summary>

HackTricksをサポートする他の方法：

* **HackTricksにあなたの会社を広告したい**、または**HackTricksをPDFでダウンロードしたい**場合は、[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式のPEASS & HackTricksグッズ**](https://peass.creator-spring.com)を手に入れる
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見する、私たちの独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクション
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)に**参加する**か、[**telegramグループ**](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)で**フォロー**してください。
* [**HackTricks**](https://github.com/carlospolop/hacktricks)と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のgithubリポジトリにPRを提出して、あなたのハッキングのコツを共有してください。

</details>
```
