# Μεθοδολογία Ελέγχου Επέκτασης Προγράμματος Περιήγησης

<details>

<summary><strong>Μάθετε το χάκινγκ του AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι για να υποστηρίξετε το HackTricks:

* Εάν θέλετε να δείτε την **εταιρεία σας να διαφημίζεται στο HackTricks** ή να **κατεβάσετε το HackTricks σε μορφή PDF** ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**The PEASS Family**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Εγγραφείτε στη** 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στη [**ομάδα telegram**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Μοιραστείτε τα χάκινγκ κόλπα σας υποβάλλοντας PRs στα** [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) αποθετήρια του github.

</details>

## Βασικές Πληροφορίες

Οι επεκτάσεις προγράμματος περιήγησης γράφονται σε JavaScript και φορτώνονται από το πρόγραμμα περιήγησης στο παρασκήνιο. Διαθέτουν το [DOM](https://www.w3schools.com/js/js\_htmldom.asp) τους, αλλά μπορούν να αλληλεπιδράσουν με τα DOM άλλων ιστοσελίδων. Αυτό σημαίνει ότι μπορεί να απειλήσει την εμπιστευτικότητα, την ακεραιότητα και τη διαθεσιμότητα (CIA) άλλων ιστοσελίδων.

## Κύρια Συστατικά

Οι διάταξεις των επεκτάσεων φαίνονται καλύτερα όταν οπτικοποιούνται και αποτελούνται από τρία συστατικά. Ας ρίξουμε μια ματιά σε κάθε συστατικό αναλυτικά.

<figure><img src="../../.gitbook/assets/image (4).png" alt=""><figcaption><p><a href="http://webblaze.cs.berkeley.edu/papers/Extensions.pdf">http://webblaze.cs.berkeley.edu/papers/Extensions.pdf</a></p></figcaption></figure>

### **Σενάρια Περιεχομένου**

Κάθε σενάριο περιεχομένου έχει άμεση πρόσβαση στο DOM μιας **μόνο ιστοσελίδας** και εκτίθεται έτσι σε **ενδεχόμενη κακόβουλη είσοδο**. Ωστόσο, το σενάριο περιεχομένου δεν έχει άλλες άδειες εκτός από τη δυνατότητα αποστολής μηνυμάτων στον πυρήνα της επέκτασης.

### **Πυρήνας Επέκτασης**

Ο πυρήνας της επέκτασης περιέχει τις περισσότερες από τις προνομιούχες πρόσβασης/δικαιώματα της επέκτασης, αλλά μπορεί να αλληλεπιδράσει με το περιεχόμενο του ιστού μόνο μέσω του [XMLHttpRequest](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest) και των σεναρίων περιεχομένου. Επίσης, ο πυρήνας της επέκτασης δεν έχει άμεση πρόσβαση στη μηχανή του κεντρικού υπολογιστή.

### **Φυσικός Δυαδικός Κώδικας**

Η επέκταση επιτρέπει έναν φυσικό δυαδικό κώδικα που μπορεί να **έχει πρόσβαση στη μηχανή του κεντρικού υπολογιστή με τα πλήρη δικαιώματα του χρήστη**. Ο φυσικός δυαδικός κώδικας αλληλεπιδρά με τον πυρήνα της επέκτασης μέσω της τυπικής διεπαφής προγραμματισμού εφαρμογών Netscape Plugin ([NPAPI](https://en.wikipedia.org/wiki/NPAPI)) που χρησιμοποιείται από το Flash και άλλα πρόσθετα προγράμματα περιήγησης.

### Όρια

{% hint style="danger" %}
Για να αποκτήσει κάποιος τα πλήρη δικαιώματα του χρήστη, ένας επιτιθέμενος πρέπει να πείσει την επέκταση να περάσει κακόβουλη είσοδο από το σενάριο περιεχομένου στον πυρήνα της επέκτασης και από τον πυρήνα της επέκτασης στον φυσικό δυαδικό κώδικα.
{% endhint %}

Κάθε συστατικό της επέκτασης είναι χωρισμένο από τα υπόλοιπα με **ισχυρά προστατευτικά όρια**. Κάθε συστατικό λειτουργεί σε ένα **ξεχωριστό διαδικαστικό σύστημα λειτουργίας**. Τα σενάρια περιεχομένου και οι πυρήνες επέκτασης λειτουργούν σε **διεργασίες αμμού** που δεν είναι διαθέσιμες στις περισσότερες υπηρεσίες του λειτουργικού συστήματος.

Επιπλέον, τα σενάρια περιεχομένου χωρίζονται από τις σχετιζόμενες ιστοσελίδες τους με το **τρέξιμο σε ξεχωριστή στοίβα JavaScript**. Το σενάριο περιεχομένου και η ιστοσελίδα έχουν **πρόσβαση στο ίδιο βασικό DOM**, αλλά οι δύο δεν ανταλλάσσουν ποτέ δείκτες JavaScript, αποτρέποντας τη διαρροή λειτουργικότητας της JavaScript.
```json
{
"manifest_version": 2,
"name": "My extension",
"version": "1.0",
"permissions": [
"storage"
],
"content_scripts": [
{
"js": [
"script.js"
],
"matches": [
"https://example.com/*",
"https://www.example.com/*"
],
"exclude_matches": ["*://*/*business*"],
}
],
"background": {
"scripts": [
"background.js"
]
},
"options_ui": {
"page": "options.html"
}
}
```
### `content_scripts`

Τα content scripts φορτώνονται κάθε φορά που ο χρήστης πλοηγείται σε μια αντίστοιχη σελίδα, στην περίπτωσή μας οποιαδήποτε σελίδα που ταιριάζει με την έκφραση `https://example.com/*` και δεν ταιριάζει με τον κανονικό έκφραση `*://*/*/business*`. Εκτελούνται όπως οι δικοί της σενάριοι της σελίδας και έχουν αυθαίρετη πρόσβαση στο [Document Object Model (DOM)](https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model) της σελίδας.
```json
"content_scripts": [
{
"js": [
"script.js"
],
"matches": [
"https://example.com/*",
"https://www.example.com/*"
],
"exclude_matches": ["*://*/*business*"],
}
],
```
Για να περιλάβετε ή να αποκλείσετε περισσότερες διευθύνσεις URL, είναι επίσης δυνατή η χρήση των **`include_globs`** και **`exclude_globs`**.

Αυτό είναι ένα παράδειγμα script περιεχομένου που θα προσθέσει ένα κουμπί εξήγησης στη σελίδα όταν [το API αποθήκευσης](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/storage) χρησιμοποιείται για να ανακτήσει την τιμή `message` από την αποθήκευση της επέκτασης.
```js
chrome.storage.local.get("message", result =>
{
let div = document.createElement("div");
div.innerHTML = result.message + " <button>Explain</button>";
div.querySelector("button").addEventListener("click", () =>
{
chrome.runtime.sendMessage("explain");
});
document.body.appendChild(div);
});
```
<figure><img src="../../.gitbook/assets/image (7).png" alt=""><figcaption></figcaption></figure>

Ένα μήνυμα αποστέλλεται στις σελίδες της επέκτασης από τον content script όταν αυτό το κουμπί πατηθεί, μέσω της χρήσης του [**runtime.sendMessage() API**](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/runtime/sendMessage). Αυτό συμβαίνει λόγω του περιορισμού του content script στην άμεση πρόσβαση σε APIs, με το `storage` να είναι μία από τις λίγες εξαιρέσεις. Για λειτουργίες πέρα από αυτές τις εξαιρέσεις, τα μηνύματα αποστέλλονται στις σελίδες της επέκτασης με τις οποίες τα content scripts μπορούν να επικοινωνήσουν.

{% hint style="warning" %}
Ανάλογα με τον περιηγητή, οι δυνατότητες του content script μπορεί να διαφέρουν ελαφρώς. Για περιηγητές βασισμένους στο Chromium, η λίστα των δυνατοτήτων είναι διαθέσιμη στην [τεκμηρίωση των Chrome Developers](https://developer.chrome.com/docs/extensions/mv3/content_scripts/#capabilities), και για τον Firefox, η πρωταρχική πηγή είναι το [MDN](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/Content_scripts#webextension_apis).\
Επίσης, είναι σημαντικό να σημειωθεί ότι τα content scripts έχουν τη δυνατότητα να επικοινωνούν με τα background scripts, επιτρέποντάς τους να εκτελούν ενέργειες και να μεταδίδουν απαντήσεις πίσω.
{% endhint %}

Για να προβάλλετε και να εντοπίσετε σφάλματα στα content scripts στο Chrome, μπορείτε να αποκτήσετε πρόσβαση στο μενού των εργαλείων για προγραμματιστές του Chrome από τις Επιλογές > Περισσότερα εργαλεία > Εργαλεία προγραμματιστή ή πατώντας ταυτόχρονα τα πλήκτρα Ctrl + Shift + I.

Αφού εμφανιστούν τα εργαλεία προγραμματιστή, πρέπει να κάνετε κλικ στην καρτέλα **Πηγή**, ακολουθούμενη από την καρτέλα **Content Scripts**. Αυτό επιτρέπει την παρατήρηση των εκτελούμενων content scripts από διάφορες επεκτάσεις και την ορισμό breakpoints για την παρακολούθηση της ροής εκτέλεσης.

### Ενσωματωμένα content scripts

{% hint style="success" %}
Σημειώστε ότι τα **Content Scripts δεν είναι υποχρεωτικά**, καθώς είναι επίσης δυνατή η **δυναμική** **ενσωμάτωση** σεναρίων και η **προγραμματική ενσωμάτωσή τους** σε ιστοσελίδες μέσω της **`tabs.executeScript`**. Αυτό παρέχει περισσότερο **ακριβή έλεγχο**.
{% endhint %}

Για την προγραμματική ενσωμάτωση ενός content script, η επέκταση πρέπει να έχει [δικαιώματα κατοχυρωμένα από τον κεντρικό υπολογιστή](https://developer.chrome.com/docs/extensions/reference/permissions) για τη σελίδα στην οποία τα σενάρια θα ενσωματωθούν. Αυτά τα δικαιώματα μπορούν να εξασφαλιστούν είτε με τον **αίτημα** τους στον προσαρμογέα της επέκτασης είτε προσωρινά μέσω του [**activeTab**](https://developer.chrome.com/docs/extensions/reference/manifest/activeTab).

#### Παράδειγμα επέκτασης βασισμένης στο activeTab

{% code title="manifest.json" %}
```json
{
"name": "My extension",
...
"permissions": [
"activeTab",
"scripting"
],
"background": {
"service_worker": "background.js"
},
"action": {
"default_title": "Action Button"
}
}
```
{% endcode %}

* **Ενσωμάτωση ενός αρχείου JS με κλικ:**
```javascript
// content-script.js
document.body.style.backgroundColor = "orange";

//service-worker.js - Inject the JS file
chrome.action.onClicked.addListener((tab) => {
chrome.scripting.executeScript({
target: { tabId: tab.id },
files: ["content-script.js"]
});
});
```
* **Εισαγωγή μιας συνάρτησης** κατά το κλικ:
```javascript
//service-worker.js - Inject a function
function injectedFunction() {
document.body.style.backgroundColor = "orange";
}

chrome.action.onClicked.addListener((tab) => {
chrome.scripting.executeScript({
target : {tabId : tab.id},
func : injectedFunction,
});
});
```
#### Παράδειγμα με δικαιώματα σεναρίου

In this example, we will explore how to leverage scripting permissions in a browser extension for pentesting purposes.

Σε αυτό το παράδειγμα, θα εξετάσουμε πώς να αξιοποιήσουμε τα δικαιώματα σεναρίου σε ένα πρόσθετο προγράμματος περιήγησης για σκοπούς pentesting.

First, we need to identify the browser extension we want to test. We can do this by inspecting the extension's manifest file, which typically contains information about the extension's permissions and capabilities.

Πρώτα, πρέπει να εντοπίσουμε το πρόσθετο προγράμματος περιήγησης που θέλουμε να δοκιμάσουμε. Μπορούμε να το κάνουμε αυτό επιθεωρώντας το αρχείο manifest του πρόσθετου, το οποίο συνήθως περιέχει πληροφορίες σχετικά με τα δικαιώματα και τις δυνατότητες του πρόσθετου.

Once we have identified the extension, we can check if it has any scripting permissions. These permissions allow the extension to execute scripts on specific web pages.

Αφού εντοπίσουμε το πρόσθετο, μπορούμε να ελέγξουμε αν έχει οποιαδήποτε δικαιώματα σεναρίου. Αυτά τα δικαιώματα επιτρέπουν στο πρόσθετο να εκτελεί σενάρια σε συγκεκριμένες ιστοσελίδες.

To exploit these scripting permissions, we can create a malicious script that takes advantage of the extension's capabilities. This script can be injected into a vulnerable web page, allowing us to execute arbitrary code within the context of the extension.

Για να εκμεταλλευτούμε αυτά τα δικαιώματα σεναρίου, μπορούμε να δημιουργήσουμε ένα κακόβουλο σενάριο που εκμεταλλεύεται τις δυνατότητες του πρόσθετου. Αυτό το σενάριο μπορεί να εισαχθεί σε μια ευπάθεια ιστοσελίδα, επιτρέποντάς μας να εκτελέσουμε αυθαίρετο κώδικα μέσα στο πλαίσιο του πρόσθετου.

By executing this malicious script, we can perform various actions, such as stealing sensitive information, modifying web page content, or even gaining remote access to the user's system.

Εκτελώντας αυτό το κακόβουλο σενάριο, μπορούμε να πραγματοποιήσουμε διάφορες ενέργειες, όπως κλοπή ευαίσθητων πληροφοριών, τροποποίηση περιεχομένου ιστοσελίδας ή ακόμα και αποκτήση απομακρυσμένης πρόσβασης στο σύστημα του χρήστη.

It is important to note that exploiting scripting permissions in a browser extension requires careful planning and consideration of potential risks and legal implications.

Είναι σημαντικό να σημειωθεί ότι η εκμετάλλευση των δικαιωμάτων σεναρίου σε ένα πρόσθετο προγράμματος περιήγησης απαιτεί προσεκτικό σχεδιασμό και λήψη υπόψη των πιθανών κινδύνων και νομικών επιπτώσεων.
```javascript
// service-workser.js
chrome.scripting.registerContentScripts([{
id : "test",
matches : [ "https://*.example.com/*" ],
excludeMatches : [ "*://*/*business*" ],
js : [ "contentScript.js" ],
}]);

// Another example
chrome.tabs.executeScript(tabId, { file: "content_script.js" });
```
Για να περιλάβετε ή να αποκλείσετε περισσότερα URLs, είναι επίσης δυνατή η χρήση των **`include_globs`** και **`exclude_globs`**.

### Το πεδίο `run_at` των Content Scripts

Το πεδίο `run_at` ελέγχει **πότε οι αρχεία JavaScript ενσωματώνονται στην ιστοσελίδα**. Η προτιμώμενη και προεπιλεγμένη τιμή είναι `"document_idle"`.

Οι δυνατές τιμές είναι:

* **`document_idle`**: Όποτε είναι δυνατόν
* **`document_start`**: Μετά από οποιαδήποτε αρχεία `css`, αλλά πριν από την κατασκευή οποιουδήποτε άλλου DOM ή την εκτέλεση οποιουδήποτε άλλου script.
* **`document_end`**: Αμέσως μετά την ολοκλήρωση του DOM, αλλά πριν φορτωθούν υποπόρισματα όπως εικόνες και πλαίσια.

#### Μέσω του `manifest.json`
```json
{
"name": "My extension",
...
"content_scripts": [
{
"matches": ["https://*.example.com/*"],
"run_at": "document_idle",
"js": ["contentScript.js"]
}
],
...
}

```
Μέσω του **`service-worker.js`**
```javascript
chrome.scripting.registerContentScripts([{
id : "test",
matches : [ "https://*.example.com/*" ],
runAt : "document_idle",
js : [ "contentScript.js" ],
}]);
```
### `Υπόβαθρο`

Τα μηνύματα που στέλνονται από τα content scripts λαμβάνονται από την **σελίδα υπόβαθρου**, η οποία διαδραματίζει κεντρικό ρόλο στον συντονισμό των συστατικών της επέκτασης. Είναι σημαντικό να σημειωθεί ότι η σελίδα υπόβαθρου διατηρείται καθ' όλη τη διάρκεια ζωής της επέκτασης, λειτουργώντας απαρατήρητα χωρίς άμεση αλληλεπίδραση με τον χρήστη. Διαθέτει το δικό της Document Object Model (DOM), επιτρέποντας πολύπλοκες αλληλεπιδράσεις και διαχείριση καταστάσεων.

**Κύρια Σημεία**:

- **Ρόλος Σελίδας Υπόβαθρου:** Δρα ως κέντρο ελέγχου για την επέκταση, εξασφαλίζοντας την επικοινωνία και τον συντονισμό μεταξύ των διάφορων μερών της επέκτασης.
- **Διατήρηση:** Είναι μια παρουσία που υπάρχει συνεχώς, αόρατη για τον χρήστη αλλά ουσιώδης για τη λειτουργικότητα της επέκτασης.
- **Αυτόματη Δημιουργία:** Εάν δεν έχει καθοριστεί ρητά, ο περιηγητής θα δημιουργήσει αυτόματα μια σελίδα υπόβαθρου. Αυτή η αυτόματη δημιουργημένη σελίδα θα περιλαμβάνει όλα τα υπόβαθρα scripts που έχουν καθοριστεί στο αρχείο περιγραφής της επέκτασης, εξασφαλίζοντας την άριστη λειτουργία των φόντων της επέκτασης.

{% hint style="success" %}
Η ευκολία που παρέχει ο περιηγητής με την αυτόματη δημιουργία μιας σελίδας υπόβαθρου (όταν δεν έχει καθοριστεί ρητά) εξασφαλίζει ότι όλα τα απαραίτητα υπόβαθρα scripts ενσωματώνονται και λειτουργούν, διευκολύνοντας τη διαδικασία εγκατάστασης της επέκτασης.
{% endhint %}

Παράδειγμα υπόβαθρου script:
```js
chrome.runtime.onMessage.addListener((request, sender, sendResponse) =>
{
if (request == "explain")
{
chrome.tabs.create({ url: "https://example.net/explanation" });
}
})
```
Χρησιμοποιεί το [runtime.onMessage API](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/runtime/onMessage) για να ακούει μηνύματα. Όταν λαμβάνει ένα μήνυμα "explain", χρησιμοποιεί το [tabs API](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/tabs) για να ανοίξει μια σελίδα σε ένα νέο tab.

Για να εντοπίσετε σφάλματα στο background script, μπορείτε να πάτε στις **λεπτομέρειες της επέκτασης και να επιθεωρήσετε τον service worker**, αυτό θα ανοίξει τα εργαλεία προγραμματιστή με το background script:

<figure><img src="broken-reference" alt=""><figcaption></figcaption></figure>

### Σελίδες επιλογών και άλλες

Οι επεκτάσεις του προγράμματος περιήγησης μπορούν να περιέχουν διάφορους τύπους σελίδων:

* **Σελίδες δράσης** εμφανίζονται σε ένα **αναπτυσσόμενο μενού όταν γίνει κλικ στο εικονίδιο** της επέκτασης.
* Σελίδες που η επέκταση θα **φορτώσει σε ένα νέο tab**.
* **Σελίδες επιλογών**: Αυτή η σελίδα εμφανίζεται πάνω από την επέκταση όταν γίνει κλικ. Στο προηγούμενο αρχείο παραμέτρων, μπόρεσα να αποκτήσω πρόσβαση σε αυτήν τη σελίδα στο `chrome://extensions/?options=fadlhnelkbeojnebcbkacjilhnbjfjca` ή κάνοντας κλικ:

<figure><img src="../../.gitbook/assets/image (8).png" alt="" width="375"><figcaption></figcaption></figure>

Σημειώστε ότι αυτές οι σελίδες δεν είναι μόνιμες όπως οι σελίδες background καθώς φορτώνουν δυναμικά περιεχόμενο κατά ανάγκη. Παρόλα αυτά, μοιράζονται ορισμένες δυνατότητες με τη σελίδα background:

- **Επικοινωνία με Content Scripts:** Παρόμοια με τη σελίδα background, αυτές οι σελίδες μπορούν να λαμβάνουν μηνύματα από content scripts, διευκολύνοντας την αλληλεπίδραση εντός της επέκτασης.
- **Πρόσβαση σε ειδικές API της επέκτασης:** Αυτές οι σελίδες έχουν πλήρη πρόσβαση σε ειδικές API της επέκτασης, σύμφωνα με τις άδειες που έχουν οριστεί για την επέκταση.

### `permissions` & `host_permissions`

**`permissions`** και **`host_permissions`** είναι καταχωρήσεις από το `manifest.json` που υποδεικνύουν **ποιες άδειες** έχει η επέκταση του προγράμματος περιήγησης (αποθήκευση, τοποθεσία...) και **σε ποιες ιστοσελίδες**.

Καθώς οι επεκτάσεις του προγράμματος περιήγησης μπορούν να έχουν τόσο **προνομιούχες** δυνατότητες, μια κακόβουλη επέκταση ή μια που έχει παραβιαστεί μπορεί να επιτρέψει στον επιτιθέμενο **διάφορους τρόπους για να κλέψει ευαίσθητες πληροφορίες και να κατασκοπεύσει τον χρήστη**.

Ελέγξτε πώς λειτουργούν αυτές οι ρυθμίσεις και πώς μπορούν να καταχραστούν στο:

{% content-ref url="browext-permissions-and-host_permissions.md" %}
[browext-permissions-and-host\_permissions.md](browext-permissions-and-host\_permissions.md)
{% endcontent-ref %}

### `content_security_policy`

Μια **πολιτική ασφαλείας περιεχομένου** μπορεί να δηλωθεί επίσης μέσα στο `manifest.json`. Αν έχει οριστεί μια, μπορεί να είναι **ευάλωτη**.

Η προεπιλεγμένη ρύθμιση για τις σελίδες των επεκτάσεων του προγράμματος περιήγησης είναι αρκετά περιοριστική:
```bash
script-src 'self'; object-src 'self';
```
Για περισσότερες πληροφορίες σχετικά με το CSP και πιθανές παρακάμψεις, ελέγξτε:

{% content-ref url="../content-security-policy-csp-bypass/" %}
[content-security-policy-csp-bypass](../content-security-policy-csp-bypass/)
{% endcontent-ref %}

### `web_accessible_resources`

Για να μπορεί μια ιστοσελίδα να έχει πρόσβαση σε μια σελίδα ενός πρόσθετου προγράμματος περιήγησης, όπως για παράδειγμα μια σελίδα `.html`, αυτή η σελίδα πρέπει να αναφέρεται στο πεδίο **`web_accessible_resources`** του `manifest.json`.\
Για παράδειγμα:
```javascript
{
...
"web_accessible_resources": [
{
"resources": [ "images/*.png" ],
"matches": [ "https://example.com/*" ]
},
{
"resources": [ "fonts/*.woff" ],
"matches": [ "https://example.com/*" ]
}
],
...
}
```
Αυτές οι σελίδες είναι προσβάσιμες στο URL:
```
chrome-extension://<extension-id>/message.html
```
Στις δημόσιες επεκτάσεις, το **αναγνωριστικό της επέκτασης είναι προσβάσιμο**:

<figure><img src="../../.gitbook/assets/image (722).png" alt="" width="375"><figcaption></figcaption></figure>

Ωστόσο, εάν χρησιμοποιείται η παράμετρος `use_dynamic_url` στο αρχείο `manifest.json`, το **αναγνωριστικό μπορεί να είναι δυναμικό**.

Η δυνατότητα πρόσβασης σε αυτές τις σελίδες καθιστά αυτές τις σελίδες **δυνητικά ευάλωτες σε επιθέσεις ClickJacking**:

{% content-ref url="browext-clickjacking.md" %}
[browext-clickjacking.md](browext-clickjacking.md)
{% endcontent-ref %}

{% hint style="success" %}
Η επιτροπή φόρτωσης αυτών των σελίδων μόνο από την επέκταση και όχι από τυχαίες διευθύνσεις URL μπορεί να αποτρέψει επιθέσεις ClickJacking.
{% endhint %}

### `externally_connectable`

Σύμφωνα με τα [**έγγραφα**](https://developer.chrome.com/docs/extensions/reference/manifest/externally-connectable), η ιδιότητα `"externally_connectable"` στο αρχείο manifest καθορίζει **ποιες επεκτάσεις και ιστοσελίδες μπορούν να συνδεθούν** με την επέκτασή σας μέσω των [runtime.connect](https://developer.chrome.com/docs/extensions/reference/runtime#method-connect) και [runtime.sendMessage](https://developer.chrome.com/docs/extensions/reference/runtime#method-sendMessage).

* Εάν η κλειδί **`externally_connectable`** δεν έχει δηλωθεί στο αρχείο manifest της επέκτασής σας ή έχει δηλωθεί ως **`"ids": ["*"]`**, **όλες οι επεκτάσεις μπορούν να συνδεθούν, αλλά καμία ιστοσελίδα δεν μπορεί να συνδεθεί**.
* Εάν δηλώνονται **συγκεκριμένα αναγνωριστικά**, όπως στην περίπτωση `"ids": ["aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"]`, **μόνο αυτές οι εφαρμογές** μπορούν να συνδεθούν.
* Εάν δηλώνονται **αντιστοιχίες**, αυτές οι ιστοσελίδες θα μπορούν να συνδεθούν:
```json
"matches": [
"https://*.google.com/*",
"*://*.chromium.org/*",
```
* Εάν καθοριστεί ως κενό: **`"externally_connectable": {}`**, κανένα πρόγραμμα ή ιστοσελίδα δεν θα μπορεί να συνδεθεί.

Όσο **λιγότερες επεκτάσεις και URLs** δηλώνονται εδώ, τόσο **μικρότερη θα είναι η επιθετική επιφάνεια**.

{% hint style="danger" %}
Εάν μια ιστοσελίδα ευάλωτη σε XSS ή κατάληψη δηλώνεται στο **`externally_connectable`**, ένας επιτιθέμενος θα μπορεί να **στείλει μηνύματα απευθείας στο φόντο σενάριο**, παρακάμπτοντας εντελώς το Content Script και το CSP του.

Επομένως, αυτό είναι ένας **πολύ ισχυρός παράκαμψη**.
{% endhint %}

## Επικοινωνία Ιστοσελίδας **↔︎** Content Script

Τα περιβάλλοντα όπου λειτουργούν τα **content scripts** και όπου υπάρχουν οι σελίδες φιλοξενούμενων είναι **απομονωμένα** μεταξύ τους, εξασφαλίζοντας **απομόνωση**. Παρά την απομόνωση αυτή, και οι δύο έχουν τη δυνατότητα να αλληλεπιδρούν με το **Document Object Model (DOM)** της σελίδας, ένα κοινόχρηστο πόρο. Για να επικοινωνήσει η σελίδα φιλοξενούμενων με το **content script**, ή έμμεσα με την επέκταση μέσω του content script, απαιτείται η χρήση του **DOM** που είναι προσβάσιμο από τις δύο πλευρές ως κανάλι επικοινωνίας.

### Αποστολή Μηνυμάτων

{% code title="content-script.js" %}
```javascript
var port = chrome.runtime.connect();

window.addEventListener("message", (event) => {
// We only accept messages from ourselves
if (event.source !== window) {
return;
}

if (event.data.type && (event.data.type === "FROM_PAGE")) {
console.log("Content script received: " + event.data.text);
port.postMessage(event.data.text);
}
}, false);
```
{% code title="παράδειγμα.js" %}
```javascript
document.getElementById("theButton").addEventListener("click", () => {
window.postMessage(
{type : "FROM_PAGE", text : "Hello from the webpage!"}, "*");
}, false);
```
{% endcode %}

Μια ασφαλής επικοινωνία Post Message θα πρέπει να ελέγχει την αυθεντικότητα του ληφθέντος μηνύματος, αυτό μπορεί να γίνει ελέγχοντας:

* **`event.isTrusted`**: Αυτό είναι αληθές μόνο αν το γεγονός προκλήθηκε από μια ενέργεια του χρήστη
* Το script περιεχομένου μπορεί να περιμένει ένα μήνυμα μόνο αν ο χρήστης εκτελεί κάποια ενέργεια
* **προέλευση τομέα**: μπορεί να περιμένει ένα μήνυμα μόνο από μια λίστα επιτρεπόμενων τομέων.
* Εάν χρησιμοποιείται ένας κανόνας regex, να είστε πολύ προσεκτικοί
* **Πηγή**: Μπορεί να χρησιμοποιηθεί η `received_message.source !== window` για να ελεγχθεί αν το μήνυμα ήταν **από το ίδιο παράθυρο** όπου το Content Script ακούει.

Οι προηγούμενοι έλεγχοι, ακόμη και αν πραγματοποιούνται, μπορεί να είναι ευάλωτοι, επομένως ελέγξτε στην ακόλουθη σελίδα τις **πιθανές παρακάμψεις Post Message**:

{% content-ref url="../postmessage-vulnerabilities/" %}
[postmessage-vulnerabilities](../postmessage-vulnerabilities/)
{% endcontent-ref %}

### Iframe

Ένας άλλος πιθανός τρόπος επικοινωνίας μπορεί να είναι μέσω των **Iframe URLs**, μπορείτε να βρείτε ένα παράδειγμα στο:

{% content-ref url="browext-xss-example.md" %}
[browext-xss-example.md](browext-xss-example.md)
{% endcontent-ref %}

### DOM

Αυτό δεν είναι "ακριβώς" ένας τρόπος επικοινωνίας, αλλά το **web και το script περιεχομένου θα έχουν πρόσβαση στο DOM του web**. Έτσι, αν το **script περιεχομένου** διαβάζει κάποιες πληροφορίες από αυτό, **εμπιστευόμενο το DOM του web**, το web μπορεί να **τροποποιήσει αυτά τα δεδομένα** (επειδή το web δεν πρέπει να εμπιστεύεται, ή επειδή το web είναι ευάλωτο σε XSS) και να **θέσει σε κίνδυνο το Content Script**.

Μπορείτε επίσης να βρείτε ένα παράδειγμα ενός **DOM based XSS για να θέσει σε κίνδυνο μια επέκταση προγράμματος περιήγησης** στο:

{% content-ref url="browext-xss-example.md" %}
[browext-xss-example.md](browext-xss-example.md)
{% endcontent-ref %}

## Ευαίσθητες Πληροφορίες στη Μνήμη/Κώδικας

Εάν μια Επέκταση Προγράμματος Περιήγησης αποθηκεύει **ευαίσθητες πληροφορίες μέσα στη μνήμη της**, αυτές μπορεί να **διαρρεύσουν** (ειδικά σε μηχανές Windows) και να **αναζητηθούν** για αυτές τις πληροφορίες.

Επομένως, η μνήμη της Επέκτασης Προγράμματος Περιήγησης **δεν πρέπει να θεωρείται ασφαλής** και **ευαίσθητες πληροφορίες** όπως διαπιστευτήρια ή φράσεις μνημονικής **δεν πρέπει να αποθηκεύονται**.

Φυσικά, **μην τοποθετείτε ευαίσθητες πληροφορίες στον κώδικα**, καθώς θα είναι **δημόσιες**.

## Επικοινωνία Σεναρίου Περιεχομένου **↔︎** Σεναρίου Υποβάθρου

Ένα Σενάριο Περιεχομένου μπορεί να χρησιμοποιήσει τις συναρτήσεις [**runtime.sendMessage()**](https://developer.chrome.com/docs/extensions/reference/runtime#method-sendMessage) **ή** [**tabs.sendMessage()**](https://developer.chrome.com/docs/extensions/reference/tabs#method-sendMessage) για να στείλει ένα μήνυμα **μιας φοράς που μπορεί να αναπαρασταθεί σε JSON**.

Για να χειριστείτε την **απάντηση**, χρησιμοποιήστε την επιστρεφόμενη **Promise**. Ωστόσο, για συμβατότητα προς τα πίσω, μπορείτε ακόμα να περάσετε ένα **callback** ως το τελευταίο όρισμα.

Η αποστολή ενός αιτήματος από ένα **σενάριο περιεχομένου** φαίνεται όπως εδώ:
```javascript
(async () => {
const response = await chrome.runtime.sendMessage({greeting: "hello"});
// do something with response here, not outside the function
console.log(response);
})();
```
Αποστολή αιτήματος από την **επέκταση** (συνήθως ένα **σενάριο φόντου**) Ένα Σενάριο Περιεχομένου μπορεί να χρησιμοποιήσει τις συναρτήσεις, εκτός από το γεγονός ότι πρέπει να καθορίσετε σε ποια καρτέλα να το στείλετε. Παράδειγμα πώς να στείλετε μήνυμα στο σενάριο περιεχομένου στην επιλεγμένη καρτέλα:
```javascript
// From https://stackoverflow.com/questions/36153999/how-to-send-a-message-between-chrome-extension-popup-and-content-script
(async () => {
const [tab] = await chrome.tabs.query({active: true, lastFocusedWindow: true});
const response = await chrome.tabs.sendMessage(tab.id, {greeting: "hello"});
// do something with response here, not outside the function
console.log(response);
})();
```
Στην **λήψη**, πρέπει να δημιουργήσετε έναν [**runtime.onMessage**](https://developer.chrome.com/docs/extensions/reference/runtime#event-onMessage) **ακροατή** για να χειριστείτε το μήνυμα. Αυτό φαίνεται το ίδιο από ένα script περιεχομένου ή μια σελίδα επέκτασης.
```javascript
// From https://stackoverflow.com/questions/70406787/javascript-send-message-from-content-js-to-background-js
chrome.runtime.onMessage.addListener(
function(request, sender, sendResponse) {
console.log(sender.tab ?
"from a content script:" + sender.tab.url :
"from the extension");
if (request.greeting === "hello")
sendResponse({farewell: "goodbye"});
}
);
```
Στο παράδειγμα που επισημαίνεται, το **`sendResponse()`** εκτελέστηκε με συγχρονισμένο τρόπο. Για να τροποποιηθεί ο χειριστής γεγονότων `onMessage` για ασύγχρονη εκτέλεση του `sendResponse()`, είναι απαραίτητο να ενσωματωθεί το `return true;`.

Ένα σημαντικό στοιχείο που πρέπει να ληφθεί υπόψη είναι ότι σε περιπτώσεις όπου πολλές σελίδες έχουν οριστεί για να λαμβάνουν γεγονότα `onMessage`, **η πρώτη σελίδα που εκτελεί το `sendResponse()`** για ένα συγκεκριμένο γεγονός θα είναι η μόνη που θα μπορεί να παράσχει αποτελεσματικά την απόκριση. Οποιεσδήποτε επόμενες απαντήσεις για το ίδιο γεγονός δεν θα ληφθούν υπόψη.

Κατά τη δημιουργία νέων επεκτάσεων, προτιμάται η χρήση promises αντί για callbacks. Όσον αφορά τη χρήση callbacks, η συνάρτηση `sendResponse()` θεωρείται έγκυρη μόνο εάν εκτελείται απευθείας εντός του συγχρονισμένου περιβάλλοντος ή εάν ο χειριστής γεγονότων υποδεικνύει μια ασύγχρονη λειτουργία επιστρέφοντας `true`. Εάν κανένας από τους χειριστές δεν επιστρέψει `true` ή εάν η συνάρτηση `sendResponse()` αφαιρεθεί από τη μνήμη (συλλεκτικής απόρριψης), το callback που συσχετίζεται με τη συνάρτηση `sendMessage()` θα ενεργοποιηθεί από προεπιλογή.

## Φόρτωση μιας επέκτασης στον περιηγητή

1. **Κατεβάστε** την επέκταση του περιηγητή και αποσυμπιέστε την
2. Πηγαίνετε στην **`chrome://extensions/`** και **ενεργοποιήστε** την `Developer Mode`
3. Κάντε κλικ στο κουμπί **`Load unpacked`**

Στο **Firefox** πηγαίνετε στο **`about:debugging#/runtime/this-firefox`** και κάντε κλικ στο κουμπί **`Load Temporary Add-on`**.

## Λήψη του πηγαίου κώδικα από το κατάστημα

Ο πηγαίος κώδικας μιας επέκτασης Chrome μπορεί να ληφθεί μέσω διάφορων μεθόδων. Παρακάτω παρέχονται λεπτομερείς εξηγήσεις και οδηγίες για κάθε επιλογή.

### Λήψη της επέκτασης ως ZIP μέσω της γραμμής εντολών

Ο πηγαίος κώδικας μιας επέκτασης Chrome μπορεί να ληφθεί ως αρχείο ZIP χρησιμοποιώντας τη γραμμή εντολών. Αυτό περιλαμβάνει τη χρήση της εντολής `curl` για να ανακτήσετε το αρχείο ZIP από μια συγκεκριμένη διεύθυνση URL και στη συνέχεια να εξαγάγετε τα περιεχόμενα του αρχείου ZIP σε έναν κατάλογο. Οι ακόλουθες εντολές περιγράφουν τα βήματα:
```bash
extension_id=your_extension_id   # Replace with the actual extension ID
curl -L -o "$extension_id.zip" "https://clients2.google.com/service/update2/crx?response=redirect&os=mac&arch=x86-64&nacl_arch=x86-64&prod=chromecrx&prodchannel=stable&prodversion=44.0.2403.130&x=id%3D$extension_id%26uc"
unzip -d "$extension_id-source" "$extension_id.zip"
```
### Χρησιμοποιήστε τον ιστότοπο CRX Viewer

[https://robwu.nl/crxviewer/](https://robwu.nl/crxviewer/)

### Χρησιμοποιήστε την επέκταση CRX Viewer

Ένας άλλος βολικός τρόπος είναι να χρησιμοποιήσετε το Chrome Extension Source Viewer, το οποίο είναι ένα ανοιχτού κώδικα έργο. Μπορεί να εγκατασταθεί από το [Chrome Web Store](https://chrome.google.com/webstore/detail/chrome-extension-source-v/jifpbeccnghkjeaalbbjmodiffmgedin?hl=en). Ο πηγαίος κώδικας του viewer είναι διαθέσιμος στο [αποθετήριο GitHub](https://github.com/Rob--W/crxviewer).

### Προβολή πηγής τοπικά εγκατεστημένης επέκτασης

Οι τοπικά εγκατεστημένες επεκτάσεις του Chrome μπορούν επίσης να επιθεωρηθούν. Ακολουθούν οι οδηγίες:

1. Αποκτήστε πρόσβαση στον τοπικό φάκελο προφίλ του Chrome επισκεπτόμενοι τη διεύθυνση `chrome://version/` και εντοπίζοντας το πεδίο "Profile Path".
2. Πλοηγηθείτε στον υποφάκελο `Extensions/` εντός του φακέλου προφίλ.
3. Αυτός ο φάκελος περιέχει όλες τις εγκατεστημένες επεκτάσεις, συνήθως με τον πηγαίο κώδικά τους σε μια αναγνώσιμη μορφή.

Για να αναγνωρίσετε τις επεκτάσεις, μπορείτε να αντιστοιχίσετε τα αναγνωριστικά τους με τα ονόματά τους:

- Ενεργοποιήστε τη λειτουργία προγραμματιστή στη σελίδα `about:extensions` για να δείτε τα αναγνωριστικά κάθε επέκτασης.
- Εντός του φακέλου κάθε επέκτασης, το αρχείο `manifest.json` περιέχει ένα αναγνώσιμο πεδίο `name`, που σας βοηθά να αναγνωρίσετε την επέκταση.

### Χρησιμοποιήστε έναν αρχειοθέτη ή αποσυμπιεστή αρχείων
Πηγαίνετε στο Chrome Web Store και κατεβάστε την επέκταση. Το αρχείο θα έχει την κατάληξη `.crx`.
Αλλάξτε την κατάληξη του αρχείου από `.crx` σε `.zip`.
Χρησιμοποιήστε οποιονδήποτε αρχειοθέτη αρχείων (όπως το WinRAR, το 7-Zip κ.λπ.) για να εξαγάγετε τα περιεχόμενα του αρχείου ZIP.

### Χρησιμοποιήστε τη λειτουργία προγραμματιστή στο Chrome
Ανοίξτε το Chrome και μεταβείτε στη διεύθυνση `chrome://extensions/`.
Ενεργοποιήστε την "Λειτουργία προγραμματιστή" στην πάνω δεξιά γωνία.
Κάντε κλικ στο "Φόρτωση αποσυμπιεσμένης επέκτασης...".
Πλοηγηθείτε στον φάκελο της επέκτασής σας.
Αυτό δεν κατεβάζει τον πηγαίο κώδικα, αλλά είναι χρήσιμο για την προβολή και την τροποποίηση του κώδικα μιας ήδη κατεβασμένης ή αναπτυγμένης επέκτασης.

## Λίστα ελέγχου ασφαλείας

Αν και οι επεκτάσεις προγράμματος περιήγησης έχουν έναν **περιορισμένο επιθετικό χώρο**, ορισμένες από αυτές μπορεί να περιέχουν **ευπάθειες** ή **δυνητικές βελτιώσεις της ασφάλειας**. Οι παρακάτω είναι οι πιο κοινές:

* [ ] **Περιορίστε** όσο το δυνατόν περισσότερο τις αιτούμενες **`permissions`**
* [ ] **Περιορίστε** όσο το δυνατόν περισσότερο τις **`host_permissions`**
* [ ] Χρησιμοποιήστε μ
* Εάν θέλετε να δείτε την **εταιρεία σας να διαφημίζεται στο HackTricks** ή να **κατεβάσετε το HackTricks σε μορφή PDF**, ελέγξτε τα [**ΠΛΑΝΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**την Οικογένεια PEASS**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Εγγραφείτε στη** 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στην [**ομάδα telegram**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Μοιραστείτε τα κόλπα σας στο hacking υποβάλλοντας PRs στα** [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) αποθετήρια του github.

</details>
