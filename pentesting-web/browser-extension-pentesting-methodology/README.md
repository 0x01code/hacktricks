# M√©thodologie de test d'intrusion des extensions de navigateur

<details>

<summary><strong>Apprenez le piratage AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Expert Red Team AWS de HackTricks)</strong></a><strong>!</strong></summary>

Autres fa√ßons de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**La famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez-nous** sur **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

## Informations de base

Les extensions de navigateur sont √©crites en JavaScript et charg√©es par le navigateur en arri√®re-plan. Elles ont leur [DOM](https://www.w3schools.com/js/js\_htmldom.asp) mais peuvent interagir avec les DOM d'autres sites. Cela signifie qu'elles peuvent compromettre la confidentialit√©, l'int√©grit√© et la disponibilit√© d'autres sites (CIA).

## Composants principaux

Les mises en page des extensions sont mieux visualis√©es et se composent de trois composants. Examinons chaque composant en d√©tail.

<figure><img src="../../.gitbook/assets/image (13).png" alt=""><figcaption><p><a href="http://webblaze.cs.berkeley.edu/papers/Extensions.pdf">http://webblaze.cs.berkeley.edu/papers/Extensions.pdf</a></p></figcaption></figure>

### **Scripts de contenu**

Chaque script de contenu a un acc√®s direct au DOM d'une **seule page web** et est donc expos√© √† une **entr√©e potentiellement malveillante**. Cependant, le script de contenu ne contient aucune autorisation autre que la capacit√© d'envoyer des messages au c≈ìur de l'extension.

### **C≈ìur de l'extension**

Le c≈ìur de l'extension contient la plupart des privil√®ges/d'acc√®s de l'extension, mais il ne peut interagir avec le contenu web que via [XMLHttpRequest](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest) et des scripts de contenu. De plus, le c≈ìur de l'extension n'a pas un acc√®s direct √† la machine h√¥te.

### **Binaire natif**

L'extension permet un binaire natif qui peut **acc√©der √† la machine h√¥te avec les privil√®ges complets de l'utilisateur**. Le binaire natif interagit avec le c≈ìur de l'extension via l'interface de programmation d'application de plugin Netscape standard ([NPAPI](https://en.wikipedia.org/wiki/NPAPI)) utilis√©e par Flash et d'autres plugins de navigateur.

### Limites

{% hint style="danger" %}
Pour obtenir les privil√®ges complets de l'utilisateur, un attaquant doit convaincre l'extension de transmettre une entr√©e malveillante du script de contenu au c≈ìur de l'extension et du c≈ìur de l'extension au binaire natif.
{% endhint %}

Chaque composant de l'extension est s√©par√© des autres par des **limites protectrices solides**. Chaque composant s'ex√©cute dans un **processus de syst√®me d'exploitation s√©par√©**. Les scripts de contenu et les c≈ìurs d'extension s'ex√©cutent dans des **processus sandbox** inaccessibles √† la plupart des services du syst√®me d'exploitation.

De plus, les scripts de contenu sont s√©par√©s de leurs pages web associ√©es en **s'ex√©cutant dans un tas JavaScript s√©par√©**. Le script de contenu et la page web ont **acc√®s au m√™me DOM sous-jacent**, mais les deux **n'√©changent jamais de pointeurs JavaScript**, emp√™chant la fuite de fonctionnalit√©s JavaScript.

## **`manifest.json`**

Une extension Chrome est simplement un dossier ZIP avec une extension de fichier [.crx](https://www.lifewire.com/crx-file-2620391). Le c≈ìur de l'extension est le fichier **`manifest.json`** √† la racine du dossier, qui sp√©cifie la mise en page, les autorisations et d'autres options de configuration.

Exemple :
```json
{
"manifest_version": 2,
"name": "My extension",
"version": "1.0",
"permissions": [
"storage"
],
"content_scripts": [
{
"js": [
"script.js"
],
"matches": [
"https://example.com/*",
"https://www.example.com/*"
],
"exclude_matches": ["*://*/*business*"],
}
],
"background": {
"scripts": [
"background.js"
]
},
"options_ui": {
"page": "options.html"
}
}
```
### `content_scripts`

Les scripts de contenu sont **charg√©s** chaque fois que l'utilisateur **acc√®de √† une page correspondante**, dans notre cas toute page correspondant √† l'expression **`https://example.com/*`** et ne correspondant pas √† l'expression r√©guli√®re **`*://*/*/business*`**. Ils s'ex√©cutent **comme les scripts de la page elle-m√™me** et ont un acc√®s arbitraire au [Mod√®le d'Objet de Document (DOM)](https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model) de la page.
```json
"content_scripts": [
{
"js": [
"script.js"
],
"matches": [
"https://example.com/*",
"https://www.example.com/*"
],
"exclude_matches": ["*://*/*business*"],
}
],
```
Pour inclure ou exclure davantage d'URL, il est √©galement possible d'utiliser **`include_globs`** et **`exclude_globs`**.

Voici un exemple de script de contenu qui ajoutera un bouton d'explication √† la page lorsque [l'API de stockage](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/storage) est utilis√©e pour r√©cup√©rer la valeur `message` du stockage de l'extension.
```js
chrome.storage.local.get("message", result =>
{
let div = document.createElement("div");
div.innerHTML = result.message + " <button>Explain</button>";
div.querySelector("button").addEventListener("click", () =>
{
chrome.runtime.sendMessage("explain");
});
document.body.appendChild(div);
});
```
<figure><img src="../../.gitbook/assets/image (20).png" alt=""><figcaption></figcaption></figure>

Un message est envoy√© aux pages de l'extension par le script de contenu lorsque ce bouton est cliqu√©, en utilisant l'API [**runtime.sendMessage()**](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/runtime/sendMessage). Cela est d√ª √† la limitation du script de contenu dans l'acc√®s direct aux API, le `storage` √©tant l'une des rares exceptions. Pour les fonctionnalit√©s au-del√† de ces exceptions, des messages sont envoy√©s aux pages de l'extension avec lesquelles les scripts de contenu peuvent communiquer.

{% hint style="warning" %}
Selon le navigateur, les capacit√©s du script de contenu peuvent varier l√©g√®rement. Pour les navigateurs bas√©s sur Chromium, la liste des capacit√©s est disponible dans la documentation des [d√©veloppeurs Chrome](https://developer.chrome.com/docs/extensions/mv3/content_scripts/#capabilities), et pour Firefox, le [MDN](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/Content_scripts#webextension_apis) sert de source principale.\
Il est √©galement √† noter que les scripts de contenu ont la capacit√© de communiquer avec les scripts d'arri√®re-plan, leur permettant d'effectuer des actions et de transmettre des r√©ponses.
{% endhint %}

Pour visualiser et d√©boguer les scripts de contenu dans Chrome, le menu des outils de d√©veloppement Chrome peut √™tre acc√©d√© depuis Options > Autres outils > Outils de d√©veloppement OU en appuyant sur Ctrl + Maj + I.

Une fois les outils de d√©veloppement affich√©s, l'onglet **Source** doit √™tre cliqu√©, suivi de l'onglet **Scripts de contenu**. Cela permet d'observer l'ex√©cution des scripts de contenu en cours √† partir de diverses extensions et de d√©finir des points d'arr√™t pour suivre le flux d'ex√©cution.

### Scripts de contenu inject√©s

{% hint style="success" %}
Notez que les **Scripts de contenu ne sont pas obligatoires** car il est √©galement possible de **injecter dynamiquement** des scripts et de les **injecter de mani√®re programmatique** dans les pages web via **`tabs.executeScript`**. Cela offre en fait un contr√¥le plus **granulaire**.
{% endhint %}

Pour l'injection programmatique d'un script de contenu, l'extension doit avoir les [permissions d'h√¥te](https://developer.chrome.com/docs/extensions/reference/permissions) pour la page dans laquelle les scripts doivent √™tre inject√©s. Ces autorisations peuvent √™tre s√©curis√©es soit en les **demandant** dans le manifeste de l'extension, soit de mani√®re temporaire via [**activeTab**](https://developer.chrome.com/docs/extensions/reference/manifest/activeTab).

#### Exemple d'extension bas√©e sur activeTab

{% code title="manifest.json" %}
```json
{
"name": "My extension",
...
"permissions": [
"activeTab",
"scripting"
],
"background": {
"service_worker": "background.js"
},
"action": {
"default_title": "Action Button"
}
}
```
{% endcode %}

* **Injecter un fichier JS au clic :**
```javascript
// content-script.js
document.body.style.backgroundColor = "orange";

//service-worker.js - Inject the JS file
chrome.action.onClicked.addListener((tab) => {
chrome.scripting.executeScript({
target: { tabId: tab.id },
files: ["content-script.js"]
});
});
```
* **Injecter une fonction** au clic:
```javascript
//service-worker.js - Inject a function
function injectedFunction() {
document.body.style.backgroundColor = "orange";
}

chrome.action.onClicked.addListener((tab) => {
chrome.scripting.executeScript({
target : {tabId : tab.id},
func : injectedFunction,
});
});
```
#### Exemple avec autorisations de script
```javascript
// service-workser.js
chrome.scripting.registerContentScripts([{
id : "test",
matches : [ "https://*.example.com/*" ],
excludeMatches : [ "*://*/*business*" ],
js : [ "contentScript.js" ],
}]);

// Another example
chrome.tabs.executeScript(tabId, { file: "content_script.js" });
```
### Scripts de contenu `run_at`

Le champ `run_at` contr√¥le **quand les fichiers JavaScript sont inject√©s dans la page web**. La valeur pr√©f√©r√©e et par d√©faut est `"document_idle"`.

Les valeurs possibles sont :

* **`document_idle`** : Chaque fois que c'est possible
* **`document_start`** : Apr√®s tout fichier `css`, mais avant que tout autre DOM ne soit construit ou qu'un autre script ne soit ex√©cut√©.
* **`document_end`** : Imm√©diatement apr√®s que le DOM est complet, mais avant que des sous-ressources comme les images et les cadres ne soient charg√©es.

#### Via `manifest.json`
```json
{
"name": "My extension",
...
"content_scripts": [
{
"matches": ["https://*.example.com/*"],
"run_at": "document_idle",
"js": ["contentScript.js"]
}
],
...
}

```
Via **`service-worker.js`**
```javascript
chrome.scripting.registerContentScripts([{
id : "test",
matches : [ "https://*.example.com/*" ],
runAt : "document_idle",
js : [ "contentScript.js" ],
}]);
```
### `arri√®re-plan`

Les messages envoy√©s par les scripts de contenu sont re√ßus par la **page d'arri√®re-plan**, qui joue un r√¥le central dans la coordination des composants de l'extension. Notamment, la page d'arri√®re-plan persiste tout au long de la dur√©e de vie de l'extension, fonctionnant discr√®tement sans interaction directe de l'utilisateur. Elle poss√®de son propre Mod√®le d'Objet de Document (DOM), permettant des interactions complexes et une gestion de l'√©tat.

**Points Cl√©s**:

* **R√¥le de la Page d'Arri√®re-plan:** Agit comme le centre nerveux de l'extension, assurant la communication et la coordination entre les diff√©rentes parties de l'extension.
* **Persistance:** C'est une entit√© toujours pr√©sente, invisible pour l'utilisateur mais essentielle au fonctionnement de l'extension.
* **G√©n√©ration Automatique:** Si elle n'est pas explicitement d√©finie, le navigateur cr√©era automatiquement une page d'arri√®re-plan. Cette page g√©n√©r√©e automatiquement inclura tous les scripts d'arri√®re-plan sp√©cifi√©s dans le manifeste de l'extension, garantissant le bon fonctionnement des t√¢ches d'arri√®re-plan de l'extension.

{% hint style="success" %}
La commodit√© offerte par le navigateur en g√©n√©rant automatiquement une page d'arri√®re-plan (lorsqu'elle n'est pas explicitement d√©clar√©e) garantit que tous les scripts d'arri√®re-plan n√©cessaires sont int√©gr√©s et op√©rationnels, simplifiant le processus de configuration de l'extension.
{% endhint %}

Exemple de script d'arri√®re-plan:
```js
chrome.runtime.onMessage.addListener((request, sender, sendResponse) =>
{
if (request == "explain")
{
chrome.tabs.create({ url: "https://example.net/explanation" });
}
})
```
Il utilise l'[API runtime.onMessage](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/runtime/onMessage) pour √©couter les messages. Lorsqu'un message `"explain"` est re√ßu, il utilise l'[API tabs](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/tabs) pour ouvrir une page dans un nouvel onglet.

Pour d√©boguer le script arri√®re-plan, vous pouvez acc√©der aux **d√©tails de l'extension et inspecter le service worker**, cela ouvrira les outils de d√©veloppement avec le script arri√®re-plan :

<figure><img src="https://github.com/carlospolop/hacktricks/blob/master/pentesting-web/browser-extension-pentesting-methodology/broken-reference" alt=""><figcaption></figcaption></figure>

### Pages d'options et autres

Les extensions de navigateur peuvent contenir diff√©rents types de pages :

* Les **pages d'action** s'affichent dans un **menu d√©roulant lorsque l'ic√¥ne de l'extension est cliqu√©e**.
* Les pages que l'extension **chargera dans un nouvel onglet**.
* **Pages d'options** : Cette page s'affiche en haut de l'extension lorsqu'elle est cliqu√©e. Dans le manifeste pr√©c√©dent, j'ai pu acc√©der √† cette page via `chrome://extensions/?options=fadlhnelkbeojnebcbkacjilhnbjfjca` ou en cliquant sur :

<figure><img src="../../.gitbook/assets/image (21).png" alt="" width="375"><figcaption></figcaption></figure>

Notez que ces pages ne sont pas persistantes comme les pages d'arri√®re-plan car elles chargent dynamiquement du contenu en cas de n√©cessit√©. Malgr√© cela, elles partagent certaines capacit√©s avec la page d'arri√®re-plan :

* **Communication avec les scripts de contenu :** Similaire √† la page d'arri√®re-plan, ces pages peuvent recevoir des messages des scripts de contenu, facilitant l'interaction au sein de l'extension.
* **Acc√®s aux API sp√©cifiques √† l'extension :** Ces pages b√©n√©ficient d'un acc√®s complet aux API sp√©cifiques √† l'extension, sous r√©serve des autorisations d√©finies pour l'extension.

### `permissions` & `host_permissions`

**`permissions`** et **`host_permissions`** sont des entr√©es du `manifest.json` qui indiqueront **quelles autorisations** les extensions de navigateur poss√®dent (stockage, localisation...) et dans **quelles pages web**.

Comme les extensions de navigateur peuvent √™tre si **privil√©gi√©es**, une extension malveillante ou compromise pourrait permettre √† l'attaquant **diff√©rents moyens de voler des informations sensibles et d'espionner l'utilisateur**.

D√©couvrez comment ces param√®tres fonctionnent et comment ils pourraient √™tre abus√©s dans :

{% content-ref url="browext-permissions-and-host_permissions.md" %}
[browext-permissions-and-host\_permissions.md](browext-permissions-and-host\_permissions.md)
{% endcontent-ref %}

### `content_security_policy`

Une **politique de s√©curit√© du contenu** peut √©galement √™tre d√©clar√©e dans le `manifest.json`. Si une est d√©finie, elle pourrait √™tre **vuln√©rable**.

Le param√®tre par d√©faut pour les pages d'extension de navigateur est plut√¥t restrictif :
```bash
script-src 'self'; object-src 'self';
```
Pour plus d'informations sur CSP et les √©ventuelles contournements, consultez :

{% content-ref url="../content-security-policy-csp-bypass/" %}
[content-security-policy-csp-bypass](../content-security-policy-csp-bypass/)
{% endcontent-ref %}

### `web_accessible_resources`

pour qu'une page web puisse acc√©der √† une page d'une extension de navigateur, une page `.html` par exemple, cette page doit √™tre mentionn√©e dans le champ **`web_accessible_resources`** du `manifest.json`.\
Par exemple :
```javascript
{
...
"web_accessible_resources": [
{
"resources": [ "images/*.png" ],
"matches": [ "https://example.com/*" ]
},
{
"resources": [ "fonts/*.woff" ],
"matches": [ "https://example.com/*" ]
}
],
...
}
```
Ces pages sont accessibles via des URL comme :
```
chrome-extension://<extension-id>/message.html
```
Dans les extensions publiques, l'**identifiant de l'extension est accessible** :

<figure><img src="../../.gitbook/assets/image (1191).png" alt="" width="375"><figcaption></figcaption></figure>

Cependant, si le param√®tre `manifest.json` **`use_dynamic_url`** est utilis√©, cet **identifiant peut √™tre dynamique**.

Le fait de pouvoir acc√©der √† ces pages rend ces pages **potentiellement vuln√©rables au ClickJacking** :

{% content-ref url="browext-clickjacking.md" %}
[browext-clickjacking.md](browext-clickjacking.md)
{% endcontent-ref %}

{% hint style="success" %}
Le fait de permettre le chargement de ces pages uniquement par l'extension et non par des URL al√©atoires pourrait pr√©venir les attaques de ClickJacking.
{% endhint %}

### `externally_connectable`

Selon la [**documentation**](https://developer.chrome.com/docs/extensions/reference/manifest/externally-connectable), la propri√©t√© de manifeste `"externally_connectable"` d√©clare **quelles extensions et quelles pages web peuvent se connecter** √† votre extension via [runtime.connect](https://developer.chrome.com/docs/extensions/reference/runtime#method-connect) et [runtime.sendMessage](https://developer.chrome.com/docs/extensions/reference/runtime#method-sendMessage).

* Si la cl√© **`externally_connectable`** n'est **pas** d√©clar√©e dans le manifeste de votre extension ou si elle est d√©clar√©e comme **`"ids": ["*"]`**, **toutes les extensions peuvent se connecter, mais aucune page web ne peut se connecter**.
* Si des **IDs sp√©cifiques sont sp√©cifi√©s**, comme dans `"ids": ["aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"]`, **seules ces applications** peuvent se connecter.
* Si des **correspondances** sont sp√©cifi√©es, ces applications web pourront se connecter :
```json
"matches": [
"https://*.google.com/*",
"*://*.chromium.org/*",
```
* Si elle est sp√©cifi√©e comme vide : **`"externally_connectable": {}`**, aucune application ou site web ne pourra se connecter.

Moins il y a d'extensions et d'URL indiqu√©es ici, plus la surface d'attaque sera r√©duite.

{% hint style="danger" %}
Si une page web vuln√©rable aux attaques XSS ou √† la prise de contr√¥le est indiqu√©e dans **`externally_connectable`**, un attaquant pourra envoyer des messages directement au script d'arri√®re-plan, contournant compl√®tement le Content Script et sa CSP.

Il s'agit donc d'une **√©chappatoire tr√®s puissante**.

De plus, si le client installe une extension malveillante, m√™me si elle n'est pas autoris√©e √† communiquer avec l'extension vuln√©rable, elle pourrait injecter des donn√©es XSS dans une page web autoris√©e ou abuser des API **`WebRequest`** ou **`DeclarativeNetRequest`** pour manipuler les requ√™tes sur un domaine cibl√© en modifiant une requ√™te de page pour un fichier **JavaScript**. (Notez que la CSP sur la page cibl√©e pourrait emp√™cher ces attaques). Cette id√©e provient de [**cet article**](https://www.darkrelay.com/post/opera-zero-day-rce-vulnerability).
{% endhint %}

##

## Communication entre le Web **‚ÜîÔ∏é** le Content Script

Les environnements o√π les **scripts de contenu** op√®rent et o√π les pages h√¥tes existent sont **s√©par√©s** les uns des autres, assurant une **isolation**. Malgr√© cette isolation, les deux ont la capacit√© d'interagir avec le **Mod√®le d'Objet de Document (DOM)** de la page, une ressource partag√©e. Pour que la page h√¥te puisse communiquer avec le **script de contenu**, ou indirectement avec l'extension via le script de contenu, il est n√©cessaire d'utiliser le **DOM** accessible par les deux parties comme canal de communication.

### Messages Post√©s

{% code title="content-script.js" %}
```javascript
var port = chrome.runtime.connect();

window.addEventListener("message", (event) => {
// We only accept messages from ourselves
if (event.source !== window) {
return;
}

if (event.data.type && (event.data.type === "FROM_PAGE")) {
console.log("Content script received: " + event.data.text);
port.postMessage(event.data.text);
}
}, false);
```
{% endcode %}

{% code title="example.js" %}
```javascript
document.getElementById("theButton").addEventListener("click", () => {
window.postMessage(
{type : "FROM_PAGE", text : "Hello from the webpage!"}, "*");
}, false);
```
{% endcode %}

Une communication s√©curis√©e par Post Message devrait v√©rifier l'authenticit√© du message re√ßu, cela peut √™tre fait en v√©rifiant :

- **`event.isTrusted`** : Cela est vrai uniquement si l'√©v√©nement a √©t√© d√©clench√© par une action de l'utilisateur
- Le script de contenu peut s'attendre √† un message uniquement si l'utilisateur effectue une action
- **Domaine d'origine** : peut s'attendre √† un message uniquement √† partir d'une liste blanche de domaines.
- Si une expression r√©guli√®re est utilis√©e, soyez tr√®s prudent
- **Source** : `received_message.source !== window` peut √™tre utilis√© pour v√©rifier si le message provient de **la m√™me fen√™tre** o√π le script de contenu √©coute.

Les v√©rifications pr√©c√©dentes, m√™me si elles sont effectu√©es, pourraient √™tre vuln√©rables, donc v√©rifiez sur la page suivante les **bypass potentiels de Post Message** :

{% content-ref url="../postmessage-vulnerabilities/" %}
[vuln√©rabilit√©s-postmessage](../postmessage-vulnerabilities/)
{% endcontent-ref %}

### Iframe

Une autre fa√ßon possible de communication pourrait √™tre √† travers les **URLs Iframe**, vous pouvez trouver un exemple dans :

{% content-ref url="browext-xss-example.md" %}
[browext-xss-example.md](browext-xss-example.md)
{% endcontent-ref %}

### DOM

Ce n'est pas "exactement" un moyen de communication, mais le **web et le script de contenu auront acc√®s au DOM web**. Donc, si le **script de contenu** lit des informations √† partir de celui-ci, **faisant confiance au DOM web**, le web pourrait **modifier ces donn√©es** (car le web ne devrait pas √™tre digne de confiance, ou parce que le web est vuln√©rable aux XSS) et **compromettre le script de contenu**.

Vous pouvez √©galement trouver un exemple de **XSS bas√© sur le DOM pour compromettre une extension de navigateur** dans :

{% content-ref url="browext-xss-example.md" %}
[browext-xss-example.md](browext-xss-example.md)
{% endcontent-ref %}

## Informations Sensibles en M√©moire/Code

Si une extension de navigateur stocke des **informations sensibles dans sa m√©moire**, celles-ci pourraient √™tre **extraites** (surtout sur les machines Windows) et **recherch√©es** pour ces informations.

Par cons√©quent, la m√©moire de l'extension de navigateur **ne devrait pas √™tre consid√©r√©e comme s√©curis√©e** et les **informations sensibles** telles que les identifiants ou les phrases mn√©moniques **ne devraient pas √™tre stock√©es**.

Bien s√ªr, ne **mettez pas d'informations sensibles dans le code**, car elles seront **publiques**.

## Communication Script de Contenu **‚ÜîÔ∏é** Script d'Arri√®re-plan

Un script de contenu peut utiliser les fonctions [**runtime.sendMessage()**](https://developer.chrome.com/docs/extensions/reference/runtime#method-sendMessage) **ou** [**tabs.sendMessage()**](https://developer.chrome.com/docs/extensions/reference/tabs#method-sendMessage) pour envoyer un message **s√©rialisable en JSON** une seule fois.

Pour g√©rer la **r√©ponse**, utilisez la **Promise** retourn√©e. Cependant, pour des raisons de compatibilit√© ascendante, vous pouvez toujours passer un **callback** en dernier argument.

Envoyer une demande √† partir d'un **script de contenu** ressemble √† ceci :
```javascript
(async () => {
const response = await chrome.runtime.sendMessage({greeting: "hello"});
// do something with response here, not outside the function
console.log(response);
})();
```
Envoyer une requ√™te depuis l'**extension** (g√©n√©ralement un **script d'arri√®re-plan**). Un script de contenu peut utiliser les fonctions, √† condition de sp√©cifier l'onglet auquel l'envoyer. Exemple de comment envoyer un message au script de contenu dans l'onglet s√©lectionn√© :
```javascript
// From https://stackoverflow.com/questions/36153999/how-to-send-a-message-between-chrome-extension-popup-and-content-script
(async () => {
const [tab] = await chrome.tabs.query({active: true, lastFocusedWindow: true});
const response = await chrome.tabs.sendMessage(tab.id, {greeting: "hello"});
// do something with response here, not outside the function
console.log(response);
})();
```
Sur le **c√¥t√© r√©cepteur**, vous devez configurer un [**runtime.onMessage**](https://developer.chrome.com/docs/extensions/reference/runtime#event-onMessage) **√©couteur d'√©v√©nements** pour g√©rer le message. Cela ressemble de la m√™me mani√®re depuis un script de contenu ou une page d'extension.
```javascript
// From https://stackoverflow.com/questions/70406787/javascript-send-message-from-content-js-to-background-js
chrome.runtime.onMessage.addListener(
function(request, sender, sendResponse) {
console.log(sender.tab ?
"from a content script:" + sender.tab.url :
"from the extension");
if (request.greeting === "hello")
sendResponse({farewell: "goodbye"});
}
);
```
Dans l'exemple mis en √©vidence, **`sendResponse()`** a √©t√© ex√©cut√© de mani√®re synchrone. Pour modifier le gestionnaire d'√©v√©nements `onMessage` pour une ex√©cution asynchrone de `sendResponse()`, il est imp√©ratif d'incorporer `return true;`.

Une consid√©ration importante est que dans les sc√©narios o√π plusieurs pages sont configur√©es pour recevoir des √©v√©nements `onMessage`, **la premi√®re page √† ex√©cuter `sendResponse()`** pour un √©v√©nement sp√©cifique sera la seule capable de d√©livrer efficacement la r√©ponse. Toutes les r√©ponses ult√©rieures au m√™me √©v√©nement ne seront pas prises en compte.

Lors de la cr√©ation de nouvelles extensions, la pr√©f√©rence devrait √™tre donn√©e aux promesses plut√¥t qu'aux rappels. En ce qui concerne l'utilisation des rappels, la fonction `sendResponse()` est consid√©r√©e comme valide uniquement si elle est ex√©cut√©e directement dans le contexte synchrone, ou si le gestionnaire d'√©v√©nements indique une op√©ration asynchrone en retournant `true`. Si aucun des gestionnaires ne retourne `true` ou si la fonction `sendResponse()` est supprim√©e de la m√©moire (collecte des d√©chets), le rappel associ√© √† la fonction `sendMessage()` sera d√©clench√© par d√©faut.

## Chargement d'une extension dans le navigateur

1. **T√©l√©chargez** l'extension du navigateur et d√©compressez-la
2. Acc√©dez √† **`chrome://extensions/`** et **activez** le `Mode d√©veloppeur`
3. Cliquez sur le bouton **`Charger l'extension non empaquet√©e`**

Sur **Firefox**, acc√©dez √† **`about:debugging#/runtime/this-firefox`** et cliquez sur le bouton **`Charger une extension temporaire`**.

## Obtenir le code source depuis le magasin

Le code source d'une extension Chrome peut √™tre obtenu par divers moyens. Voici des explications d√©taill√©es et des instructions pour chaque option.

### T√©l√©charger l'extension au format ZIP via la ligne de commande

Le code source d'une extension Chrome peut √™tre t√©l√©charg√© au format ZIP en utilisant la ligne de commande. Cela implique d'utiliser `curl` pour r√©cup√©rer le fichier ZIP √† partir d'une URL sp√©cifique, puis d'extraire le contenu du fichier ZIP dans un r√©pertoire. Voici les √©tapes :

1. Remplacez `"extension_id"` par l'identifiant r√©el de l'extension.
2. Ex√©cutez les commandes suivantes :
```bash
extension_id=your_extension_id   # Replace with the actual extension ID
curl -L -o "$extension_id.zip" "https://clients2.google.com/service/update2/crx?response=redirect&os=mac&arch=x86-64&nacl_arch=x86-64&prod=chromecrx&prodchannel=stable&prodversion=44.0.2403.130&x=id%3D$extension_id%26uc"
unzip -d "$extension_id-source" "$extension_id.zip"
```
### Utiliser le site CRX Viewer

[https://robwu.nl/crxviewer/](https://robwu.nl/crxviewer/)

### Utiliser l'extension CRX Viewer

Une autre m√©thode pratique consiste √† utiliser Chrome Extension Source Viewer, qui est un projet open-source. Il peut √™tre install√© depuis le [Chrome Web Store](https://chrome.google.com/webstore/detail/chrome-extension-source-v/jifpbeccnghkjeaalbbjmodiffmgedin?hl=en). Le code source du visualiseur est disponible dans son [d√©p√¥t GitHub](https://github.com/Rob--W/crxviewer).

### Visualiser le code source de l'extension install√©e localement

Les extensions Chrome install√©es localement peuvent √©galement √™tre inspect√©es. Voici comment proc√©der :

1. Acc√©dez au r√©pertoire de profil local de Chrome en visitant `chrome://version/` et en localisant le champ "Chemin du profil".
2. Naviguez jusqu'au sous-dossier `Extensions/` dans le r√©pertoire du profil.
3. Ce dossier contient toutes les extensions install√©es, g√©n√©ralement avec leur code source dans un format lisible.

Pour identifier les extensions, vous pouvez faire correspondre leurs ID √† leurs noms :

* Activez le mode d√©veloppeur sur la page `about:extensions` pour voir les ID de chaque extension.
* Dans le dossier de chaque extension, le fichier `manifest.json` contient un champ `name` lisible, vous aidant √† identifier l'extension.

### Utiliser un archiveur de fichiers ou un d√©compresseur

Allez sur le Chrome Web Store et t√©l√©chargez l'extension. Le fichier aura une extension `.crx`. Changez l'extension du fichier de `.crx` √† `.zip`. Utilisez n'importe quel archiveur de fichiers (comme WinRAR, 7-Zip, etc.) pour extraire le contenu du fichier ZIP.

### Utiliser le mode d√©veloppeur dans Chrome

Ouvrez Chrome et allez √† `chrome://extensions/`. Activez le "Mode d√©veloppeur" en haut √† droite. Cliquez sur "Charger l'extension non empaquet√©e...". Naviguez jusqu'au r√©pertoire de votre extension. Cela ne t√©l√©charge pas le code source, mais c'est utile pour visualiser et modifier le code d'une extension d√©j√† t√©l√©charg√©e ou d√©velopp√©e.

## Liste de v√©rification d'audit de s√©curit√©

Bien que les extensions de navigateur aient une **surface d'attaque limit√©e**, certaines d'entre elles pourraient contenir des **vuln√©rabilit√©s** ou des **am√©liorations potentielles de renforcement**. Voici les plus courantes :

* [ ] **Limitez** autant que possible les **`permissions`** demand√©es
* [ ] **Limitez** autant que possible les **`host_permissions`**
* [ ] Utilisez une **`content_security_policy`** **forte**
* [ ] **Limitez** autant que possible les **`externally_connectable`**, s'il n'est pas n√©cessaire et possible, ne le laissez pas par d√©faut, sp√©cifiez **`{}`**
* [ ] Si une **URL vuln√©rable aux XSS ou √† la prise de contr√¥le** est mentionn√©e ici, un attaquant pourra **envoyer des messages directement aux scripts d'arri√®re-plan**. Une faille tr√®s puissante.
* [ ] **Limitez** autant que possible les **`web_accessible_resources`**, m√™me vide si possible.
* [ ] Si **`web_accessible_resources`** n'est pas nul, v√©rifiez le [**ClickJacking**](browext-clickjacking.md)
* [ ] Si une **communication** se produit de l'**extension** √† la **page web**, [**v√©rifiez les vuln√©rabilit√©s XSS**](browext-xss-example.md) caus√©es dans la communication.
* [ ] Si des messages Post sont utilis√©s, v√©rifiez les [**vuln√©rabilit√©s des messages Post**](../postmessage-vulnerabilities/)**.**
* [ ] Si le **Script de contenu acc√®de aux d√©tails du DOM**, v√©rifiez qu'ils n'introduisent pas de XSS s'ils sont **modifi√©s** par le web
* [ ] Mettez un accent particulier si cette communication est √©galement impliqu√©e dans la **communication Script de contenu -> Script d'arri√®re-plan**
* [ ] Les **informations sensibles ne doivent pas √™tre stock√©es** √† l'int√©rieur du code de l'extension de navigateur
* [ ] Les **informations sensibles ne doivent pas √™tre stock√©es** √† l'int√©rieur de la m√©moire de l'extension de navigateur

## Outils

### [**Tarnish**](https://thehackerblog.com/tarnish/)

* R√©cup√®re n'importe quelle extension Chrome √† partir d'un lien fourni par le Chrome Web Store.
* **Visionneur de manifest.json** : affiche simplement une version JSON mise en forme du manifeste de l'extension.
* **Analyse d'empreinte digitale** : D√©tection des [web\_accessible\_resources](https://developer.chrome.com/extensions/manifest/web\_accessible\_resources) et g√©n√©ration automatique de JavaScript de l'empreinte digitale de l'extension Chrome.
* **Analyse potentielle du Clickjacking** : D√©tection des pages HTML d'extension avec la directive [web\_accessible\_resources](https://developer.chrome.com/extensions/manifest/web\_accessible\_resources) d√©finie. Elles sont potentiellement vuln√©rables au clickjacking en fonction de l'objectif des pages.
* **Visionneur d'avertissement(s) de permission** : qui affiche une liste de tous les avertissements de permission Chrome qui s'afficheront lorsqu'un utilisateur tentera d'installer l'extension.
* **Fonction(s) dangereuse(s)** : montre l'emplacement des fonctions dangereuses qui pourraient potentiellement √™tre exploit√©es par un attaquant (par exemple, des fonctions telles que innerHTML, chrome.tabs.executeScript).
* **Point(s) d'entr√©e** : montre o√π l'extension prend en compte les entr√©es utilisateur/externes. Cela est utile pour comprendre la surface d'une extension et rechercher des points potentiels pour envoyer des donn√©es malveillantes √† l'extension.
* Les scanners de Fonction(s) dangereuse(s) et de Point(s) d'entr√©e ont les √©l√©ments suivants pour leurs alertes g√©n√©r√©es :
* Extrait de code pertinent et ligne ayant provoqu√© l'alerte.
* Description du probl√®me.
* Un bouton "Voir le fichier" pour voir le fichier source complet contenant le code.
* Le chemin du fichier alert√©.
* L'URI complet de l'extension Chrome du fichier alert√©.
* Le type de fichier, tel qu'un script de page d'arri√®re-plan, un script de contenu, une action de navigateur, etc.
* Si la ligne vuln√©rable est dans un fichier JavaScript, les chemins de toutes les pages o√π il est inclus ainsi que le statut de [web\_accessible\_resource](https://developer.chrome.com/extensions/manifest/web\_accessible\_resources) de ces pages.
* **Analyseur de strat√©gie de s√©curit√© du contenu (CSP) et v√©rificateur de contournement** : Cela mettra en √©vidence les faiblesses de la CSP de votre extension et mettra √©galement en lumi√®re les √©ventuelles fa√ßons de contourner votre CSP en raison des CDN autoris√©s, etc.
* **Biblioth√®ques vuln√©rables connues** : Cela utilise [Retire.js](https://retirejs.github.io/retire.js/) pour v√©rifier toute utilisation de biblioth√®ques JavaScript connues comme vuln√©rables.
* T√©l√©charger l'extension et les versions format√©es.
* T√©l√©charger l'extension originale.
* T√©l√©charger une version embelli de l'extension (HTML et JavaScript automatiquement mis en forme).
* Mise en cache automatique des r√©sultats de l'analyse, lancer une analyse d'extension prendra beaucoup de temps la premi√®re fois que vous l'ex√©cutez. Cependant, la deuxi√®me fois, en supposant que l'extension n'ait pas √©t√© mise √† jour, sera presque instantan√©e en raison de la mise en cache des r√©sultats.
* URLs de rapport liables, permettant de facilement partager un rapport d'extension g√©n√©r√© par tarnish avec quelqu'un d'autre.

### [Neto](https://github.com/elevenpaths/neto)

Le projet Neto est un package Python 3 con√ßu pour analyser et d√©voiler les fonctionnalit√©s cach√©es des plugins et extensions de navigateur pour des navigateurs bien connus tels que Firefox et Chrome. Il automatise le processus de d√©compression des fichiers empaquet√©s pour extraire ces fonctionnalit√©s des ressources pertinentes dans une extension comme `manifest.json`, les dossiers de localisation ou les fichiers source Javascript et HTML.

## R√©f√©rences

* **Merci √†** [**@naivenom**](https://twitter.com/naivenom) **pour l'aide apport√©e √† cette m√©thodologie**
* [https://www.cobalt.io/blog/introduction-to-chrome-browser-extension-security-testing](https://www.cobalt.io/blog/introduction-to-chrome-browser-extension-security-testing)
* [https://palant.info/2022/08/10/anatomy-of-a-basic-extension/](https://palant.info/2022/08/10/anatomy-of-a-basic-extension/)
* [https://palant.info/2022/08/24/attack-surface-of-extension-pages/](https://palant.info/2022/08/24/attack-surface-of-extension-pages/)
* [https://palant.info/2022/08/31/when-extension-pages-are-web-accessible/](https://palant.info/2022/08/31/when-extension-pages-are-web-accessible/)
* [https://help.passbolt.com/assets/files/PBL-02-report.pdf](https://help.passbolt.com/assets/files/PBL-02-report.pdf)
* [https://developer.chrome.com/docs/extensions/develop/concepts/content-scripts](https://developer.chrome.com/docs/extensions/develop/concepts/content-scripts)
* [https://developer.chrome.com/docs/extensions/mv2/background-pages](https://developer.chrome.com/docs/extensions/mv2/background-pages)
* [https://thehackerblog.com/kicking-the-rims-a-guide-for-securely-writing-and-auditing-chrome-extensions/](https://thehackerblog.com/kicking-the-rims-a-guide-for-securely-writing-and-auditing-chrome-extensions/)
* [https://gist.github.com/LongJohnCoder/9ddf5735df3a4f2e9559665fb864eac0](https://gist.github.com/LongJohnCoder/9ddf5735df3a4f2e9559665fb864eac0)

<details>

<summary><strong>Apprenez le piratage AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

D'autres fa√ßons de soutenir HackTricks:
* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**La famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Rejoignez** le üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez-nous** sur **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) d√©p√¥ts GitHub.

</details>
