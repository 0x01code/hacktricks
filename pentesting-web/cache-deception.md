# 캐시 독촉과 캐시 속임수

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong>를 통해 AWS 해킹을 처음부터 전문가까지 배워보세요<strong>!</strong></summary>

HackTricks를 지원하는 다른 방법:

* **회사를 HackTricks에서 광고하거나 HackTricks를 PDF로 다운로드**하려면 [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스웨그**](https://peass.creator-spring.com)를 얻으세요.
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요. 독점적인 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션입니다.
* 💬 [**Discord 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**텔레그램 그룹**](https://t.me/peass)에 **참여**하거나 **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)을 **팔로우**하세요.
* **Hacking 트릭을 공유하려면** [**HackTricks**](https://github.com/carlospolop/hacktricks) 및 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github 저장소에 PR을 제출하세요.

</details>

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
[**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks)를 사용하여 세계에서 가장 고급스러운 커뮤니티 도구로 구동되는 **워크플로우를 쉽게 구축하고 자동화**하세요.\
오늘 바로 액세스하세요:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## 차이점

> **웹 캐시 독촉과 웹 캐시 속임수의 차이점은 무엇인가요?**
>
> * **웹 캐시 독촉**에서 공격자는 애플리케이션이 캐시에 악성 콘텐츠를 저장하도록 하고, 이 콘텐츠는 캐시에서 다른 애플리케이션 사용자에게 제공됩니다.
> * **웹 캐시 속임수**에서 공격자는 애플리케이션이 캐시에 다른 사용자에게 속한 민감한 콘텐츠를 저장하도록 하고, 그런 다음 공격자는 이 콘텐츠를 캐시에서 검색합니다.

## 캐시 독촉

캐시 독촉은 클라이언트 측 캐시를 조작하여 클라이언트가 예상치 않은, 부분적인 또는 공격자의 제어 아래에 있는 리소스를 로드하도록 강제하는 것을 목표로 합니다. 영향의 정도는 영향을 받는 페이지의 인기에 따라 달라지며, 오염된 캐시 기간 동안 페이지를 방문하는 사용자에게만 오염된 응답이 제공됩니다.

캐시 독촉 공격의 실행은 다음과 같은 단계로 이루어집니다:

1. **키가 없는 입력 식별**: 이는 요청이 캐시될 필요는 없지만 서버가 반환하는 응답을 변경할 수 있는 매개변수입니다. 이러한 입력을 식별하는 것은 캐시를 조작하는 데 있어서 중요합니다.

2. **키가 없는 입력의 악용**: 키가 없는 입력을 식별한 후, 다음 단계는 이러한 매개변수를 오용하여 서버의 응답을 공격자에게 유리하게 수정하는 방법을 찾는 것입니다.

3. **독촉된 응답이 캐시에 저장되도록 보장**: 마지막 단계는 조작된 응답이 캐시에 저장되도록 보장하는 것입니다. 이렇게 하면 캐시가 독촉된 상태에서 영향을 받는 페이지에 액세스하는 모든 사용자가 오염된 응답을 받게 됩니다.

### 발견: HTTP 헤더 확인

일반적으로 응답이 **캐시에 저장**된 경우 **그에 대한 헤더가 표시**됩니다. 어떤 헤더에 주의를 기울여야 하는지 확인하려면 이 게시물을 참조하세요: [**HTTP 캐시 헤더**](../network-services-pentesting/pentesting-web/special-http-headers.md#cache-headers).

### 발견: 캐시 400 코드

응답이 캐시에 저장되고 있다고 생각한다면, **잘못된 헤더로 요청을 보내**서 **상태 코드 400**으로 응답을 받아볼 수 있습니다. 그런 다음 요청을 정상적으로 액세스하려고 하고, **응답이 400 상태 코드**인 경우 취약하다는 것을 알 수 있습니다 (심지어 DoS를 수행할 수도 있습니다).\
잘못 구성된 헤더는 단순히 `\:`일 수 있습니다.\
_이러한 종류의 상태 코드가 때로는 캐시되지 않을 수 있으므로 이 테스트는 쓸모가 없을 수 있습니다._

### 발견: 키가 없는 입력 식별 및 평가

[**Param Miner**](https://portswigger.net/bappstore/17d2949a985c4b7ca092728dba871943)를 사용하여 페이지의 응답을 변경할 수 있는 **매개변수 및 헤더를 무차별 대입**할 수 있습니다. 예를 들어, 페이지가 `X-Forwarded-For` 헤더를 사용하여 클라이언트가 스크립트를 해당 위치에서 로드하도록 지시할 수 있습니다:
```markup
<script type="text/javascript" src="//<X-Forwarded-For_value>/resources/js/tracking.js"></script>
```
### 백엔드 서버로부터 유해한 응답을 유도하기

식별한 매개변수/헤더를 확인하여 어떻게 **검열**되고 어디에서 **반영**되거나 헤더로부터 응답에 영향을 주는지 확인하십시오. 그것을 어떻게 남용할 수 있을까요 (XSS를 수행하거나 자체적으로 제어하는 JS 코드를 로드할 수 있을까요? DoS를 수행할 수 있을까요?...)

### 응답 캐시 가져오기

남용할 수 있는 **페이지**, 사용할 **매개변수/헤더** 및 **어떻게** 남용할지를 식별한 후 페이지를 캐시해야 합니다. 캐시에 저장하려는 리소스에 따라 시간이 걸릴 수 있으며, 여러 초 동안 시도해야 할 수도 있습니다.\
응답의 헤더 **`X-Cache`**는 요청이 캐시되지 않았을 때 **`miss`** 값을 가질 수 있으며, 캐시되었을 때 **`hit`** 값을 가질 수 있습니다.\
헤더 **`Cache-Control`**은 리소스가 캐시되고 다음에 리소스가 다시 캐시될 시간을 알 수 있는 흥미로운 정보입니다: `Cache-Control: public, max-age=1800`\
또 다른 흥미로운 헤더는 **`Vary`**입니다. 이 헤더는 일반적으로 키가 없는 헤더라도 캐시 키의 일부로 처리되는 **추가 헤더**를 나타내는 데 자주 사용됩니다. 따라서 사용자가 피해자의 `User-Agent`를 알고 있다면 해당 특정 `User-Agent`를 사용하는 사용자의 캐시를 오염시킬 수 있습니다.\
캐시와 관련된 또 다른 헤더는 **`Age`**입니다. 이 헤더는 객체가 프록시 캐시에 저장된 시간을 초 단위로 정의합니다.

요청을 캐시할 때는 사용할 헤더에 **주의**해야 합니다. 일부 헤더는 예상치 못하게 **키로 사용**될 수 있으며, 피해자는 동일한 헤더를 사용해야 합니다. 항상 **다른 브라우저**에서 캐시 오염을 테스트하여 작동 여부를 확인하십시오.

## 악용 예시

### 가장 쉬운 예

`X-Forwarded-For`와 같은 헤더가 응답에서 검열되지 않고 반영됩니다.\
기본 XSS 페이로드를 보내고 캐시를 오염시켜 페이지에 액세스하는 모든 사람이 XSS를 당할 수 있습니다:
```markup
GET /en?region=uk HTTP/1.1
Host: innocent-website.com
X-Forwarded-Host: a."><script>alert(1)</script>"
```
_참고로, 이것은 `/en?region=uk`가 아닌 `/en`으로 요청을 변조합니다._

### 웹 캐시 변조를 사용하여 쿠키 처리 취약점을 악용하기

쿠키는 페이지의 응답에도 반영될 수 있습니다. 예를 들어 XSS를 유발하기 위해 이를 악용할 수 있다면, 악성 캐시 응답을 로드하는 여러 클라이언트에서 XSS를 악용할 수 있을 것입니다.
```markup
GET / HTTP/1.1
Host: vulnerable.com
Cookie: session=VftzO7ZtiBj5zNLRAuFpXpSQLjS4lBmU; fehost=asd"%2balert(1)%2b"
```
참고로 취약한 쿠키가 사용자에게 많이 사용된다면 정기적인 요청으로 캐시가 지워질 수 있습니다.

### 웹 캐시 위조 취약점을 악용하기 위해 여러 헤더 사용하기 <a href="#using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities" id="using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities"></a>

가끔은 캐시를 악용하기 위해 **여러 키가 없는 입력**을 악용해야 할 수도 있습니다. 예를 들어, `X-Forwarded-Host`를 자신이 제어하는 도메인으로 설정하고 `X-Forwarded-Scheme`을 `http`로 설정하면 **오픈 리디렉트**를 찾을 수 있습니다. **만약** 서버가 모든 **HTTP** 요청을 **HTTPS**로 **전달**하고 리디렉트의 도메인 이름으로 `X-Forwarded-Scheme` 헤더를 사용한다면, 리디렉트로 페이지가 가리킬 위치를 제어할 수 있습니다.
```markup
GET /resources/js/tracking.js HTTP/1.1
Host: acc11fe01f16f89c80556c2b0056002e.web-security-academy.net
X-Forwarded-Host: ac8e1f8f1fb1f8cb80586c1d01d500d3.web-security-academy.net/
X-Forwarded-Scheme: http
```
### 제한된 `Vary` 헤더를 이용한 공격

만약 **`X-Host`** 헤더가 **JS 리소스를 로드하기 위한 도메인 이름으로 사용**되고 응답의 **`Vary`** 헤더가 **`User-Agent`**를 나타내고 있다면, 피해자의 User-Agent를 유출하고 해당 User-Agent를 사용하여 캐시를 조작해야 합니다:
```markup
GET / HTTP/1.1
Host: vulnerbale.net
User-Agent: THE SPECIAL USER-AGENT OF THE VICTIM
X-Host: attacker.com
```
### HTTP 요청 스머글링을 악용한 HTTP 캐시 위조 공격

[HTTP 요청 스머글링을 악용한 웹 캐시 위조](http-request-smuggling/#using-http-request-smuggling-to-perform-web-cache-poisoning)에 대해 알아보세요.

### 웹 캐시 위조를 위한 자동 테스트

[웹 캐시 취약점 스캐너](https://github.com/Hackmanit/Web-Cache-Vulnerability-Scanner)를 사용하여 웹 캐시 위조를 자동으로 테스트할 수 있습니다. 이 도구는 다양한 기술을 지원하며 매우 유연하게 설정할 수 있습니다.

예시 사용법: `wcvs -u example.com`

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
[**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks)를 사용하여 세계에서 가장 고급화된 커뮤니티 도구를 활용한 **워크플로우를 쉽게 구축**하고 **자동화**할 수 있습니다.\
지금 바로 액세스하세요:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## 취약한 예시

### Apache Traffic Server ([CVE-2021-27577](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-27577))

ATS는 URL 내의 fragment를 제거하지 않고 전달하고, 캐시 키는 host, path 및 query만 사용하여 생성했습니다 (fragment는 무시). 따라서 요청 `/#/../?r=javascript:alert(1)`은 `/#/../?r=javascript:alert(1)`로 백엔드로 전송되었고, 캐시 키에는 페이로드가 아닌 host, path 및 query만 포함되었습니다.

### GitHub CP-DoS

content-type 헤더에 잘못된 값을 보내면 405 캐시 응답이 트리거됩니다. 캐시 키에는 쿠키가 포함되므로 인증되지 않은 사용자만 공격할 수 있습니다.

### GitLab + GCP CP-DoS

GitLab은 정적 콘텐츠를 저장하기 위해 GCP 버킷을 사용합니다. **GCP 버킷**은 **`x-http-method-override`** 헤더를 지원합니다. 따라서 헤더 `x-http-method-override: HEAD`를 보내고 캐시를 독립적인 응답 본문으로 반환하도록 조작할 수 있습니다. 또한 `PURGE` 메서드도 지원할 수 있습니다.

### Rack Middleware (Ruby on Rails)

Ruby on Rails 애플리케이션에서는 Rack 미들웨어를 자주 사용합니다. Rack 코드의 목적은 **`x-forwarded-scheme`** 헤더의 값을 요청의 스키마로 설정하는 것입니다. 헤더 `x-forwarded-scheme: http`가 전송되면 동일한 위치로 301 리디렉션이 발생하여 해당 리소스에 대한 서비스 거부 (DoS)를 유발할 수 있습니다. 또한 애플리케이션은 `X-forwarded-host` 헤더를 인식하고 사용자를 지정된 호스트로 리디렉션할 수 있습니다. 이 동작은 공격자의 서버에서 JavaScript 파일을 로드하여 보안 위험을 초래할 수 있습니다.

### 403 및 스토리지 버킷

Cloudflare는 이전에 403 응답을 캐시했습니다. 잘못된 인증 헤더로 S3 또는 Azure Storage Blobs에 액세스하려고 하면 403 응답이 캐시되었습니다. Cloudflare는 403 응답을 더 이상 캐시하지 않지만 다른 프록시 서비스에서 이러한 동작이 여전히 존재할 수 있습니다.

### 키 파라미터 주입

캐시는 종종 캐시 키에 특정 GET 매개변수를 포함합니다. 예를 들어, Fastly의 Varnish는 요청에서 `size` 매개변수를 캐시에 저장했습니다. 그러나 URL 인코딩된 버전의 매개변수 (예: `siz%65`)가 잘못된 값과 함께 전송되면 캐시 키는 올바른 `size` 매개변수를 사용하여 구성됩니다. 그러나 백엔드는 URL 인코딩된 매개변수의 값을 처리합니다. 두 번째 `size` 매개변수를 URL 인코딩하면 캐시에서는 무시되지만 백엔드에서는 사용됩니다. 이 매개변수에 0 값을 할당하면 캐시 가능한 400 Bad Request 오류가 발생합니다.

### 사용자 에이전트 규칙

일부 개발자는 FFUF 또는 Nuclei와 같은 고트래픽 도구와 일치하는 사용자 에이전트의 요청을 차단합니다. 이러한 접근 방식은 캐시 위조 및 DoS와 같은 취약점을 유발할 수 있습니다.

### 비법적인 헤더 필드

[RFC7230](https://datatracker.ietf.mrg/doc/html/rfc7230)는 헤더 이름에 허용되는 문자를 지정합니다. 지정된 **tchar** 범위를 벗어난 문자를 포함하는 헤더는 이상적으로는 400 Bad Request 응답을 트리거해야 합니다. 실제로 서버는 항상 이 표준을 준수하지는 않습니다. 대표적인 예로 Akamai가 있으며, 이는 잘못된 문자를 포함하는 헤더를 전달하고 `cache-control` 헤더가 없는 한 모든 400 오류를 캐시합니다. `\`와 같은 비법적인 문자를 포함하는 헤더를 전송하면 캐시 가능한 400 Bad Request 오류가 발생할 수 있는 취약한 패턴이 식별되었습니다.

### 새로운 헤더 찾기

[https://gist.github.com/iustin24/92a5ba76ee436c85716f003dda8eecc6](https://gist.github.com/iustin24/92a5ba76ee436c85716f003dda8eecc6)

## 캐시 위조

캐시 위조의 목표는 클라이언트가 **캐시에 저장될 리소스를 불러올 때 민감한 정보가 포함된 리소스를 불러오도록 만드는 것**입니다.

먼저, `.css`, `.js`, `.png` 등과 같은 **확장자**는 일반적으로 **캐시에 저장**되도록 **구성**됩니다. 따라서 `www.example.com/profile.php/nonexistent.js`에 액세스하면 `.js` **확장자**를 보기 때문에 캐시가
<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong>를 통해 AWS 해킹을 처음부터 전문가까지 배워보세요<strong>!</strong></summary>

HackTricks를 지원하는 다른 방법:

* **회사를 HackTricks에서 광고하거나 HackTricks를 PDF로 다운로드**하려면 [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스웨그**](https://peass.creator-spring.com)를 얻으세요.
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요. 독점적인 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션입니다.
* 💬 [**Discord 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**텔레그램 그룹**](https://t.me/peass)에 **참여**하거나 **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)을 **팔로우**하세요.
* **Hacking 트릭을 공유하려면** [**HackTricks**](https://github.com/carlospolop/hacktricks)와 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github 저장소에 PR을 제출하세요.

</details>
