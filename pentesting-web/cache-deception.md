# Cache Poisoning und Cache Täuschung

<details>

<summary>Lernen Sie AWS-Hacking von Grund auf mit <a href="https://training.hacktricks.xyz/courses/arte">htARTE (HackTricks AWS Red Team Expert)</a>!</summary>

Andere Möglichkeiten, HackTricks zu unterstützen:

- Wenn Sie Ihr Unternehmen in HackTricks bewerben möchten oder HackTricks als PDF herunterladen möchten, überprüfen Sie die [ABONNEMENTPLÄNE](https://github.com/sponsors/carlospolop)!
- Holen Sie sich das offizielle PEASS & HackTricks-Merchandise
- Entdecken Sie die PEASS-Familie, unsere Sammlung exklusiver NFTs
- Treten Sie der Discord-Gruppe oder der Telegram-Gruppe bei oder folgen Sie uns auf Twitter
- Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die HackTricks- und HackTricks Cloud-GitHub-Repositories senden.

</details>

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Verwenden Sie [Trickest](https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks), um Workflows einfach zu erstellen und zu automatisieren, die von den fortschrittlichsten Community-Tools der Welt unterstützt werden.
Erhalten Sie noch heute Zugriff:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## Der Unterschied

> Was ist der Unterschied zwischen Web-Cache-Vergiftung und Web-Cache-Täuschung?
>
> - Bei der **Web-Cache-Vergiftung** veranlasst der Angreifer die Anwendung, einige bösartige Inhalte im Cache zu speichern, und diese Inhalte werden anderen Anwendungsbenutzern aus dem Cache bereitgestellt.
> - Bei der **Web-Cache-Täuschung** veranlasst der Angreifer die Anwendung, einige sensible Inhalte eines anderen Benutzers im Cache zu speichern, und der Angreifer ruft dann diese Inhalte aus dem Cache ab.

## Cache-Vergiftung

Die Cache-Vergiftung zielt darauf ab, den Client-Cache zu manipulieren, um die Clients dazu zu zwingen, Ressourcen zu laden, die unerwartet, teilweise oder unter der Kontrolle eines Angreifers stehen. Das Ausmaß der Auswirkungen hängt von der Beliebtheit der betroffenen Seite ab, da die kontaminierte Antwort ausschließlich an Benutzer geliefert wird, die die Seite während des Zeitraums der Cache-Kontamination besuchen.

Die Durchführung eines Cache-Vergiftungsangriffs umfasst mehrere Schritte:

1. **Identifizierung von nicht gekennzeichneten Eingaben**: Dies sind Parameter, die zwar nicht für eine zwischengespeicherte Anfrage erforderlich sind, aber die vom Server zurückgegebene Antwort ändern können. Die Identifizierung dieser Eingaben ist entscheidend, da sie ausgenutzt werden können, um den Cache zu manipulieren.

2. **Ausnutzung der nicht gekennzeichneten Eingaben**: Nach der Identifizierung der nicht gekennzeichneten Eingaben besteht der nächste Schritt darin, herauszufinden, wie diese Parameter missbraucht werden können, um die Antwort des Servers auf eine Weise zu ändern, die dem Angreifer zugutekommt.

3. **Sicherstellen, dass die vergiftete Antwort zwischengespeichert wird**: Der letzte Schritt besteht darin, sicherzustellen, dass die manipulierte Antwort im Cache gespeichert wird. Auf diese Weise erhält jeder Benutzer, der während der Vergiftung des Caches auf die betroffene Seite zugreift, die kontaminierte Antwort.

### Entdeckung: Überprüfen der HTTP-Header

Normalerweise gibt es einen Header, der anzeigt, dass eine Antwort im Cache gespeichert wurde. Sie können überprüfen, auf welche Header Sie in diesem Beitrag achten sollten: [HTTP-Cache-Header](../network-services-pentesting/pentesting-web/special-http-headers.md#cache-headers).

### Entdeckung: Caching von Statuscode 400

Wenn Sie vermuten, dass die Antwort im Cache gespeichert wird, können Sie versuchen, Anfragen mit einem ungültigen Header zu senden, auf die mit dem Statuscode 400 geantwortet werden sollte. Versuchen Sie dann, die Anfrage normal abzurufen, und wenn die Antwort ein Statuscode 400 ist, wissen Sie, dass sie verwundbar ist (und Sie könnten sogar einen DoS-Angriff durchführen).
Ein schlecht konfigurierter Header könnte einfach `\:` als Header sein.
Beachten Sie, dass solche Statuscodes manchmal nicht zwischengespeichert werden, sodass dieser Test nutzlos sein wird.

### Entdeckung: Identifizieren und Bewerten nicht gekennzeichneter Eingaben

Sie können [Param Miner](https://portswigger.net/bappstore/17d2949a985c4b7ca092728dba871943) verwenden, um Parameter und Header zu brute-forcen, die die Antwort der Seite ändern können. Eine Seite kann beispielsweise den Header `X-Forwarded-For` verwenden, um den Client anzuweisen, das Skript von dort zu laden:
```markup
<script type="text/javascript" src="//<X-Forwarded-For_value>/resources/js/tracking.js"></script>
```
### Elicitieren Sie eine schädliche Antwort vom Backend-Server

Überprüfen Sie mit dem identifizierten Parameter/ Header, wie er **gesäubert** wird und **wo** er sich in der Antwort des Headers **widerspiegelt** oder diese beeinflusst. Können Sie ihn missbrauchen (eine XSS durchführen oder einen von Ihnen kontrollierten JS-Code laden? Einen DoS durchführen?...)

### Holen Sie sich die zwischengespeicherte Antwort

Sobald Sie die **Seite** identifiziert haben, die missbraucht werden kann, welchen **Parameter**/**Header** Sie verwenden und wie Sie ihn missbrauchen können, müssen Sie die Seite zwischenspeichern. Je nach Ressource, die Sie im Cache abrufen möchten, kann dies einige Zeit dauern. Sie müssen möglicherweise mehrere Sekunden lang versuchen.\
Der Header **`X-Cache`** in der Antwort kann sehr nützlich sein, da er den Wert **`miss`** haben kann, wenn die Anfrage nicht zwischengespeichert wurde, und den Wert **`hit`**, wenn sie zwischengespeichert ist.\
Der Header **`Cache-Control`** ist auch interessant, um festzustellen, ob eine Ressource zwischengespeichert wird und wann die Ressource das nächste Mal wieder zwischengespeichert wird: `Cache-Control: public, max-age=1800`\
Ein weiterer interessanter Header ist **`Vary`**. Dieser Header wird häufig verwendet, um **zusätzliche Header** anzugeben, die als **Teil des Cache-Schlüssels** behandelt werden, auch wenn sie normalerweise nicht als Schlüssel verwendet werden. Wenn der Benutzer den `User-Agent` des Opfers kennt, kann er den Cache für Benutzer vergiften, die diesen bestimmten `User-Agent` verwenden.\
Ein weiterer Header, der mit dem Cache zusammenhängt, ist **`Age`**. Er definiert die Zeit in Sekunden, die das Objekt im Proxy-Cache verbracht hat.

Beim Zwischenspeichern einer Anfrage sollten Sie **vorsichtig mit den verwendeten Headern** sein, da einige von ihnen **unerwartet als Schlüssel verwendet werden** könnten und das Opfer diesen gleichen Header verwenden muss. Testen Sie immer eine Cache-Vergiftung mit **verschiedenen Browsern**, um zu überprüfen, ob sie funktioniert.

## Beispiele für Ausnutzung

### Einfachstes Beispiel

Ein Header wie `X-Forwarded-For` wird unsaniert in der Antwort reflektiert.\
Sie können eine grundlegende XSS-Payload senden und den Cache vergiften, sodass jeder, der auf die Seite zugreift, XSS ausgesetzt wird:
```markup
GET /en?region=uk HTTP/1.1
Host: innocent-website.com
X-Forwarded-Host: a."><script>alert(1)</script>"
```
_Note that this will poison a request to `/en?region=uk` not to `/en`_

### Verwendung von Web-Cache-Vergiftung zur Ausnutzung von Cookie-Handling-Schwachstellen

Cookies können auch in der Antwort einer Seite reflektiert werden. Wenn Sie es zum Beispiel missbrauchen können, um eine XSS zu verursachen, könnten Sie in der Lage sein, XSS in mehreren Clients auszunutzen, die die bösartige Cache-Antwort laden.
```markup
GET / HTTP/1.1
Host: vulnerable.com
Cookie: session=VftzO7ZtiBj5zNLRAuFpXpSQLjS4lBmU; fehost=asd"%2balert(1)%2b"
```
Beachten Sie, dass der anfällige Cookie durch regelmäßige Anfragen von der Cache bereinigt werden kann.

### Verwendung mehrerer Header zur Ausnutzung von Schwachstellen bei der Web-Cache-Vergiftung <a href="#using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities" id="using-multiple-headers-to-exploit-web-cache-poisoning-vulnerabilities"></a>

Manchmal müssen Sie **mehrere nicht gekennzeichnete Eingaben** ausnutzen, um einen Cache zu missbrauchen. Zum Beispiel können Sie eine **Offene Weiterleitung** finden, wenn Sie `X-Forwarded-Host` auf eine von Ihnen kontrollierte Domain und `X-Forwarded-Scheme` auf `http` setzen. **Wenn** der **Server** alle **HTTP**-Anfragen **an HTTPS** weiterleitet und den Header `X-Forwarded-Scheme` als Domainnamen für die Weiterleitung verwendet. Sie können kontrollieren, wohin die Seite durch die Weiterleitung zeigt.
```markup
GET /resources/js/tracking.js HTTP/1.1
Host: acc11fe01f16f89c80556c2b0056002e.web-security-academy.net
X-Forwarded-Host: ac8e1f8f1fb1f8cb80586c1d01d500d3.web-security-academy.net/
X-Forwarded-Scheme: http
```
### Ausnutzung mit begrenztem `Vary`-Header

Wenn Sie feststellen, dass der Header **`X-Host`** als **Domainname zum Laden einer JS-Ressource** verwendet wird, der **`Vary`**-Header in der Antwort jedoch auf **`User-Agent`** hinweist, müssen Sie einen Weg finden, um den User-Agent des Opfers auszulesen und den Cache mit diesem User-Agent zu manipulieren:
```markup
GET / HTTP/1.1
Host: vulnerbale.net
User-Agent: THE SPECIAL USER-AGENT OF THE VICTIM
X-Host: attacker.com
```
### Ausnutzung der HTTP-Cache-Vergiftung durch Missbrauch des HTTP-Request-Smuggling

Erfahren Sie hier, wie Sie [Cache-Vergiftungsangriffe durch Missbrauch des HTTP-Request-Smuggling](http-request-smuggling/#using-http-request-smuggling-to-perform-web-cache-poisoning) durchführen können.

### Automatisiertes Testen auf Web-Cache-Vergiftung

Der [Web-Cache-Vulnerability-Scanner](https://github.com/Hackmanit/Web-Cache-Vulnerability-Scanner) kann verwendet werden, um automatisch auf Web-Cache-Vergiftung zu testen. Er unterstützt viele verschiedene Techniken und ist hochgradig anpassbar.

Beispielhafte Verwendung: `wcvs -u example.com`

<figure><img src="../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Verwenden Sie [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks), um Workflows einfach zu erstellen und zu automatisieren, die von den fortschrittlichsten Community-Tools der Welt unterstützt werden.\
Erhalten Sie noch heute Zugang:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## Anfällige Beispiele

### Apache Traffic Server ([CVE-2021-27577](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-27577))

ATS leitete das Fragment in der URL weiter, ohne es zu entfernen, und generierte den Cache-Schlüssel nur unter Verwendung des Hosts, des Pfads und der Abfrage (wobei das Fragment ignoriert wurde). Daher wurde die Anfrage `/#/../?r=javascript:alert(1)` als `/#/../?r=javascript:alert(1)` an den Backend gesendet und der Cache-Schlüssel enthielt die Nutzlast nicht, sondern nur Host, Pfad und Abfrage.

### GitHub CP-DoS

Das Senden eines ungültigen Werts im Content-Type-Header löste eine zwischengespeicherte 405-Antwort aus. Der Cache-Schlüssel enthielt das Cookie, sodass nur nicht authentifizierte Benutzer angegriffen werden konnten.

### GitLab + GCP CP-DoS

GitLab verwendet GCP-Buckets zur Speicherung von statischem Inhalt. **GCP Buckets** unterstützen den Header `x-http-method-override`. Es war also möglich, den Header `x-http-method-override: HEAD` zu senden und den Cache dazu zu bringen, eine leere Antwort zurückzugeben. Es könnte auch die Methode `PURGE` unterstützen.

### Rack Middleware (Ruby on Rails)

In Ruby on Rails-Anwendungen wird häufig Rack-Middleware verwendet. Der Zweck des Rack-Codes besteht darin, den Wert des Headers **`x-forwarded-scheme`** zu nehmen und ihn als Schema der Anfrage festzulegen. Wenn der Header `x-forwarded-scheme: http` gesendet wird, erfolgt eine 301-Weiterleitung zum selben Ort, was potenziell zu einer Denial-of-Service (DoS) für diese Ressource führen kann. Darüber hinaus kann die Anwendung den `X-forwarded-host`-Header erkennen und Benutzer zur angegebenen Host-Adresse umleiten. Dieses Verhalten kann dazu führen, dass JavaScript-Dateien von einem Server eines Angreifers geladen werden, was ein Sicherheitsrisiko darstellt.

### 403 und Storage Buckets

Cloudflare hat früher 403-Antworten zwischengespeichert. Wenn versucht wurde, auf S3- oder Azure Storage-Blobs mit falschen Autorisierungsheadern zuzugreifen, wurde eine 403-Antwort zwischengespeichert. Obwohl Cloudflare aufgehört hat, 403-Antworten zu zwischenspeichern, könnte dieses Verhalten bei anderen Proxy-Diensten noch vorhanden sein.

### Einfügen von Schlüsselparametern

Caches enthalten oft bestimmte GET-Parameter im Cache-Schlüssel. Zum Beispiel hat Fastlys Varnish den `size`-Parameter in Anfragen zwischengespeichert. Wenn jedoch eine URL-codierte Version des Parameters (z. B. `siz%65`) mit einem fehlerhaften Wert gesendet wurde, wurde der Cache-Schlüssel unter Verwendung des korrekten `size`-Parameters konstruiert. Die Backend-Verarbeitung erfolgte jedoch mit dem Wert im URL-codierten Parameter. Durch die URL-Codierung des zweiten `size`-Parameters wurde dieser vom Cache ausgelassen, aber vom Backend verwendet. Das Zuweisen eines Werts von 0 zu diesem Parameter führte zu einem zwischenspeicherbaren 400 Bad Request-Fehler.

### User-Agent-Regeln

Einige Entwickler blockieren Anfragen mit User-Agents, die denen von stark frequentierten Tools wie FFUF oder Nuclei entsprechen, um die Serverlast zu verwalten. Ironischerweise kann dieser Ansatz Sicherheitslücken wie Cache-Vergiftung und DoS einführen.

### Ungültige Header-Felder

Die [RFC7230](https://datatracker.ietf.mrg/doc/html/rfc7230) gibt die akzeptablen Zeichen in Header-Namen an. Header, die Zeichen außerhalb des angegebenen **tchar**-Bereichs enthalten, sollten idealerweise eine 400 Bad Request-Antwort auslösen. In der Praxis halten sich Server jedoch nicht immer an diesen Standard. Ein bemerkenswertes Beispiel ist Akamai, das Header mit ungültigen Zeichen weiterleitet und jeden 400-Fehler zwischenspeichert, solange der `cache-control`-Header nicht vorhanden ist. Es wurde ein ausnutzbares Muster identifiziert, bei dem das Senden eines Headers mit einem ungültigen Zeichen, wie z. B. `\`, zu einem zwischenspeicherbaren 400 Bad Request-Fehler führte.

### Auffinden neuer Header

[https://gist.github.com/iustin24/92a5ba76ee436c85716f003dda8eecc6](https://gist.github.com/iustin24/92a5ba76ee436c85716f003dda8eecc6)

## Cache-Täuschung

Das Ziel der Cache-Täuschung besteht darin, dass Clients **Ressourcen laden, die vom Cache mit ihren sensiblen Informationen gespeichert werden**.

Zunächst ist zu beachten, dass **Erweiterungen** wie `.css`, `.js`, `.png` usw. normalerweise so **konfiguriert** sind, dass sie im **Cache gespeichert** werden. Wenn Sie also auf `www.example.com/profile.php/nonexistent.js` zugreifen, wird der Cache wahrscheinlich die Antwort speichern, weil er die `.js`-**Erweiterung** sieht. Wenn die **Anwendung** jedoch mit den **sensiblen** Benutzerinhalten, die in _www.example.com/profile.php_ gespeichert sind, wiederholt wird, können Sie diese Inhalte von anderen Benutzern **stehlen**.

Andere Dinge, die getestet werden können:

* _www.example.com/profile.php/.js_
* _www.example.com/profile.php/.css_
* _www.example.com/profile.php/test.js_
* _www.example.com/profile.php/../test.js_
* _www.example.com/profile.php/%2e%2e/test.js_
* _Verwenden Sie weniger bekannte Erweiterungen wie_ `.avif`

Ein weiteres sehr deutliches Beispiel finden Sie in diesem Bericht: [https://hackerone.com/reports/593712](https://hackerone.com/reports/593712).\
In dem Beispiel wird erklärt, dass beim Laden einer nicht vorhandenen Seite wie _http://www.example.com/home.php/non-existent.css_ der Inhalt von _http://www.example.com/home.php_ (**mit den sensiblen Informationen des Benutzers**) zurückgegeben wird und der Cache-Server das Ergebnis speichert.\
Dann kann der **Angreifer** _http://www.example.com/home.php/non-existent.css_ in seinem eigenen Browser aufrufen und die **vertraulichen Informationen** der zuvor aufgerufenen Benutzer beobachten.

Beachten Sie, dass der **Cache-Proxy** so konfiguriert sein sollte, dass Dateien **basierend** auf der **Erweiterung** der Datei (_.css_) und nicht basierend auf dem Content-Type zwischengespeichert werden. In dem Beispiel wird _http://www.example.com/home.php/non-existent.css_ einen `text/html`-Content-Type anstelle eines `text
<summary><strong>Lernen Sie AWS-Hacking von Null auf Held mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere Möglichkeiten, HackTricks zu unterstützen:

* Wenn Sie Ihr **Unternehmen in HackTricks bewerben möchten** oder **HackTricks als PDF herunterladen möchten**, überprüfen Sie die [**ABONNEMENTPLÄNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** 💬 [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs zu den** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) Github-Repositories einreichen.

</details>
