# Genérico

## Rede

| Raw Sockets   | WinAPI Sockets |
| ------------- | -------------- |
| socket()      | WSAStratup()   |
| bind()        | bind()         |
| listen()      | listen()       |
| accept()      | accept()       |
| connect()     | connect()      |
| read()/recv() | recv()         |
| write()       | send()         |
| shutdown()    | WSACleanup()   |

## Persistência

| Registro         | Arquivo       | Serviço                      |
| ---------------- | ------------- | ---------------------------- |
| RegCreateKeyEx() | GetTempPath() | OpenSCManager                |
| RegOpenKeyEx()   | CopyFile()    | CreateService()              |
| RegSetValueEx()  | CreateFile()  | StartServiceCtrlDispatcher() |
| RegDeleteKeyEx() | WriteFile()   |                              |
| RegGetValue()    | ReadFile()    |                              |

## Criptografia

| Nome                  |
| --------------------- |
| WinCrypt              |
| CryptAcquireContext() |
| CryptGenKey()         |
| CryptDeriveKey()      |
| CryptDecrypt()        |
| CryptReleaseContext() |

## Anti-Análise/VM

| Nome da Função                                            | Instruções Assembly |
| --------------------------------------------------------- | ------------------- |
| IsDebuggerPresent()                                       | CPUID()             |
| GetSystemInfo()                                           | IN()                |
| GlobalMemoryStatusEx()                                    |                     |
| GetVersion()                                              |                     |
| CreateToolhelp32Snapshot \[Verificar se um processo está em execução] |                     |
| CreateFileW/A \[Verificar se um arquivo existe]                    |                     |

## Furtividade

| Nome                     |                                                                            |
| ------------------------ | -------------------------------------------------------------------------- |
| VirtualAlloc             | Alocar memória (empacotadores)                                                     |
| VirtualProtect           | Alterar permissão de memória (empacotador dando permissão de execução a uma seção) |
| ReadProcessMemory        | Injeção em processos externos                                          |
| WriteProcessMemoryA/W    | Injeção em processos externos                                          |
| NtWriteVirtualMemory     |                                                                            |
| CreateRemoteThread       | Injeção de DLL/Processo...                                                   |
| NtUnmapViewOfSection     |                                                                            |
| QueueUserAPC             |                                                                            |
| CreateProcessInternalA/W |                                                                            |

## Execução

| Nome da Função    |
| ---------------- |
| CreateProcessA/W |
| ShellExecute     |
| WinExec          |
| ResumeThread     |
| NtResumeThread   |

## Diversos

* GetAsyncKeyState() -- Registro de teclas
* SetWindowsHookEx -- Registro de teclas
* GetForeGroundWindow -- Obter o nome da janela em execução (ou o site de um navegador)
* LoadLibrary() -- Importar biblioteca
* GetProcAddress() -- Importar biblioteca
* CreateToolhelp32Snapshot() -- Listar processos em execução
* GetDC() -- Captura de tela
* BitBlt() -- Captura de tela
* InternetOpen(), InternetOpenUrl(), InternetReadFile(), InternetWriteFile() -- Acesso à Internet
* FindResource(), LoadResource(), LockResource() -- Acesso a recursos do executável

# Técnicas de Malware

## Injeção de DLL

Executar uma DLL arbitrária dentro de outro processo

1. Localizar o processo para injetar a DLL maliciosa: CreateToolhelp32Snapshot, Process32First, Process32Next
2. Abrir o processo: GetModuleHandle, GetProcAddress, OpenProcess
3. Escrever o caminho para a DLL dentro do processo: VirtualAllocEx, WriteProcessMemory
4. Criar uma thread no processo que carregará a DLL maliciosa: CreateRemoteThread, LoadLibrary

Outras funções a serem usadas: NTCreateThreadEx, RtlCreateUserThread

## Injeção de DLL Reflexiva

Carregar uma DLL maliciosa sem chamar chamadas normais do Windows API.\
A DLL é mapeada dentro de um processo, ela resolverá os endereços de importação, corrigirá as realocações e chamará a função DllMain.

## Sequestro de Thread

Encontrar uma thread de um processo e fazê-la carregar uma DLL maliciosa

1. Encontrar uma thread de destino: CreateToolhelp32Snapshot, Thread32First, Thread32Next
2. Abrir a thread: OpenThread
3. Suspender a thread: SuspendThread
4. Escrever o caminho para a DLL maliciosa dentro do processo vítima: VirtualAllocEx, WriteProcessMemory
5. Retomar a thread carregando a biblioteca: ResumeThread

## Injeção de PE

Injeção de Execução Portátil: O executável será escrito na memória do processo vítima e será executado a partir daí.

## Oco de Processo

O malware desmapeará o código legítimo da memória do processo e carregará um binário malicioso

1. Criar um novo processo: CreateProcess
2. Desmapear a memória: ZwUnmapViewOfSection, NtUnmapViewOfSection
3. Escrever o binário malicioso na memória do processo: VirtualAllocEc, WriteProcessMemory
4. Definir o ponto de entrada e executar: SetThreadContext, ResumeThread

# Hooking

* A **SSDT** (**System Service Descriptor Table**) aponta para funções do kernel (ntoskrnl.exe) ou driver GUI (win32k.sys) para que os processos do usuário possam chamar essas funções.
  * Um rootkit pode modificar esses ponteiros para endereços que ele controla
* **IRP** (**I/O Request Packets**) transmitem pedaços de dados de um componente para outro. Quase tudo no kernel usa IRPs e cada objeto de dispositivo tem sua própria tabela de funções que pode ser conectada: DKOM (Direct Kernel Object Manipulation)
* O **IAT** (**Import Address Table**) é útil para resolver dependências. É possível conectar essa tabela para sequestrar o código que será chamado.
* **EAT** (**Export Address Table**) Hooks. Esses hooks podem ser feitos a partir do **userland**. O objetivo é sequestrar funções exportadas por DLLs.
* **Inline Hooks**: Este tipo é difícil de alcançar. Isso envolve modificar o código das próprias funções. Talvez colocando um salto no início disso.
