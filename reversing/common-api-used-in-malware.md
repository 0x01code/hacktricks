# Genérico

## Redes

| Raw Sockets   | WinAPI Sockets |
| ------------- | -------------- |
| socket()      | WSAStratup()   |
| bind()        | bind()         |
| listen()      | listen()       |
| accept()      | accept()       |
| connect()     | connect()      |
| read()/recv() | recv()         |
| write()       | send()         |
| shutdown()    | WSACleanup()   |

## Persistencia

| Registro         | Archivo       | Servicio                     |
| ---------------- | ------------- | ---------------------------- |
| RegCreateKeyEx() | GetTempPath() | OpenSCManager                |
| RegOpenKeyEx()   | CopyFile()    | CreateService()              |
| RegSetValueEx()  | CreateFile()  | StartServiceCtrlDispatcher() |
| RegDeleteKeyEx() | WriteFile()   |                              |
| RegGetValue()    | ReadFile()    |                              |

## Encriptación

| Nombre                |
| --------------------- |
| WinCrypt              |
| CryptAcquireContext() |
| CryptGenKey()         |
| CryptDeriveKey()      |
| CryptDecrypt()        |
| CryptReleaseContext() |

## Anti-Análisis/VM

| Nombre de la función                                       | Instrucciones de ensamblador |
| ----------------------------------------------------------- | --------------------------- |
| IsDebuggerPresent()                                        | CPUID()                     |
| GetSystemInfo()                                            | IN()                        |
| GlobalMemoryStatusEx()                                     |                             |
| GetVersion()                                               |                             |
| CreateToolhelp32Snapshot \[Comprobar si un proceso está en ejecución] |                             |
| CreateFileW/A \[Comprobar si un archivo existe]             |                             |

## Sigilo

| Nombre                   |                                                                 |
| ------------------------ | --------------------------------------------------------------- |
| VirtualAlloc             | Asignar memoria (empaquetadores)                                  |
| VirtualProtect           | Cambiar los permisos de memoria (empaquetador que da permiso de ejecución a una sección) |
| ReadProcessMemory        | Inyección en procesos externos                                   |
| WriteProcessMemoryA/W    | Inyección en procesos externos                                   |
| NtWriteVirtualMemory     |                                                                 |
| CreateRemoteThread       | Inyección de DLL/proceso...                                      |
| NtUnmapViewOfSection     |                                                                 |
| QueueUserAPC             |                                                                 |
| CreateProcessInternalA/W |                                                                 |

## Ejecución

| Nombre de la función |
| ------------------- |
| CreateProcessA/W     |
| ShellExecute         |
| WinExec              |
| ResumeThread         |
| NtResumeThread       |

## Varios

* GetAsyncKeyState() -- Registro de teclas
* SetWindowsHookEx -- Registro de teclas
* GetForeGroundWindow -- Obtener el nombre de la ventana en ejecución (o el sitio web de un navegador)
* LoadLibrary() -- Importar biblioteca
* GetProcAddress() -- Importar biblioteca
* CreateToolhelp32Snapshot() -- Listar procesos en ejecución
* GetDC() -- Captura de pantalla
* BitBlt() -- Captura de pantalla
* InternetOpen(), InternetOpenUrl(), InternetReadFile(), InternetWriteFile() -- Acceder a Internet
* FindResource(), LoadResource(), LockResource() -- Acceder a los recursos del ejecutable

# Técnicas de Malware

## Inyección de DLL

Ejecutar una DLL arbitraria dentro de otro proceso

1. Localizar el proceso para inyectar la DLL maliciosa: CreateToolhelp32Snapshot, Process32First, Process32Next
2. Abrir el proceso: GetModuleHandle, GetProcAddress, OpenProcess
3. Escribir la ruta de la DLL dentro del proceso: VirtualAllocEx, WriteProcessMemory
4. Crear un hilo en el proceso que cargará la DLL maliciosa: CreateRemoteThread, LoadLibrary

Otras funciones a utilizar: NTCreateThreadEx, RtlCreateUserThread

## Inyección de DLL Reflectante

Cargar una DLL maliciosa sin llamar a las llamadas normales de la API de Windows.\
La DLL se mapea dentro de un proceso, resolverá las direcciones de importación, corregirá las reubicaciones y llamará a la función DllMain.

## Secuestro de Hilo

Encontrar un hilo de un proceso y hacer que cargue una DLL maliciosa

1. Encontrar un hilo objetivo: CreateToolhelp32Snapshot, Thread32First, Thread32Next
2. Abrir el hilo: OpenThread
3. Suspender el hilo: SuspendThread
4. Escribir la ruta de la DLL maliciosa dentro del proceso víctima: VirtualAllocEx, WriteProcessMemory
5. Reanudar el hilo cargando la biblioteca: ResumeThread

## Inyección de PE

Inyección de Ejecución Portátil: El ejecutable se escribirá en la memoria del proceso víctima y se ejecutará desde allí.

## Hollowing de Proceso

El malware desmapeará el código legítimo de la memoria del proceso y cargará un binario malicioso

1. Crear un nuevo proceso: CreateProcess
2. Desmapear la memoria: ZwUnmapViewOfSection, NtUnmapViewOfSection
3. Escribir el binario malicioso en la memoria del proceso: VirtualAllocEc, WriteProcessMemory
4. Establecer el punto de entrada y ejecutar: SetThreadContext, ResumeThread

# Hooking

* La **SSDT** (**Tabla de Descriptores de Servicios del Sistema**) apunta a funciones del kernel (ntoskrnl.exe) o del controlador GUI (win32k.sys) para que los procesos de usuario puedan llamar a estas funciones.
  * Un rootkit puede modificar estos punteros a direcciones que controla
* Los **IRP** (**Paquetes de Solicitud de E/S**) transmiten fragmentos de datos de un componente a otro. Casi todo en el kernel utiliza IRPs y cada objeto de dispositivo tiene su propia tabla de funciones que se pueden enganchar: DKOM (Manipulación Directa de Objetos del Kernel)
* La **IAT** (**Tabla de Direcciones de Importación**) es útil para resolver dependencias. Es posible enganchar esta tabla para secuestrar el código que se llamará.
* **Hooks EAT** (**Tabla de Direcciones de Exportación**). Estos hooks se pueden hacer desde **userland**. El objetivo es enganchar las funciones exportadas por las DLL.
* **Hooks Inline**: Este tipo es difícil de lograr. Esto implica modificar el código de las funciones en sí. Tal vez poniendo un salto al principio de esto.
